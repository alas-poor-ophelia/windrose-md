<!-- Compiled by Datacore Script Compiler -->
<!-- Source: Projects/dungeon-map-tracker -->
<!-- Main Component: DungeonMapTracker -->
<!-- Compiled: 2026-01-28T03:13:19.669Z -->
<!-- Files: 138 -->
<!-- Version: 1.5.4 -->
<!-- CSS Files: 1 -->

# Demo

```datacorejsx
// Example: How to use the compiled DungeonMapTracker component
const { View: DungeonMapTracker } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "DungeonMapTracker"));

// Pass props to your component as needed:
// return <DungeonMapTracker someProp="value" />;

return <DungeonMapTracker />;
```

# dmtConstants

```ts
// Path: dmtConstants.ts
// Converted from dmtConstants.js - Theme, defaults, and dynamic path resolution

// Type-only imports
import type { SegmentName } from '#types/core/cell.types';
import type { HexBounds, MapType } from '#types/core/map.types';
import type { HexColor } from '#types/core/common.types';
import type {
  HexOrientation,
  DiagonalRule,
  DistanceDisplayFormat,
} from '#types/settings/settings.types';
import type { CornerName } from '#types/hooks/diagonalFill.types';

// =============================================================================
// Type Definitions
// =============================================================================

/** Grid visual theme settings */
interface GridTheme {
  lines: HexColor;
  lineWidth: number;
  background: HexColor;
}

/** Cell visual theme settings */
interface CellTheme {
  fill: HexColor;
  border: HexColor;
  borderWidth: number;
}

/** Coordinate key theme (letter labels) */
interface CoordinateKeyTheme {
  color: HexColor;
}

/** Coordinate text theme (number labels) */
interface CoordinateTextTheme {
  color: HexColor;
  shadow: HexColor;
}

/** Compass rose theme */
interface CompassTheme {
  color: HexColor;
  size: number;
}

/** Fog of war visual settings */
interface FogOfWarTheme {
  color: HexColor;
  opacity: number;
  blurEnabled: boolean;
  blurFactor: number;
}

/** Complete theme configuration */
interface Theme {
  grid: GridTheme;
  cells: CellTheme;
  coordinateKey: CoordinateKeyTheme;
  coordinateText: CoordinateTextTheme;
  compass: CompassTheme;
  fogOfWar: FogOfWarTheme;
}

/** Map dimensions (width/height in cells) */
interface Dimensions {
  width: number;
  height: number;
}

/** Canvas size in pixels */
interface CanvasSize {
  width: number;
  height: number;
}

/** Distance measurement settings */
interface DistanceDefaults {
  perCellGrid: number;
  perCellHex: number;
  unitGrid: string;
  unitHex: string;
  gridDiagonalRule: DiagonalRule;
  displayFormat: DistanceDisplayFormat;
}

/** Complete defaults configuration */
interface Defaults {
  gridSize: number;
  dimensions: Dimensions;
  hexSize: number;
  hexOrientation: HexOrientation;
  hexBounds: HexBounds;
  mapType: MapType;
  initialZoom: number;
  canvasSize: CanvasSize;
  maxHistory: number;
  minZoom: number;
  maxZoom: number;
  zoomButtonStep: number;
  zoomWheelStep: number;
  distance: DistanceDefaults;
}

// =============================================================================
// Segment System Types
// =============================================================================

// SegmentName imported from '#types/core/cell.types' (canonical source)

/** Vertex identifier for segment triangle definitions */
type VertexName = 'TL' | 'TR' | 'BR' | 'BL' | 'TM' | 'RM' | 'BM' | 'LM' | 'C';

/** Vertex position as ratio (0-1) within cell bounds */
interface VertexRatio {
  xRatio: number;
  yRatio: number;
}

/** Triangle definition as array of vertex names [center, vertex1, vertex2] */
type TriangleDefinition = [VertexName, VertexName, VertexName];

/** Internal edge key format */
type InternalEdgeKey = 'C-TL' | 'C-TM' | 'C-TR' | 'C-RM' | 'C-BR' | 'C-BM' | 'C-BL' | 'C-LM';

/** Cross-cell adjacency definition */
interface CrossCellAdjacency {
  dx: number;
  dy: number;
  neighborSegment: SegmentName;
}

/** Cell edge names */
type CellEdge = 'top' | 'right' | 'bottom' | 'left';

/** Edge half (for segment positioning) */
type EdgeHalf = 'first' | 'second';

/** External edge definition for a segment */
interface ExternalEdge {
  edge: CellEdge;
  half: EdgeHalf;
}

// =============================================================================
// Diagonal Fill Tool Types
// =============================================================================

/** Neighbor offset for corner validation */
interface NeighborOffset {
  dx: number;
  dy: number;
}

/** Diagonal direction identifier */
type DiagonalDirection = 'TL-BR' | 'TR-BL';

// =============================================================================
// Datacore Imports
// =============================================================================


// =============================================================================
// Theme Configuration
// =============================================================================

const THEME: Theme = {
  grid: {
    lines: '#666666',
    lineWidth: 1,
    background: '#1a1a1a'
  },
  cells: {
    fill: '#c4a57b',
    border: '#8b6842',
    borderWidth: 2
  },
  coordinateKey: {
    color: '#c4a57b'
  },
  coordinateText: {
    color: '#ffffff',
    shadow: '#000000'
  },
  compass: {
    color: '#ffffff',
    size: 40
  },
  fogOfWar: {
    color: '#000000',
    opacity: 0.9,
    blurEnabled: false,
    blurFactor: 0.99
  }
};

// =============================================================================
// Schema Version
// =============================================================================

/**
 * Schema version for data migration (Z-Layer Architecture)
 * Increment when mapData structure changes in a breaking way
 */
const SCHEMA_VERSION: number = 2;

// =============================================================================
// Defaults Configuration
// =============================================================================

const DEFAULTS: Defaults = {
  // Grid map defaults
  gridSize: 32,
  dimensions: { 
    width: 300,
    height: 300 
  },
  
  // Hex map defaults
  hexSize: 80,
  hexOrientation: 'flat',
  hexBounds: {
    maxCol: 26,
    maxRow: 20
  },
  
  // Map type
  mapType: 'grid',
  
  // Shared defaults
  initialZoom: 1.5,
  canvasSize: {              
    width: 800, 
    height: 900 
  },
  maxHistory: 50,
  minZoom: 0.1,       
  maxZoom: 4,         
  zoomButtonStep: 0.05,
  zoomWheelStep: 0.05,
  
  // Distance measurement defaults
  distance: {
    perCellGrid: 5,
    perCellHex: 6,
    unitGrid: 'ft',
    unitHex: 'mi',
    gridDiagonalRule: 'alternating',
    displayFormat: 'both'
  }
};

// Dynamically resolve the correct JSON path
const DATA_FILE_PATH: string = dc.resolvePath("windrose-md-data.json");

// =============================================================================
// Segment System Constants
// =============================================================================

/**
 * Segment names in clockwise order from top-left
 * 8 triangular segments radiating from cell center
 * 
 *     TL ----TM---- TR
 *     |\  nw | n  /|
 *     | \   |   / |
 *     |  \  |  /  |
 *     | w \ | / ne|
 *    LM------*------RM
 *     | sw / | \ e |
 *     |  /   |  \  |
 *     | /    |   \ |
 *     |/  s  | se \|
 *     BL ----BM---- BR
 */
const SEGMENT_NAMES: readonly SegmentName[] = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'] as const;

/**
 * Vertex positions for segment triangle definitions
 * Each segment is defined by: center + two boundary vertices
 */
const SEGMENT_VERTICES: Record<VertexName, VertexRatio> = {
  // Corner vertices
  TL: { xRatio: 0, yRatio: 0 },
  TR: { xRatio: 1, yRatio: 0 },
  BR: { xRatio: 1, yRatio: 1 },
  BL: { xRatio: 0, yRatio: 1 },
  // Midpoint vertices
  TM: { xRatio: 0.5, yRatio: 0 },
  RM: { xRatio: 1, yRatio: 0.5 },
  BM: { xRatio: 0.5, yRatio: 1 },
  LM: { xRatio: 0, yRatio: 0.5 },
  // Center vertex
  C:  { xRatio: 0.5, yRatio: 0.5 }
};

/**
 * Triangle vertex definitions for each segment
 * Each segment is a triangle: [center, vertex1, vertex2] (clockwise order)
 */
const SEGMENT_TRIANGLES: Record<SegmentName, TriangleDefinition> = {
  nw: ['C', 'TL', 'TM'],
  n:  ['C', 'TM', 'TR'],
  ne: ['C', 'TR', 'RM'],
  e:  ['C', 'RM', 'BR'],
  se: ['C', 'BR', 'BM'],
  s:  ['C', 'BM', 'BL'],
  sw: ['C', 'BL', 'LM'],
  w:  ['C', 'LM', 'TL']
};

/**
 * Internal adjacency within a cell
 * Maps internal edge (center to boundary point) to the two segments sharing it
 */
const SEGMENT_INTERNAL_ADJACENCY: Record<InternalEdgeKey, [SegmentName, SegmentName]> = {
  'C-TL': ['w', 'nw'],
  'C-TM': ['nw', 'n'],
  'C-TR': ['n', 'ne'],
  'C-RM': ['ne', 'e'],
  'C-BR': ['e', 'se'],
  'C-BM': ['se', 's'],
  'C-BL': ['s', 'sw'],
  'C-LM': ['sw', 'w']
};

/**
 * Cross-cell adjacency for border calculation
 * Maps each segment to its neighbor cell and which segment in that neighbor it touches
 */
const SEGMENT_CROSS_CELL_ADJACENCY: Record<SegmentName, CrossCellAdjacency> = {
  nw: { dx: 0, dy: -1, neighborSegment: 's' },
  n:  { dx: 0, dy: -1, neighborSegment: 'se' },
  ne: { dx: 1, dy: 0, neighborSegment: 'w' },
  e:  { dx: 1, dy: 0, neighborSegment: 'sw' },
  se: { dx: 0, dy: 1, neighborSegment: 'n' },
  s:  { dx: 0, dy: 1, neighborSegment: 'nw' },
  sw: { dx: -1, dy: 0, neighborSegment: 'e' },
  w:  { dx: -1, dy: 0, neighborSegment: 'ne' }
};

/**
 * External edge definitions for each segment
 * Maps segment to which cell boundary edge it touches
 */
const SEGMENT_EXTERNAL_EDGES: Record<SegmentName, ExternalEdge> = {
  nw: { edge: 'top', half: 'first' },
  n:  { edge: 'top', half: 'second' },
  ne: { edge: 'right', half: 'first' },
  e:  { edge: 'right', half: 'second' },
  se: { edge: 'bottom', half: 'second' },
  s:  { edge: 'bottom', half: 'first' },
  sw: { edge: 'left', half: 'second' },
  w:  { edge: 'left', half: 'first' }
};

// =============================================================================
// Diagonal Fill Tool Constants
// =============================================================================

/**
 * Segment fill mapping for diagonal fill tool
 * Maps corner to the 4 segments that create a diagonal border through that corner
 */
const CORNER_SEGMENT_FILL: Record<CornerName, [SegmentName, SegmentName, SegmentName, SegmentName]> = {
  'TL': ['n', 'nw', 'w', 'sw'],
  'TR': ['nw', 'n', 'ne', 'e'],
  'BR': ['ne', 'e', 'se', 's'],
  'BL': ['se', 's', 'sw', 'w']
};

/**
 * Neighbor checks for concave corner validation
 * For each corner, lists the two neighbor offsets that must be painted
 */
const CORNER_NEIGHBOR_CHECKS: Record<CornerName, [NeighborOffset, NeighborOffset]> = {
  'TL': [{ dx: 0, dy: -1 }, { dx: -1, dy: 0 }],
  'TR': [{ dx: 0, dy: -1 }, { dx: 1, dy: 0 }],
  'BR': [{ dx: 0, dy: 1 }, { dx: 1, dy: 0 }],
  'BL': [{ dx: 0, dy: 1 }, { dx: -1, dy: 0 }]
};

/**
 * Diagonal direction based on corner type
 */
const CORNER_DIAGONAL_DIRECTION: Record<CornerName, DiagonalDirection> = {
  'TL': 'TR-BL',
  'BR': 'TR-BL',
  'TR': 'TL-BR',
  'BL': 'TL-BR'
};

// =============================================================================
// Type Exports (for consuming modules)
// These are stripped at transpile time, so they must come before return
// =============================================================================

export type {
  // Theme types
  Theme,
  GridTheme,
  CellTheme,
  FogOfWarTheme,
  // Defaults types
  Defaults,
  Dimensions,
  HexBounds,
  CanvasSize,
  DistanceDefaults,
  HexOrientation,
  MapType,
  DiagonalRule,
  DistanceDisplayFormat,
  // Segment types
  SegmentName,
  VertexName,
  VertexRatio,
  TriangleDefinition,
  InternalEdgeKey,
  CrossCellAdjacency,
  CellEdge,
  EdgeHalf,
  ExternalEdge,
  // Diagonal fill types
  CornerName,
  NeighborOffset,
  DiagonalDirection
};

// =============================================================================
// Module Exports (Datacore pattern)
// =============================================================================

return {
  // Theme and defaults
  THEME,
  DEFAULTS,
  DATA_FILE_PATH,
  SCHEMA_VERSION,
  // Segment system constants
  SEGMENT_NAMES,
  SEGMENT_VERTICES,
  SEGMENT_TRIANGLES,
  SEGMENT_INTERNAL_ADJACENCY,
  SEGMENT_CROSS_CELL_ADJACENCY,
  SEGMENT_EXTERNAL_EDGES,
  // Diagonal fill tool constants
  CORNER_SEGMENT_FILL,
  CORNER_NEIGHBOR_CHECKS,
  CORNER_DIAGONAL_DIRECTION
};
```

# offsetCoordinates

```ts
/**
 * offsetCoordinates.ts
 *
 * Utilities for converting between axial and offset coordinates
 * for hexagonal grids (both flat-top and pointy-top).
 *
 * Coordinate Systems:
 * - Axial (q, r): Used for storage and hex math. Creates parallelogram when iterated.
 * - Offset (col, row): Used for bounds and iteration. Creates rectangle when iterated.
 *
 * For flat-top hexes (odd-q offset):
 * - Columns are vertical (odd columns shift down by 0.5 hex)
 * - Rows are horizontal
 * - maxCol = width, maxRow = height
 *
 * For pointy-top hexes (odd-r offset):
 * - Rows are vertical (odd rows shift right by 0.5 hex)
 * - Columns are horizontal
 * - maxCol = horizontal extent, maxRow = vertical extent
 *
 * Both systems create rectangular iteration while preserving hex geometry.
 */

import type { OffsetCoords, GridBounds } from '#types/core/geometry.types';
import type { HexOrientation } from '#types/settings/settings.types';

/** Axial coordinates for hex grids */
interface AxialCoords {
  q: number;
  r: number;
}

/**
 * Convert axial coordinates to offset coordinates
 * For flat-top hexes: uses odd-q offset (columns vertical, odd cols shift down)
 * For pointy-top hexes: uses odd-r offset (rows vertical, odd rows shift right)
 */
function axialToOffset(q: number, r: number, orientation: HexOrientation = 'flat'): OffsetCoords {
  if (orientation === 'flat') {
    // Odd-Q offset: columns are vertical, odd columns shift down by 0.5 hex
    const col = q;
    const row = r + (q - (q & 1)) / 2;
    return { col, row };
  } else {
    // Odd-R offset: rows are vertical, odd rows shift right by 0.5 hex
    const col = q + (r - (r & 1)) / 2;
    const row = r;
    return { col, row };
  }
}

/**
 * Convert offset coordinates to axial coordinates
 * For flat-top hexes: uses odd-q offset (columns vertical)
 * For pointy-top hexes: uses odd-r offset (rows vertical)
 */
function offsetToAxial(col: number, row: number, orientation: HexOrientation = 'flat'): AxialCoords {
  if (orientation === 'flat') {
    // Odd-Q offset: columns are vertical, odd columns shift down by 0.5 hex
    const q = col;
    const r = row - (col - (col & 1)) / 2;
    return { q, r };
  } else {
    // Odd-R offset: rows are vertical, odd rows shift right by 0.5 hex
    const q = col - (row - (row & 1)) / 2;
    const r = row;
    return { q, r };
  }
}

/**
 * Check if offset coordinates are within rectangular bounds
 * Works for both flat-top and pointy-top hexes
 */
function isWithinOffsetBounds(col: number, row: number, bounds: GridBounds | null): boolean {
  if (!bounds) return true; // No bounds = infinite
  // Exclusive bounds: maxCol=26 means 26 columns (indices 0-25)
  return col >= 0 && col < bounds.maxCol &&
         row >= 0 && row < bounds.maxRow;
}

/**
 * Convert column number to Excel-style letter label
 * For flat-top: represents vertical columns (A, B, C...)
 * For pointy-top: represents horizontal columns (A, B, C...)
 */
function columnToLabel(col: number): string {
  let label = '';
  let num = col;

  while (num >= 0) {
    label = String.fromCharCode(65 + (num % 26)) + label;
    num = Math.floor(num / 26) - 1;
  }

  return label;
}

/**
 * Convert row number to 1-based numeric label
 * For flat-top: represents horizontal rows (1, 2, 3...)
 * For pointy-top: represents vertical rows (1, 2, 3...)
 */
function rowToLabel(row: number): string {
  return String(row + 1);
}

return {
  axialToOffset,
  offsetToAxial,
  isWithinOffsetBounds,
  columnToLabel,
  rowToLabel
};

```

# settingsAccessor

```ts
/**
 * settingsAccessor.ts
 * Utility to access plugin settings with fallback defaults
 */

// Type-only imports
import type {
  PluginSettings,
  ResolvedTheme,
  BuiltInColor,
  ObjectSettings,
  ResolvedColorEntry,
  MapSpecificSettings,
  HexOrientation,
  DiagonalRule,
  DistanceDisplayFormat,
  CoordinateKeyMode,
  HexColor
} from '#types/settings/settings.types';
import type { Theme, Defaults } from '../utils/dmtConstants';

// Datacore imports
const { THEME, DEFAULTS } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants")) as {
  THEME: Theme;
  DEFAULTS: Defaults;
};

// ===========================================
// Constants
// ===========================================

/** Built-in color palette - matches settings plugin */
const BUILT_IN_COLORS: BuiltInColor[] = [
  { id: 'default', color: '#c4a57b', label: 'Default (Tan)' },
  { id: 'stone', color: '#808080', label: 'Stone Gray' },
  { id: 'dark-stone', color: '#505050', label: 'Dark Gray' },
  { id: 'water', color: '#4a9eff', label: 'Water Blue' },
  { id: 'forest', color: '#4ade80', label: 'Forest Green' },
  { id: 'danger', color: '#ef4444', label: 'Danger Red' },
  { id: 'sand', color: '#fbbf24', label: 'Sand Yellow' },
  { id: 'magic', color: '#a855f7', label: 'Magic Purple' },
  { id: 'fire', color: '#fb923c', label: 'Fire Orange' },
  { id: 'ice', color: '#14b8a6', label: 'Ice Teal' }
];

/** Fallback settings based on theme constants */
const FALLBACK_SETTINGS: PluginSettings = {
  version: '1.0.0',
  hexOrientation: DEFAULTS.hexOrientation as HexOrientation,
  gridLineColor: THEME.grid.lines,
  gridLineWidth: THEME.grid.lineWidth,
  backgroundColor: THEME.grid.background,
  borderColor: THEME.cells.border,  
  coordinateKeyColor: THEME.coordinateKey.color,
  coordinateTextColor: THEME.coordinateText.color,
  coordinateTextShadow: THEME.coordinateText.shadow,
  coordinateKeyMode: 'hold' as CoordinateKeyMode,
  expandedByDefault: false,
  
  // Canvas dimensions
  canvasHeight: 600,
  canvasHeightMobile: 400,
  
  // Distance measurement settings
  distancePerCellGrid: DEFAULTS.distance.perCellGrid,
  distancePerCellHex: DEFAULTS.distance.perCellHex,
  distanceUnitGrid: DEFAULTS.distance.unitGrid,
  distanceUnitHex: DEFAULTS.distance.unitHex,
  gridDiagonalRule: DEFAULTS.distance.gridDiagonalRule as DiagonalRule,
  distanceDisplayFormat: DEFAULTS.distance.displayFormat as DistanceDisplayFormat,
  
  // Fog of War appearance settings
  fogOfWarColor: THEME.fogOfWar.color,
  fogOfWarOpacity: THEME.fogOfWar.opacity,
  fogOfWarImage: null,
  fogOfWarBlurEnabled: THEME.fogOfWar.blurEnabled,
  fogOfWarBlurFactor: THEME.fogOfWar.blurFactor,
  
  // Controls visibility
  alwaysShowControls: false,
  
  // Shape preview settings
  shapePreviewKbm: true,
  shapePreviewTouch: false
};

/** Default object customization settings */
const FALLBACK_OBJECT_SETTINGS: ObjectSettings = {
  objectOverrides: {},
  customObjects: [],
  customCategories: []
};

// ===========================================
// Type for Obsidian plugin access
// ===========================================

interface PluginInstance {
  settings?: Partial<PluginSettings>;
}

interface PluginsCollection {
  plugins: Record<string, PluginInstance>;
}

interface ObsidianApp {
  plugins: PluginsCollection;
}

// ===========================================
// Settings Access Functions
// ===========================================

/**
 * Get settings from the plugin, or return fallback defaults if plugin not available
 */
function getSettings(): PluginSettings {
  try {
    // Check if dc.app exists and is ready
    if (!dc || !(dc as { app?: ObsidianApp }).app || !(dc as { app: ObsidianApp }).app.plugins) {
      return FALLBACK_SETTINGS;
    }
    
    // Try to get plugin settings
    const app = (dc as { app: ObsidianApp }).app;
    const plugin = app.plugins.plugins['dungeon-map-tracker-settings'];
    
    if (plugin && plugin.settings) {
      // Merge with fallbacks to ensure all keys exist
      return { ...FALLBACK_SETTINGS, ...plugin.settings };
    }
  } catch (error) {
    console.warn('[settingsAccessor] Could not access plugin settings:', error);
  }
  
  // Return fallbacks if plugin not available
  return FALLBACK_SETTINGS;
}

/**
 * Get a specific setting value
 */
function getSetting<K extends keyof PluginSettings>(key: K): PluginSettings[K] {
  try {
    const settings = getSettings();
    return settings[key];
  } catch (error) {
    console.warn('[settingsAccessor] Error getting setting:', key, error);
    return FALLBACK_SETTINGS[key];
  }
}

/**
 * Check if the settings plugin is installed and enabled
 */
function isPluginAvailable(): boolean {
  try {
    if (!dc || !(dc as { app?: ObsidianApp }).app || !(dc as { app: ObsidianApp }).app.plugins) {
      return false;
    }
    const app = (dc as { app: ObsidianApp }).app;
    const plugin = app.plugins.plugins['dungeon-map-tracker-settings'];
    return !!(plugin && plugin.settings);
  } catch (error) {
    return false;
  }
}

/**
 * Get complete theme object with configurable values from settings
 * and non-configurable values from constants.
 * This is the facade/wrapper that components should use.
 */
function getTheme(): ResolvedTheme {
  const settings = getSettings();
  
  return {
    grid: {
      lines: settings.gridLineColor,
      lineWidth: settings.gridLineWidth,
      background: settings.backgroundColor
    },
    cells: {
      fill: THEME.cells.fill,
      border: settings.borderColor,
      borderWidth: THEME.cells.borderWidth
    },
    compass: {
      color: THEME.compass.color,
      size: THEME.compass.size
    },
    // Note: decorativeBorder is defined inline where needed (e.g., exportOperations)
    // not in THEME constants
    decorativeBorder: {
      color: '#8b7355',
      width: 20,
      dashArray: ''
    },
    coordinateKey: settings.coordinateKeyColor,
    fogOfWar: {
      color: settings.fogOfWarColor,
      opacity: settings.fogOfWarOpacity,
      image: settings.fogOfWarImage,
      blurEnabled: settings.fogOfWarBlurEnabled,
      blurFactor: settings.fogOfWarBlurFactor
    }
  };
}

/**
 * Get effective settings for a map, merging map-specific overrides with global settings
 */
function getEffectiveSettings(
  mapSettings: MapSpecificSettings | null | undefined,
  globalSettings: PluginSettings | null = null
): PluginSettings {
  // Get global settings if not provided
  const globals = globalSettings || getSettings();
  
  // If map has no settings or is using global settings, return global settings
  if (!mapSettings || mapSettings.useGlobalSettings) {
    return globals;
  }
  
  // Merge global settings with map overrides (map overrides take precedence)
  return {
    ...globals,
    ...mapSettings.overrides
  };
}

/**
 * Get object customization settings from the plugin for a specific map type
 * Returns object overrides, custom objects, and custom categories
 */
function getObjectSettings(mapType: 'hex' | 'grid' = 'grid'): ObjectSettings {
  try {
    // Check if dc.app exists and is ready
    if (!dc || !(dc as { app?: ObsidianApp }).app || !(dc as { app: ObsidianApp }).app.plugins) {
      return FALLBACK_OBJECT_SETTINGS;
    }
    
    // Try to get plugin settings
    const app = (dc as { app: ObsidianApp }).app;
    const plugin = app.plugins.plugins['dungeon-map-tracker-settings'];
    
    if (plugin && plugin.settings) {
      // Use map-type specific settings keys
      if (mapType === 'hex') {
        return {
          objectOverrides: plugin.settings.hexObjectOverrides || {},
          customObjects: plugin.settings.customHexObjects || [],
          customCategories: plugin.settings.customHexCategories || []
        };
      } else {
        return {
          objectOverrides: plugin.settings.gridObjectOverrides || {},
          customObjects: plugin.settings.customGridObjects || [],
          customCategories: plugin.settings.customGridCategories || []
        };
      }
    }
  } catch (error) {
    console.warn('[settingsAccessor] Could not access object settings:', error);
  }
  
  return FALLBACK_OBJECT_SETTINGS;
}

/**
 * Get color palette settings from the plugin
 * Returns resolved color palette (built-in with overrides + custom colors)
 */
function getColorPaletteSettings(): ResolvedColorEntry[] {
  try {
    // Check if dc.app exists and is ready
    if (!dc || !(dc as { app?: ObsidianApp }).app || !(dc as { app: ObsidianApp }).app.plugins) {
      return BUILT_IN_COLORS.map(c => ({ 
        ...c, 
        order: 0,
        isBuiltIn: true, 
        isModified: false 
      }));
    }
    
    // Try to get plugin settings
    const app = (dc as { app: ObsidianApp }).app;
    const plugin = app.plugins.plugins['dungeon-map-tracker-settings'];
    
    if (plugin && plugin.settings) {
      const { colorPaletteOverrides = {}, customPaletteColors = [] } = plugin.settings;
      
      // Resolve built-in colors with overrides
      const resolvedBuiltIns: ResolvedColorEntry[] = BUILT_IN_COLORS
        .filter(c => !colorPaletteOverrides[c.id]?.hidden)
        .map((c, index) => {
          const override = colorPaletteOverrides[c.id];
          if (override) {
            const { hidden, ...overrideProps } = override;
            return { 
              ...c, 
              ...overrideProps, 
              order: override.order ?? index,
              isBuiltIn: true, 
              isModified: true 
            };
          }
          return { ...c, order: index, isBuiltIn: true, isModified: false };
        });
      
      // Add custom colors
      const resolvedCustom: ResolvedColorEntry[] = (customPaletteColors || []).map((c, index) => ({
        ...c,
        order: c.order ?? (100 + index),
        isCustom: true,
        isBuiltIn: false
      }));
      
      return [...resolvedBuiltIns, ...resolvedCustom].sort((a, b) => a.order - b.order);
    }
  } catch (error) {
    console.warn('[settingsAccessor] Could not access color palette settings:', error);
  }
  
  // Return default colors if plugin not available
  return BUILT_IN_COLORS.map((c, index) => ({ 
    ...c, 
    order: index,
    isBuiltIn: true, 
    isModified: false 
  }));
}

// ===========================================
// Exports
// ===========================================

return { 
  getSettings, 
  getSetting, 
  isPluginAvailable, 
  getTheme, 
  getEffectiveSettings, 
  getObjectSettings, 
  getColorPaletteSettings, 
  FALLBACK_SETTINGS, 
  BUILT_IN_COLORS 
};
```

# layerAccessor

```ts
/**
 * layerAccessor.ts
 * Helper functions for accessing and manipulating layer data in Windrose maps.
 * Part of Phase 1: Z-Layer Architecture
 */

// Type-only imports
import type { Cell } from '#types/core/cell.types';
import type { IGeometry } from '#types/core/geometry.types';
import type {
  MapData,
  MapLayer,
  LayerId,
  LayerUpdate,
  LegacyMapData,
  FogOfWar,
  FoggedCell,
  FogState,
  FogBounds,
  MigrationValidation,
  SchemaVersion
} from '#types/core/map.types';

// Datacore imports
const { SCHEMA_VERSION } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants")) as {
  SCHEMA_VERSION: SchemaVersion
};

// ============================================================================
// UUID GENERATION
// ============================================================================

/**
 * Generate a unique ID for a layer
 */
function generateLayerId(): LayerId {
  return 'layer-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
}

// ============================================================================
// LAYER ACCESS FUNCTIONS
// ============================================================================

/**
 * Get the currently active layer data
 */
function getActiveLayer(mapData: MapData | null | undefined): MapLayer {
  if (!mapData?.layers || !mapData.activeLayerId) {
    // Legacy fallback (should not happen after migration)
    return {
      id: 'legacy',
      name: '1',
      order: 0,
      visible: true,
      cells: (mapData as LegacyMapData)?.cells || [],
      edges: (mapData as LegacyMapData)?.edges || [],
      objects: (mapData as LegacyMapData)?.objects || [],
      textLabels: (mapData as LegacyMapData)?.textLabels || [],
      fogOfWar: null
    };
  }
  return mapData.layers.find(l => l.id === mapData.activeLayerId) || mapData.layers[0];
}

/**
 * Get all layers sorted by order (ascending - lowest order first)
 */
function getLayersOrdered(mapData: MapData | null | undefined): MapLayer[] {
  if (!mapData?.layers) return [];
  return [...mapData.layers].sort((a, b) => a.order - b.order);
}

/**
 * Get layer by ID
 */
function getLayerById(mapData: MapData | null | undefined, layerId: LayerId): MapLayer | null {
  return mapData?.layers?.find(l => l.id === layerId) || null;
}

/**
 * Get the index of a layer in the layers array
 */
function getLayerIndex(mapData: MapData | null | undefined, layerId: LayerId): number {
  if (!mapData?.layers) return -1;
  return mapData.layers.findIndex(l => l.id === layerId);
}

/**
 * Get the layer directly below the specified layer (by order).
 * Returns null if no layer exists below (i.e., this is the bottom layer).
 */
function getLayerBelow(mapData: MapData | null | undefined, layerId: LayerId): MapLayer | null {
  if (!mapData?.layers) return null;

  const layer = getLayerById(mapData, layerId);
  if (!layer) return null;

  // Find the layer with the highest order that is still less than this layer's order
  const sortedLayers = getLayersOrdered(mapData);
  let layerBelow: MapLayer | null = null;

  for (const candidate of sortedLayers) {
    if (candidate.order < layer.order) {
      // This candidate is below our layer; keep the highest one
      if (!layerBelow || candidate.order > layerBelow.order) {
        layerBelow = candidate;
      }
    }
  }

  return layerBelow;
}

// ============================================================================
// LAYER MODIFICATION FUNCTIONS
// ============================================================================

/**
 * Update a specific layer's data (immutable)
 */
function updateLayer(mapData: MapData, layerId: LayerId, updates: LayerUpdate): MapData {
  if (!mapData?.layers) return mapData;
  
  return {
    ...mapData,
    layers: mapData.layers.map(layer =>
      layer.id === layerId ? { ...layer, ...updates } : layer
    )
  };
}

/**
 * Update the active layer's data (convenience function)
 */
function updateActiveLayer(mapData: MapData, updates: LayerUpdate): MapData {
  if (!mapData?.activeLayerId) return mapData;
  return updateLayer(mapData, mapData.activeLayerId, updates);
}

/**
 * Set the active layer by ID
 */
function setActiveLayer(mapData: MapData, layerId: LayerId): MapData {
  // Verify the layer exists
  if (!getLayerById(mapData, layerId)) {
    console.warn(`Cannot set active layer: layer ${layerId} not found`);
    return mapData;
  }
  
  return {
    ...mapData,
    activeLayerId: layerId
  };
}

/**
 * Add a new layer to the map
 */
function addLayer(mapData: MapData, name: string | null = null): MapData {
  if (!mapData?.layers) return mapData;
  
  // Calculate new order (one higher than current max)
  const maxOrder = mapData.layers.length > 0
    ? Math.max(...mapData.layers.map(l => l.order))
    : -1;
  
  const newLayer: MapLayer = {
    id: generateLayerId(),
    name: name || String(mapData.layers.length + 1),
    order: maxOrder + 1,
    visible: true,
    cells: [],
    edges: [],
    objects: [],
    textLabels: [],
    fogOfWar: null
  };
  
  return {
    ...mapData,
    layers: [...mapData.layers, newLayer],
    activeLayerId: newLayer.id  // Auto-switch to new layer
  };
}

/**
 * Remove a layer from the map (prevents removing last layer)
 */
function removeLayer(mapData: MapData, layerId: LayerId): MapData {
  if (!mapData?.layers) return mapData;
  
  // Prevent removing the last layer
  if (mapData.layers.length <= 1) {
    console.warn('Cannot remove last layer');
    return mapData;
  }
  
  const newLayers = mapData.layers.filter(l => l.id !== layerId);
  const wasActive = mapData.activeLayerId === layerId;
  
  // If we removed the active layer, switch to the first remaining layer
  // (sorted by order for consistency)
  let newActiveId = mapData.activeLayerId;
  if (wasActive) {
    const sortedRemaining = [...newLayers].sort((a, b) => a.order - b.order);
    newActiveId = sortedRemaining[0].id;
  }
  
  return {
    ...mapData,
    layers: newLayers,
    activeLayerId: newActiveId
  };
}

/**
 * Reorder layers by moving a layer to a new position
 */
function reorderLayers(mapData: MapData, layerId: LayerId, newIndex: number): MapData {
  if (!mapData?.layers) return mapData;
  
  // Get layers sorted by current order
  const sortedLayers = getLayersOrdered(mapData);
  const currentIndex = sortedLayers.findIndex(l => l.id === layerId);
  
  if (currentIndex === -1) {
    console.warn(`Cannot reorder: layer ${layerId} not found`);
    return mapData;
  }
  
  // Clamp newIndex to valid range
  const clampedIndex = Math.max(0, Math.min(newIndex, sortedLayers.length - 1));
  
  if (currentIndex === clampedIndex) {
    return mapData; // No change needed
  }
  
  // Remove layer from current position and insert at new position
  const [movedLayer] = sortedLayers.splice(currentIndex, 1);
  sortedLayers.splice(clampedIndex, 0, movedLayer);
  
  // Reassign order values based on new positions
  const reorderedLayers = sortedLayers.map((layer, index) => ({
    ...layer,
    order: index
  }));
  
  return {
    ...mapData,
    layers: reorderedLayers
  };
}

// ============================================================================
// MIGRATION FUNCTIONS
// ============================================================================

/**
 * Create an empty layer structure (for new layers or migration)
 */
function createEmptyLayer(id: LayerId, name: string, order: number): MapLayer {
  return {
    id,
    name,
    order,
    visible: true,
    cells: [],
    edges: [],
    objects: [],
    textLabels: [],
    fogOfWar: null
  };
}

/**
 * Create a deep clone of map data for backup purposes
 */
function createBackup<T>(mapData: T): T | null {
  try {
    return JSON.parse(JSON.stringify(mapData));
  } catch (error) {
    console.error('[layerAccessor] Failed to create backup:', error);
    return null;
  }
}

/**
 * Validate that layer data was properly migrated
 */
function validateMigration(originalData: LegacyMapData, migratedData: MapData): MigrationValidation {
  const errors: string[] = [];
  
  // Check that layers array exists and has content
  if (!migratedData.layers || !Array.isArray(migratedData.layers)) {
    errors.push('Migration failed: layers array missing');
    return { valid: false, errors };
  }
  
  if (migratedData.layers.length === 0) {
    errors.push('Migration failed: layers array is empty');
    return { valid: false, errors };
  }
  
  const layer = migratedData.layers[0];
  
  // Check that layer has required structure
  if (!layer.id || typeof layer.id !== 'string') {
    errors.push('Migration failed: layer missing valid id');
  }
  
  // Verify data was actually copied (not just empty arrays when original had data)
  const originalCells = originalData.cells || [];
  const originalObjects = originalData.objects || [];
  const originalTextLabels = originalData.textLabels || [];
  const originalEdges = originalData.edges || [];
  
  const layerCells = layer.cells || [];
  const layerObjects = layer.objects || [];
  const layerTextLabels = layer.textLabels || [];
  const layerEdges = layer.edges || [];
  
  // Check cell count matches
  if (originalCells.length !== layerCells.length) {
    errors.push(`Migration data loss: cells count mismatch (original: ${originalCells.length}, migrated: ${layerCells.length})`);
  }
  
  // Check objects count matches
  if (originalObjects.length !== layerObjects.length) {
    errors.push(`Migration data loss: objects count mismatch (original: ${originalObjects.length}, migrated: ${layerObjects.length})`);
  }
  
  // Check text labels count matches
  if (originalTextLabels.length !== layerTextLabels.length) {
    errors.push(`Migration data loss: textLabels count mismatch (original: ${originalTextLabels.length}, migrated: ${layerTextLabels.length})`);
  }
  
  // Check edges count matches
  if (originalEdges.length !== layerEdges.length) {
    errors.push(`Migration data loss: edges count mismatch (original: ${originalEdges.length}, migrated: ${layerEdges.length})`);
  }
  
  // Check schemaVersion is set correctly
  if (migratedData.schemaVersion !== SCHEMA_VERSION) {
    errors.push(`Migration failed: schemaVersion incorrect (expected: ${SCHEMA_VERSION}, got: ${migratedData.schemaVersion})`);
  }
  
  return { 
    valid: errors.length === 0, 
    errors 
  };
}

/**
 * Migrate legacy (v1) map data to the new layer schema (v2)
 * Includes backup creation and validation with automatic rollback on failure
 */
function migrateToLayerSchema(legacyMapData: LegacyMapData): MapData | LegacyMapData {
  // Already migrated? Return as-is
  if ((legacyMapData.schemaVersion ?? 0) >= SCHEMA_VERSION && (legacyMapData as MapData).layers) {
    return legacyMapData as MapData;
  }
  
  console.log('[layerAccessor] Starting migration to schema version', SCHEMA_VERSION);
  
  // Create backup BEFORE any modifications
  const backup = createBackup(legacyMapData);
  if (!backup) {
    console.error('[layerAccessor] CRITICAL: Could not create backup, aborting migration');
    return legacyMapData; // Return original unchanged
  }
  
  try {
    // Generate layer ID for the migrated content
    const layerId = generateLayerId();
    
    // IMPORTANT: Extract data BEFORE creating migrated structure
    // Use explicit array copying to ensure data is preserved
    const cellsData = Array.isArray(legacyMapData.cells) 
      ? [...legacyMapData.cells] 
      : [];
    const edgesData = Array.isArray(legacyMapData.edges) 
      ? [...legacyMapData.edges] 
      : [];
    const objectsData = Array.isArray(legacyMapData.objects) 
      ? [...legacyMapData.objects] 
      : [];
    const textLabelsData = Array.isArray(legacyMapData.textLabels) 
      ? [...legacyMapData.textLabels] 
      : [];
    
    console.log('[layerAccessor] Migrating data:', {
      cells: cellsData.length,
      edges: edgesData.length,
      objects: objectsData.length,
      textLabels: textLabelsData.length
    });
    
    // Create the layer with copied data
    const layerData: MapLayer = {
      id: layerId,
      name: '1',
      order: 0,
      visible: true,
      cells: cellsData,
      edges: edgesData,
      objects: objectsData,
      textLabels: textLabelsData,
      fogOfWar: null
    };
    
    // Build migrated structure (spread original first, then override)
    const migratedData: MapData = {
      ...legacyMapData as Partial<MapData>,
      schemaVersion: SCHEMA_VERSION,
      mapType: legacyMapData.mapType || 'grid',
      activeLayerId: layerId,
      layerPanelVisible: false,
      layers: [layerData]
    };
    
    // Validate BEFORE removing legacy fields
    const validation = validateMigration(backup, migratedData);
    
    if (!validation.valid) {
      console.error('[layerAccessor] Migration validation failed:', validation.errors);
      console.error('[layerAccessor] Restoring from backup');
      return backup; // Return the backup (original data)
    }
    
    // Only NOW remove legacy root-level layer data (after validation passed)
    // TypeScript doesn't like delete on typed objects, so we use a workaround
    const cleanedData = { ...migratedData } as MapData & Partial<LegacyMapData>;
    delete cleanedData.cells;
    delete cleanedData.edges;
    delete cleanedData.objects;
    delete cleanedData.textLabels;
    
    // Store migration metadata for debugging
    cleanedData._migratedAt = new Date().toISOString();
    
    console.log('[layerAccessor] Migration successful to schema version', SCHEMA_VERSION);
    
    return cleanedData as MapData;
    
  } catch (error) {
    console.error('[layerAccessor] Migration failed with error:', error);
    console.error('[layerAccessor] Restoring from backup');
    return backup; // Return the backup (original data)
  }
}

/**
 * Check if map data needs migration
 */
function needsMigration(mapData: MapData | LegacyMapData | null | undefined): boolean {
  if (!mapData) return false;
  
  // Needs migration if no schemaVersion, or version is old, or no layers array
  const needsIt = !mapData.schemaVersion || 
                  mapData.schemaVersion < SCHEMA_VERSION || 
                  !(mapData as MapData).layers;
  
  if (needsIt) {
    console.log('[layerAccessor] Map needs migration:', {
      currentVersion: mapData.schemaVersion || 'none',
      targetVersion: SCHEMA_VERSION,
      hasLayers: !!(mapData as MapData).layers
    });
  }
  
  return needsIt;
}

// ============================================================================
// FOG OF WAR FUNCTIONS
// ============================================================================

/**
 * Initialize fog of war for a layer (first use)
 * Creates the fogOfWar structure with empty foggedCells array
 */
function initializeFogOfWar(mapData: MapData, layerId: LayerId): MapData {
  return updateLayer(mapData, layerId, {
    fogOfWar: {
      enabled: true,
      foggedCells: [],
      texture: null
    }
  });
}

/**
 * Check if a cell is fogged
 */
function isCellFogged(layer: MapLayer, col: number, row: number): boolean {
  if (!layer.fogOfWar || !layer.fogOfWar.enabled) return false;
  return layer.fogOfWar.foggedCells.some(c => c.col === col && c.row === row);
}

/**
 * Add fog to a single cell
 */
function fogCell(layer: MapLayer, col: number, row: number): MapLayer {
  if (!layer.fogOfWar) return layer;
  if (isCellFogged(layer, col, row)) return layer; // Already fogged
  
  return {
    ...layer,
    fogOfWar: {
      ...layer.fogOfWar,
      foggedCells: [...layer.fogOfWar.foggedCells, { col, row }]
    }
  };
}

/**
 * Remove fog from a single cell (reveal it)
 */
function revealCell(layer: MapLayer, col: number, row: number): MapLayer {
  if (!layer.fogOfWar) return layer;
  
  return {
    ...layer,
    fogOfWar: {
      ...layer.fogOfWar,
      foggedCells: layer.fogOfWar.foggedCells.filter(
        c => !(c.col === col && c.row === row)
      )
    }
  };
}

/**
 * Add fog to a rectangular area of cells
 */
function fogRectangle(
  layer: MapLayer,
  startCol: number,
  startRow: number,
  endCol: number,
  endRow: number
): MapLayer {
  if (!layer.fogOfWar) return layer;
  
  // Normalize coordinates (handle any corner order)
  const minCol = Math.min(startCol, endCol);
  const maxCol = Math.max(startCol, endCol);
  const minRow = Math.min(startRow, endRow);
  const maxRow = Math.max(startRow, endRow);
  
  // Build set of existing fogged cells for fast lookup
  const existingSet = new Set(
    layer.fogOfWar.foggedCells.map(c => `${c.col},${c.row}`)
  );
  
  // Collect new cells to add
  const newCells: FoggedCell[] = [];
  for (let col = minCol; col <= maxCol; col++) {
    for (let row = minRow; row <= maxRow; row++) {
      const key = `${col},${row}`;
      if (!existingSet.has(key)) {
        newCells.push({ col, row });
      }
    }
  }
  
  if (newCells.length === 0) return layer;
  
  return {
    ...layer,
    fogOfWar: {
      ...layer.fogOfWar,
      foggedCells: [...layer.fogOfWar.foggedCells, ...newCells]
    }
  };
}

/**
 * Remove fog from a rectangular area of cells (reveal them)
 */
function revealRectangle(
  layer: MapLayer,
  startCol: number,
  startRow: number,
  endCol: number,
  endRow: number
): MapLayer {
  if (!layer.fogOfWar) return layer;
  
  // Normalize coordinates
  const minCol = Math.min(startCol, endCol);
  const maxCol = Math.max(startCol, endCol);
  const minRow = Math.min(startRow, endRow);
  const maxRow = Math.max(startRow, endRow);
  
  return {
    ...layer,
    fogOfWar: {
      ...layer.fogOfWar,
      foggedCells: layer.fogOfWar.foggedCells.filter(c => 
        c.col < minCol || c.col > maxCol || c.row < minRow || c.row > maxRow
      )
    }
  };
}

/**
 * Add fog to all cells within bounds
 */
function fogAll(layer: MapLayer, bounds: FogBounds): MapLayer {
  if (!layer.fogOfWar) return layer;
  if (!bounds || bounds.maxCol === undefined || bounds.maxRow === undefined) {
    console.warn('[fogAll] Invalid bounds provided');
    return layer;
  }
  
  const allCells: FoggedCell[] = [];
  for (let col = 0; col < bounds.maxCol; col++) {
    for (let row = 0; row < bounds.maxRow; row++) {
      allCells.push({ col, row });
    }
  }
  
  return {
    ...layer,
    fogOfWar: {
      ...layer.fogOfWar,
      foggedCells: allCells
    }
  };
}

/**
 * Fog all painted cells on a layer
 * For unbounded maps where we only want to fog cells that have been drawn
 */
function fogPaintedCells(layer: MapLayer, geometry: IGeometry): MapLayer {
  if (!layer.fogOfWar) return layer;
  if (!layer.cells || layer.cells.length === 0) return layer;
  if (!geometry || typeof geometry.cellToOffsetCoords !== 'function') {
    console.warn('[fogPaintedCells] Invalid geometry provided');
    return layer;
  }
  
  const existingFogged = new Set(
    layer.fogOfWar.foggedCells.map(c => `${c.col},${c.row}`)
  );
  
  const newCells: FoggedCell[] = [];
  for (const cell of layer.cells) {
    const { col, row } = geometry.cellToOffsetCoords(cell);
    const key = `${col},${row}`;
    if (!existingFogged.has(key)) {
      newCells.push({ col, row });
      existingFogged.add(key);
    }
  }
  
  if (newCells.length === 0) return layer;
  
  return {
    ...layer,
    fogOfWar: {
      ...layer.fogOfWar,
      foggedCells: [...layer.fogOfWar.foggedCells, ...newCells]
    }
  };
}

/**
 * Remove all fog from a layer (reveal everything)
 */
function revealAll(layer: MapLayer): MapLayer {
  if (!layer.fogOfWar) return layer;
  
  return {
    ...layer,
    fogOfWar: {
      ...layer.fogOfWar,
      foggedCells: []
    }
  };
}

/**
 * Toggle fog visibility without changing fogged cells
 */
function toggleFogVisibility(layer: MapLayer): MapLayer {
  if (!layer.fogOfWar) return layer;
  
  return {
    ...layer,
    fogOfWar: {
      ...layer.fogOfWar,
      enabled: !layer.fogOfWar.enabled
    }
  };
}

/**
 * Set fog visibility explicitly
 */
function setFogVisibility(layer: MapLayer, enabled: boolean): MapLayer {
  if (!layer.fogOfWar) return layer;
  
  return {
    ...layer,
    fogOfWar: {
      ...layer.fogOfWar,
      enabled: !!enabled
    }
  };
}

/**
 * Check if a layer has any fog data (regardless of visibility)
 */
function hasFogData(layer: MapLayer): boolean {
  return !!(layer.fogOfWar && layer.fogOfWar.foggedCells && layer.fogOfWar.foggedCells.length > 0);
}

/**
 * Get fog state summary for UI display
 */
function getFogState(layer: MapLayer): FogState {
  if (!layer.fogOfWar) {
    return { initialized: false, enabled: false, cellCount: 0 };
  }
  return {
    initialized: true,
    enabled: layer.fogOfWar.enabled,
    cellCount: layer.fogOfWar.foggedCells?.length || 0
  };
}

// ============================================================================
// EXPORTS
// ============================================================================

return {
  // Constants (re-exported from dmtConstants for convenience)
  SCHEMA_VERSION,
  
  // UUID generation
  generateLayerId,
  
  // Layer access
  getActiveLayer,
  getLayersOrdered,
  getLayerById,
  getLayerIndex,
  getLayerBelow,
  
  // Layer modification
  updateLayer,
  updateActiveLayer,
  setActiveLayer,
  addLayer,
  removeLayer,
  reorderLayers,
  
  // Migration
  createEmptyLayer,
  createBackup,
  validateMigration,
  migrateToLayerSchema,
  needsMigration,
  
  // Fog of War
  initializeFogOfWar,
  isCellFogged,
  fogCell,
  revealCell,
  fogRectangle,
  revealRectangle,
  fogAll,
  fogPaintedCells,
  revealAll,
  toggleFogVisibility,
  setFogVisibility,
  hasFogData,
  getFogState
};
```

# fileOperations

```ts
/**
 * fileOperations.ts
 *
 * File I/O operations for map data persistence.
 * Handles loading/saving map data to the Obsidian vault.
 */

import type { MapData, MapType, ViewState } from '#types/core/map.types';
import type { HexOrientation } from '#types/settings/settings.types';
import type { Layer } from '#types/core/layer.types';

/** Constants module */
interface ConstantsModule {
  DEFAULTS: {
    hexSize: number;
    hexOrientation: HexOrientation;
    hexBounds: { maxCol: number; maxRow: number };
    dimensions: { width: number; height: number };
    gridSize: number;
    initialZoom: number;
  };
  DATA_FILE_PATH: string;
  SCHEMA_VERSION: number;
}

/** Layer accessor module */
interface LayerAccessorModule {
  migrateToLayerSchema: (mapData: MapData) => MapData;
  needsMigration: (mapData: MapData) => boolean;
  generateLayerId: () => string;
}

/** Settings accessor module */
interface SettingsAccessorModule {
  getSettings: () => { hexSize?: number; hexOrientation?: HexOrientation };
}

/** Offset coordinates module */
interface OffsetCoordsModule {
  offsetToAxial: (col: number, row: number, orientation: HexOrientation) => { q: number; r: number };
}

const { DEFAULTS, DATA_FILE_PATH, SCHEMA_VERSION } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants")) as ConstantsModule;
const { offsetToAxial } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "offsetCoordinates")) as OffsetCoordsModule;
const { getSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsAccessor")) as SettingsAccessorModule;
const {
  migrateToLayerSchema,
  needsMigration,
  generateLayerId
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor")) as LayerAccessorModule;

/** Data file structure */
interface DataFile {
  maps: Record<string, MapData>;
}

/**
 * Load map data from vault
 */
async function loadMapData(mapId: string, mapName: string = '', mapType: MapType = 'grid'): Promise<MapData> {
  try {
    const file = app.vault.getAbstractFileByPath(DATA_FILE_PATH);

    if (!file) {
      return createNewMap(mapId, mapName, mapType);
    }

    const content = await app.vault.read(file);
    const data = JSON.parse(content) as DataFile;

    if (data.maps && data.maps[mapId]) {
      const mapData = data.maps[mapId];

      // Ensure all arrays exist
      if (!mapData.objects) {
        mapData.objects = [];
      }
      if (!mapData.textLabels) {
        mapData.textLabels = [];
      }
      if (!mapData.customColors) {
        mapData.customColors = [];
      }
      // Ensure edges array exists (for edge painting feature)
      if (!mapData.edges) {
        mapData.edges = [];
      }
      // Ensure mapType exists (backward compatibility)
      if (!mapData.mapType) {
        mapData.mapType = 'grid';
      }
      // Ensure settings exist (backward compatibility)
      if (!mapData.settings) {
        mapData.settings = {
          useGlobalSettings: true,
          overrides: {}
        };
      }
      // Ensure uiPreferences exist (backward compatibility)
      if (!mapData.uiPreferences) {
        mapData.uiPreferences = {
          rememberPanZoom: true,
          rememberSidebarState: true,
          rememberExpandedState: false
        };
      }
      // Ensure expandedState exists (backward compatibility)
      if (mapData.expandedState === undefined) {
        mapData.expandedState = false;
      }
      // Ensure lastTextLabelSettings exists (backward compatibility)
      if (!mapData.lastTextLabelSettings) {
        mapData.lastTextLabelSettings = null;
      }
      // Ensure hexBounds exists for hex maps (use defaults, handle migration)
      if (mapData.mapType === 'hex') {
        if (!mapData.hexBounds) {
          // No bounds at all - use defaults
          mapData.hexBounds = { ...DEFAULTS.hexBounds };
        } else if ((mapData.hexBounds as any).maxQ !== undefined) {
          // Old axial bounds format - convert to offset format
          mapData.hexBounds = {
            maxCol: (mapData.hexBounds as any).maxQ,
            maxRow: (mapData.hexBounds as any).maxR
          };
        }
        // else: already has maxCol/maxRow (new format) - no action needed

        // Ensure backgroundImage exists for hex maps (backward compatibility)
        if (!mapData.backgroundImage) {
          mapData.backgroundImage = {
            path: null,
            lockBounds: false,
            gridDensity: 'medium',
            customColumns: 24,
            sizingMode: 'density',
            measurementMethod: 'corner',
            measurementSize: 86,
            fineTuneOffset: 0
          };
        } else {
          // Ensure new fields exist on existing backgroundImage objects
          if (mapData.backgroundImage.gridDensity === undefined) {
            mapData.backgroundImage.gridDensity = 'medium';
          }
          if (mapData.backgroundImage.customColumns === undefined) {
            mapData.backgroundImage.customColumns = 24;
          }
          // Add new fields for measurement mode (v1.1.0)
          if (mapData.backgroundImage.sizingMode === undefined) {
            mapData.backgroundImage.sizingMode = 'density';
          }
          if (mapData.backgroundImage.measurementMethod === undefined) {
            mapData.backgroundImage.measurementMethod = 'corner';
          }
          if (mapData.backgroundImage.measurementSize === undefined) {
            mapData.backgroundImage.measurementSize = 86;
          }
          if (mapData.backgroundImage.fineTuneOffset === undefined) {
            mapData.backgroundImage.fineTuneOffset = 0;
          }
        }
      }
      // Migrate to layer schema if needed (v2)
      if (needsMigration(mapData)) {
        data.maps[mapId] = migrateToLayerSchema(mapData);
      }

      return data.maps[mapId];
    } else {
      return createNewMap(mapId, mapName, mapType);
    }
  } catch (error) {
    console.error('[loadMapData] Error:', error);
    return createNewMap(mapId, mapName, mapType);
  }
}

/**
 * Save map data to vault
 */
async function saveMapData(mapId: string, mapData: MapData): Promise<boolean> {
  try {
    let allData: DataFile = { maps: {} };

    // Load existing data
    const file = app.vault.getAbstractFileByPath(DATA_FILE_PATH);
    if (file) {
      const content = await app.vault.read(file);
      allData = JSON.parse(content) as DataFile;
    }

    // Update specific map
    if (!allData.maps) allData.maps = {};
    allData.maps[mapId] = mapData;

    // Save back
    const jsonString = JSON.stringify(allData, null, 2);

    if (file) {
      await app.vault.modify(file, jsonString);
    } else {
      await app.vault.create(DATA_FILE_PATH, jsonString);
    }

    return true;
  } catch (error) {
    console.error('Error saving map data:', error);
    return false;
  }
}

/**
 * Create a new map with defaults
 */
function createNewMap(mapId: string, mapName: string = '', mapType: MapType = 'grid'): MapData {
  if (!DEFAULTS) {
    console.error('[createNewMap] CRITICAL: DEFAULTS is undefined!');
    throw new Error('DEFAULTS is undefined - constants.js import failed');
  }

  // Generate layer ID for initial layer
  const initialLayerId = generateLayerId();

  // Initial layer
  const initialLayer: Layer = {
    id: initialLayerId,
    name: '1',
    order: 0,
    visible: true,
    cells: [],
    edges: [],
    objects: [],
    textLabels: [],
    fogOfWar: null
  };

  // Base map structure with layer schema (v2)
  const baseMap: MapData = {
    // Global settings
    name: mapName,
    description: "",
    mapType: mapType,
    northDirection: 0,
    customColors: [],
    sidebarCollapsed: false,
    expandedState: false,
    settings: {
      useGlobalSettings: true,
      overrides: {}
    },
    uiPreferences: {
      rememberPanZoom: true,
      rememberSidebarState: true,
      rememberExpandedState: false
    },
    lastTextLabelSettings: null,

    // Layer system (v2)
    schemaVersion: SCHEMA_VERSION,
    activeLayerId: initialLayerId,
    layerPanelVisible: false,
    layers: [initialLayer],

    // Will be set below based on mapType
    gridSize: DEFAULTS.gridSize,
    dimensions: { ...DEFAULTS.dimensions },
    viewState: {
      zoom: DEFAULTS.initialZoom,
      center: { x: 0, y: 0 }
    }
  };

  // Add type-specific properties
  if (mapType === 'hex') {
    // Get global settings to respect user configuration
    const globalSettings = getSettings();

    baseMap.hexSize = globalSettings.hexSize || DEFAULTS.hexSize;
    baseMap.orientation = globalSettings.hexOrientation || DEFAULTS.hexOrientation;
    baseMap.hexBounds = { ...DEFAULTS.hexBounds };
    baseMap.dimensions = { ...DEFAULTS.dimensions };

    // Calculate proper viewport center for hex map using offset coordinates
    const hexSize = baseMap.hexSize;
    const orientation = baseMap.orientation;

    // Calculate center in offset coordinates (rectangular bounds)
    const centerCol = Math.floor(DEFAULTS.hexBounds.maxCol / 2);
    const centerRow = Math.floor(DEFAULTS.hexBounds.maxRow / 2);

    // Convert offset center to axial coordinates
    const { q: centerQ, r: centerR } = offsetToAxial(centerCol, centerRow, orientation);

    // Convert hex center to world coordinates (using axial coords)
    let worldX: number, worldY: number;
    if (orientation === 'flat') {
      worldX = hexSize * (3 / 2) * centerQ;
      worldY = hexSize * (Math.sqrt(3) / 2 * centerQ + Math.sqrt(3) * centerR);
    } else {
      // pointy
      worldX = hexSize * (Math.sqrt(3) * centerQ + Math.sqrt(3) / 2 * centerR);
      worldY = hexSize * (3 / 2) * centerR;
    }

    baseMap.viewState = {
      zoom: DEFAULTS.initialZoom,
      center: {
        x: worldX,
        y: worldY
      }
    };
  } else {
    // Grid map
    baseMap.gridSize = DEFAULTS.gridSize;
    baseMap.dimensions = { ...DEFAULTS.dimensions };
    baseMap.viewState = {
      zoom: DEFAULTS.initialZoom,
      center: {
        x: Math.floor(DEFAULTS.dimensions.width / 2),
        y: Math.floor(DEFAULTS.dimensions.height / 2)
      }
    };
  }

  return baseMap;
}

return { loadMapData, saveMapData, createNewMap };

```

# imageOperations

```ts
/**
 * imageOperations.ts
 *
 * Utilities for working with vault images:
 * - Building image index for autocomplete
 * - Loading and caching images
 * - Calculating grid dimensions from image size
 */

import type {
  HexOrientation,
  ImageDimensions,
  GridCalculation,
  GridDensityPreset,
} from '#types/settings/settings.types';

/** Image file index entry */
interface ImageIndexEntry {
  path: string;
  displayName: string;
}

/** Grid density presets map */
type GridDensityPresets = Record<string, GridDensityPreset>;

// Module-level caches (persist across renders)
const imageCache = new Map<string, HTMLImageElement>();
const loadingPromises = new Map<string, Promise<HTMLImageElement | null>>();
const dimensionsCache = new Map<string, ImageDimensions>();

/**
 * Grid density presets for hex maps
 */
const GRID_DENSITY_PRESETS: GridDensityPresets = {
  sparse: { columns: 12, label: 'Sparse (~12 columns)', description: 'Regional scale' },
  medium: { columns: 24, label: 'Medium (~24 columns)', description: 'Dungeon scale' },
  dense: { columns: 48, label: 'Dense (~48 columns)', description: 'Tactical scale' }
};

/**
 * Build index of all image files in vault for autocomplete
 */
async function buildImageIndex(): Promise<ImageIndexEntry[]> {
  const imageExtensions = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp'];
  const imageFiles: ImageIndexEntry[] = [];

  // Get all files from vault
  const files = app.vault.getFiles();

  for (const file of files) {
    const ext = file.extension.toLowerCase();
    if (imageExtensions.includes(ext)) {
      imageFiles.push({
        path: file.path,
        displayName: file.basename + '.' + file.extension
      });
    }
  }

  // Sort by display name for better UX
  imageFiles.sort((a, b) => a.displayName.localeCompare(b.displayName));

  return imageFiles;
}

/**
 * Get image display names only (for autocomplete suggestions)
 */
async function getImageDisplayNames(): Promise<string[]> {
  const index = await buildImageIndex();
  return index.map(item => item.displayName);
}

/**
 * Get full vault path from display name
 * If multiple files have same name, returns first match
 */
async function getFullPathFromDisplayName(displayName: string): Promise<string | null> {
  const index = await buildImageIndex();
  const match = index.find(item => item.displayName === displayName);
  return match ? match.path : null;
}

/**
 * Get display name from full path
 */
function getDisplayNameFromPath(fullPath: string): string {
  if (!fullPath) return '';
  const parts = fullPath.split('/');
  return parts[parts.length - 1];
}

/**
 * Preload image into cache. Safe to call multiple times.
 * Returns cached image if available, otherwise loads and caches.
 */
async function preloadImage(vaultPath: string): Promise<HTMLImageElement | null> {
  if (!vaultPath) return null;

  // Return cached if available
  if (imageCache.has(vaultPath)) {
    return imageCache.get(vaultPath)!;
  }

  // Return existing load promise if in progress
  if (loadingPromises.has(vaultPath)) {
    return loadingPromises.get(vaultPath)!;
  }

  // Start new load
  const loadPromise = (async (): Promise<HTMLImageElement | null> => {
    try {
      // Get file from vault
      const file = app.vault.getAbstractFileByPath(vaultPath);
      if (!file) {
        console.warn(`[imageOperations] Image file not found: ${vaultPath}`);
        loadingPromises.delete(vaultPath);
        return null;
      }

      // Read as binary
      const binary = await app.vault.readBinary(file);

      // Convert to blob URL
      const blob = new Blob([binary]);
      const url = URL.createObjectURL(blob);

      // Create and load image
      const img = new Image();

      await new Promise<void>((resolve, reject) => {
        img.onload = () => {
          // Cache dimensions
          dimensionsCache.set(vaultPath, {
            width: img.naturalWidth,
            height: img.naturalHeight
          });
          resolve();
        };
        img.onerror = () => {
          console.error(`[imageOperations] Failed to load image: ${vaultPath}`);
          URL.revokeObjectURL(url);
          reject(new Error(`Failed to load image: ${vaultPath}`));
        };
        img.src = url;
      });

      // Cache the loaded image
      imageCache.set(vaultPath, img);
      loadingPromises.delete(vaultPath);

      return img;
    } catch (error) {
      console.error('[imageOperations] Error loading image:', error);
      loadingPromises.delete(vaultPath);
      return null;
    }
  })();

  loadingPromises.set(vaultPath, loadPromise);
  return loadPromise;
}

/**
 * Synchronous cache read for renderer.
 * Returns null if image not cached (renderer should handle gracefully).
 */
function getCachedImage(vaultPath: string): HTMLImageElement | null {
  return imageCache.get(vaultPath) || null;
}

/**
 * Get image dimensions (loads image if needed, caches result)
 */
async function getImageDimensions(vaultPath: string): Promise<ImageDimensions | null> {
  if (!vaultPath) return null;

  // Return cached dimensions if available
  if (dimensionsCache.has(vaultPath)) {
    return dimensionsCache.get(vaultPath)!;
  }

  // Load image (which will cache dimensions)
  const img = await preloadImage(vaultPath);

  if (!img) return null;

  // Should be in cache now
  return dimensionsCache.get(vaultPath) || null;
}

/**
 * Clear image from all caches
 */
function clearCachedImage(vaultPath: string): void {
  const img = imageCache.get(vaultPath);
  if (img && img.src) {
    // Revoke blob URL if it exists
    if (img.src.startsWith('blob:')) {
      URL.revokeObjectURL(img.src);
    }
  }

  imageCache.delete(vaultPath);
  loadingPromises.delete(vaultPath);
  dimensionsCache.delete(vaultPath);
}

/**
 * Calculate grid dimensions from image size and desired columns
 * Supports both flat-top and pointy-top hex orientations.
 *
 * For flat-top hexes:
 * - Horizontal spacing: hexSize * 1.5 per column
 * - Vertical spacing: hexSize * sqrt(3) per row
 *
 * For pointy-top hexes:
 * - Horizontal spacing: hexSize * sqrt(3) per column
 * - Vertical spacing: hexSize * 1.5 per row
 */
function calculateGridFromImage(
  imageWidth: number,
  imageHeight: number,
  columns: number,
  orientation: HexOrientation = 'flat'
): GridCalculation {
  let hexSize: number, hexWidth: number, hexHeight: number, vertSpacing: number;

  if (orientation === 'pointy') {
    // For pointy-top hexes in offset coordinate system:
    // - Each column adds hexSize * sqrt(3) to the width
    // - Total width = columns * hexSize * sqrt(3)
    // - Therefore: hexSize = width / (columns * sqrt(3))
    const sqrt3 = Math.sqrt(3);
    hexSize = imageWidth / (columns * sqrt3);
    hexWidth = hexSize * sqrt3;
    hexHeight = hexSize * 2;

    // Vertical spacing = hexSize * 1.5 for pointy-top hexes
    vertSpacing = hexSize * 1.5;
  } else {
    // For flat-top hexes in offset coordinate system:
    // - Each column adds hexSize * 1.5 to the width
    // - First hex takes hexSize * 2, subsequent hexes add hexSize * 1.5 each
    // - Total width = hexSize * 2 + (columns - 1) * hexSize * 1.5
    // - Simplified: width = hexSize * (2 + (columns - 1) * 1.5)
    // - Therefore: hexSize = width / (2 + (columns - 1) * 1.5)
    hexSize = imageWidth / (2 + (columns - 1) * 1.5);
    hexWidth = hexSize * 2;
    hexHeight = hexSize * Math.sqrt(3);

    // Vertical spacing = hexSize * sqrt(3) for flat-top hexes
    vertSpacing = hexSize * Math.sqrt(3);
  }

  // Calculate rows needed to cover image height
  const rows = Math.ceil(imageHeight / vertSpacing);

  return {
    columns,
    rows,
    hexSize: hexSize,
    hexWidth: Math.round(hexWidth)
  };
}

return {
  buildImageIndex,
  getImageDisplayNames,
  getFullPathFromDisplayName,
  getDisplayNameFromPath,
  preloadImage,
  getCachedImage,
  getImageDimensions,
  clearCachedImage,
  calculateGridFromImage,
  GRID_DENSITY_PRESETS
};

```

# useMapData

```ts
/**
 * useMapData.ts
 *
 * Hook for loading, saving, and managing map data.
 * Handles debounced autosave, background image preloading, and save status tracking.
 *
 * Features:
 * - Loads map data on mount (creates new map if not found)
 * - Debounced autosave (2 second delay)
 * - Force save for critical operations
 * - Background image preloading for hex maps
 * - Fog of war texture preloading
 * - Race condition prevention via version tracking
 */

// Type-only imports
import type { MapData, MapType } from '#types/core/map.types';
import type { PluginSettings } from '#types/settings/settings.types';
import type {
  SaveStatus,
  MapDataUpdater,
  UseMapDataResult,
  MapId,
  MapName,
} from '#types/hooks/mapData.types';

// Datacore imports
const { loadMapData, saveMapData } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "fileOperations")) as {
  loadMapData: (mapId: string, mapName: string, mapType: MapType) => Promise<MapData>;
  saveMapData: (mapId: string, mapData: MapData) => Promise<boolean>;
};

const { preloadImage } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "imageOperations")) as {
  preloadImage: (path: string) => Promise<HTMLImageElement | null>;
};

const { getEffectiveSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsAccessor")) as {
  getEffectiveSettings: (mapSettings: MapData['settings']) => PluginSettings;
};

/**
 * Hook for managing map data loading, saving, and state.
 *
 * @param mapId - Unique identifier for the map
 * @param mapName - Display name for the map (used when creating new maps)
 * @param mapType - Type of map ('grid' or 'hex')
 * @returns Map data management interface
 */
function useMapData(
  mapId: MapId,
  mapName: MapName = '',
  mapType: MapType = 'grid'
): UseMapDataResult {
  const [mapData, setMapData] = dc.useState<MapData | null>(null);
  const [isLoading, setIsLoading] = dc.useState<boolean>(true);
  const [saveStatus, setSaveStatus] = dc.useState<SaveStatus>('Saved');
  const [pendingData, setPendingData] = dc.useState<MapData | null>(null);
  const [backgroundImageReady, setBackgroundImageReady] = dc.useState<boolean>(false);
  const [fowImageReady, setFowImageReady] = dc.useState<boolean>(false);
  const saveTimerRef = dc.useRef<ReturnType<typeof setTimeout> | null>(null);
  const saveVersionRef = dc.useRef<number>(0);

  // Load map data on mount
  dc.useEffect(() => {
    async function load(): Promise<void> {
      const data = await loadMapData(mapId, mapName, mapType);
      setMapData(data);
      setIsLoading(false);
    }
    load();
  }, [mapId, mapName, mapType]);

  // Preload background image when map data loads
  dc.useEffect(() => {
    if (mapData?.backgroundImage?.path) {
      setBackgroundImageReady(false);
      preloadImage(mapData.backgroundImage.path).then((img) => {
        if (img) {
          setBackgroundImageReady(true);
        }
      });
    } else {
      setBackgroundImageReady(false);
    }
  }, [mapData?.backgroundImage?.path]);

  // Preload fog of war image when map loads or settings change
  dc.useEffect(() => {
    if (!mapData) return;

    const effectiveSettings = getEffectiveSettings(mapData.settings);
    const fowImagePath = effectiveSettings.fogOfWarImage;

    if (fowImagePath) {
      setFowImageReady(false);
      preloadImage(fowImagePath).then((img) => {
        if (img) {
          setFowImageReady(true);
        }
      });
    } else {
      setFowImageReady(false);
    }
  }, [mapData?.settings]);

  // Debounced save effect
  dc.useEffect(() => {
    if (!pendingData) return;

    // Clear existing timer
    if (saveTimerRef.current) {
      clearTimeout(saveTimerRef.current);
    }

    // Increment version for this pending data
    const currentVersion = ++saveVersionRef.current;

    // Set new timer for 2 seconds
    saveTimerRef.current = setTimeout(async () => {
      setSaveStatus('Saving...');
      const success = await saveMapData(mapId, pendingData);

      // Only clear pendingData if no new changes came in during the async save
      if (saveVersionRef.current === currentVersion) {
        setSaveStatus(success ? 'Saved' : 'Save failed');
        setPendingData(null);
        saveTimerRef.current = null;
      } else {
        // New changes came in during save - they'll be saved by their own timer
        if (success) {
          setSaveStatus('Unsaved changes');
        }
      }
    }, 2000);

    // Cleanup function
    return () => {
      if (saveTimerRef.current) {
        clearTimeout(saveTimerRef.current);
      }
    };
  }, [pendingData, mapId]);

  // Update map data and trigger debounced save
  const updateMapData: MapDataUpdater = dc.useCallback((updaterOrData) => {
    setMapData((prev) => {
      if (!prev) return prev;
      const newData = typeof updaterOrData === 'function'
        ? updaterOrData(prev)
        : updaterOrData;
      setPendingData(newData);
      setSaveStatus('Unsaved changes');
      return newData;
    });
  }, []);

  // Force immediate save
  const forceSave = dc.useCallback(async (): Promise<void> => {
    if (pendingData) {
      if (saveTimerRef.current) {
        clearTimeout(saveTimerRef.current);
        saveTimerRef.current = null;
      }

      const versionAtSaveStart = saveVersionRef.current;

      setSaveStatus('Saving...');
      const success = await saveMapData(mapId, pendingData);

      if (saveVersionRef.current === versionAtSaveStart) {
        setSaveStatus(success ? 'Saved' : 'Save failed');
        setPendingData(null);
      } else {
        if (success) {
          setSaveStatus('Unsaved changes');
        }
      }
    }
  }, [pendingData, mapId]);

  // Save on unmount if there's pending data
  dc.useEffect(() => {
    return () => {
      if (pendingData && saveTimerRef.current) {
        clearTimeout(saveTimerRef.current);
        // Fire and forget save on unmount
        saveMapData(mapId, pendingData);
      }
    };
  }, [pendingData, mapId]);

  return {
    mapData,
    isLoading,
    saveStatus,
    updateMapData,
    forceSave,
    backgroundImageReady,
    fowImageReady
  };
}

return { useMapData };

```

# useHistory

```ts
/**
 * useHistory.ts
 *
 * Generic undo/redo history management hook.
 * Maintains a stack of historical states with configurable max size.
 *
 * Features:
 * - Add states to history (clears redo stack)
 * - Undo/redo navigation
 * - History size limiting (from DEFAULTS.maxHistory)
 * - Full state save/restore for layer switching
 */

// Type-only imports
import type { HistoryState, UseHistoryResult } from '#types/hooks/history.types';

// Datacore imports
const { DEFAULTS } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants")) as {
  DEFAULTS: { maxHistory: number }
};

/**
 * Hook for managing undo/redo history of any state type.
 *
 * @template T - The type of state being tracked
 * @param initialState - Initial state to start history with
 * @returns History management interface
 */
function useHistory<T>(initialState: T): UseHistoryResult<T> {
  // Combine history and index into single state for better synchronization
  const [historyState, setHistoryState] = dc.useState<HistoryState<T>>({
    history: [initialState],
    currentIndex: 0
  });

  // Add a new state to history
  const addToHistory = dc.useCallback((newState: T): void => {
    setHistoryState((prev: HistoryState<T>) => {
      // Remove any "future" states (redo states) when adding new state
      const newHistory = prev.history.slice(0, prev.currentIndex + 1);

      // Add new state
      newHistory.push(newState);

      // Limit history size
      let newIndex = newHistory.length - 1;
      if (newHistory.length > DEFAULTS.maxHistory) {
        newHistory.shift();
        newIndex = prev.currentIndex; // Index stays the same since we removed from beginning
      }

      return {
        history: newHistory,
        currentIndex: newIndex
      };
    });
  }, []);

  // Undo to previous state
  const undo = dc.useCallback((): T | null => {
    let result: T | null = null;
    setHistoryState((prev: HistoryState<T>) => {
      if (prev.currentIndex > 0) {
        result = prev.history[prev.currentIndex - 1];
        return {
          ...prev,
          currentIndex: prev.currentIndex - 1
        };
      }
      return prev;
    });
    return result;
  }, []);

  // Redo to next state
  const redo = dc.useCallback((): T | null => {
    let result: T | null = null;
    setHistoryState((prev: HistoryState<T>) => {
      if (prev.currentIndex < prev.history.length - 1) {
        result = prev.history[prev.currentIndex + 1];
        return {
          ...prev,
          currentIndex: prev.currentIndex + 1
        };
      }
      return prev;
    });
    return result;
  }, []);

  // Reset history (useful when loading new map)
  const resetHistory = dc.useCallback((newState: T): void => {
    setHistoryState({
      history: [newState],
      currentIndex: 0
    });
  }, []);

  // Get full history state (for saving before layer switch)
  const getHistoryState = dc.useCallback((): HistoryState<T> => {
    return historyState;
  }, [historyState]);

  // Set full history state (for restoring after layer switch)
  const restoreHistoryState = dc.useCallback((savedState: HistoryState<T>): void => {
    if (savedState && savedState.history && typeof savedState.currentIndex === 'number') {
      setHistoryState(savedState);
    }
  }, []);

  // Check if undo/redo are available
  const canUndo = historyState.currentIndex > 0;
  const canRedo = historyState.currentIndex < historyState.history.length - 1;

  // Get current state
  const currentState = historyState.history[historyState.currentIndex];

  return {
    currentState,
    addToHistory,
    undo,
    redo,
    canUndo,
    canRedo,
    resetHistory,
    getHistoryState,
    restoreHistoryState
  };
}

return { useHistory };

```

# useLayerHistory

```ts
/**
 * useLayerHistory.ts
 *
 * Manages layer switching with per-layer undo/redo history.
 * This hook centralizes all history-related logic including:
 * - Per-layer history caching (each layer has independent undo/redo stacks)
 * - Layer select/add/delete handlers that preserve history state
 * - Undo/redo operations
 * - History tracking for data change handlers
 *
 * The hook internally uses useHistory and manages the layer-specific caching,
 * providing a clean API for the parent component.
 */

// Type-only imports
import type { MapData, MapLayer, LayerId } from '#types/core/map.types';
import type { HistoryState, UseHistoryResult } from '#types/hooks/history.types';
import type {
  LayerHistorySnapshot,
  LayerHistoryCache,
  UseLayerHistoryOptions,
  LayerActions,
  HistoryActions,
  UseLayerHistoryResult,
} from '#types/hooks/layerHistory.types';

// Datacore imports
const { useHistory } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useHistory")) as {
  useHistory: <T>(initialState: T) => UseHistoryResult<T>
};

const {
  getActiveLayer,
  getLayerById,
  updateActiveLayer,
  updateLayer,
  addLayer,
  removeLayer,
  reorderLayers,
  setActiveLayer
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor")) as {
  getActiveLayer: (mapData: MapData) => MapLayer;
  getLayerById: (mapData: MapData, layerId: LayerId) => MapLayer | null;
  updateActiveLayer: (mapData: MapData, updates: Partial<MapLayer>) => MapData;
  updateLayer: (mapData: MapData, layerId: LayerId, updates: Partial<MapLayer>) => MapData;
  addLayer: (mapData: MapData) => MapData;
  removeLayer: (mapData: MapData, layerId: LayerId) => MapData;
  reorderLayers: (mapData: MapData, layerId: LayerId, newIndex: number) => MapData;
  setActiveLayer: (mapData: MapData, layerId: LayerId) => MapData;
};

/**
 * Hook for managing layer switching with per-layer history
 *
 * @param options - Configuration options
 * @returns Layer and history state/actions
 */
function useLayerHistory({
  mapData,
  updateMapData,
  isLoading
}: UseLayerHistoryOptions): UseLayerHistoryResult {
  // =========================================================================
  // Core History Hook
  // =========================================================================

  const initialSnapshot: LayerHistorySnapshot = {
    cells: [],
    name: "",
    objects: [],
    textLabels: [],
    edges: [],
    curves: []
  };

  const {
    currentState: historyState,
    addToHistory: addToHistoryInternal,
    undo: undoInternal,
    redo: redoInternal,
    canUndo,
    canRedo,
    resetHistory,
    getHistoryState,
    restoreHistoryState
  } = useHistory<LayerHistorySnapshot>(initialSnapshot);

  // =========================================================================
  // Refs for History Management
  // =========================================================================

  // Track if we're applying history (to avoid adding to history during undo/redo)
  const isApplyingHistoryRef = dc.useRef<boolean>(false);

  // Track if history has been initialized for the current session
  const historyInitialized = dc.useRef<boolean>(false);

  // Cache history state per layer (keyed by layer ID)
  const layerHistoryCache = dc.useRef<LayerHistoryCache>({});

  // =========================================================================
  // History Initialization Effect
  // =========================================================================

  // Initialize history when map data loads (only once)
  dc.useEffect(() => {
    if (mapData && !isLoading && !historyInitialized.current) {
      const activeLayer = getActiveLayer(mapData);
      resetHistory({
        cells: activeLayer.cells,
        name: mapData.name || '',
        objects: activeLayer.objects || [],
        textLabels: activeLayer.textLabels || [],
        edges: activeLayer.edges || [],
        curves: activeLayer.curves || []
      });
      historyInitialized.current = true;
    }
  }, [mapData, isLoading, resetHistory]);

  // =========================================================================
  // Layer State Helpers
  // =========================================================================

  /**
   * Build a history state snapshot from layer data
   */
  const buildHistoryState = dc.useCallback(
    (layer: MapLayer, name: string): LayerHistorySnapshot => ({
      cells: layer.cells || [],
      name: name,
      objects: layer.objects || [],
      textLabels: layer.textLabels || [],
      edges: layer.edges || [],
      curves: layer.curves || []
    }),
    []
  );

  /**
   * Save current layer's history to cache
   */
  const saveCurrentLayerHistory = dc.useCallback((): void => {
    if (!mapData) return;
    const currentLayerId = mapData.activeLayerId;
    layerHistoryCache.current[currentLayerId] = getHistoryState();
  }, [mapData, getHistoryState]);

  /**
   * Restore or initialize history for a layer
   */
  const restoreOrInitLayerHistory = dc.useCallback(
    (newMapData: MapData, layerId: LayerId): void => {
      const cachedHistory = layerHistoryCache.current[layerId];
      if (cachedHistory) {
        restoreHistoryState(cachedHistory);
      } else {
        // No cached history for this layer - initialize fresh
        const layer = getActiveLayer(newMapData);
        historyInitialized.current = false;
        resetHistory(buildHistoryState(layer, newMapData.name || ''));
        historyInitialized.current = true;
      }
    },
    [restoreHistoryState, resetHistory, buildHistoryState]
  );

  // =========================================================================
  // Layer Management Handlers
  // =========================================================================

  const handleLayerSelect = dc.useCallback(
    (layerId: LayerId): void => {
      if (!mapData || mapData.activeLayerId === layerId) return;

      // Save current layer's history before switching
      saveCurrentLayerHistory();

      const newMapData = setActiveLayer(mapData, layerId);
      updateMapData(newMapData);

      // Restore new layer's history or initialize if none cached
      restoreOrInitLayerHistory(newMapData, layerId);
    },
    [mapData, updateMapData, saveCurrentLayerHistory, restoreOrInitLayerHistory]
  );

  // Add a new layer
  const handleLayerAdd = dc.useCallback((): void => {
    if (!mapData) return;

    // Save current layer's history before switching
    saveCurrentLayerHistory();

    const newMapData = addLayer(mapData);
    updateMapData(newMapData);

    // New layer always starts with fresh history
    const newActiveLayer = getActiveLayer(newMapData);
    historyInitialized.current = false;
    resetHistory(buildHistoryState(newActiveLayer, newMapData.name || ''));
    historyInitialized.current = true;
  }, [mapData, updateMapData, saveCurrentLayerHistory, resetHistory, buildHistoryState]);

  const handleLayerDelete = dc.useCallback(
    (layerId: LayerId): void => {
      if (!mapData) return;

      // removeLayer handles preventing deletion of last layer
      const newMapData = removeLayer(mapData, layerId);

      // Only update if something changed
      if (newMapData !== mapData) {
        // Clear cached history for deleted layer
        delete layerHistoryCache.current[layerId];

        updateMapData(newMapData);

        // If active layer changed, restore or init history for new active layer
        if (newMapData.activeLayerId !== mapData.activeLayerId) {
          restoreOrInitLayerHistory(newMapData, newMapData.activeLayerId);
        }
      }
    },
    [mapData, updateMapData, restoreOrInitLayerHistory]
  );

  // Reorder layers (no history interaction needed)
  const handleLayerReorder = dc.useCallback(
    (layerId: LayerId, newIndex: number): void => {
      if (!mapData) return;

      const newMapData = reorderLayers(mapData, layerId, newIndex);
      updateMapData(newMapData);
    },
    [mapData, updateMapData]
  );

  // Toggle show layer below for a specific layer
  const handleToggleShowLayerBelow = dc.useCallback(
    (layerId: LayerId): void => {
      if (!mapData) return;

      const layer = getLayerById(mapData, layerId);
      if (!layer) return;

      const newMapData = updateLayer(mapData, layerId, {
        showLayerBelow: !layer.showLayerBelow
      });
      updateMapData(newMapData);
    },
    [mapData, updateMapData]
  );

  // Set layer below opacity for a specific layer
  const handleSetLayerBelowOpacity = dc.useCallback(
    (layerId: LayerId, opacity: number): void => {
      if (!mapData) return;

      // Clamp opacity to valid range
      const clampedOpacity = Math.max(0.1, Math.min(0.5, opacity));

      const newMapData = updateLayer(mapData, layerId, {
        layerBelowOpacity: clampedOpacity
      });
      updateMapData(newMapData);
    },
    [mapData, updateMapData]
  );

  const handleUpdateLayerDisplay = dc.useCallback(
    (layerId: LayerId, newName: string, icon: string | null): void => {
      if (!mapData) return;

      const updates: Partial<MapLayer> = { name: newName };
      if (icon !== null) {
        updates.icon = icon;
      } else {
        // If icon is null, we need to remove it - use undefined
        updates.icon = undefined;
      }

      const newMapData = updateLayer(mapData, layerId, updates);
      updateMapData(newMapData);
    },
    [mapData, updateMapData]
  );

  // =========================================================================
  // Undo/Redo Handlers
  // =========================================================================

  const handleUndo = dc.useCallback((): void => {
    const previousState = undoInternal();
    if (previousState && mapData) {
      isApplyingHistoryRef.current = true;
      // Apply layer-specific data to active layer, name stays at root
      const newMapData = updateActiveLayer(
        { ...mapData, name: previousState.name },
        {
          cells: previousState.cells,
          objects: previousState.objects || [],
          textLabels: previousState.textLabels || [],
          edges: previousState.edges || [],
          curves: previousState.curves || []
        }
      );
      updateMapData(newMapData);
      // Use setTimeout to ensure state update completes before re-enabling history
      setTimeout(() => {
        isApplyingHistoryRef.current = false;
      }, 0);
    }
  }, [undoInternal, mapData, updateMapData]);

  const handleRedo = dc.useCallback((): void => {
    const nextState = redoInternal();
    if (nextState && mapData) {
      isApplyingHistoryRef.current = true;
      // Apply layer-specific data to active layer, name stays at root
      const newMapData = updateActiveLayer(
        { ...mapData, name: nextState.name },
        {
          cells: nextState.cells,
          objects: nextState.objects || [],
          textLabels: nextState.textLabels || [],
          edges: nextState.edges || [],
          curves: nextState.curves || []
        }
      );
      updateMapData(newMapData);
      // Use setTimeout to ensure state update completes before re-enabling history
      setTimeout(() => {
        isApplyingHistoryRef.current = false;
      }, 0);
    }
  }, [redoInternal, mapData, updateMapData]);

  // =========================================================================
  // History API for Data Handlers
  // =========================================================================

  /**
   * Check if we're currently applying history (undo/redo in progress)
   * Data handlers should skip adding to history when this returns true
   */
  const isApplyingHistory = dc.useCallback((): boolean => {
    return isApplyingHistoryRef.current;
  }, []);

  /**
   * Add a state to history (wrapper that checks isApplyingHistory)
   * This is what data change handlers should call
   */
  const addToHistory = dc.useCallback(
    (state: LayerHistorySnapshot): void => {
      if (!isApplyingHistoryRef.current) {
        addToHistoryInternal(state);
      }
    },
    [addToHistoryInternal]
  );

  // =========================================================================
  // Return Value
  // =========================================================================

  const layerActions: LayerActions = {
    handleLayerSelect,
    handleLayerAdd,
    handleLayerDelete,
    handleLayerReorder,
    handleToggleShowLayerBelow,
    handleSetLayerBelowOpacity,
    handleUpdateLayerDisplay
  };

  const historyActions: HistoryActions = {
    handleUndo,
    handleRedo,
    addToHistory,
    isApplyingHistory
  };

  return {
    layerActions,
    handleLayerSelect,
    handleLayerAdd,
    handleLayerDelete,
    handleLayerReorder,
    handleToggleShowLayerBelow,
    handleSetLayerBelowOpacity,
    handleUpdateLayerDisplay,
    canUndo,
    canRedo,
    historyActions,
    handleUndo,
    handleRedo,
    addToHistory,
    isApplyingHistory
  };
}

return { useLayerHistory };

```

# colorOperations

```ts
/**
 * colorOperations.ts
 * 
 * Color palette and utilities for cell coloring.
 */

// Type-only imports
import type { Cell } from '#types/core/cell.types';

// Datacore imports
const { getColorPaletteSettings, BUILT_IN_COLORS } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsAccessor")) as {
  getColorPaletteSettings: () => ColorDefinition[];
  BUILT_IN_COLORS: ColorDefinition[];
};

// ===========================================
// Types
// ===========================================

/** Color definition in the palette */
export interface ColorDefinition {
  id: string;
  color: string;
  label: string;
  isBuiltIn?: boolean;
  isCustom?: boolean;
  isModified?: boolean;
}

// ===========================================
// Constants
// ===========================================

/** Default cell color (tan/brown) */
const DEFAULT_COLOR = '#c4a57b';

/** 
 * Static fallback palette for backward compatibility.
 * Components should prefer getColorPalette() for dynamic colors.
 */
const COLOR_PALETTE: ColorDefinition[] = BUILT_IN_COLORS;

// ===========================================
// Functions
// ===========================================

/**
 * Get the current color palette (including customizations from settings).
 * This is the preferred way to get colors - it includes user customizations.
 */
function getColorPalette(): ColorDefinition[] {
  try {
    return getColorPaletteSettings();
  } catch (_error) {
    // Fallback to built-in colors
    return BUILT_IN_COLORS;
  }
}

/**
 * Get color for a cell (handles backward compatibility).
 */
function getCellColor(cell: Cell): string {
  return cell.color || DEFAULT_COLOR;
}

/**
 * Get color definition by hex value from current palette.
 */
function getColorByHex(colorHex: string): ColorDefinition | null {
  const palette = getColorPalette();
  return palette.find(c => c.color === colorHex) || null;
}

/**
 * Check if color is the default color.
 */
function isDefaultColor(colorHex: string | null | undefined): boolean {
  return !colorHex || colorHex === DEFAULT_COLOR;
}

// ===========================================
// Exports
// ===========================================

return {
  DEFAULT_COLOR,
  COLOR_PALETTE,
  getColorPalette,
  getCellColor,
  getColorByHex,
  isDefaultColor
};
```

# useToolState

```ts
/**
 * useToolState.ts
 *
 * Manages tool selection and color/opacity state for DungeonMapTracker.
 * Extracts related state into a cohesive unit for better organization.
 *
 * State managed:
 * - currentTool: Active drawing/interaction tool
 * - selectedObjectType: Object type for placement tool
 * - selectedColor: Active color for painting
 * - selectedOpacity: Opacity for painting (0-1)
 * - isColorPickerOpen: Whether color picker UI is visible
 */

// Type-only imports
import type {
  ToolId,
  UseToolStateOptions,
  UseToolStateResult,
  ToolStateValues,
  ToolStateActions
} from '#types/tools/tool.types';
import type { ObjectTypeId } from '#types/objects/object.types';

// Datacore imports
const { DEFAULT_COLOR } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "colorOperations")) as {
  DEFAULT_COLOR: string
};

/**
 * Hook for managing tool and color state
 */
function useToolState(options: UseToolStateOptions = {}): UseToolStateResult {
  const {
    initialTool = 'select',
    initialColor = DEFAULT_COLOR,
    initialOpacity = 1
  } = options;

  // Tool selection state
  const [currentTool, setCurrentTool] = dc.useState(initialTool);
  const [selectedObjectType, setSelectedObjectType] = dc.useState(null);

  // Color and opacity state
  const [selectedColor, setSelectedColor] = dc.useState(initialColor);
  const [selectedOpacity, setSelectedOpacity] = dc.useState(initialOpacity);
  const [isColorPickerOpen, setIsColorPickerOpen] = dc.useState(false);

  // Grouped state object for easy destructuring
  const toolState: ToolStateValues = {
    currentTool,
    selectedObjectType,
    selectedColor,
    selectedOpacity,
    isColorPickerOpen
  };

  // Grouped actions object
  const toolActions: ToolStateActions = {
    setCurrentTool,
    setSelectedObjectType,
    setSelectedColor,
    setSelectedOpacity,
    setIsColorPickerOpen
  };

  return {
    toolState,
    toolActions,
    currentTool,
    selectedObjectType,
    selectedColor,
    selectedOpacity,
    isColorPickerOpen,
    setCurrentTool,
    setSelectedObjectType,
    setSelectedColor,
    setSelectedOpacity,
    setIsColorPickerOpen
  };
}

return { useToolState };

```

# useFogOfWar

```ts
/**
 * useFogOfWar.ts
 *
 * Manages Fog of War UI state and high-level operations for DungeonMapTracker.
 * This is distinct from useFogTools.ts which handles canvas-level interactions.
 *
 * State managed:
 * - showFogTools: Whether the fog tools panel is expanded
 * - fogActiveTool: Currently selected fog tool ('paint' | 'erase' | 'rectangle' | null)
 *
 * Computed:
 * - currentFogState: Combined state from layer data + UI state
 *
 * Operations provided:
 * - Tool panel toggle and tool selection
 * - Fog visibility toggle
 * - Fill all / Clear all fog
 * - Handle fog changes from FogOfWarLayer
 */

// Type-only imports
import type { MapData, MapLayer, FogOfWar, FogState } from '#types/core/map.types';
import type { IGeometry, GridBounds } from '#types/core/geometry.types';
import type {
  FogToolId,
  CurrentFogState,
  UseFogOfWarOptions,
  FogStateValues,
  FogActions,
  UseFogOfWarResult,
} from '#types/hooks/fog.types';

// Datacore imports
const {
  getActiveLayer,
  updateActiveLayer,
  initializeFogOfWar,
  fogAll,
  fogPaintedCells,
  revealAll,
  toggleFogVisibility,
  getFogState
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor")) as {
  getActiveLayer: (mapData: MapData) => MapLayer;
  updateActiveLayer: (mapData: MapData, updates: Partial<MapLayer>) => MapData;
  initializeFogOfWar: (mapData: MapData, layerId: string) => MapData;
  fogAll: (layer: MapLayer, bounds: GridBounds) => MapLayer;
  fogPaintedCells: (layer: MapLayer, geometry: IGeometry) => MapLayer;
  revealAll: (layer: MapLayer) => MapLayer;
  toggleFogVisibility: (layer: MapLayer) => MapLayer;
  getFogState: (layer: MapLayer) => FogState;
};

/**
 * Hook for managing Fog of War UI state and high-level operations
 *
 * @param options - Configuration options
 * @returns Fog state and actions
 */
function useFogOfWar({
  mapData,
  geometry,
  updateMapData
}: UseFogOfWarOptions): UseFogOfWarResult {
  const [showFogTools, setShowFogTools] = dc.useState<boolean>(false);
  const [fogActiveTool, setFogActiveTool] = dc.useState<FogToolId | null>(null);

  // =========================================================================
  // Computed State
  // =========================================================================

  // Get current fog state for UI (combines layer data + UI state)
  const currentFogState = dc.useMemo((): CurrentFogState => {
    if (!mapData) {
      return { initialized: false, enabled: false, activeTool: null };
    }
    const activeLayer = getActiveLayer(mapData);
    const state = getFogState(activeLayer);
    return {
      ...state,
      activeTool: fogActiveTool
    };
  }, [mapData, fogActiveTool]);

  // =========================================================================
  // Handlers
  // =========================================================================

  const handleFogToolsToggle = dc.useCallback((): void => {
    setShowFogTools((prev: boolean) => !prev);
    // Clear active tool when closing panel
    if (showFogTools) {
      setFogActiveTool(null);
    }
  }, [showFogTools]);

  const handleFogToolSelect = dc.useCallback((tool: FogToolId): void => {
    setFogActiveTool((prev: FogToolId | null) => prev === tool ? null : tool);
  }, []);

  const handleFogVisibilityToggle = dc.useCallback((): void => {
    if (!mapData) return;

    const activeLayer = getActiveLayer(mapData);
    if (!activeLayer.fogOfWar) return;

    const updatedLayer = toggleFogVisibility(activeLayer);
    updateMapData(updateActiveLayer(mapData, { fogOfWar: updatedLayer.fogOfWar }));
  }, [mapData, updateMapData]);

  // Fill all cells with fog
  // For bounded maps (hex): fogs all cells within bounds
  // For unbounded maps (grid): fogs only painted cells
  const handleFogFillAll = dc.useCallback((): void => {
    if (!mapData || !geometry) return;

    let workingMapData = mapData;
    let activeLayer = getActiveLayer(workingMapData);

    // Initialize FoW if needed
    if (!activeLayer.fogOfWar) {
      workingMapData = initializeFogOfWar(workingMapData, workingMapData.activeLayerId);
      activeLayer = getActiveLayer(workingMapData);
    }

    // Use geometry to determine fog strategy
    let updatedLayer: MapLayer;
    if (geometry.isBounded()) {
      // Bounded maps: fog all cells within bounds
      const bounds = geometry.getBounds();
      if (!bounds) return;
      updatedLayer = fogAll(activeLayer, bounds);
    } else {
      // Unbounded maps: fog only painted cells
      if (!activeLayer.cells || activeLayer.cells.length === 0) {
        console.warn('[FoW] No painted cells to fog');
        return;
      }
      updatedLayer = fogPaintedCells(activeLayer, geometry);
    }

    // Ensure fog is enabled
    updateMapData(updateActiveLayer(workingMapData, {
      fogOfWar: {
        ...updatedLayer.fogOfWar!,
        enabled: true
      }
    }));
  }, [mapData, geometry, updateMapData]);

  const handleFogClearAll = dc.useCallback((): void => {
    if (!mapData) return;

    const activeLayer = getActiveLayer(mapData);
    if (!activeLayer.fogOfWar) return;

    const updatedLayer = revealAll(activeLayer);
    updateMapData(updateActiveLayer(mapData, { fogOfWar: updatedLayer.fogOfWar }));
  }, [mapData, updateMapData]);

  // Handle fog changes from FogOfWarLayer (for paint/erase/rectangle operations)
  const handleFogChange = dc.useCallback((updatedFogOfWar: FogOfWar): void => {
    if (!mapData) return;
    updateMapData(updateActiveLayer(mapData, { fogOfWar: updatedFogOfWar }));
  }, [mapData, updateMapData]);

  // =========================================================================
  // Return Value
  // =========================================================================

  const fogState: FogStateValues = {
    showFogTools,
    fogActiveTool,
    currentFogState
  };

  const fogActions: FogActions = {
    handleFogToolsToggle,
    handleFogToolSelect,
    handleFogVisibilityToggle,
    handleFogFillAll,
    handleFogClearAll,
    handleFogChange
  };

  return {
    fogState,
    fogActions,
    showFogTools,
    fogActiveTool,
    currentFogState,
    handleFogToolsToggle,
    handleFogToolSelect,
    handleFogVisibilityToggle,
    handleFogFillAll,
    handleFogClearAll,
    handleFogChange
  };
}

return { useFogOfWar };

```

# useDataHandlers

```ts
/**
 * useDataHandlers.ts
 *
 * Manages data change handlers for DungeonMapTracker.
 * Provides handlers for updating layer data (cells, objects, textLabels, edges)
 * and map-level data (name, custom colors).
 *
 * All layer data handlers use functional updaters for consistency and to avoid
 * stale closure issues. History tracking is integrated into each handler.
 */

// Type-only imports
import type { MapData, MapLayer, ViewState, TextLabelSettings } from '#types/core/map.types';
import type { Cell } from '#types/core/cell.types';
import type { Curve } from '#types/core/curve.types';
import type { MapObject } from '#types/objects/object.types';
import type { TextLabel } from '#types/objects/note.types';
import type { HexColor } from '#types/core/common.types';
import type {
  UseDataHandlersOptions,
  UseDataHandlersResult,
  HistoryState,
  CustomColor,
  LayerDataHandlers,
  MapDataHandlers,
} from '#types/hooks/dataHandlers.types';

// Datacore imports
const { getActiveLayer, updateActiveLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor")) as {
  getActiveLayer: (mapData: MapData) => MapLayer;
  updateActiveLayer: (mapData: MapData, updates: Partial<MapLayer>) => MapData;
};

/**
 * Hook for managing data change handlers
 */
function useDataHandlers({
  mapData,
  updateMapData,
  addToHistory,
  isApplyingHistory
}: UseDataHandlersOptions): UseDataHandlersResult {

  // =========================================================================
  // Helper: Build history state from layer + name
  // =========================================================================

  const buildHistoryState = dc.useCallback((
    layer: MapLayer,
    name: string,
    overrides: Partial<HistoryState> = {}
  ): HistoryState => ({
    cells: overrides.cells ?? layer.cells ?? [],
    name: name,
    objects: overrides.objects ?? layer.objects ?? [],
    textLabels: overrides.textLabels ?? layer.textLabels ?? [],
    edges: overrides.edges ?? layer.edges ?? [],
    curves: overrides.curves ?? layer.curves ?? []
  }), []);

  // =========================================================================
  // Factory: Create layer data change handler
  // =========================================================================

  type LayerField = 'cells' | 'objects' | 'textLabels' | 'edges' | 'curves';

  const createLayerDataHandler = dc.useCallback(<T,>(field: LayerField) => {
    return (newValue: T, suppressHistory = false): void => {
      if (isApplyingHistory()) return;

      updateMapData((currentMapData: MapData | null) => {
        if (!currentMapData) return currentMapData;

        const newMapData = updateActiveLayer(currentMapData, { [field]: newValue });

        if (!suppressHistory) {
          const activeLayer = getActiveLayer(currentMapData);
          addToHistory(buildHistoryState(activeLayer, currentMapData.name, { [field]: newValue as unknown as Cell[] | MapObject[] | TextLabel[] | unknown[] }));
        }

        return newMapData;
      });
    };
  }, [updateMapData, addToHistory, isApplyingHistory, buildHistoryState]);

  // =========================================================================
  // Layer Data Handlers (using factory)
  // =========================================================================

  const handleCellsChange = dc.useMemo(
    () => createLayerDataHandler<Cell[]>('cells'),
    [createLayerDataHandler]
  );

  const handleObjectsChange = dc.useMemo(
    () => createLayerDataHandler<MapObject[]>('objects'),
    [createLayerDataHandler]
  );

  const handleTextLabelsChange = dc.useMemo(
    () => createLayerDataHandler<TextLabel[]>('textLabels'),
    [createLayerDataHandler]
  );

  const handleEdgesChange = dc.useMemo(
    () => createLayerDataHandler<unknown[]>('edges'),
    [createLayerDataHandler]
  );

  const handleCurvesChange = dc.useMemo(
    () => createLayerDataHandler<Curve[]>('curves'),
    [createLayerDataHandler]
  );

  // =========================================================================
  // Map-Level Data Handlers
  // =========================================================================

  // Handle map name change
  const handleNameChange = dc.useCallback((newName: string): void => {
    if (isApplyingHistory()) return;

    updateMapData((currentMapData: MapData | null) => {
      if (!currentMapData) return currentMapData;

      const activeLayer = getActiveLayer(currentMapData);
      addToHistory(buildHistoryState(activeLayer, newName));

      return { ...currentMapData, name: newName };
    });
  }, [updateMapData, addToHistory, isApplyingHistory, buildHistoryState]);

  // Handle adding a custom color
  const handleAddCustomColor = dc.useCallback((newColor: HexColor): void => {
    updateMapData((currentMapData: MapData | null) => {
      if (!currentMapData) return currentMapData;

      const customColorId = `custom-${Date.now()}`;
      const customColorNumber = (currentMapData.customColors?.length || 0) + 1;
      const customColorLabel = `Custom ${customColorNumber}`;

      const newCustomColor: CustomColor = {
        id: customColorId,
        color: newColor,
        label: customColorLabel
      };

      return {
        ...currentMapData,
        customColors: [...(currentMapData.customColors || []), newCustomColor]
      };
    });
  }, [updateMapData]);

  // Handle deleting a custom color
  const handleDeleteCustomColor = dc.useCallback((colorId: string): void => {
    updateMapData((currentMapData: MapData | null) => {
      if (!currentMapData) return currentMapData;

      return {
        ...currentMapData,
        customColors: (currentMapData.customColors || []).filter(c => c.id !== colorId)
      };
    });
  }, [updateMapData]);

  // Handle updating a color's opacity
  const handleUpdateColorOpacity = dc.useCallback((colorId: string, newOpacity: number): void => {
    updateMapData((currentMapData: MapData | null) => {
      if (!currentMapData) return currentMapData;

      const isCustomColor = (currentMapData.customColors || []).some(c => c.id === colorId);

      if (isCustomColor) {
        return {
          ...currentMapData,
          customColors: currentMapData.customColors!.map(c =>
            c.id === colorId ? { ...c, opacity: newOpacity } : c
          )
        };
      } else {
        return {
          ...currentMapData,
          paletteColorOpacityOverrides: {
            ...(currentMapData.paletteColorOpacityOverrides || {}),
            [colorId]: newOpacity
          }
        };
      }
    });
  }, [updateMapData]);

  // Handle view state change - NOT tracked in history
  const handleViewStateChange = dc.useCallback((newViewState: ViewState): void => {
    updateMapData((currentMapData: MapData | null) => {
      if (!currentMapData) return currentMapData;
      return { ...currentMapData, viewState: newViewState };
    });
  }, [updateMapData]);

  // Handle sidebar collapse state change - NOT tracked in history
  const handleSidebarCollapseChange = dc.useCallback((collapsed: boolean): void => {
    updateMapData((currentMapData: MapData | null) => {
      if (!currentMapData) return currentMapData;
      return { ...currentMapData, sidebarCollapsed: collapsed };
    });
  }, [updateMapData]);

  // Handle text label settings change - NOT tracked in history
  const handleTextLabelSettingsChange = dc.useCallback((settings: TextLabelSettings): void => {
    updateMapData((currentMapData: MapData | null) => {
      if (!currentMapData) return currentMapData;
      return { ...currentMapData, lastTextLabelSettings: settings };
    });
  }, [updateMapData]);

  // =========================================================================
  // Return Value
  // =========================================================================

  const layerDataHandlers: LayerDataHandlers = {
    handleCellsChange,
    handleObjectsChange,
    handleTextLabelsChange,
    handleEdgesChange,
    handleCurvesChange
  };

  const mapDataHandlers: MapDataHandlers = {
    handleNameChange,
    handleAddCustomColor,
    handleDeleteCustomColor,
    handleUpdateColorOpacity,
    handleViewStateChange,
    handleSidebarCollapseChange,
    handleTextLabelSettingsChange
  };

  return {
    // Grouped access
    layerDataHandlers,
    mapDataHandlers,

    // Direct access
    handleNameChange,
    handleCellsChange,
    handleObjectsChange,
    handleTextLabelsChange,
    handleEdgesChange,
    handleCurvesChange,
    handleAddCustomColor,
    handleDeleteCustomColor,
    handleUpdateColorOpacity,
    handleViewStateChange,
    handleSidebarCollapseChange,
    handleTextLabelSettingsChange
  };
}

return { useDataHandlers };

```

# BaseGeometry

```ts
/**
 * BaseGeometry.ts
 * 
 * Abstract base class for geometry implementations (GridGeometry, HexGeometry).
 * Defines the common interface that all geometry classes must implement,
 * and provides shared utility methods.
 * 
 * COORDINATE SYSTEMS (implemented by subclasses):
 * - Grid coordinates: Normalized as Point {x, y}
 *   - GridGeometry interprets: x = gridX, y = gridY
 *   - HexGeometry interprets: x = q, y = r (axial)
 * 
 * - World coordinates: Float pixel coordinates in the map's coordinate system
 *   Origin and scale defined by geometry implementation
 * 
 * - Screen coordinates: Pixel coordinates on the canvas
 *   Includes viewport transforms (pan/zoom)
 * 
 * IMPLEMENTATION GUIDELINES:
 * - Subclasses MUST implement all abstract methods
 * - All coordinate I/O uses normalized Point for polymorphic usage
 * - Implementations map Point.x/y to their native coordinate names internally
 */

// Type-only imports - stripped at runtime, invisible to Datacore
import type {
  Point,
  ScreenCoords,
  WorldCoords,
  OffsetCoords,
  GridBounds,
  StrokeStyle,
  GridStyle,
  DistanceOptions,
  Cell,
  IGeometry
} from '#types/core/geometry.types';

// Re-export types for consumers
export type {
  Point,
  ScreenCoords,
  WorldCoords,
  OffsetCoords,
  GridBounds,
  StrokeStyle,
  GridStyle,
  DistanceOptions,
  Cell,
  IGeometry
};

/**
 * Abstract base class for geometry implementations.
 * Implements IGeometry interface with concrete shared methods
 * and abstract methods for subclass implementation.
 */
abstract class BaseGeometry implements IGeometry {
  /**
   * @throws {Error} If instantiated directly (must use subclass)
   */
  constructor() {
    if (new.target === BaseGeometry) {
      throw new Error('BaseGeometry is abstract and cannot be instantiated directly');
    }
  }
  
  // ============================================================================
  // CONCRETE METHODS (Shared implementation for all geometry types)
  // ============================================================================
  
  /**
   * Apply iOS-safe stroke style to canvas context
   * 
   * iOS may corrupt stroke-related canvas state during memory pressure events
   * (when app is backgrounded). This helper ensures all stroke properties are
   * explicitly set to valid values before any stroke operations.
   * 
   * @param ctx - Canvas context
   * @param style - Stroke style options
   * @param callback - Function containing stroke operations
   */
  withStrokeStyle(
    ctx: CanvasRenderingContext2D,
    style: StrokeStyle,
    callback: () => void
  ): void {
    const { lineColor = '#333333', lineWidth = 1 } = style;
    
    // Save context state
    ctx.save();
    
    // Explicitly reset ALL stroke-related properties
    // This protects against iOS state corruption
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = lineWidth;
    ctx.lineCap = 'butt';
    ctx.lineJoin = 'miter';
    ctx.miterLimit = 10;
    ctx.setLineDash([]);
    ctx.lineDashOffset = 0;
    
    // Execute stroke operations
    callback();
    
    // Restore context state
    ctx.restore();
  }
  
  /**
   * Convert world coordinates to screen coordinates (for rendering)
   * This is a pure coordinate transform that works identically for all geometry types
   * 
   * @param worldX - World X coordinate
   * @param worldY - World Y coordinate
   * @param offsetX - Screen offset X (viewport pan)
   * @param offsetY - Screen offset Y (viewport pan)
   * @param zoom - Current zoom level
   * @returns Screen coordinates
   */
  worldToScreen(
    worldX: number,
    worldY: number,
    offsetX: number,
    offsetY: number,
    zoom: number
  ): ScreenCoords {
    const screenX = offsetX + worldX * zoom;
    const screenY = offsetY + worldY * zoom;
    return { screenX, screenY };
  }

  /**
   * Convert screen coordinates to world coordinates
   * This is the inverse of worldToScreen and works identically for all geometry types
   * Useful for calculating visible bounds and converting pointer events
   * 
   * @param screenX - Screen X coordinate
   * @param screenY - Screen Y coordinate
   * @param zoom - Current zoom level
   * @returns World coordinates
   */
  screenToWorld(screenX: number, screenY: number, zoom: number): WorldCoords {
    return {
      worldX: screenX / zoom,
      worldY: screenY / zoom
    };
  }
  
  // ============================================================================
  // ABSTRACT METHODS (Must be implemented by subclasses)
  // ============================================================================
  
  /**
   * Convert world coordinates to grid coordinates
   * @returns Point where x/y are in the geometry's native coordinate system
   */
  abstract worldToGrid(worldX: number, worldY: number): Point;
  
  /**
   * Convert grid coordinates to world coordinates
   * @param x - Grid coordinate (gridX or q)
   * @param y - Grid coordinate (gridY or r)
   */
  abstract gridToWorld(x: number, y: number): WorldCoords;
  
  /**
   * Convert grid coordinates to screen coordinates
   */
  abstract gridToScreen(
    x: number,
    y: number,
    offsetX: number,
    offsetY: number,
    zoom: number
  ): ScreenCoords;
  
  /**
   * Get the scaled cell/hex size at current zoom level
   */
  abstract getScaledCellSize(zoom: number): number;
  
  /**
   * Create a cell object in the geometry's native format
   */
  abstract createCellObject(coords: Point, color: string): Cell;
  
  /**
   * Check if a cell matches given coordinates
   */
  abstract cellMatchesCoords(cell: Cell, coords: Point): boolean;
  
  /**
   * Get all cells within a rectangular area
   */
  abstract getCellsInRectangle(
    x1: number,
    y1: number,
    x2: number,
    y2: number
  ): Point[];
  
  /**
   * Get all cells within a circular area
   * @param radius - Radius in cells (not pixels)
   */
  abstract getCellsInCircle(
    centerX: number,
    centerY: number,
    radius: number
  ): Point[];
  
  /**
   * Get all cells along a line between two points
   */
  abstract getCellsInLine(
    x1: number,
    y1: number,
    x2: number,
    y2: number
  ): Point[];
  
  /**
   * Calculate Euclidean distance between two cells
   */
  abstract getEuclideanDistance(
    x1: number,
    y1: number,
    x2: number,
    y2: number
  ): number;
  
  /**
   * Calculate Manhattan distance between two cells
   */
  abstract getManhattanDistance(
    x1: number,
    y1: number,
    x2: number,
    y2: number
  ): number;
  
  /**
   * Calculate "game distance" between two cells with configurable rules
   * For grid: supports different diagonal calculation rules
   * For hex: returns hex distance (options are ignored)
   */
  abstract getCellDistance(
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    options?: DistanceOptions
  ): number;
  
  /**
   * Get all neighboring cells
   */
  abstract getNeighbors(x: number, y: number): Point[];
  
  /**
   * Check if coordinates are within bounds
   */
  abstract isWithinBounds(x: number, y: number): boolean;
  
  /**
   * Clamp coordinates to bounds
   */
  abstract clampToBounds(x: number, y: number): Point;
  
  /**
   * Convert grid coordinates to offset coordinates (col, row)
   * For grid: passthrough (x=col, y=row)
   * For hex: axial to offset conversion
   */
  abstract toOffsetCoords(gridX: number, gridY: number): OffsetCoords;
  
  /**
   * Convert a cell object to offset coordinates
   */
  abstract cellToOffsetCoords(cell: Cell): OffsetCoords;
  
  /**
   * Check if this geometry has defined bounds
   */
  abstract isBounded(): boolean;
  
  /**
   * Get the bounds for this geometry (if bounded)
   * Returns null for unbounded geometries
   */
  abstract getBounds(): GridBounds | null;
  
  /**
   * Draw grid lines on canvas
   */
  abstract drawGrid(
    ctx: CanvasRenderingContext2D,
    offsetX: number,
    offsetY: number,
    width: number,
    height: number,
    zoom: number,
    style: GridStyle
  ): void;
}

// Type exports for consuming modules
export type { BaseGeometry };

return { BaseGeometry };
```

# GridGeometry

```ts
/**
 * GridGeometry.ts
 * 
 * Handles all grid-specific geometric calculations and rendering.
 * Extends BaseGeometry to implement the standard geometry interface
 * for square grid-based maps.
 * 
 * COORDINATE SYSTEMS:
 * - Grid coordinates (x, y): Integer cell indices via Point type
 *   Used internally for all grid math and storage. Origin at (0,0) in top-left.
 * 
 * - World coordinates (worldX, worldY): Float pixel coordinates in the map's coordinate system
 *   Used for positioning and measurements. Origin at (0,0) at top-left corner of cell (0,0).
 * 
 * - Screen coordinates (screenX, screenY): Pixel coordinates on the canvas
 *   Used for rendering. Includes viewport transforms (pan/zoom/rotation).
 * 
 * API CONSISTENCY:
 * - All methods return Point {x, y} for grid coordinates
 * - Storage uses {x, y, color} format
 * - Polymorphic with HexGeometry through IGeometry interface
 * 
 * @extends BaseGeometry
 */

// Type-only imports
import type {
  Point,
  WorldCoords,
  ScreenCoords,
  OffsetCoords,
  GridBounds,
  BoundingBox,
  GridStyle,
  DistanceOptions,
  Cell
} from '#types/core/geometry.types';
import type { EdgeInfo } from '#types/contexts/context.types';

// Datacore imports
const { BaseGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "BaseGeometry")) as {
  BaseGeometry: new () => InstanceType<typeof BaseGeometryClass>
};

// Type for BaseGeometry class (we need this for extends)
declare class BaseGeometryClass {
  cellSize: number;
  worldToScreen(worldX: number, worldY: number, offsetX: number, offsetY: number, zoom: number): ScreenCoords;
  screenToWorld(screenX: number, screenY: number, zoom: number): WorldCoords;
}

/** Visible grid range for viewport calculations */
interface VisibleGridRange {
  startX: number;
  endX: number;
  startY: number;
  endY: number;
}

class GridGeometry extends BaseGeometry {
  readonly type = 'grid' as const;
  cellSize: number;

  /**
   * @param cellSize - Base size of each grid cell in pixels (before zoom)
   */
  constructor(cellSize: number) {
    super();
    this.cellSize = cellSize;
  }
  
  /**
   * Convert world coordinates to grid cell coordinates
   * @returns Point where x=gridX, y=gridY
   */
  worldToGrid(worldX: number, worldY: number): Point {
    const x = Math.floor(worldX / this.cellSize);
    const y = Math.floor(worldY / this.cellSize);
    return { x, y };
  }
  
  /**
   * Convert grid cell coordinates to world coordinates (top-left corner of cell)
   */
  gridToWorld(x: number, y: number): WorldCoords {
    const worldX = x * this.cellSize;
    const worldY = y * this.cellSize;
    return { worldX, worldY };
  }
  
  /**
   * Get the center point of a grid cell in world coordinates
   */
  getCellCenter(x: number, y: number): WorldCoords {
    const worldX = (x + 0.5) * this.cellSize;
    const worldY = (y + 0.5) * this.cellSize;
    return { worldX, worldY };
  }
  
  /**
   * Convert offset coordinates to world coordinates
   * For GridGeometry, offset coordinates are identical to grid coordinates.
   */
  offsetToWorld(col: number, row: number): WorldCoords {
    return this.gridToWorld(col, row);
  }
  
  /**
   * Snap world coordinates to the nearest grid cell (top-left corner)
   */
  snapToGrid(worldX: number, worldY: number): WorldCoords {
    const { x, y } = this.worldToGrid(worldX, worldY);
    return this.gridToWorld(x, y);
  }
  
  /**
   * Snap world coordinates to the nearest grid cell center
   */
  snapToCellCenter(worldX: number, worldY: number): WorldCoords {
    const { x, y } = this.worldToGrid(worldX, worldY);
    return this.getCellCenter(x, y);
  }
  
  /**
   * Calculate visible grid range for a given viewport
   */
  getVisibleGridRange(
    offsetX: number,
    offsetY: number,
    width: number,
    height: number,
    zoom: number
  ): VisibleGridRange {
    const scaledCellSize = this.cellSize * zoom;
    
    const startX = Math.floor(-offsetX / scaledCellSize);
    const endX = Math.ceil((width - offsetX) / scaledCellSize);
    const startY = Math.floor(-offsetY / scaledCellSize);
    const endY = Math.ceil((height - offsetY) / scaledCellSize);
    
    return { startX, endX, startY, endY };
  }
  
  /**
   * Convert grid coordinates to screen coordinates (for rendering)
   */
  gridToScreen(
    x: number,
    y: number,
    offsetX: number,
    offsetY: number,
    zoom: number
  ): ScreenCoords {
    const scaledCellSize = this.cellSize * zoom;
    const screenX = offsetX + x * scaledCellSize;
    const screenY = offsetY + y * scaledCellSize;
    return { screenX, screenY };
  }
  
  /**
   * Determine which edge of a cell was clicked based on world coordinates
   * 
   * @param worldX - World X coordinate
   * @param worldY - World Y coordinate
   * @param threshold - Distance from edge to count as hit (0-0.5, default 0.15)
   * @returns Edge info or null if click was in cell center
   */
  screenToEdge(worldX: number, worldY: number, threshold = 0.15): EdgeInfo | null {
    const cellX = Math.floor(worldX / this.cellSize);
    const cellY = Math.floor(worldY / this.cellSize);
    
    const offsetX = (worldX / this.cellSize) - cellX;
    const offsetY = (worldY / this.cellSize) - cellY;
    
    if (offsetY < threshold) {
      return { x: cellX, y: cellY, side: 'top' };
    }
    if (offsetY > 1 - threshold) {
      return { x: cellX, y: cellY, side: 'bottom' };
    }
    if (offsetX < threshold) {
      return { x: cellX, y: cellY, side: 'left' };
    }
    if (offsetX > 1 - threshold) {
      return { x: cellX, y: cellY, side: 'right' };
    }
    
    return null;
  }
  
  /**
   * Draw grid lines on the canvas using fill-based rendering
   * 
   * NOTE: Uses ctx.fillRect() instead of ctx.stroke() to work around
   * a rendering bug in Obsidian's Live Preview mode where CodeMirror's
   * canvas operations can corrupt the strokeStyle state.
   */
  drawGrid(
    ctx: CanvasRenderingContext2D,
    offsetX: number,
    offsetY: number,
    width: number,
    height: number,
    zoom: number,
    style: GridStyle = {}
  ): void {
    const { lineColor = '#333333', lineWidth = 1 } = style;
    const scaledCellSize = this.cellSize * zoom;
    
    const { startX, endX, startY, endY } = this.getVisibleGridRange(
      offsetX, offsetY, width, height, zoom
    );
    
    // Add extra padding for rotation handling
    const diagonal = Math.sqrt(width * width + height * height);
    const extraCells = Math.ceil(diagonal / scaledCellSize);
    
    const paddedStartX = startX - extraCells;
    const paddedEndX = endX + extraCells;
    const paddedStartY = startY - extraCells;
    const paddedEndY = endY + extraCells;
    
    // iOS defensive: Limit line extension
    const maxExtension = Math.max(width, height);
    
    // iOS defensive: Reset composite operation
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    
    const halfWidth = lineWidth / 2;
    
    // Draw vertical lines
    for (let x = paddedStartX; x <= paddedEndX; x++) {
      ctx.fillStyle = lineColor;
      const screenX = offsetX + x * scaledCellSize;
      ctx.fillRect(
        screenX - halfWidth,
        -maxExtension,
        lineWidth,
        height + maxExtension * 2
      );
    }
    
    // Draw horizontal lines
    for (let y = paddedStartY; y <= paddedEndY; y++) {
      ctx.fillStyle = lineColor;
      const screenY = offsetY + y * scaledCellSize;
      ctx.fillRect(
        -maxExtension,
        screenY - halfWidth,
        width + maxExtension * 2,
        lineWidth
      );
    }
  }
  
  /**
   * Draw a filled cell on the canvas
   */
  drawCell(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    offsetX: number,
    offsetY: number,
    zoom: number,
    color: string
  ): void {
    const scaledCellSize = this.cellSize * zoom;
    const { screenX, screenY } = this.gridToScreen(x, y, offsetX, offsetY, zoom);
    
    ctx.fillStyle = color;
    ctx.fillRect(screenX, screenY, scaledCellSize, scaledCellSize);
  }
  
  /**
   * Draw multiple cells of the same color (optimized batch rendering)
   */
  drawCells(
    ctx: CanvasRenderingContext2D,
    cells: Point[],
    offsetX: number,
    offsetY: number,
    zoom: number,
    color: string
  ): void {
    const scaledCellSize = this.cellSize * zoom;
    ctx.fillStyle = color;
    
    for (const cell of cells) {
      const { screenX, screenY } = this.gridToScreen(cell.x, cell.y, offsetX, offsetY, zoom);
      ctx.fillRect(screenX, screenY, scaledCellSize, scaledCellSize);
    }
  }
  
  /**
   * Get the size of a cell in screen pixels at current zoom
   */
  getScaledCellSize(zoom: number): number {
    return this.cellSize * zoom;
  }
  
  /**
   * Check if coordinates are within bounds
   * GridGeometry is unbounded by default, always returns true
   */
  isWithinBounds(_x: number, _y: number): boolean {
    return true;
  }
  
  /**
   * Clamp coordinates to bounds
   * GridGeometry is unbounded, returns input unchanged
   */
  clampToBounds(x: number, y: number): Point {
    return { x, y };
  }
  
  /**
   * Convert grid coordinates to offset coordinates
   * For grid geometry, gridX/gridY are already col/row
   */
  toOffsetCoords(x: number, y: number): OffsetCoords {
    return { col: x, row: y };
  }
  
  /**
   * Convert a cell object to offset coordinates
   */
  cellToOffsetCoords(cell: Cell): OffsetCoords {
    if ('x' in cell) {
      return { col: cell.x, row: cell.y };
    }
    // HexCell - shouldn't happen for GridGeometry but handle gracefully
    return { col: cell.q, row: cell.r };
  }
  
  /**
   * Check if this geometry has defined bounds
   * Grid maps are unbounded (infinite canvas)
   */
  isBounded(): boolean {
    return false;
  }
  
  /**
   * Get the bounds for this geometry
   * Grid maps have no bounds
   */
  getBounds(): GridBounds | null {
    return null;
  }
  
  /**
   * Get all grid cells within a rectangular area
   */
  getCellsInRectangle(x1: number, y1: number, x2: number, y2: number): Point[] {
    const minX = Math.min(x1, x2);
    const maxX = Math.max(x1, x2);
    const minY = Math.min(y1, y2);
    const maxY = Math.max(y1, y2);
    
    const cells: Point[] = [];
    for (let x = minX; x <= maxX; x++) {
      for (let y = minY; y <= maxY; y++) {
        cells.push({ x, y });
      }
    }
    
    return cells;
  }
  
  /**
   * Get all grid cells within a circle
   *
   * Supports float center coordinates for proper midpoint-centered circles.
   * The circle includes cells whose grid coordinates fall within the radius.
   */
  getCellsInCircle(centerX: number, centerY: number, radiusInCells: number): Point[] {
    const cells: Point[] = [];
    const radiusSquared = radiusInCells * radiusInCells;

    const minX = Math.floor(centerX - radiusInCells);
    const maxX = Math.ceil(centerX + radiusInCells);
    const minY = Math.floor(centerY - radiusInCells);
    const maxY = Math.ceil(centerY + radiusInCells);

    for (let x = minX; x <= maxX; x++) {
      for (let y = minY; y <= maxY; y++) {
        // Distance from cell's grid coordinate to the (possibly float) center
        const dx = x - centerX;
        const dy = y - centerY;
        const distSquared = dx * dx + dy * dy;

        if (distSquared <= radiusSquared) {
          cells.push({ x, y });
        }
      }
    }

    return cells;
  }
  
  /**
   * Get grid cells along a line (Bresenham's algorithm)
   */
  getCellsInLine(x1: number, y1: number, x2: number, y2: number): Point[] {
    const cells: Point[] = [];
    
    let x = x1;
    let y = y1;
    
    const dx = Math.abs(x2 - x1);
    const dy = Math.abs(y2 - y1);
    const sx = x1 < x2 ? 1 : -1;
    const sy = y1 < y2 ? 1 : -1;
    let err = dx - dy;
    
    while (true) {
      cells.push({ x, y });
      
      if (x === x2 && y === y2) break;
      
      const e2 = 2 * err;
      if (e2 > -dy) {
        err -= dy;
        x += sx;
      }
      if (e2 < dx) {
        err += dx;
        y += sy;
      }
    }
    
    return cells;
  }
  
  /**
   * Calculate distance between two grid cells (Manhattan distance)
   */
  getManhattanDistance(x1: number, y1: number, x2: number, y2: number): number {
    return Math.abs(x2 - x1) + Math.abs(y2 - y1);
  }
  
  /**
   * Calculate distance between two grid cells (Euclidean distance)
   */
  getEuclideanDistance(x1: number, y1: number, x2: number, y2: number): number {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
  }
  
  /**
   * Calculate game distance between two grid cells with configurable diagonal rules
   */
  getCellDistance(
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    options: DistanceOptions = {}
  ): number {
    const { diagonalRule = 'alternating' } = options;
    
    const dx = Math.abs(x2 - x1);
    const dy = Math.abs(y2 - y1);
    
    switch (diagonalRule) {
      case 'equal':
        return Math.max(dx, dy);
        
      case 'euclidean':
        return Math.sqrt(dx * dx + dy * dy);
        
      case 'alternating':
      default:
        const straights = Math.abs(dx - dy);
        const diagonals = Math.min(dx, dy);
        return straights + diagonals + Math.floor(diagonals / 2);
    }
  }
  
  /**
   * Create a cell object in grid coordinate format
   * @param coords - Point coordinates {x, y}
   * @param color - Cell color
   */
  createCellObject(coords: Point, color: string): Cell {
    return { x: coords.x, y: coords.y, color };
  }
  
  /**
   * Check if a cell matches given coordinates
   * @param cell - Cell object to check
   * @param coords - Point coordinates {x, y}
   */
  cellMatchesCoords(cell: Cell, coords: Point): boolean {
    if ('x' in cell) {
      return cell.x === coords.x && cell.y === coords.y;
    }
    // HexCell comparison - x maps to q, y maps to r
    return cell.q === coords.x && cell.r === coords.y;
  }

  /**
   * Get all neighboring cells (4-directional: up, down, left, right)
   */
  getNeighbors(x: number, y: number): Point[] {
    return [
      { x: x + 1, y },     // Right
      { x: x - 1, y },     // Left
      { x, y: y + 1 },     // Down
      { x, y: y - 1 }      // Up
    ];
  }

  /**
   * Get all neighboring cells including diagonals (8-directional)
   */
  getNeighbors8(x: number, y: number): Point[] {
    return [
      { x: x + 1, y },         // Right
      { x: x + 1, y: y - 1 },  // Top-right
      { x, y: y - 1 },         // Up
      { x: x - 1, y: y - 1 },  // Top-left
      { x: x - 1, y },         // Left
      { x: x - 1, y: y + 1 },  // Bottom-left
      { x, y: y + 1 },         // Down
      { x: x + 1, y: y + 1 }   // Bottom-right
    ];
  }

  /**
   * Get the bounding box of a cell in world coordinates
   */
  getCellBounds(cell: Cell): BoundingBox {
    const cellX = 'x' in cell ? cell.x : cell.q;
    const cellY = 'x' in cell ? cell.y : cell.r;
    const x = cellX * this.cellSize;
    const y = cellY * this.cellSize;
    return {
      minX: x,
      minY: y,
      maxX: x + this.cellSize,
      maxY: y + this.cellSize
    };
  }

  /**
   * Get the bounding box of an object in world coordinates
   */
  getObjectBounds(obj: { position: Point; size?: { width: number; height: number } }): BoundingBox {
    const size = obj.size || { width: 1, height: 1 };
    const x = obj.position.x * this.cellSize;
    const y = obj.position.y * this.cellSize;
    return {
      minX: x,
      minY: y,
      maxX: x + size.width * this.cellSize,
      maxY: y + size.height * this.cellSize
    };
  }
}

// Export type for consumers
export type { GridGeometry };

return { GridGeometry };
```

# HexGeometry

```ts
/**
 * HexGeometry.ts
 * 
 * Handles all hex-specific geometric calculations and rendering.
 * Extends BaseGeometry to implement the standard geometry interface
 * for hexagonal grid-based maps.
 * 
 * COORDINATE SYSTEMS:
 * - Axial coordinates (q, r): Integer hex indices using axial coordinate system
 *   Used internally for hex math. Storage uses {q, r, color}.
 * 
 * - Point coordinates (x, y): API format where x=q, y=r
 *   Used for cross-geometry polymorphism with GridGeometry.
 * 
 * - Offset coordinates (col, row): Integer indices in rectangular space
 *   Used for bounds checking and rectangular iteration.
 * 
 * - World coordinates (worldX, worldY): Float pixel coordinates
 *   Used for positioning and measurements.
 * 
 * - Screen coordinates (screenX, screenY): Pixel coordinates on canvas
 *   Used for rendering with viewport transforms.
 * 
 * API CONSISTENCY:
 * - worldToGrid() returns Point {x, y} where x=q, y=r
 * - Collection methods return Point[] for polymorphism with GridGeometry
 * - Storage uses native {q, r, color} format (handled by cellAccessor)
 * 
 * @extends BaseGeometry
 */

// Type-only imports
import type {
  Point,
  WorldCoords,
  ScreenCoords,
  OffsetCoords,
  GridBounds,
  BoundingBox,
  GridStyle,
  DistanceOptions,
  Cell
} from '#types/core/geometry.types';
import type { HexBounds } from '#types/core/map.types';

// Datacore imports
const { BaseGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "BaseGeometry")) as {
  BaseGeometry: new () => InstanceType<typeof BaseGeometryClass>
};

const { axialToOffset, offsetToAxial, isWithinOffsetBounds } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "offsetCoordinates")) as {
  axialToOffset: (q: number, r: number, orientation: string) => OffsetCoords;
  offsetToAxial: (col: number, row: number, orientation: string) => { q: number; r: number };
  isWithinOffsetBounds: (col: number, row: number, maxCol: number, maxRow: number) => boolean;
};

// Type for BaseGeometry class
declare class BaseGeometryClass {
  worldToScreen(worldX: number, worldY: number, offsetX: number, offsetY: number, zoom: number): ScreenCoords;
  screenToWorld(screenX: number, screenY: number, zoom: number): WorldCoords;
}

/** Axial coordinate pair */
interface AxialCoords {
  q: number;
  r: number;
}

/** Visible hex range */
interface VisibleHexRange {
  minQ: number;
  maxQ: number;
  minR: number;
  maxR: number;
}

class HexGeometry extends BaseGeometry {
  readonly type = 'hex' as const;
  hexSize: number;
  orientation: 'flat' | 'pointy';
  bounds: HexBounds | null;
  sqrt3: number;
  width: number;
  height: number;
  horizSpacing: number;
  vertSpacing: number;

  /**
   * @param hexSize - Radius from hex center to vertex in pixels
   * @param orientation - Either 'flat' or 'pointy'
   * @param bounds - Optional bounds {maxCol, maxRow} in offset coordinates
   */
  constructor(hexSize: number, orientation: 'flat' | 'pointy' = 'flat', bounds: HexBounds | null = null) {
    super();
    this.hexSize = hexSize;
    this.orientation = orientation;
    this.bounds = bounds;
    
    // Precalculate commonly used values
    this.sqrt3 = Math.sqrt(3);
    
    // Layout constants depend on orientation
    if (orientation === 'flat') {
      this.width = hexSize * 2;
      this.height = hexSize * this.sqrt3;
      this.horizSpacing = hexSize * 1.5;
      this.vertSpacing = hexSize * this.sqrt3;
    } else {
      this.width = hexSize * this.sqrt3;
      this.height = hexSize * 2;
      this.horizSpacing = hexSize * this.sqrt3;
      this.vertSpacing = hexSize * 1.5;
    }
  }
  
  /**
   * Convert world coordinates to axial hex coordinates
   */
  worldToHex(worldX: number, worldY: number): AxialCoords {
    if (this.orientation === 'flat') {
      const q = (worldX * (2/3)) / this.hexSize;
      const r = ((-worldX / 3) + (this.sqrt3 / 3) * worldY) / this.hexSize;
      return this.roundHex(q, r);
    } else {
      const q = ((this.sqrt3 / 3) * worldX - (1/3) * worldY) / this.hexSize;
      const r = ((2/3) * worldY) / this.hexSize;
      return this.roundHex(q, r);
    }
  }
  
  /**
   * Convert world coordinates to grid coordinates (Point API)
   * Returns {x, y} where x=q, y=r for API consistency with GridGeometry
   */
  worldToGrid(worldX: number, worldY: number): Point {
    const { q, r } = this.worldToHex(worldX, worldY);
    return { x: q, y: r };
  }
  
  /**
   * Round fractional hex coordinates to nearest integer hex
   * Uses cube coordinate rounding for accuracy
   */
  roundHex(q: number, r: number): AxialCoords {
    const x = q;
    const z = r;
    const y = -x - z;
    
    let rx = Math.round(x);
    let ry = Math.round(y);
    let rz = Math.round(z);
    
    const xDiff = Math.abs(rx - x);
    const yDiff = Math.abs(ry - y);
    const zDiff = Math.abs(rz - z);
    
    if (xDiff > yDiff && xDiff > zDiff) {
      rx = -ry - rz;
    } else if (yDiff > zDiff) {
      ry = -rx - rz;
    } else {
      rz = -rx - ry;
    }
    
    return { q: rx, r: rz };
  }
  
  /**
   * Convert axial hex coordinates to world coordinates (hex center)
   */
  hexToWorld(q: number, r: number): WorldCoords {
    if (this.orientation === 'flat') {
      const worldX = this.hexSize * (3/2) * q;
      const worldY = this.hexSize * (this.sqrt3 / 2 * q + this.sqrt3 * r);
      return { worldX, worldY };
    } else {
      const worldX = this.hexSize * (this.sqrt3 * q + this.sqrt3 / 2 * r);
      const worldY = this.hexSize * (3/2) * r;
      return { worldX, worldY };
    }
  }
  
  /**
   * Alias for hexToWorld - provides consistent API with GridGeometry
   */
  gridToWorld(x: number, y: number): WorldCoords {
    return this.hexToWorld(x, y);
  }
  
  /**
   * Get the center point of a hex in world coordinates
   */
  getHexCenter(q: number, r: number): WorldCoords {
    return this.hexToWorld(q, r);
  }
  
  /**
   * Alias for getHexCenter with Point API naming
   */
  getCellCenter(x: number, y: number): WorldCoords {
    return this.hexToWorld(x, y);
  }
  
  /**
   * Convert offset coordinates to world coordinates
   */
  offsetToWorld(col: number, row: number): WorldCoords {
    const { q, r } = offsetToAxial(col, row, this.orientation);
    return this.hexToWorld(q, r);
  }
  
  /**
   * Get the six vertices of a hex in world coordinates
   */
  getHexVertices(q: number, r: number): WorldCoords[] {
    const center = this.hexToWorld(q, r);
    const vertices: WorldCoords[] = [];
    
    const angleOffset = this.orientation === 'flat' ? 0 : 30;
    
    for (let i = 0; i < 6; i++) {
      const angleDeg = 60 * i + angleOffset;
      const angleRad = (Math.PI / 180) * angleDeg;
      vertices.push({
        worldX: center.worldX + this.hexSize * Math.cos(angleRad),
        worldY: center.worldY + this.hexSize * Math.sin(angleRad)
      });
    }
    
    return vertices;
  }
  
  /**
   * Snap world coordinates to the nearest hex center
   */
  snapToHexCenter(worldX: number, worldY: number): WorldCoords {
    const { q, r } = this.worldToHex(worldX, worldY);
    return this.getHexCenter(q, r);
  }
  
  /**
   * Alias for snapToHexCenter
   */
  snapToCellCenter(worldX: number, worldY: number): WorldCoords {
    return this.snapToHexCenter(worldX, worldY);
  }
  
  /**
   * Calculate visible hex range for a given viewport
   */
  getVisibleHexRange(
    offsetX: number,
    offsetY: number,
    width: number,
    height: number,
    zoom: number
  ): VisibleHexRange {
    const topLeft = this.screenToWorld(-offsetX, -offsetY, zoom);
    const topRight = this.screenToWorld(width - offsetX, -offsetY, zoom);
    const bottomLeft = this.screenToWorld(-offsetX, height - offsetY, zoom);
    const bottomRight = this.screenToWorld(width - offsetX, height - offsetY, zoom);
    
    const corners = [
      this.worldToHex(topLeft.worldX, topLeft.worldY),
      this.worldToHex(topRight.worldX, topRight.worldY),
      this.worldToHex(bottomLeft.worldX, bottomLeft.worldY),
      this.worldToHex(bottomRight.worldX, bottomRight.worldY)
    ];
    
    const padding = 2;
    const minQ = Math.min(...corners.map(c => c.q)) - padding;
    const maxQ = Math.max(...corners.map(c => c.q)) + padding;
    const minR = Math.min(...corners.map(c => c.r)) - padding;
    const maxR = Math.max(...corners.map(c => c.r)) + padding;
    
    return { minQ, maxQ, minR, maxR };
  }
  
  /**
   * Convert hex coordinates to screen coordinates (for rendering)
   */
  gridToScreen(
    x: number,
    y: number,
    offsetX: number,
    offsetY: number,
    zoom: number
  ): ScreenCoords {
    const { worldX, worldY } = this.hexToWorld(x, y);
    
    const topLeftWorldX = worldX - (this.hexSize / 2);
    const topLeftWorldY = worldY - (this.hexSize / 2);
    
    return this.worldToScreen(topLeftWorldX, topLeftWorldY, offsetX, offsetY, zoom);
  }
  
  /**
   * Draw hex grid on the canvas using fill-based rendering
   */
  drawGrid(
    ctx: CanvasRenderingContext2D,
    offsetX: number,
    offsetY: number,
    width: number,
    height: number,
    zoom: number,
    style: GridStyle = {}
  ): void {
    const { lineColor = '#333333', lineWidth = 1 } = style;
    
    if (!isFinite(width) || !isFinite(height) || !isFinite(zoom) || 
        !isFinite(offsetX) || !isFinite(offsetY) || zoom <= 0) {
      console.warn('[HexGeometry.drawGrid] Invalid input values, skipping render');
      return;
    }
    
    let minCol: number, maxCol: number, minRow: number, maxRow: number;
    
    if (this.bounds) {
      minCol = 0;
      maxCol = this.bounds.maxCol - 1;
      minRow = 0;
      maxRow = this.bounds.maxRow - 1;
    } else {
      const diagonal = Math.sqrt(width * width + height * height) * 2;
      const expandedWidth = diagonal;
      const expandedHeight = diagonal;
      
      const { minQ, maxQ, minR, maxR } = this.getVisibleHexRange(
        offsetX, offsetY, expandedWidth, expandedHeight, zoom
      );
      
      const corner1 = axialToOffset(minQ, minR, this.orientation);
      const corner2 = axialToOffset(maxQ, maxR, this.orientation);
      const corner3 = axialToOffset(minQ, maxR, this.orientation);
      const corner4 = axialToOffset(maxQ, minR, this.orientation);
      
      minCol = Math.min(corner1.col, corner2.col, corner3.col, corner4.col);
      maxCol = Math.max(corner1.col, corner2.col, corner3.col, corner4.col);
      minRow = Math.min(corner1.row, corner2.row, corner3.row, corner4.row);
      maxRow = Math.max(corner1.row, corner2.row, corner3.row, corner4.row);
    }
    
    // Safety check on iteration count
    const totalHexes = (maxCol - minCol + 1) * (maxRow - minRow + 1);
    if (totalHexes > 50000 || !isFinite(totalHexes)) {
      console.warn(`[HexGeometry.drawGrid] Too many hexes to draw (${totalHexes}), aborting`);
      return;
    }
    
    // Use fill-based rendering to work around strokeStyle corruption
    ctx.fillStyle = lineColor;
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    
    for (let col = minCol; col <= maxCol; col++) {
      for (let row = minRow; row <= maxRow; row++) {
        const { q, r } = offsetToAxial(col, row, this.orientation);
        
        if (!this.bounds || this.isWithinBounds(q, r)) {
          this.drawHexOutline(ctx, q, r, offsetX, offsetY, zoom, lineWidth);
        }
      }
    }
  }
  
  /**
   * Draw a line as a filled polygon (for fill-based rendering)
   * Works around strokeStyle corruption in Obsidian's Live Preview mode
   */
  drawLineAsFill(
    ctx: CanvasRenderingContext2D,
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    lineWidth: number
  ): void {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const length = Math.sqrt(dx * dx + dy * dy);
    
    if (length === 0) return;
    
    const nx = -dy / length * (lineWidth / 2);
    const ny = dx / length * (lineWidth / 2);
    
    ctx.beginPath();
    ctx.moveTo(x1 + nx, y1 + ny);
    ctx.lineTo(x2 + nx, y2 + ny);
    ctx.lineTo(x2 - nx, y2 - ny);
    ctx.lineTo(x1 - nx, y1 - ny);
    ctx.closePath();
    ctx.fill();
  }
  
  /**
   * Draw a single hex outline using fill-based rendering
   */
  drawHexOutline(
    ctx: CanvasRenderingContext2D,
    q: number,
    r: number,
    offsetX: number,
    offsetY: number,
    zoom: number,
    lineWidth: number | null = null
  ): void {
    const vertices = this.getHexVertices(q, r);
    const width = lineWidth !== null ? lineWidth : (ctx.lineWidth || 1);
    
    const screenVertices = vertices.map(v => 
      this.worldToScreen(v.worldX, v.worldY, offsetX, offsetY, zoom)
    );
    
    for (let i = 0; i < 6; i++) {
      const v1 = screenVertices[i];
      const v2 = screenVertices[(i + 1) % 6];
      this.drawLineAsFill(ctx, v1.screenX, v1.screenY, v2.screenX, v2.screenY, width);
    }
  }
  
  /**
   * Draw a filled hex on the canvas (alias for drawCell)
   */
  drawHex(
    ctx: CanvasRenderingContext2D,
    q: number,
    r: number,
    offsetX: number,
    offsetY: number,
    zoom: number,
    color: string
  ): void {
    this.drawCell(ctx, q, r, offsetX, offsetY, zoom, color);
  }
  
  /**
   * Get the scaled hex size at current zoom
   */
  getScaledHexSize(zoom: number): number {
    return this.hexSize * zoom;
  }
  
  /**
   * Draw a filled hex on the canvas
   */
  drawCell(
    ctx: CanvasRenderingContext2D,
    x: number,
    y: number,
    offsetX: number,
    offsetY: number,
    zoom: number,
    color: string
  ): void {
    const vertices = this.getHexVertices(x, y);
    const scaledVertices = vertices.map(v => 
      this.worldToScreen(v.worldX, v.worldY, offsetX, offsetY, zoom)
    );
    
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(scaledVertices[0].screenX, scaledVertices[0].screenY);
    for (let i = 1; i < scaledVertices.length; i++) {
      ctx.lineTo(scaledVertices[i].screenX, scaledVertices[i].screenY);
    }
    ctx.closePath();
    ctx.fill();
  }
  
  /**
   * Draw multiple cells of the same color
   */
  drawCells(
    ctx: CanvasRenderingContext2D,
    cells: Point[],
    offsetX: number,
    offsetY: number,
    zoom: number,
    color: string
  ): void {
    ctx.fillStyle = color;
    
    for (const cell of cells) {
      const vertices = this.getHexVertices(cell.x, cell.y);
      const scaledVertices = vertices.map(v => 
        this.worldToScreen(v.worldX, v.worldY, offsetX, offsetY, zoom)
      );
      
      ctx.beginPath();
      ctx.moveTo(scaledVertices[0].screenX, scaledVertices[0].screenY);
      for (let i = 1; i < scaledVertices.length; i++) {
        ctx.lineTo(scaledVertices[i].screenX, scaledVertices[i].screenY);
      }
      ctx.closePath();
      ctx.fill();
    }
  }
  
  /**
   * Get the scaled cell size at current zoom
   */
  getScaledCellSize(zoom: number): number {
    return this.hexSize * zoom;
  }
  
  /**
   * Check if coordinates are within bounds
   */
  isWithinBounds(x: number, y: number): boolean {
    if (!this.bounds) return true;
    
    const { col, row } = axialToOffset(x, y, this.orientation);
    return col >= 0 && col < this.bounds.maxCol && 
           row >= 0 && row < this.bounds.maxRow;
  }
  
  /**
   * Clamp coordinates to bounds
   */
  clampToBounds(x: number, y: number): Point {
    if (!this.bounds) return { x, y };
    
    const { col, row } = axialToOffset(x, y, this.orientation);
    const clampedCol = Math.max(0, Math.min(this.bounds.maxCol - 1, col));
    const clampedRow = Math.max(0, Math.min(this.bounds.maxRow - 1, row));
    
    const clamped = offsetToAxial(clampedCol, clampedRow, this.orientation);
    return { x: clamped.q, y: clamped.r };
  }
  
  /**
   * Convert grid coordinates to offset coordinates
   */
  toOffsetCoords(x: number, y: number): OffsetCoords {
    return axialToOffset(x, y, this.orientation);
  }
  
  /**
   * Convert a cell object to offset coordinates
   */
  cellToOffsetCoords(cell: Cell): OffsetCoords {
    if ('q' in cell) {
      return axialToOffset(cell.q, cell.r, this.orientation);
    }
    // GridCell format - x=q, y=r
    return axialToOffset(cell.x, cell.y, this.orientation);
  }
  
  /**
   * Check if this geometry has defined bounds
   */
  isBounded(): boolean {
    return this.bounds !== null;
  }
  
  /**
   * Get the bounds for this geometry
   */
  getBounds(): HexBounds | null {
    return this.bounds;
  }
  
  /**
   * Create a cell object in hex coordinate format
   * Accepts Point {x, y} where x=q, y=r
   */
  createCellObject(coords: Point, color: string): { q: number; r: number; color: string } {
    return { q: coords.x, r: coords.y, color };
  }
  
  /**
   * Check if a cell matches given coordinates
   * Accepts Point {x, y} where x=q, y=r
   */
  cellMatchesCoords(cell: Cell, coords: Point): boolean {
    if ('q' in cell) {
      return cell.q === coords.x && cell.r === coords.y;
    }
    // GridCell format
    return cell.x === coords.x && cell.y === coords.y;
  }
  
  /**
   * Get all hexes within a rectangular area
   */
  getCellsInRectangle(x1: number, y1: number, x2: number, y2: number): Point[] {
    const offset1 = axialToOffset(x1, y1, this.orientation);
    const offset2 = axialToOffset(x2, y2, this.orientation);
    
    const minCol = Math.min(offset1.col, offset2.col);
    const maxCol = Math.max(offset1.col, offset2.col);
    const minRow = Math.min(offset1.row, offset2.row);
    const maxRow = Math.max(offset1.row, offset2.row);
    
    const cells: Point[] = [];
    for (let col = minCol; col <= maxCol; col++) {
      for (let row = minRow; row <= maxRow; row++) {
        const { q, r } = offsetToAxial(col, row, this.orientation);
        
        if (this.isWithinBounds(q, r)) {
          cells.push({ x: q, y: r });
        }
      }
    }
    
    return cells;
  }
  
  /**
   * Get all hexes within a circular area
   */
  getCellsInCircle(centerX: number, centerY: number, radiusInHexes: number): Point[] {
    const cells: Point[] = [];
    
    const centerOffset = axialToOffset(centerX, centerY, this.orientation);
    const minCol = Math.floor(centerOffset.col - radiusInHexes);
    const maxCol = Math.ceil(centerOffset.col + radiusInHexes);
    const minRow = Math.floor(centerOffset.row - radiusInHexes);
    const maxRow = Math.ceil(centerOffset.row + radiusInHexes);
    
    for (let col = minCol; col <= maxCol; col++) {
      for (let row = minRow; row <= maxRow; row++) {
        const { q, r } = offsetToAxial(col, row, this.orientation);
        
        if (this.isWithinBounds(q, r)) {
          const distance = this.getHexDistance(centerX, centerY, q, r);
          if (distance <= radiusInHexes) {
            cells.push({ x: q, y: r });
          }
        }
      }
    }
    
    return cells;
  }
  
  /**
   * Get hexes along a line between two hexes
   */
  getCellsInLine(x1: number, y1: number, x2: number, y2: number): Point[] {
    const distance = this.getHexDistance(x1, y1, x2, y2);
    const cells: Point[] = [];
    
    if (distance === 0) {
      return [{ x: x1, y: y1 }];
    }
    
    for (let i = 0; i <= distance; i++) {
      const t = i / distance;
      
      const cx1 = x1;
      const cz1 = y1;
      const cy1 = -cx1 - cz1;
      
      const cx2 = x2;
      const cz2 = y2;
      const cy2 = -cx2 - cz2;
      
      const x = cx1 + (cx2 - cx1) * t;
      const y = cy1 + (cy2 - cy1) * t;
      const z = cz1 + (cz2 - cz1) * t;
      
      const rounded = this.roundHex(x, z);
      
      if (this.isWithinBounds(rounded.q, rounded.r)) {
        cells.push({ x: rounded.q, y: rounded.r });
      }
    }
    
    return cells;
  }
  
  /**
   * Get all neighboring hexes (returns Point[] for API consistency)
   */
  getNeighbors(x: number, y: number): Point[] {
    const directions = [
      { q: 1, r: 0 },
      { q: 1, r: -1 },
      { q: 0, r: -1 },
      { q: -1, r: 0 },
      { q: -1, r: 1 },
      { q: 0, r: 1 }
    ];
    
    return directions.map(dir => ({
      x: x + dir.q,
      y: y + dir.r
    }));
  }
  
  /**
   * Calculate distance between two hexes
   */
  getHexDistance(q1: number, r1: number, q2: number, r2: number): number {
    return (Math.abs(q1 - q2) + Math.abs(q1 + r1 - q2 - r2) + Math.abs(r1 - r2)) / 2;
  }
  
  /**
   * Alias for getHexDistance - API consistency with GridGeometry
   */
  getEuclideanDistance(x1: number, y1: number, x2: number, y2: number): number {
    return this.getHexDistance(x1, y1, x2, y2);
  }
  
  /**
   * Manhattan distance - same as hex distance for hexes
   */
  getManhattanDistance(x1: number, y1: number, x2: number, y2: number): number {
    return this.getHexDistance(x1, y1, x2, y2);
  }
  
  /**
   * Game distance - hex grids have no diagonal rules
   */
  getCellDistance(
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    _options: DistanceOptions = {}
  ): number {
    return this.getHexDistance(x1, y1, x2, y2);
  }
  
  /**
   * Get the bounding box of a hex cell in world coordinates
   */
  getCellBounds(cell: Cell): BoundingBox {
    const q = 'q' in cell ? cell.q : cell.x;
    const r = 'q' in cell ? cell.r : cell.y;
    
    const center = this.hexToWorld(q, r);
    const halfWidth = this.width / 2;
    const halfHeight = this.height / 2;
    return {
      minX: center.worldX - halfWidth,
      minY: center.worldY - halfHeight,
      maxX: center.worldX + halfWidth,
      maxY: center.worldY + halfHeight
    };
  }
  
  /**
   * Get the bounding box of an object in world coordinates
   */
  getObjectBounds(obj: { position: Point; size?: { width: number; height: number } }): BoundingBox {
    const center = this.hexToWorld(obj.position.x, obj.position.y);
    const size = obj.size || { width: 1, height: 1 };
    
    const halfWidth = (this.width * size.width) / 2;
    const halfHeight = (this.height * size.height) / 2;
    return {
      minX: center.worldX - halfWidth,
      minY: center.worldY - halfHeight,
      maxX: center.worldX + halfWidth,
      maxY: center.worldY + halfHeight
    };
  }
}

// Export type for consumers
export type { HexGeometry };

return { HexGeometry };
```

# MapHeader

```jsx
// components/MapHeader.jsx - Map name and save status header

const MapHeader = ({ mapData, onNameChange, saveStatus, showFooter, onToggleFooter }) => {
  // Determine icon and CSS class based on save status
  const getStatusIcon = () => {
    if (saveStatus === 'Unsaved changes') return '';
    if (saveStatus === 'Saving...') return '';
    if (saveStatus === 'Save failed') return '';
    return ''; // Saved
  };
  
  const getStatusClass = () => {
    if (saveStatus === 'Unsaved changes') return 'dmt-save-status dmt-save-status-unsaved';
    if (saveStatus === 'Saving...') return 'dmt-save-status dmt-save-status-saving';
    if (saveStatus === 'Save failed') return 'dmt-save-status dmt-save-status-error';
    return 'dmt-save-status';
  };
  
  const getStatusTitle = () => {
    return saveStatus; // Show full text in tooltip
  };
  
  return (
    <div className="dmt-header">
      <input
        type="text"
        className="dmt-map-name"
        placeholder="Map Name (optional)"
        value={mapData.name}
        onChange={(e) => onNameChange(e.target.value)}
      />
      <div className="dmt-header-controls">
        <button
          className={`dmt-info-toggle ${showFooter ? 'dmt-info-toggle-active' : ''}`}
          onClick={onToggleFooter}
          title={showFooter ? 'Hide footer info' : 'Show footer info'}
        >
          <dc.Icon icon="lucide-info" />
        </button>
        <span 
          className={getStatusClass()}
          title={getStatusTitle()}
        >
          {getStatusIcon()}
        </span>
      </div>
    </div>
  );
};

return { MapHeader };
```

# borderCalculator

```ts
/**
 * borderCalculator.ts - Smart border detection for exterior edges
 */

import type { Cell } from '#types/core/cell.types';

/** Border side identifier */
type BorderSide = 'top' | 'right' | 'bottom' | 'left';

/** Lookup map for cell coordinates */
type CellLookup = Set<string>;

/** Adjacent direction definition */
interface AdjacentDirection {
  dx: number;
  dy: number;
  side: BorderSide;
}

/** Adjacent directions for border checking */
const ADJACENT_DIRECTIONS: AdjacentDirection[] = [
  { dx: 0, dy: -1, side: 'top' },
  { dx: 1, dy: 0, side: 'right' },
  { dx: 0, dy: 1, side: 'bottom' },
  { dx: -1, dy: 0, side: 'left' }
];

/**
 * Check if a cell exists at given coordinates
 */
function cellExists(cells: Cell[], x: number, y: number): boolean {
  return cells.some(cell => cell.x === x && cell.y === y);
}

/**
 * Calculate which borders should be drawn for a cell
 * Only returns borders where there's NO adjacent cell (exterior edges)
 */
function calculateBorders(cells: Cell[], x: number, y: number): BorderSide[] {
  const borders: BorderSide[] = [];

  for (const dir of ADJACENT_DIRECTIONS) {
    const adjX = x + dir.dx;
    const adjY = y + dir.dy;

    if (!cellExists(cells, adjX, adjY)) {
      borders.push(dir.side);
    }
  }

  return borders;
}

/**
 * Build a lookup map for faster cell existence checks
 * Returns a Set with keys like "x,y"
 */
function buildCellLookup(cells: Cell[]): CellLookup {
  const lookup = new Set<string>();
  for (const cell of cells) {
    lookup.add(`${cell.x},${cell.y}`);
  }
  return lookup;
}

/**
 * Check if cell exists in lookup map
 */
function cellExistsInLookup(lookup: CellLookup, x: number, y: number): boolean {
  return lookup.has(`${x},${y}`);
}

/**
 * Calculate borders using lookup map for better performance
 */
function calculateBordersOptimized(lookup: CellLookup, x: number, y: number): BorderSide[] {
  const borders: BorderSide[] = [];

  for (const dir of ADJACENT_DIRECTIONS) {
    const adjX = x + dir.dx;
    const adjY = y + dir.dy;

    if (!cellExistsInLookup(lookup, adjX, adjY)) {
      borders.push(dir.side);
    }
  }

  return borders;
}

return {
  calculateBorders,
  cellExists,
  buildCellLookup,
  calculateBordersOptimized
};

```

# objectTypes

```ts
/**
 * objectTypes.ts
 *
 * Object type definitions for dungeon mapping.
 * Defines available object symbols and their categories.
 */

// Types defined in #types/objects/object.types.ts
// Duplicated here for datacore runtime compatibility
interface ObjectType {
  id: string;
  symbol: string;
  label: string;
  category: string;
}

interface Category {
  id: string;
  label: string;
}

// ===========================================
// Constants
// ===========================================

const OBJECT_TYPES: readonly ObjectType[] = [
  // Notes
  { id: 'note_pin', symbol: '', label: 'Note Pin', category: 'notes' },

  // Navigation
  { id: 'entrance', symbol: '', label: 'Entrance/Exit', category: 'navigation' },
  { id: 'stairs-up', symbol: '', label: 'Stairs Up', category: 'navigation' },
  { id: 'stairs-down', symbol: '', label: 'Stairs Down', category: 'navigation' },
  { id: 'ladder', symbol: '', label: 'Ladder', category: 'navigation' },
  { id: 'door-vertical', symbol: '', label: 'Door (Vertical)', category: 'navigation' },
  { id: 'door-horizontal', symbol: '', label: 'Door (Horizontal)', category: 'navigation' },
  { id: 'secret-door', symbol: '', label: 'Secret Door', category: 'navigation' },
  { id: 'portal', symbol: '', label: 'Portal/Teleport', category: 'navigation' },
  
  // Hazards
  { id: 'trap', symbol: '', label: 'Trap', category: 'hazards' },
  { id: 'hazard', symbol: '', label: 'Hazard', category: 'hazards' },
  { id: 'pit', symbol: '', label: 'Pit', category: 'hazards' },
  { id: 'poison', symbol: '', label: 'Poison', category: 'hazards' },
  
  // Features
  { id: 'chest', symbol: '', label: 'Chest/Treasure', category: 'features' },
  { id: 'crate', symbol: '', label: 'Crate/Barrel', category: 'features' },
  { id: 'sack', symbol: '', label: 'Sack/Bag', category: 'features' },
  { id: 'altar', symbol: '', label: 'Altar', category: 'features' },
  { id: 'coffin', symbol: '', label: 'Coffin', category: 'features' },
  { id: 'statue', symbol: '', label: 'Statue', category: 'features' },
  { id: 'cage', symbol: '', label: 'Chains/Cage', category: 'features' },
  { id: 'book', symbol: '', label: 'Book/Shelf', category: 'features' },
  { id: 'table', symbol: '', label: 'Table', category: 'features' },
  { id: 'chair', symbol: '', label: 'Chair', category: 'features' },
  { id: 'bed', symbol: '', label: 'Bed', category: 'features' },
  { id: 'anvil', symbol: '', label: 'Anvil/Forge', category: 'features' },
  { id: 'cauldron', symbol: '', label: 'Cauldron', category: 'features' },
  { id: 'fountain', symbol: '', label: 'Fountain', category: 'features' },
  { id: 'lever', symbol: '', label: 'Lever/Switch', category: 'features' },
  { id: 'flower', symbol: '', label: 'Flower', category: 'features' },
  { id: 'plant', symbol: '', label: 'Plant', category: 'features' },
  { id: 'tree-dec', symbol: '', label: 'Tree', category: 'features' },
  { id: 'tree-ev', symbol: '', label: 'Tree', category: 'features' },
  { id: 'tree-lfls', symbol: '', label: 'Tree', category: 'features' },
  
  // Encounters
  { id: 'monster', symbol: '', label: 'Monster/Enemy', category: 'encounters' },
  { id: 'boss', symbol: '', label: 'Boss', category: 'encounters' },
  { id: 'boss-alt', symbol: '', label: 'Boss (alt)', category: 'encounters' },
  { id: 'npc', symbol: '', label: 'NPC', category: 'encounters' },
  { id: 'npc-alt', symbol: '', label: 'NPC', category: 'encounters' },
  { id: 'guard', symbol: '', label: 'Guard', category: 'encounters' },
  
  // Markers
  { id: 'poi', symbol: '', label: 'Point of Interest', category: 'markers' },
  { id: 'flag', symbol: '', label: 'Note/Flag', category: 'markers' }
] as const;

const CATEGORIES: readonly Category[] = [
  { id: 'navigation', label: 'Navigation' },
  { id: 'hazards', label: 'Hazards' },
  { id: 'features', label: 'Features' },
  { id: 'encounters', label: 'Encounters' },
  { id: 'markers', label: 'Markers' }
] as const;

// ===========================================
// Exports
// ===========================================

return { OBJECT_TYPES, CATEGORIES };
```

# rpgAwesomeIcons

```ts
/**
 * rpgAwesomeIcons.ts - Icon mapping and categories for RPGAwesome font
 * Generated from official rpg-awesome npm package v0.2.0
 * Source: scss/_variables.scss
 * License: SIL OFL 1.1 (Font), MIT (CSS)
 * Total icons: 496
 */

import type { IconCategory, IconData, IconMap, IconWithClass } from '#types/objects/icon.types';

/**
 * Icon categories for filtering in the picker UI
 */
const RA_CATEGORIES: IconCategory[] = [
  { id: 'weapons', label: 'Weapons', order: 10 },
  { id: 'armor', label: 'Armor & Defense', order: 20 },
  { id: 'creatures', label: 'Creatures', order: 30 },
  { id: 'potions', label: 'Potions', order: 40 },
  { id: 'magic', label: 'Magic', order: 50 },
  { id: 'food', label: 'Food & Drink', order: 60 },
  { id: 'plants', label: 'Plants', order: 70 },
  { id: 'astrology', label: 'Astrology', order: 80 },
  { id: 'cards-dice', label: 'Cards & Dice', order: 90 },
  { id: 'electronics', label: 'Electronics', order: 100 },
  { id: 'dangers', label: 'Dangers', order: 110 },
  { id: 'player', label: 'Player', order: 120 },
  { id: 'inventory', label: 'Inventory', order: 130 },
  { id: 'rpg', label: 'RPG & Misc', order: 140 },
];

/**
 * Icon definitions - char is the actual Unicode character for canvas rendering
 * Codepoints are from the official _variables.scss file
 */
const RA_ICONS: IconMap = {
  'ra-acid': { char: '\ue900', label: 'Acid', category: 'dangers' },
  'ra-acorn': { char: '\ue901', label: 'Acorn', category: 'food' },
  'ra-alien-fire': { char: '\ue902', label: 'Alien Fire', category: 'magic' },
  'ra-all-for-one': { char: '\ue903', label: 'All For One', category: 'rpg' },
  'ra-alligator-clip': { char: '\ue904', label: 'Alligator Clip', category: 'inventory' },
  'ra-ammo-bag': { char: '\ue905', label: 'Ammo Bag', category: 'inventory' },
  'ra-anchor': { char: '\ue906', label: 'Anchor', category: 'rpg' },
  'ra-angel-wings': { char: '\ue907', label: 'Angel Wings', category: 'rpg' },
  'ra-ankh': { char: '\ue908', label: 'Ankh', category: 'rpg' },
  'ra-anvil': { char: '\ue909', label: 'Anvil', category: 'rpg' },
  'ra-apple': { char: '\ue90a', label: 'Apple', category: 'food' },
  'ra-aquarius': { char: '\ue90b', label: 'Aquarius', category: 'astrology' },
  'ra-arcane-mask': { char: '\ue90c', label: 'Arcane Mask', category: 'armor' },
  'ra-archer': { char: '\ue90d', label: 'Archer', category: 'weapons' },
  'ra-archery-target': { char: '\ue90e', label: 'Archery Target', category: 'weapons' },
  'ra-arena': { char: '\ue90f', label: 'Arena', category: 'rpg' },
  'ra-aries': { char: '\ue910', label: 'Aries', category: 'astrology' },
  'ra-arrow-cluster': { char: '\ue911', label: 'Arrow Cluster', category: 'weapons' },
  'ra-arrow-flights': { char: '\ue912', label: 'Arrow Flights', category: 'weapons' },
  'ra-arson': { char: '\ue913', label: 'Arson', category: 'dangers' },
  'ra-aura': { char: '\ue914', label: 'Aura', category: 'magic' },
  'ra-aware': { char: '\ue915', label: 'Aware', category: 'player' },
  'ra-axe': { char: '\ue917', label: 'Axe', category: 'weapons' },
  'ra-axe-swing': { char: '\ue916', label: 'Axe Swing', category: 'weapons' },
  'ra-ball': { char: '\ue918', label: 'Ball', category: 'inventory' },
  'ra-barbed-arrow': { char: '\ue919', label: 'Barbed Arrow', category: 'weapons' },
  'ra-barrier': { char: '\ue91a', label: 'Barrier', category: 'armor' },
  'ra-bat-sword': { char: '\ue91b', label: 'Bat Sword', category: 'weapons' },
  'ra-battered-axe': { char: '\ue91c', label: 'Battered Axe', category: 'weapons' },
  'ra-batteries': { char: '\ue91d', label: 'Batteries', category: 'electronics' },
  'ra-battery-0': { char: '\ue91e', label: 'Battery 0', category: 'electronics' },
  'ra-battery-100': { char: '\ue922', label: 'Battery 100', category: 'electronics' },
  'ra-battery-25': { char: '\ue91f', label: 'Battery 25', category: 'electronics' },
  'ra-battery-50': { char: '\ue920', label: 'Battery 50', category: 'electronics' },
  'ra-battery-75': { char: '\ue921', label: 'Battery 75', category: 'electronics' },
  'ra-battery-black': { char: '\ue923', label: 'Battery Black', category: 'electronics' },
  'ra-battery-negative': { char: '\ue924', label: 'Battery Negative', category: 'electronics' },
  'ra-battery-positive': { char: '\ue925', label: 'Battery Positive', category: 'electronics' },
  'ra-battery-white': { char: '\ue926', label: 'Battery White', category: 'electronics' },
  'ra-batwings': { char: '\ue927', label: 'Batwings', category: 'rpg' },
  'ra-beam-wake': { char: '\ue928', label: 'Beam Wake', category: 'rpg' },
  'ra-bear-trap': { char: '\ue929', label: 'Bear Trap', category: 'dangers' },
  'ra-beer': { char: '\ue92a', label: 'Beer', category: 'food' },
  'ra-beetle': { char: '\ue92b', label: 'Beetle', category: 'creatures' },
  'ra-bell': { char: '\ue92c', label: 'Bell', category: 'inventory' },
  'ra-biohazard': { char: '\ue92d', label: 'Biohazard', category: 'dangers' },
  'ra-bird-claw': { char: '\ue92e', label: 'Bird Claw', category: 'creatures' },
  'ra-bird-mask': { char: '\ue92f', label: 'Bird Mask', category: 'armor' },
  'ra-blade-bite': { char: '\ue930', label: 'Blade Bite', category: 'dangers' },
  'ra-blast': { char: '\ue931', label: 'Blast', category: 'dangers' },
  'ra-blaster': { char: '\ue932', label: 'Blaster', category: 'weapons' },
  'ra-bleeding-eye': { char: '\ue933', label: 'Bleeding Eye', category: 'dangers' },
  'ra-bleeding-hearts': { char: '\ue934', label: 'Bleeding Hearts', category: 'dangers' },
  'ra-bolt-shield': { char: '\ue935', label: 'Bolt Shield', category: 'armor' },
  'ra-bomb-explosion': { char: '\ue936', label: 'Bomb Explosion', category: 'dangers' },
  'ra-bombs': { char: '\ue937', label: 'Bombs', category: 'weapons' },
  'ra-bone-bite': { char: '\ue938', label: 'Bone Bite', category: 'dangers' },
  'ra-bone-knife': { char: '\ue939', label: 'Bone Knife', category: 'weapons' },
  'ra-book': { char: '\ue93a', label: 'Book', category: 'inventory' },
  'ra-boomerang': { char: '\ue93b', label: 'Boomerang', category: 'weapons' },
  'ra-boot-stomp': { char: '\ue93c', label: 'Boot Stomp', category: 'armor' },
  'ra-bottle-vapors': { char: '\ue93d', label: 'Bottle Vapors', category: 'potions' },
  'ra-bottled-bolt': { char: '\ue93e', label: 'Bottled Bolt', category: 'potions' },
  'ra-bottom-right': { char: '\ue93f', label: 'Bottom Right', category: 'cards-dice' },
  'ra-bowie-knife': { char: '\ue940', label: 'Bowie Knife', category: 'weapons' },
  'ra-bowling-pin': { char: '\ue941', label: 'Bowling Pin', category: 'inventory' },
  'ra-brain-freeze': { char: '\ue942', label: 'Brain Freeze', category: 'magic' },
  'ra-brandy-bottle': { char: '\ue943', label: 'Brandy Bottle', category: 'food' },
  'ra-bridge': { char: '\ue944', label: 'Bridge', category: 'rpg' },
  'ra-broadhead-arrow': { char: '\ue945', label: 'Broadhead Arrow', category: 'weapons' },
  'ra-broadsword': { char: '\ue946', label: 'Broadsword', category: 'weapons' },
  'ra-broken-bone': { char: '\ue947', label: 'Broken Bone', category: 'dangers' },
  'ra-broken-bottle': { char: '\ue948', label: 'Broken Bottle', category: 'potions' },
  'ra-broken-heart': { char: '\ue949', label: 'Broken Heart', category: 'dangers' },
  'ra-broken-shield': { char: '\ue94a', label: 'Broken Shield', category: 'armor' },
  'ra-broken-skull': { char: '\ue94b', label: 'Broken Skull', category: 'dangers' },
  'ra-bubbling-potion': { char: '\ue94c', label: 'Bubbling Potion', category: 'potions' },
  'ra-bullets': { char: '\ue94d', label: 'Bullets', category: 'weapons' },
  'ra-burning-book': { char: '\ue94e', label: 'Burning Book', category: 'magic' },
  'ra-burning-embers': { char: '\ue94f', label: 'Burning Embers', category: 'magic' },
  'ra-burning-eye': { char: '\ue950', label: 'Burning Eye', category: 'magic' },
  'ra-burning-meteor': { char: '\ue951', label: 'Burning Meteor', category: 'magic' },
  'ra-burst-blob': { char: '\ue952', label: 'Burst Blob', category: 'magic' },
  'ra-butterfly': { char: '\ue953', label: 'Butterfly', category: 'creatures' },
  'ra-campfire': { char: '\ue954', label: 'Campfire', category: 'rpg' },
  'ra-cancel': { char: '\ue955', label: 'Cancel', category: 'cards-dice' },
  'ra-cancer': { char: '\ue956', label: 'Cancer', category: 'astrology' },
  'ra-candle': { char: '\ue958', label: 'Candle', category: 'inventory' },
  'ra-candle-fire': { char: '\ue957', label: 'Candle Fire', category: 'inventory' },
  'ra-cannon-shot': { char: '\ue959', label: 'Cannon Shot', category: 'weapons' },
  'ra-capitol': { char: '\ue95a', label: 'Capitol', category: 'rpg' },
  'ra-capricorn': { char: '\ue95b', label: 'Capricorn', category: 'astrology' },
  'ra-carrot': { char: '\ue95c', label: 'Carrot', category: 'food' },
  'ra-castle-emblem': { char: '\ue95d', label: 'Castle Emblem', category: 'rpg' },
  'ra-castle-flag': { char: '\ue95e', label: 'Castle Flag', category: 'inventory' },
  'ra-cat': { char: '\ue95f', label: 'Cat', category: 'creatures' },
  'ra-chain': { char: '\ue960', label: 'Chain', category: 'inventory' },
  'ra-cheese': { char: '\ue961', label: 'Cheese', category: 'food' },
  'ra-chemical-arrow': { char: '\ue962', label: 'Chemical Arrow', category: 'weapons' },
  'ra-chessboard': { char: '\ue963', label: 'Chessboard', category: 'cards-dice' },
  'ra-chicken-leg': { char: '\ue964', label: 'Chicken Leg', category: 'food' },
  'ra-circle-of-circles': { char: '\ue965', label: 'Circle Of Circles', category: 'rpg' },
  'ra-circular-saw': { char: '\ue966', label: 'Circular Saw', category: 'weapons' },
  'ra-circular-shield': { char: '\ue967', label: 'Circular Shield', category: 'armor' },
  'ra-cloak-and-dagger': { char: '\ue968', label: 'Cloak And Dagger', category: 'weapons' },
  'ra-clockwork': { char: '\ue969', label: 'Clockwork', category: 'electronics' },
  'ra-clover': { char: '\ue96a', label: 'Clover', category: 'plants' },
  'ra-clovers': { char: '\ue96c', label: 'Clovers', category: 'cards-dice' },
  'ra-clovers-card': { char: '\ue96b', label: 'Clovers Card', category: 'cards-dice' },
  'ra-cluster-bomb': { char: '\ue96d', label: 'Cluster Bomb', category: 'weapons' },
  'ra-coffee-mug': { char: '\ue96e', label: 'Coffee Mug', category: 'food' },
  'ra-cog': { char: '\ue970', label: 'Cog', category: 'electronics' },
  'ra-cog-wheel': { char: '\ue96f', label: 'Cog Wheel', category: 'electronics' },
  'ra-cold-heart': { char: '\ue971', label: 'Cold Heart', category: 'magic' },
  'ra-compass': { char: '\ue972', label: 'Compass', category: 'inventory' },
  'ra-corked-tube': { char: '\ue973', label: 'Corked Tube', category: 'potions' },
  'ra-crab-claw': { char: '\ue974', label: 'Crab Claw', category: 'creatures' },
  'ra-cracked-helm': { char: '\ue975', label: 'Cracked Helm', category: 'armor' },
  'ra-cracked-shield': { char: '\ue976', label: 'Cracked Shield', category: 'armor' },
  'ra-croc-sword': { char: '\ue977', label: 'Croc Sword', category: 'weapons' },
  'ra-crossbow': { char: '\ue978', label: 'Crossbow', category: 'weapons' },
  'ra-crossed-axes': { char: '\ue979', label: 'Crossed Axes', category: 'weapons' },
  'ra-crossed-bones': { char: '\ue97a', label: 'Crossed Bones', category: 'dangers' },
  'ra-crossed-pistols': { char: '\ue97b', label: 'Crossed Pistols', category: 'weapons' },
  'ra-crossed-sabres': { char: '\ue97c', label: 'Crossed Sabres', category: 'weapons' },
  'ra-crossed-swords': { char: '\ue97d', label: 'Crossed Swords', category: 'weapons' },
  'ra-crown': { char: '\ue97f', label: 'Crown', category: 'armor' },
  'ra-crown-of-thorns': { char: '\ue97e', label: 'Crown Of Thorns', category: 'armor' },
  'ra-crowned-heart': { char: '\ue980', label: 'Crowned Heart', category: 'player' },
  'ra-crush': { char: '\ue981', label: 'Crush', category: 'dangers' },
  'ra-crystal-ball': { char: '\ue982', label: 'Crystal Ball', category: 'magic' },
  'ra-crystal-cluster': { char: '\ue983', label: 'Crystal Cluster', category: 'magic' },
  'ra-crystal-wand': { char: '\ue984', label: 'Crystal Wand', category: 'magic' },
  'ra-crystals': { char: '\ue985', label: 'Crystals', category: 'magic' },
  'ra-cubes': { char: '\ue986', label: 'Cubes', category: 'rpg' },
  'ra-cut-palm': { char: '\ue987', label: 'Cut Palm', category: 'player' },
  'ra-cycle': { char: '\ue988', label: 'Cycle', category: 'rpg' },
  'ra-daggers': { char: '\ue989', label: 'Daggers', category: 'weapons' },
  'ra-daisy': { char: '\ue98a', label: 'Daisy', category: 'plants' },
  'ra-dead-tree': { char: '\ue98b', label: 'Dead Tree', category: 'plants' },
  'ra-death-skull': { char: '\ue98c', label: 'Death Skull', category: 'dangers' },
  'ra-decapitation': { char: '\ue98d', label: 'Decapitation', category: 'dangers' },
  'ra-defibrillate': { char: '\ue98e', label: 'Defibrillate', category: 'electronics' },
  'ra-demolish': { char: '\ue98f', label: 'Demolish', category: 'dangers' },
  'ra-dervish-swords': { char: '\ue990', label: 'Dervish Swords', category: 'weapons' },
  'ra-desert-skull': { char: '\ue991', label: 'Desert Skull', category: 'dangers' },
  'ra-diamond': { char: '\ue992', label: 'Diamond', category: 'magic' },
  'ra-diamonds': { char: '\ue994', label: 'Diamonds', category: 'cards-dice' },
  'ra-diamonds-card': { char: '\ue993', label: 'Diamonds Card', category: 'cards-dice' },
  'ra-dice-five': { char: '\ue995', label: 'Dice Five', category: 'cards-dice' },
  'ra-dice-four': { char: '\ue996', label: 'Dice Four', category: 'cards-dice' },
  'ra-dice-one': { char: '\ue997', label: 'Dice One', category: 'cards-dice' },
  'ra-dice-six': { char: '\ue998', label: 'Dice Six', category: 'cards-dice' },
  'ra-dice-three': { char: '\ue999', label: 'Dice Three', category: 'cards-dice' },
  'ra-dice-two': { char: '\ue99a', label: 'Dice Two', category: 'cards-dice' },
  'ra-dinosaur': { char: '\ue99b', label: 'Dinosaur', category: 'creatures' },
  'ra-divert': { char: '\ue99c', label: 'Divert', category: 'magic' },
  'ra-diving-dagger': { char: '\ue99d', label: 'Diving Dagger', category: 'weapons' },
  'ra-double-team': { char: '\ue99e', label: 'Double Team', category: 'player' },
  'ra-doubled': { char: '\ue99f', label: 'Doubled', category: 'magic' },
  'ra-dragon': { char: '\ue9a2', label: 'Dragon', category: 'creatures' },
  'ra-dragon-breath': { char: '\ue9a0', label: 'Dragon Breath', category: 'magic' },
  'ra-dragon-wing': { char: '\ue9a1', label: 'Dragon Wing', category: 'creatures' },
  'ra-dragonfly': { char: '\ue9a3', label: 'Dragonfly', category: 'creatures' },
  'ra-drill': { char: '\ue9a4', label: 'Drill', category: 'weapons' },
  'ra-dripping-blade': { char: '\ue9a5', label: 'Dripping Blade', category: 'weapons' },
  'ra-dripping-knife': { char: '\ue9a6', label: 'Dripping Knife', category: 'weapons' },
  'ra-dripping-sword': { char: '\ue9a7', label: 'Dripping Sword', category: 'weapons' },
  'ra-droplet': { char: '\ue9a9', label: 'Droplet', category: 'magic' },
  'ra-droplet-splash': { char: '\ue9a8', label: 'Droplet Splash', category: 'magic' },
  'ra-droplets': { char: '\ue9aa', label: 'Droplets', category: 'rpg' },
  'ra-duel': { char: '\ue9ab', label: 'Duel', category: 'weapons' },
  'ra-egg': { char: '\ue9ad', label: 'Egg', category: 'food' },
  'ra-egg-pod': { char: '\ue9ac', label: 'Egg Pod', category: 'food' },
  'ra-eggplant': { char: '\ue9ae', label: 'Eggplant', category: 'food' },
  'ra-emerald': { char: '\ue9af', label: 'Emerald', category: 'magic' },
  'ra-energise': { char: '\ue9b0', label: 'Energise', category: 'electronics' },
  'ra-explosion': { char: '\ue9b1', label: 'Explosion', category: 'dangers' },
  'ra-explosive-materials': { char: '\ue9b2', label: 'Explosive Materials', category: 'weapons' },
  'ra-eye-monster': { char: '\ue9b3', label: 'Eye Monster', category: 'creatures' },
  'ra-eye-shield': { char: '\ue9b4', label: 'Eye Shield', category: 'armor' },
  'ra-eyeball': { char: '\ue9b5', label: 'Eyeball', category: 'magic' },
  'ra-fairy': { char: '\ue9b7', label: 'Fairy', category: 'creatures' },
  'ra-fairy-wand': { char: '\ue9b6', label: 'Fairy Wand', category: 'magic' },
  'ra-fall-down': { char: '\ue9b8', label: 'Fall Down', category: 'dangers' },
  'ra-falling': { char: '\ue9b9', label: 'Falling', category: 'player' },
  'ra-fast-ship': { char: '\ue9ba', label: 'Fast Ship', category: 'electronics' },
  'ra-feather-wing': { char: '\ue9bb', label: 'Feather Wing', category: 'rpg' },
  'ra-feathered-wing': { char: '\ue9bc', label: 'Feathered Wing', category: 'rpg' },
  'ra-fedora': { char: '\ue9bd', label: 'Fedora', category: 'armor' },
  'ra-fire': { char: '\ue9c3', label: 'Fire', category: 'magic' },
  'ra-fire-bomb': { char: '\ue9be', label: 'Fire Bomb', category: 'weapons' },
  'ra-fire-breath': { char: '\ue9bf', label: 'Fire Breath', category: 'magic' },
  'ra-fire-ring': { char: '\ue9c0', label: 'Fire Ring', category: 'magic' },
  'ra-fire-shield': { char: '\ue9c1', label: 'Fire Shield', category: 'armor' },
  'ra-fire-symbol': { char: '\ue9c2', label: 'Fire Symbol', category: 'magic' },
  'ra-fireball-sword': { char: '\ue9c4', label: 'Fireball Sword', category: 'weapons' },
  'ra-fish': { char: '\ue9c5', label: 'Fish', category: 'creatures' },
  'ra-fizzing-flask': { char: '\ue9c6', label: 'Fizzing Flask', category: 'potions' },
  'ra-flame-symbol': { char: '\ue9c7', label: 'Flame Symbol', category: 'magic' },
  'ra-flaming-arrow': { char: '\ue9c8', label: 'Flaming Arrow', category: 'weapons' },
  'ra-flaming-claw': { char: '\ue9c9', label: 'Flaming Claw', category: 'weapons' },
  'ra-flaming-trident': { char: '\ue9ca', label: 'Flaming Trident', category: 'weapons' },
  'ra-flask': { char: '\ue9cb', label: 'Flask', category: 'potions' },
  'ra-flat-hammer': { char: '\ue9cc', label: 'Flat Hammer', category: 'weapons' },
  'ra-flower': { char: '\ue9cd', label: 'Flower', category: 'plants' },
  'ra-flowers': { char: '\ue9ce', label: 'Flowers', category: 'plants' },
  'ra-fluffy-swirl': { char: '\ue9cf', label: 'Fluffy Swirl', category: 'rpg' },
  'ra-focused-lightning': { char: '\ue9d0', label: 'Focused Lightning', category: 'magic' },
  'ra-food-chain': { char: '\ue9d1', label: 'Food Chain', category: 'dangers' },
  'ra-footprint': { char: '\ue9d2', label: 'Footprint', category: 'player' },
  'ra-forging': { char: '\ue9d3', label: 'Forging', category: 'rpg' },
  'ra-forward': { char: '\ue9d4', label: 'Forward', category: 'rpg' },
  'ra-fox': { char: '\ue9d5', label: 'Fox', category: 'creatures' },
  'ra-frost-emblem': { char: '\ue9d6', label: 'Frost Emblem', category: 'magic' },
  'ra-frostfire': { char: '\ue9d7', label: 'Frostfire', category: 'magic' },
  'ra-frozen-arrow': { char: '\ue9d8', label: 'Frozen Arrow', category: 'weapons' },
  'ra-gamepad-cross': { char: '\ue9d9', label: 'Gamepad Cross', category: 'electronics' },
  'ra-gavel': { char: '\ue9da', label: 'Gavel', category: 'weapons' },
  'ra-gear-hammer': { char: '\ue9db', label: 'Gear Hammer', category: 'weapons' },
  'ra-gear-heart': { char: '\ue9dc', label: 'Gear Heart', category: 'electronics' },
  'ra-gears': { char: '\ue9dd', label: 'Gears', category: 'electronics' },
  'ra-gecko': { char: '\ue9de', label: 'Gecko', category: 'creatures' },
  'ra-gem': { char: '\ue9e0', label: 'Gem', category: 'magic' },
  'ra-gem-pendant': { char: '\ue9df', label: 'Gem Pendant', category: 'magic' },
  'ra-gemini': { char: '\ue9e1', label: 'Gemini', category: 'astrology' },
  'ra-glass-heart': { char: '\ue9e2', label: 'Glass Heart', category: 'player' },
  'ra-gloop': { char: '\ue9e3', label: 'Gloop', category: 'magic' },
  'ra-gold-bar': { char: '\ue9e4', label: 'Gold Bar', category: 'magic' },
  'ra-grappling-hook': { char: '\ue9e5', label: 'Grappling Hook', category: 'weapons' },
  'ra-grass': { char: '\ue9e7', label: 'Grass', category: 'plants' },
  'ra-grass-patch': { char: '\ue9e6', label: 'Grass Patch', category: 'plants' },
  'ra-grenade': { char: '\ue9e8', label: 'Grenade', category: 'weapons' },
  'ra-groundbreaker': { char: '\ue9e9', label: 'Groundbreaker', category: 'rpg' },
  'ra-guarded-tower': { char: '\ue9ea', label: 'Guarded Tower', category: 'rpg' },
  'ra-guillotine': { char: '\ue9eb', label: 'Guillotine', category: 'weapons' },
  'ra-halberd': { char: '\ue9ec', label: 'Halberd', category: 'weapons' },
  'ra-hammer': { char: '\ue9ee', label: 'Hammer', category: 'weapons' },
  'ra-hammer-drop': { char: '\ue9ed', label: 'Hammer Drop', category: 'weapons' },
  'ra-hand': { char: '\ue9f1', label: 'Hand', category: 'player' },
  'ra-hand-emblem': { char: '\ue9ef', label: 'Hand Emblem', category: 'player' },
  'ra-hand-saw': { char: '\ue9f0', label: 'Hand Saw', category: 'weapons' },
  'ra-harpoon-trident': { char: '\ue9f2', label: 'Harpoon Trident', category: 'weapons' },
  'ra-health': { char: '\ue9f5', label: 'Health', category: 'magic' },
  'ra-health-decrease': { char: '\ue9f3', label: 'Health Decrease', category: 'magic' },
  'ra-health-increase': { char: '\ue9f4', label: 'Health Increase', category: 'magic' },
  'ra-heart-bottle': { char: '\ue9f6', label: 'Heart Bottle', category: 'potions' },
  'ra-heart-tower': { char: '\ue9f7', label: 'Heart Tower', category: 'rpg' },
  'ra-heartburn': { char: '\ue9f8', label: 'Heartburn', category: 'dangers' },
  'ra-hearts': { char: '\ue9fa', label: 'Hearts', category: 'cards-dice' },
  'ra-hearts-card': { char: '\ue9f9', label: 'Hearts Card', category: 'cards-dice' },
  'ra-heat-haze': { char: '\ue9fb', label: 'Heat Haze', category: 'rpg' },
  'ra-heavy-fall': { char: '\ue9fc', label: 'Heavy Fall', category: 'dangers' },
  'ra-heavy-shield': { char: '\ue9fd', label: 'Heavy Shield', category: 'armor' },
  'ra-helmet': { char: '\ue9fe', label: 'Helmet', category: 'armor' },
  'ra-help': { char: '\ue9ff', label: 'Help', category: 'rpg' },
  'ra-hive-emblem': { char: '\uea00', label: 'Hive Emblem', category: 'rpg' },
  'ra-hole-ladder': { char: '\uea01', label: 'Hole Ladder', category: 'rpg' },
  'ra-honeycomb': { char: '\uea02', label: 'Honeycomb', category: 'food' },
  'ra-hood': { char: '\uea03', label: 'Hood', category: 'armor' },
  'ra-horn-call': { char: '\uea04', label: 'Horn Call', category: 'rpg' },
  'ra-horns': { char: '\uea05', label: 'Horns', category: 'rpg' },
  'ra-horseshoe': { char: '\uea06', label: 'Horseshoe', category: 'inventory' },
  'ra-hospital-cross': { char: '\uea07', label: 'Hospital Cross', category: 'magic' },
  'ra-hot-surface': { char: '\uea08', label: 'Hot Surface', category: 'magic' },
  'ra-hourglass': { char: '\uea09', label: 'Hourglass', category: 'inventory' },
  'ra-hydra': { char: '\uea0b', label: 'Hydra', category: 'creatures' },
  'ra-hydra-shot': { char: '\uea0a', label: 'Hydra Shot', category: 'magic' },
  'ra-ice-cube': { char: '\uea0c', label: 'Ice Cube', category: 'food' },
  'ra-implosion': { char: '\uea0d', label: 'Implosion', category: 'dangers' },
  'ra-incense': { char: '\uea0e', label: 'Incense', category: 'magic' },
  'ra-insect-jaws': { char: '\uea0f', label: 'Insect Jaws', category: 'creatures' },
  'ra-interdiction': { char: '\uea10', label: 'Interdiction', category: 'rpg' },
  'ra-jetpack': { char: '\uea11', label: 'Jetpack', category: 'electronics' },
  'ra-jigsaw-piece': { char: '\uea12', label: 'Jigsaw Piece', category: 'inventory' },
  'ra-kaleidoscope': { char: '\uea13', label: 'Kaleidoscope', category: 'magic' },
  'ra-kettlebell': { char: '\uea14', label: 'Kettlebell', category: 'inventory' },
  'ra-key': { char: '\uea16', label: 'Key', category: 'inventory' },
  'ra-key-basic': { char: '\uea15', label: 'Key Basic', category: 'inventory' },
  'ra-kitchen-knives': { char: '\uea17', label: 'Kitchen Knives', category: 'weapons' },
  'ra-knife': { char: '\uea19', label: 'Knife', category: 'weapons' },
  'ra-knife-fork': { char: '\uea18', label: 'Knife Fork', category: 'food' },
  'ra-knight-helmet': { char: '\uea1a', label: 'Knight Helmet', category: 'armor' },
  'ra-kunai': { char: '\uea1b', label: 'Kunai', category: 'weapons' },
  'ra-lantern-flame': { char: '\uea1c', label: 'Lantern Flame', category: 'inventory' },
  'ra-large-hammer': { char: '\uea1d', label: 'Large Hammer', category: 'weapons' },
  'ra-laser-blast': { char: '\uea1e', label: 'Laser Blast', category: 'weapons' },
  'ra-laser-site': { char: '\uea1f', label: 'Laser Site', category: 'electronics' },
  'ra-lava': { char: '\uea20', label: 'Lava', category: 'magic' },
  'ra-leaf': { char: '\uea21', label: 'Leaf', category: 'plants' },
  'ra-leo': { char: '\uea22', label: 'Leo', category: 'astrology' },
  'ra-level-four': { char: '\uea24', label: 'Level Four', category: 'magic' },
  'ra-level-four-advanced': { char: '\uea23', label: 'Level Four Advanced', category: 'magic' },
  'ra-level-three': { char: '\uea26', label: 'Level Three', category: 'magic' },
  'ra-level-three-advanced': { char: '\uea25', label: 'Level Three Advanced', category: 'magic' },
  'ra-level-two': { char: '\uea28', label: 'Level Two', category: 'magic' },
  'ra-level-two-advanced': { char: '\uea27', label: 'Level Two Advanced', category: 'magic' },
  'ra-lever': { char: '\uea29', label: 'Lever', category: 'electronics' },
  'ra-libra': { char: '\uea2a', label: 'Libra', category: 'astrology' },
  'ra-light-bulb': { char: '\uea2b', label: 'Light Bulb', category: 'electronics' },
  'ra-lighthouse': { char: '\uea2c', label: 'Lighthouse', category: 'electronics' },
  'ra-lightning': { char: '\uea31', label: 'Lightning', category: 'magic' },
  'ra-lightning-bolt': { char: '\uea2d', label: 'Lightning Bolt', category: 'magic' },
  'ra-lightning-storm': { char: '\uea2e', label: 'Lightning Storm', category: 'magic' },
  'ra-lightning-sword': { char: '\uea2f', label: 'Lightning Sword', category: 'weapons' },
  'ra-lightning-trio': { char: '\uea30', label: 'Lightning Trio', category: 'magic' },
  'ra-lion': { char: '\uea32', label: 'Lion', category: 'creatures' },
  'ra-lit-candelabra': { char: '\uea33', label: 'Lit Candelabra', category: 'inventory' },
  'ra-load': { char: '\uea34', label: 'Load', category: 'electronics' },
  'ra-locked-fortress': { char: '\uea35', label: 'Locked Fortress', category: 'rpg' },
  'ra-love-howl': { char: '\uea36', label: 'Love Howl', category: 'creatures' },
  'ra-maggot': { char: '\uea37', label: 'Maggot', category: 'creatures' },
  'ra-magnet': { char: '\uea38', label: 'Magnet', category: 'electronics' },
  'ra-mass-driver': { char: '\uea39', label: 'Mass Driver', category: 'weapons' },
  'ra-match': { char: '\uea3a', label: 'Match', category: 'inventory' },
  'ra-meat': { char: '\uea3c', label: 'Meat', category: 'food' },
  'ra-meat-hook': { char: '\uea3b', label: 'Meat Hook', category: 'weapons' },
  'ra-medical-pack': { char: '\uea3d', label: 'Medical Pack', category: 'inventory' },
  'ra-metal-gate': { char: '\uea3e', label: 'Metal Gate', category: 'rpg' },
  'ra-microphone': { char: '\uea3f', label: 'Microphone', category: 'electronics' },
  'ra-mine-wagon': { char: '\uea40', label: 'Mine Wagon', category: 'rpg' },
  'ra-mining-diamonds': { char: '\uea41', label: 'Mining Diamonds', category: 'magic' },
  'ra-mirror': { char: '\uea42', label: 'Mirror', category: 'inventory' },
  'ra-monster-skull': { char: '\uea43', label: 'Monster Skull', category: 'creatures' },
  'ra-moon-sun': { char: '\uea45', label: 'Moon Sun', category: 'astrology' },
  'ra-mountains': { char: '\uea44', label: 'Mountains', category: 'rpg' },
  'ra-mp5': { char: '\uea46', label: 'Mp5', category: 'weapons' },
  'ra-muscle-fat': { char: '\uea47', label: 'Muscle Fat', category: 'player' },
  'ra-muscle-up': { char: '\uea48', label: 'Muscle Up', category: 'player' },
  'ra-musket': { char: '\uea49', label: 'Musket', category: 'weapons' },
  'ra-nails': { char: '\uea4a', label: 'Nails', category: 'inventory' },
  'ra-nodular': { char: '\uea4b', label: 'Nodular', category: 'rpg' },
  'ra-noose': { char: '\uea4c', label: 'Noose', category: 'dangers' },
  'ra-nuclear': { char: '\uea4d', label: 'Nuclear', category: 'electronics' },
  'ra-ocarina': { char: '\uea4e', label: 'Ocarina', category: 'inventory' },
  'ra-ocean-emblem': { char: '\uea4f', label: 'Ocean Emblem', category: 'rpg' },
  'ra-octopus': { char: '\uea50', label: 'Octopus', category: 'creatures' },
  'ra-omega': { char: '\uea51', label: 'Omega', category: 'rpg' },
  'ra-on-target': { char: '\uea52', label: 'On Target', category: 'rpg' },
  'ra-ophiuchus': { char: '\uea53', label: 'Ophiuchus', category: 'astrology' },
  'ra-overhead': { char: '\uea54', label: 'Overhead', category: 'rpg' },
  'ra-overmind': { char: '\uea55', label: 'Overmind', category: 'rpg' },
  'ra-palm-tree': { char: '\uea56', label: 'Palm Tree', category: 'plants' },
  'ra-pawn': { char: '\uea57', label: 'Pawn', category: 'cards-dice' },
  'ra-pawprint': { char: '\uea58', label: 'Pawprint', category: 'player' },
  'ra-perspective-dice-five': { char: '\uea59', label: 'Perspective Dice Five', category: 'cards-dice' },
  'ra-perspective-dice-four': { char: '\uea5a', label: 'Perspective Dice Four', category: 'cards-dice' },
  'ra-perspective-dice-one': { char: '\uea5b', label: 'Perspective Dice One', category: 'cards-dice' },
  'ra-perspective-dice-random': { char: '\uea5c', label: 'Perspective Dice Random', category: 'cards-dice' },
  'ra-perspective-dice-six': { char: '\uea5e', label: 'Perspective Dice Six', category: 'cards-dice' },
  'ra-perspective-dice-three': { char: '\uea5f', label: 'Perspective Dice Three', category: 'cards-dice' },
  'ra-perspective-dice-two': { char: '\uea5d', label: 'Perspective Dice Two', category: 'cards-dice' },
  'ra-pill': { char: '\uea60', label: 'Pill', category: 'inventory' },
  'ra-pills': { char: '\uea61', label: 'Pills', category: 'inventory' },
  'ra-pine-tree': { char: '\uea62', label: 'Pine Tree', category: 'plants' },
  'ra-ping-pong': { char: '\uea63', label: 'Ping Pong', category: 'inventory' },
  'ra-pisces': { char: '\uea64', label: 'Pisces', category: 'astrology' },
  'ra-plain-dagger': { char: '\uea65', label: 'Plain Dagger', category: 'weapons' },
  'ra-player': { char: '\uea6f', label: 'Player', category: 'player' },
  'ra-player-despair': { char: '\uea66', label: 'Player Despair', category: 'player' },
  'ra-player-dodge': { char: '\uea67', label: 'Player Dodge', category: 'player' },
  'ra-player-king': { char: '\uea68', label: 'Player King', category: 'player' },
  'ra-player-lift': { char: '\uea69', label: 'Player Lift', category: 'player' },
  'ra-player-pain': { char: '\uea6a', label: 'Player Pain', category: 'player' },
  'ra-player-pyromaniac': { char: '\uea6b', label: 'Player Pyromaniac', category: 'player' },
  'ra-player-shot': { char: '\uea6c', label: 'Player Shot', category: 'player' },
  'ra-player-teleport': { char: '\uea6d', label: 'Player Teleport', category: 'player' },
  'ra-player-thunder-struck': { char: '\uea6e', label: 'Player Thunder Struck', category: 'player' },
  'ra-podium': { char: '\uea70', label: 'Podium', category: 'rpg' },
  'ra-poison-cloud': { char: '\uea71', label: 'Poison Cloud', category: 'dangers' },
  'ra-potion': { char: '\uea72', label: 'Potion', category: 'potions' },
  'ra-pyramids': { char: '\uea73', label: 'Pyramids', category: 'rpg' },
  'ra-queen-crown': { char: '\uea74', label: 'Queen Crown', category: 'armor' },
  'ra-quill-ink': { char: '\uea75', label: 'Quill Ink', category: 'inventory' },
  'ra-rabbit': { char: '\uea76', label: 'Rabbit', category: 'creatures' },
  'ra-radar-dish': { char: '\uea77', label: 'Radar Dish', category: 'electronics' },
  'ra-radial-balance': { char: '\uea78', label: 'Radial Balance', category: 'rpg' },
  'ra-radioactive': { char: '\uea79', label: 'Radioactive', category: 'electronics' },
  'ra-raven': { char: '\uea7a', label: 'Raven', category: 'creatures' },
  'ra-reactor': { char: '\uea7b', label: 'Reactor', category: 'electronics' },
  'ra-recycle': { char: '\uea7c', label: 'Recycle', category: 'electronics' },
  'ra-regeneration': { char: '\uea7d', label: 'Regeneration', category: 'electronics' },
  'ra-relic-blade': { char: '\uea7e', label: 'Relic Blade', category: 'weapons' },
  'ra-repair': { char: '\uea7f', label: 'Repair', category: 'electronics' },
  'ra-reverse': { char: '\uea80', label: 'Reverse', category: 'rpg' },
  'ra-revolver': { char: '\uea81', label: 'Revolver', category: 'weapons' },
  'ra-rifle': { char: '\uea82', label: 'Rifle', category: 'weapons' },
  'ra-ringing-bell': { char: '\uea83', label: 'Ringing Bell', category: 'inventory' },
  'ra-roast-chicken': { char: '\uea84', label: 'Roast Chicken', category: 'food' },
  'ra-robot-arm': { char: '\uea85', label: 'Robot Arm', category: 'electronics' },
  'ra-round-bottom-flask': { char: '\uea86', label: 'Round Bottom Flask', category: 'potions' },
  'ra-round-shield': { char: '\uea87', label: 'Round Shield', category: 'armor' },
  'ra-rss': { char: '\uea88', label: 'Rss', category: 'electronics' },
  'ra-rune-stone': { char: '\uea89', label: 'Rune Stone', category: 'magic' },
  'ra-sagittarius': { char: '\uea8a', label: 'Sagittarius', category: 'astrology' },
  'ra-sapphire': { char: '\uea8b', label: 'Sapphire', category: 'magic' },
  'ra-satellite': { char: '\uea8c', label: 'Satellite', category: 'electronics' },
  'ra-save': { char: '\uea8d', label: 'Save', category: 'electronics' },
  'ra-scorpio': { char: '\uea8e', label: 'Scorpio', category: 'astrology' },
  'ra-scroll-unfurled': { char: '\uea8f', label: 'Scroll Unfurled', category: 'magic' },
  'ra-scythe': { char: '\uea90', label: 'Scythe', category: 'weapons' },
  'ra-sea-serpent': { char: '\uea91', label: 'Sea Serpent', category: 'creatures' },
  'ra-seagull': { char: '\uea92', label: 'Seagull', category: 'creatures' },
  'ra-shark': { char: '\uea93', label: 'Shark', category: 'creatures' },
  'ra-sheep': { char: '\uea94', label: 'Sheep', category: 'creatures' },
  'ra-sheriff': { char: '\uea95', label: 'Sheriff', category: 'inventory' },
  'ra-shield': { char: '\uea96', label: 'Shield', category: 'armor' },
  'ra-ship-emblem': { char: '\uea97', label: 'Ship Emblem', category: 'inventory' },
  'ra-shoe-prints': { char: '\uea98', label: 'Shoe Prints', category: 'player' },
  'ra-shot-through-the-heart': { char: '\uea99', label: 'Shot Through The Heart', category: 'dangers' },
  'ra-shotgun-shell': { char: '\uea9a', label: 'Shotgun Shell', category: 'weapons' },
  'ra-shovel': { char: '\uea9b', label: 'Shovel', category: 'weapons' },
  'ra-shuriken': { char: '\uea9c', label: 'Shuriken', category: 'weapons' },
  'ra-sickle': { char: '\uea9d', label: 'Sickle', category: 'weapons' },
  'ra-sideswipe': { char: '\uea9e', label: 'Sideswipe', category: 'rpg' },
  'ra-site': { char: '\uea9f', label: 'Site', category: 'rpg' },
  'ra-skull': { char: '\ueaa1', label: 'Skull', category: 'dangers' },
  'ra-skull-trophy': { char: '\ueaa0', label: 'Skull Trophy', category: 'dangers' },
  'ra-slash-ring': { char: '\ueaa2', label: 'Slash Ring', category: 'inventory' },
  'ra-small-fire': { char: '\ueaa3', label: 'Small Fire', category: 'magic' },
  'ra-snail': { char: '\ueaa4', label: 'Snail', category: 'creatures' },
  'ra-snake': { char: '\ueaa5', label: 'Snake', category: 'creatures' },
  'ra-snorkel': { char: '\ueaa6', label: 'Snorkel', category: 'inventory' },
  'ra-snowflake': { char: '\ueaa7', label: 'Snowflake', category: 'magic' },
  'ra-soccer-ball': { char: '\ueaa8', label: 'Soccer Ball', category: 'inventory' },
  'ra-spades': { char: '\ueaaa', label: 'Spades', category: 'cards-dice' },
  'ra-spades-card': { char: '\ueaa9', label: 'Spades Card', category: 'cards-dice' },
  'ra-spawn-node': { char: '\ueaab', label: 'Spawn Node', category: 'rpg' },
  'ra-spear-head': { char: '\ueaac', label: 'Spear Head', category: 'weapons' },
  'ra-speech-bubble': { char: '\ueaad', label: 'Speech Bubble', category: 'electronics' },
  'ra-speech-bubbles': { char: '\ueaae', label: 'Speech Bubbles', category: 'electronics' },
  'ra-spider-face': { char: '\ueaaf', label: 'Spider Face', category: 'creatures' },
  'ra-spikeball': { char: '\ueab0', label: 'Spikeball', category: 'dangers' },
  'ra-spiked-mace': { char: '\ueab1', label: 'Spiked Mace', category: 'weapons' },
  'ra-spiked-tentacle': { char: '\ueab2', label: 'Spiked Tentacle', category: 'creatures' },
  'ra-spinning-sword': { char: '\ueab3', label: 'Spinning Sword', category: 'weapons' },
  'ra-spiral-shell': { char: '\ueab4', label: 'Spiral Shell', category: 'creatures' },
  'ra-splash': { char: '\ueab5', label: 'Splash', category: 'rpg' },
  'ra-spray-can': { char: '\ueab6', label: 'Spray Can', category: 'inventory' },
  'ra-sprout': { char: '\ueab8', label: 'Sprout', category: 'plants' },
  'ra-sprout-emblem': { char: '\ueab7', label: 'Sprout Emblem', category: 'plants' },
  'ra-stopwatch': { char: '\ueab9', label: 'Stopwatch', category: 'inventory' },
  'ra-suckered-tentacle': { char: '\ueaba', label: 'Suckered Tentacle', category: 'creatures' },
  'ra-suits': { char: '\ueabb', label: 'Suits', category: 'cards-dice' },
  'ra-sun': { char: '\ueabd', label: 'Sun', category: 'magic' },
  'ra-sun-symbol': { char: '\ueabc', label: 'Sun Symbol', category: 'magic' },
  'ra-sunbeams': { char: '\ueabe', label: 'Sunbeams', category: 'magic' },
  'ra-super-mushroom': { char: '\ueabf', label: 'Super Mushroom', category: 'plants' },
  'ra-supersonic-arrow': { char: '\ueac0', label: 'Supersonic Arrow', category: 'weapons' },
  'ra-surveillance-camera': { char: '\ueac1', label: 'Surveillance Camera', category: 'electronics' },
  'ra-sword': { char: '\ue946', label: 'Sword', category: 'weapons' },
  'ra-syringe': { char: '\ueac2', label: 'Syringe', category: 'inventory' },
  'ra-target-arrows': { char: '\ueac3', label: 'Target Arrows', category: 'weapons' },
  'ra-target-laser': { char: '\ueac4', label: 'Target Laser', category: 'rpg' },
  'ra-targeted': { char: '\ueac5', label: 'Targeted', category: 'rpg' },
  'ra-taurus': { char: '\ueac6', label: 'Taurus', category: 'astrology' },
  'ra-telescope': { char: '\ueac7', label: 'Telescope', category: 'electronics' },
  'ra-tentacle': { char: '\ueac8', label: 'Tentacle', category: 'creatures' },
  'ra-tesla': { char: '\ueac9', label: 'Tesla', category: 'electronics' },
  'ra-thorn-arrow': { char: '\ueaca', label: 'Thorn Arrow', category: 'weapons' },
  'ra-thorny-vine': { char: '\ueacb', label: 'Thorny Vine', category: 'plants' },
  'ra-three-keys': { char: '\ueacc', label: 'Three Keys', category: 'inventory' },
  'ra-tic-tac-toe': { char: '\ueacd', label: 'Tic Tac Toe', category: 'inventory' },
  'ra-toast': { char: '\ueace', label: 'Toast', category: 'food' },
  'ra-tombstone': { char: '\ueacf', label: 'Tombstone', category: 'dangers' },
  'ra-tooth': { char: '\uead0', label: 'Tooth', category: 'inventory' },
  'ra-torch': { char: '\uead1', label: 'Torch', category: 'inventory' },
  'ra-tower': { char: '\uead2', label: 'Tower', category: 'rpg' },
  'ra-trail': { char: '\uead3', label: 'Trail', category: 'rpg' },
  'ra-trefoil-lily': { char: '\uead4', label: 'Trefoil Lily', category: 'plants' },
  'ra-trident': { char: '\uead5', label: 'Trident', category: 'weapons' },
  'ra-triforce': { char: '\uead6', label: 'Triforce', category: 'magic' },
  'ra-trophy': { char: '\uead7', label: 'Trophy', category: 'inventory' },
  'ra-turd': { char: '\uead8', label: 'Turd', category: 'inventory' },
  'ra-two-dragons': { char: '\uead9', label: 'Two Dragons', category: 'creatures' },
  'ra-two-hearts': { char: '\ueada', label: 'Two Hearts', category: 'magic' },
  'ra-uncertainty': { char: '\ueadb', label: 'Uncertainty', category: 'rpg' },
  'ra-underhand': { char: '\ueadc', label: 'Underhand', category: 'rpg' },
  'ra-unplugged': { char: '\ueadd', label: 'Unplugged', category: 'electronics' },
  'ra-vase': { char: '\ueade', label: 'Vase', category: 'potions' },
  'ra-venomous-snake': { char: '\ueadf', label: 'Venomous Snake', category: 'creatures' },
  'ra-vest': { char: '\ueae0', label: 'Vest', category: 'armor' },
  'ra-vial': { char: '\ueae1', label: 'Vial', category: 'potions' },
  'ra-vine-whip': { char: '\ueae2', label: 'Vine Whip', category: 'weapons' },
  'ra-virgo': { char: '\ueae3', label: 'Virgo', category: 'astrology' },
  'ra-water-drop': { char: '\ueae4', label: 'Water Drop', category: 'magic' },
  'ra-wifi': { char: '\ueae5', label: 'Wifi', category: 'electronics' },
  'ra-wireless-signal': { char: '\ueae6', label: 'Wireless Signal', category: 'electronics' },
  'ra-wolf-head': { char: '\ueae7', label: 'Wolf Head', category: 'creatures' },
  'ra-wolf-howl': { char: '\ueae8', label: 'Wolf Howl', category: 'creatures' },
  'ra-wooden-sign': { char: '\ueae9', label: 'Wooden Sign', category: 'inventory' },
  'ra-wrench': { char: '\ueaea', label: 'Wrench', category: 'inventory' },
  'ra-wyvern': { char: '\ueaeb', label: 'Wyvern', category: 'creatures' },
  'ra-x-mark': { char: '\ueaec', label: 'X Mark', category: 'dangers' },
  'ra-zebra-shield': { char: '\ueaed', label: 'Zebra Shield', category: 'armor' },
  'ra-zigzag-leaf': { char: '\ueaee', label: 'Zigzag Leaf', category: 'plants' },
};

/**
 * Get the character for an icon class
 */
function getIconChar(iconClass: string): string | null {
  const icon = RA_ICONS[iconClass];
  return icon ? icon.char : null;
}

/**
 * Get full info for an icon
 */
function getIconInfo(iconClass: string): IconData | null {
  return RA_ICONS[iconClass] || null;
}

/**
 * Get all icons in a category
 */
function getIconsByCategory(categoryId: string): IconWithClass[] {
  return Object.entries(RA_ICONS)
    .filter(([_, data]) => data.category === categoryId)
    .map(([iconClass, data]) => ({ iconClass, ...data }));
}

/**
 * Search icons by label or class name
 */
function searchIcons(query: string): IconWithClass[] {
  const lowerQuery = query.toLowerCase();
  return Object.entries(RA_ICONS)
    .filter(([iconClass, data]) =>
      iconClass.toLowerCase().includes(lowerQuery) ||
      data.label.toLowerCase().includes(lowerQuery)
    )
    .map(([iconClass, data]) => ({ iconClass, ...data }));
}

/**
 * Get all icon class names
 */
function getAllIconClasses(): string[] {
  return Object.keys(RA_ICONS);
}

return {
  RA_CATEGORIES,
  RA_ICONS,
  getIconChar,
  getIconInfo,
  getIconsByCategory,
  searchIcons,
  getAllIconClasses
};

```

# objectTypeResolver

```ts
/**
 * objectTypeResolver.ts
 *
 * Resolves object types by merging built-in definitions with user customizations.
 * Handles:
 * - Object overrides (modified built-ins)
 * - Hidden objects
 * - Custom objects
 * - Custom categories
 * - Unknown object fallback
 */

import type { MapType } from '#types/core/map.types';
import type { IconData, IconMap } from '#types/objects/icon.types';

// Types from #types/objects/object.types.ts and #types/settings/settings.types.ts
// Duplicated here for datacore runtime compatibility (path aliases not resolved at runtime)

/** Base object type (from objectTypes.ts) */
interface ObjectType {
  id: string;
  symbol: string;
  label: string;
  category: string;
}

/** Resolved object type definition */
interface ObjectTypeDefinition {
  id: string;
  symbol?: string;
  iconClass?: string;
  label: string;
  category: string;
  order?: number;
  isBuiltIn?: boolean;
  isModified?: boolean;
  isCustom?: boolean;
  isHidden?: boolean;
  isUnknown?: boolean;
}

/** Base category (from objectTypes.ts) */
interface Category {
  id: string;
  label: string;
}

/** Resolved category definition */
interface CategoryDefinition {
  id: string;
  label: string;
  order?: number;
  isBuiltIn?: boolean;
  isCustom?: boolean;
}

/** Object override settings */
interface ObjectOverride {
  hidden?: boolean;
  symbol?: string;
  iconClass?: string;
  label?: string;
  category?: string;
  order?: number;
}

/** Object settings from settings accessor */
interface ObjectSettings {
  objectOverrides?: Record<string, ObjectOverride>;
  customObjects?: ObjectTypeDefinition[];
  customCategories?: CategoryDefinition[];
}

/** Render character result */
interface RenderChar {
  char: string;
  isIcon: boolean;
}

/** Validation result */
interface ValidationResult {
  valid: boolean;
  errors: string[];
}

/** Object types module */
interface ObjectTypesModule {
  OBJECT_TYPES: ObjectType[];
  CATEGORIES: Category[];
}

/** Settings accessor module */
interface SettingsAccessorModule {
  getObjectSettings: (mapType: MapType) => ObjectSettings;
}

/** RPG Awesome icons module */
interface RPGAwesomeIconsModule {
  RA_ICONS: IconMap;
  getIconChar: (iconClass: string) => string | null;
  getIconInfo: (iconClass: string) => IconData | null;
}

const { OBJECT_TYPES, CATEGORIES } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "objectTypes")) as ObjectTypesModule;
const { getObjectSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsAccessor")) as SettingsAccessorModule;
const { RA_ICONS, getIconChar, getIconInfo } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "rpgAwesomeIcons")) as RPGAwesomeIconsModule;

/**
 * Fallback for unknown/deleted object types
 * Used when a map references an object type that no longer exists
 */
const UNKNOWN_OBJECT_FALLBACK: ObjectTypeDefinition = {
  id: '__unknown__',
  symbol: '?',
  label: 'Unknown Object',
  category: 'markers',
  isUnknown: true
};

/**
 * Check if an object type uses an RPGAwesome icon
 */
function hasIconClass(objectType: ObjectTypeDefinition | null | undefined): boolean {
  return objectType != null && typeof objectType.iconClass === 'string' && objectType.iconClass.length > 0;
}

/**
 * Get the render character for an object type
 * Handles both iconClass (RPGAwesome) and symbol (Unicode) with fallback
 */
function getRenderChar(objectType: ObjectTypeDefinition | null | undefined): RenderChar {
  if (!objectType) {
    return { char: '?', isIcon: false };
  }

  // If iconClass is set, try to get the icon character
  if (hasIconClass(objectType)) {
    const iconChar = getIconChar(objectType.iconClass!);
    if (iconChar) {
      return { char: iconChar, isIcon: true };
    }
    // iconClass was set but invalid - fall through to symbol/fallback
    console.warn(`[objectTypeResolver] Invalid iconClass: ${objectType.iconClass}`);
  }

  // Use symbol if available
  if (objectType.symbol) {
    return { char: objectType.symbol, isIcon: false };
  }

  // Final fallback
  return { char: '?', isIcon: false };
}

/**
 * Validate an iconClass value
 */
function isValidIconClass(iconClass: string | null | undefined): boolean {
  if (!iconClass || typeof iconClass !== 'string') return false;
  return Object.prototype.hasOwnProperty.call(RA_ICONS, iconClass);
}

/**
 * Default category order for built-in categories
 */
const BUILT_IN_CATEGORY_ORDER: Record<string, number> = {
  'notes': 0,
  'navigation': 10,
  'hazards': 20,
  'features': 30,
  'encounters': 40,
  'markers': 50
};

/**
 * Get effective object types list (built-ins + overrides + custom)
 * This is the main function consumers should use for listing available objects.
 */
function getResolvedObjectTypes(mapType: MapType = 'grid'): ObjectTypeDefinition[] {
  const settings = getObjectSettings(mapType);
  const { objectOverrides = {}, customObjects = [] } = settings;

  // Apply overrides to built-ins, filter out hidden ones
  // Built-in objects get default order based on their index in OBJECT_TYPES
  const resolvedBuiltIns = OBJECT_TYPES
    .filter(obj => !objectOverrides[obj.id]?.hidden)
    .map((obj, index) => {
      const override = objectOverrides[obj.id];
      const defaultOrder = index * 10; // Leave gaps for reordering
      if (override) {
        // Merge override properties (excluding 'hidden' which is handled above)
        const { hidden, ...overrideProps } = override;
        return {
          ...obj,
          ...overrideProps,
          order: override.order ?? defaultOrder,
          isBuiltIn: true,
          isModified: true
        };
      }
      return {
        ...obj,
        order: defaultOrder,
        isBuiltIn: true,
        isModified: false
      };
    });

  // Add custom objects with their flag
  // Custom objects use their order or a high default to appear at the end
  const resolvedCustom = customObjects.map((obj, index) => ({
    ...obj,
    order: obj.order ?? (1000 + index * 10),
    isCustom: true,
    isBuiltIn: false
  }));

  return [...resolvedBuiltIns, ...resolvedCustom];
}

/**
 * Get effective categories list (built-ins + custom), sorted by order
 */
function getResolvedCategories(mapType: MapType = 'grid'): CategoryDefinition[] {
  const settings = getObjectSettings(mapType);
  const { customCategories = [] } = settings;

  // Add order to built-in categories
  const resolvedBuiltIns = CATEGORIES.map(c => ({
    ...c,
    isBuiltIn: true,
    order: BUILT_IN_CATEGORY_ORDER[c.id] ?? 50
  }));

  // Add custom categories with their flags
  const resolvedCustom = customCategories.map(c => ({
    ...c,
    isCustom: true,
    isBuiltIn: false,
    order: c.order ?? 100 // Default custom categories to end
  }));

  // Combine and sort by order
  return [...resolvedBuiltIns, ...resolvedCustom]
    .sort((a, b) => (a.order ?? 50) - (b.order ?? 50));
}

/**
 * Get list of hidden built-in objects
 * Useful for showing a "hidden objects" section in settings
 */
function getHiddenObjects(mapType: MapType = 'grid'): ObjectTypeDefinition[] {
  const settings = getObjectSettings(mapType);
  const { objectOverrides = {} } = settings;

  return OBJECT_TYPES
    .filter(obj => objectOverrides[obj.id]?.hidden)
    .map(obj => ({
      ...obj,
      isBuiltIn: true,
      isHidden: true
    }));
}

/**
 * Get a single object type by ID
 * Returns the resolved version (with overrides applied) or fallback for unknown
 */
function getObjectType(typeId: string | null | undefined, mapType: MapType = 'grid'): ObjectTypeDefinition {
  // Handle null/undefined
  if (!typeId) {
    return UNKNOWN_OBJECT_FALLBACK;
  }

  // Special case: return the fallback directly if requested
  if (typeId === '__unknown__') {
    return UNKNOWN_OBJECT_FALLBACK;
  }

  const settings = getObjectSettings(mapType);
  const { objectOverrides = {}, customObjects = [] } = settings;

  // Check built-in objects first (including hidden ones - they still need to render)
  const builtIn = OBJECT_TYPES.find(t => t.id === typeId);
  if (builtIn) {
    const override = objectOverrides[typeId];
    if (override) {
      const { hidden, ...overrideProps } = override;
      return {
        ...builtIn,
        ...overrideProps,
        isBuiltIn: true,
        isModified: true,
        isHidden: hidden || false
      };
    }
    return {
      ...builtIn,
      isBuiltIn: true,
      isModified: false
    };
  }

  // Check custom objects
  const custom = customObjects.find(t => t.id === typeId);
  if (custom) {
    return {
      ...custom,
      isCustom: true,
      isBuiltIn: false
    };
  }

  // Not found - return fallback
  return UNKNOWN_OBJECT_FALLBACK;
}

/**
 * Check if an object type exists (built-in or custom, not hidden)
 */
function objectTypeExists(typeId: string, mapType: MapType = 'grid'): boolean {
  const objType = getObjectType(typeId, mapType);
  return objType.id !== '__unknown__' && !objType.isHidden;
}

/**
 * Get the original (unmodified) built-in object definition
 * Used for "reset to default" functionality
 */
function getOriginalBuiltIn(typeId: string): ObjectTypeDefinition | null {
  const builtIn = OBJECT_TYPES.find(t => t.id === typeId);
  return builtIn ? { ...builtIn, isBuiltIn: true } : null;
}

/**
 * Generate a unique ID for a custom object
 */
function generateCustomObjectId(): string {
  return 'custom-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
}

/**
 * Generate a unique ID for a custom category
 */
function generateCustomCategoryId(): string {
  return 'custom-cat-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
}

/**
 * Validate a symbol string
 * Returns true if the symbol is valid (non-empty, reasonable length)
 */
function isValidSymbol(symbol: string | null | undefined): boolean {
  if (!symbol || typeof symbol !== 'string') return false;
  // Allow 1-4 characters (some emoji are multi-codepoint)
  const trimmed = symbol.trim();
  return trimmed.length >= 1 && trimmed.length <= 8;
}

/**
 * Validate an object definition
 * Objects can have either a symbol (Unicode) OR an iconClass (RPGAwesome), or both
 */
function validateObjectDefinition(obj: Partial<ObjectTypeDefinition>): ValidationResult {
  const errors: string[] = [];

  const hasSymbol = obj.symbol && isValidSymbol(obj.symbol);
  const hasIcon = obj.iconClass && isValidIconClass(obj.iconClass);

  // Must have at least one of symbol or iconClass
  if (!hasSymbol && !hasIcon) {
    if (obj.iconClass && !hasIcon) {
      errors.push('Invalid icon selection');
    } else if (obj.symbol && !hasSymbol) {
      errors.push('Symbol must be 1-8 characters');
    } else {
      errors.push('Either a symbol or an icon is required');
    }
  }

  if (!obj.label || typeof obj.label !== 'string' || obj.label.trim().length === 0) {
    errors.push('Label is required');
  }

  if (!obj.category || typeof obj.category !== 'string') {
    errors.push('Category is required');
  }

  return {
    valid: errors.length === 0,
    errors
  };
}

// Export all functions
return {
  // Core resolution
  getResolvedObjectTypes,
  getResolvedCategories,
  getObjectType,
  getHiddenObjects,

  // Icon/symbol helpers
  hasIconClass,
  getRenderChar,
  isValidIconClass,

  // Utilities
  objectTypeExists,
  getOriginalBuiltIn,
  generateCustomObjectId,
  generateCustomCategoryId,
  isValidSymbol,
  validateObjectDefinition,

  // Constants
  UNKNOWN_OBJECT_FALLBACK,
  BUILT_IN_CATEGORY_ORDER,

  // Re-export icon data for convenience
  RA_ICONS
};

```

# hexSlotPositioner

```ts
/**
 * hexSlotPositioner.ts
 *
 * Manages object positioning within hex cells for multi-object support.
 *
 * Slot arrangements vary by object count:
 * - 1 object:  Center
 * - 2 objects: Horizontal row (flat-top) or vertical stack (pointy-top)
 * - 3 objects: Triangle formation
 * - 4 objects: Diamond/cross pattern
 *
 * Offsets are in hex-size units (-0.5 to 0.5 range), where 1.0 = full hex width/height.
 * These get multiplied by the actual hex size during rendering.
 */

import type { MapObject } from '#types/objects/object.types';
import type { HexOrientation } from '#types/settings/settings.types';

/** Slot position data */
interface SlotPosition {
  slot: number;
  offsetX: number;
  offsetY: number;
}

/** Slot offset result */
interface SlotOffset {
  offsetX: number;
  offsetY: number;
}

/** Arrangement map by object count */
type ArrangementMap = Record<number, SlotPosition[]>;

/**
 * Flat-top hex arrangements
 */
const FLAT_TOP_ARRANGEMENTS: ArrangementMap = {
  1: [
    { slot: 0, offsetX: 0, offsetY: 0 }
  ],
  2: [
    { slot: 0, offsetX: -0.22, offsetY: 0 },
    { slot: 1, offsetX: 0.22, offsetY: 0 }
  ],
  3: [
    { slot: 0, offsetX: -0.20, offsetY: -0.15 },
    { slot: 1, offsetX: 0.20, offsetY: -0.15 },
    { slot: 2, offsetX: 0, offsetY: 0.20 }
  ],
  4: [
    { slot: 0, offsetX: 0, offsetY: -0.20 },
    { slot: 1, offsetX: 0.20, offsetY: 0 },
    { slot: 2, offsetX: 0, offsetY: 0.20 },
    { slot: 3, offsetX: -0.20, offsetY: 0 }
  ]
};

/**
 * Pointy-top hex arrangements
 */
const POINTY_TOP_ARRANGEMENTS: ArrangementMap = {
  1: [
    { slot: 0, offsetX: 0, offsetY: 0 }
  ],
  2: [
    { slot: 0, offsetX: 0, offsetY: -0.22 },
    { slot: 1, offsetX: 0, offsetY: 0.22 }
  ],
  3: [
    { slot: 0, offsetX: 0, offsetY: -0.20 },
    { slot: 1, offsetX: -0.18, offsetY: 0.15 },
    { slot: 2, offsetX: 0.18, offsetY: 0.15 }
  ],
  4: [
    { slot: 0, offsetX: 0, offsetY: -0.20 },
    { slot: 1, offsetX: 0.20, offsetY: 0 },
    { slot: 2, offsetX: 0, offsetY: 0.20 },
    { slot: 3, offsetX: -0.20, offsetY: 0 }
  ]
};

/**
 * Get slot offset for rendering
 */
function getSlotOffset(slot: number, objectCount: number, orientation: HexOrientation = 'flat'): SlotOffset {
  const arrangements = orientation === 'pointy'
    ? POINTY_TOP_ARRANGEMENTS
    : FLAT_TOP_ARRANGEMENTS;

  const count = Math.min(Math.max(objectCount, 1), 4);
  const arrangement = arrangements[count];
  const position = arrangement?.find(p => p.slot === slot);

  return position
    ? { offsetX: position.offsetX, offsetY: position.offsetY }
    : { offsetX: 0, offsetY: 0 };
}

/**
 * Assign next available slot for a new object
 */
function assignSlot(existingSlots: number[]): number {
  for (let i = 0; i < 4; i++) {
    if (!existingSlots.includes(i)) {
      return i;
    }
  }
  return -1;
}

/**
 * Reorganize slots after object removal to maintain compact arrangement
 */
function reorganizeSlots(currentSlots: number[]): Map<number, number> {
  const sorted = [...currentSlots].sort((a, b) => a - b);
  const remapping = new Map<number, number>();

  sorted.forEach((oldSlot, newSlot) => {
    if (oldSlot !== newSlot) {
      remapping.set(oldSlot, newSlot);
    }
  });

  return remapping;
}

/**
 * Get the maximum number of objects allowed per cell
 */
function getMaxObjectsPerCell(): number {
  return 4;
}

/**
 * Calculate scale factor for objects in multi-object cells
 */
function getMultiObjectScale(objectCount: number): number {
  if (objectCount <= 1) return 1.0;
  if (objectCount === 2) return 0.7;
  if (objectCount === 3) return 0.6;
  return 0.55;
}

/**
 * Get objects in a specific cell
 */
function getObjectsInCell(objects: MapObject[], x: number, y: number): MapObject[] {
  if (!objects || !Array.isArray(objects)) return [];

  return objects.filter(obj =>
    obj.position &&
    obj.position.x === x &&
    obj.position.y === y
  );
}

/**
 * Check if a cell can accept another object
 */
function canAddObjectToCell(objects: MapObject[], x: number, y: number): boolean {
  const cellObjects = getObjectsInCell(objects, x, y);
  return cellObjects.length < getMaxObjectsPerCell();
}

/**
 * Get occupied slots in a cell
 */
function getOccupiedSlots(objects: MapObject[], x: number, y: number): number[] {
  const cellObjects = getObjectsInCell(objects, x, y);
  return cellObjects
    .map(obj => obj.slot)
    .filter((slot): slot is number => slot !== undefined && slot !== null);
}

/**
 * Prepare objects array after removing an object from a multi-object cell
 */
function reorganizeAfterRemoval(objects: MapObject[], x: number, y: number): MapObject[] {
  const cellObjects = getObjectsInCell(objects, x, y);

  if (cellObjects.length <= 1) {
    if (cellObjects.length === 1 && cellObjects[0].slot !== 0) {
      return objects.map(obj => {
        if (obj.id === cellObjects[0].id) {
          return { ...obj, slot: 0 };
        }
        return obj;
      });
    }
    return objects;
  }

  const currentSlots = cellObjects.map(obj => obj.slot).filter((s): s is number => s !== undefined);
  const remapping = reorganizeSlots(currentSlots);

  if (remapping.size === 0) return objects;

  return objects.map(obj => {
    if (obj.position?.x === x && obj.position?.y === y && obj.slot !== undefined) {
      const newSlot = remapping.get(obj.slot);
      if (newSlot !== undefined) {
        return { ...obj, slot: newSlot };
      }
    }
    return obj;
  });
}

/**
 * Find which object in a multi-object cell was clicked based on proximity to slot positions
 */
function getClickedObjectInCell(
  objects: MapObject[],
  hexX: number,
  hexY: number,
  clickOffsetX: number,
  clickOffsetY: number,
  orientation: HexOrientation
): MapObject | null {
  const cellObjects = getObjectsInCell(objects, hexX, hexY);

  if (cellObjects.length === 0) return null;
  if (cellObjects.length === 1) return cellObjects[0];

  let closest: MapObject | null = null;
  let closestDist = Infinity;

  for (const obj of cellObjects) {
    const effectiveSlot = obj.slot ?? cellObjects.indexOf(obj);
    const { offsetX, offsetY } = getSlotOffset(
      effectiveSlot,
      cellObjects.length,
      orientation
    );

    const dist = Math.sqrt(
      Math.pow(clickOffsetX - offsetX, 2) +
      Math.pow(clickOffsetY - offsetY, 2)
    );

    if (dist < closestDist) {
      closestDist = dist;
      closest = obj;
    }
  }

  return closest;
}

return {
  FLAT_TOP_ARRANGEMENTS,
  POINTY_TOP_ARRANGEMENTS,
  getSlotOffset,
  assignSlot,
  reorganizeSlots,
  getMaxObjectsPerCell,
  getMultiObjectScale,
  getObjectsInCell,
  canAddObjectToCell,
  getOccupiedSlots,
  reorganizeAfterRemoval,
  getClickedObjectInCell
};

```

# objectOperations

```ts
/**
 * objectOperations.ts
 * Operations for managing map objects - placement, removal, updates.
 */

import type { MapType } from '#types/core/map.types';
import type {
  ObjectId,
  ObjectAlignment,
  ObjectTypeDef,
  ObjectSize,
  MapObject,
  ObjectUpdate,
  PlacementResult,
  RemovalResult,
  PlacementOptions,
  AlignmentOffset,
  HexSlot,
} from '#types/objects/object.types';

// Datacore imports
// Import getObjectType from the resolver (handles overrides, custom objects, fallback)
const { getObjectType } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "objectTypeResolver")) as {
  getObjectType: (typeId: string) => ObjectTypeDef
};

const { 
  assignSlot, 
  getObjectsInCell, 
  canAddObjectToCell, 
  getOccupiedSlots,
  reorganizeAfterRemoval 
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "hexSlotPositioner")) as {
  assignSlot: (occupiedSlots: HexSlot[]) => HexSlot | -1;
  getObjectsInCell: (objects: MapObject[], x: number, y: number) => MapObject[];
  canAddObjectToCell: (objects: MapObject[], x: number, y: number) => boolean;
  getOccupiedSlots: (objects: MapObject[], x: number, y: number) => HexSlot[];
  reorganizeAfterRemoval: (objects: MapObject[], x: number, y: number) => MapObject[];
};

// ===========================================
// ID Generation
// ===========================================

/**
 * Generate a unique ID for an object
 */
function generateObjectId(): ObjectId {
  return 'obj-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
}

// ===========================================
// Object Lookup
// ===========================================

/**
 * Find object at specific grid coordinates
 */
function getObjectAtPosition(objects: MapObject[] | null | undefined, x: number, y: number): MapObject | null {
  if (!objects || !Array.isArray(objects)) return null;
  
  return objects.find(obj => {
    // Ensure size exists (backward compatibility)
    const size = obj.size || { width: 1, height: 1 };
    const pos = obj.position;
    
    // Check if (x, y) is within object bounds
    return x >= pos.x && x < pos.x + size.width &&
           y >= pos.y && y < pos.y + size.height;
  }) || null;
}

// ===========================================
// Grid Object Operations
// ===========================================

/**
 * Add a new object to the objects array (grid maps - single object per cell)
 */
function addObject(objects: MapObject[], typeId: string, x: number, y: number): MapObject[] {
  const objectType = getObjectType(typeId);
  if (objectType.isUnknown) {
    console.error(`Unknown object type: ${typeId}`);
    return objects;
  }
  
  // Check if object already exists at position
  const existing = getObjectAtPosition(objects, x, y);
  if (existing) {
    console.warn(`Object already exists at position (${x}, ${y})`);
    return objects;
  }
  
  const newObject: MapObject = {
    id: generateObjectId(),
    type: typeId,
    position: { x, y },
    size: { width: 1, height: 1 },
    label: objectType.label,
    linkedNote: null,
    alignment: 'center'
  };
  
  return [...objects, newObject];
}

/**
 * Remove object by ID
 */
function removeObject(objects: MapObject[] | null | undefined, objectId: ObjectId): MapObject[] {
  if (!objects || !Array.isArray(objects)) return [];
  return objects.filter(obj => obj.id !== objectId);
}

/**
 * Remove object at specific position
 */
function removeObjectAtPosition(objects: MapObject[] | null | undefined, x: number, y: number): MapObject[] {
  if (!objects || !Array.isArray(objects)) return [];
  return objects.filter(obj => !(obj.position.x === x && obj.position.y === y));
}

/**
 * Remove all objects within a rectangular area
 */
function removeObjectsInRectangle(
  objects: MapObject[] | null | undefined,
  x1: number,
  y1: number,
  x2: number,
  y2: number
): MapObject[] {
  if (!objects || !Array.isArray(objects)) return [];
  
  const minX = Math.min(x1, x2);
  const maxX = Math.max(x1, x2);
  const minY = Math.min(y1, y2);
  const maxY = Math.max(y1, y2);
  
  return objects.filter(obj => {
    return !(obj.position.x >= minX && obj.position.x <= maxX && 
             obj.position.y >= minY && obj.position.y <= maxY);
  });
}

// ===========================================
// Hex Object Operations
// ===========================================

/**
 * Add a new object to a hex cell with automatic slot assignment.
 * Supports up to 4 objects per hex cell.
 */
function addObjectToHex(
  objects: MapObject[],
  typeId: string,
  x: number,
  y: number
): PlacementResult {
  const objectType = getObjectType(typeId);
  if (objectType.isUnknown) {
    return { 
      objects, 
      success: false, 
      error: `Unknown object type: ${typeId}` 
    };
  }
  
  // Check if cell can accept another object
  if (!canAddObjectToCell(objects, x, y)) {
    return { 
      objects, 
      success: false, 
      error: 'Cell is full (maximum 4 objects)' 
    };
  }
  
  // Get occupied slots and assign next available
  const occupiedSlots = getOccupiedSlots(objects, x, y);
  const slot = assignSlot(occupiedSlots);
  
  if (slot === -1) {
    return { 
      objects, 
      success: false, 
      error: 'No available slots' 
    };
  }
  
  const newObject: MapObject = {
    id: generateObjectId(),
    type: typeId,
    position: { x, y },
    size: { width: 1, height: 1 },
    label: objectType.label,
    linkedNote: null,
    alignment: 'center',
    slot: slot
  };
  
  return { 
    objects: [...objects, newObject], 
    success: true,
    object: newObject
  };
}

/**
 * Remove object by ID from a hex map, with slot reorganization.
 */
function removeObjectFromHex(objects: MapObject[] | null | undefined, objectId: ObjectId): MapObject[] {
  if (!objects || !Array.isArray(objects)) return [];
  
  // Find the object to get its position before removal
  const objectToRemove = objects.find(obj => obj.id === objectId);
  if (!objectToRemove) return objects;
  
  const { x, y } = objectToRemove.position;
  
  // Remove the object
  const afterRemoval = objects.filter(obj => obj.id !== objectId);
  
  // Reorganize remaining slots in that cell
  return reorganizeAfterRemoval(afterRemoval, x, y);
}

/**
 * Remove a single object from a hex cell (the one with the highest slot number).
 */
function removeOneObjectFromHex(objects: MapObject[] | null | undefined, x: number, y: number): MapObject[] {
  if (!objects || !Array.isArray(objects)) return [];
  
  // Get objects in this cell
  const cellObjects = getObjectsInCell(objects, x, y);
  if (cellObjects.length === 0) return objects;
  
  // Find object with highest slot (most recently added)
  const toRemove = cellObjects.reduce((highest, obj) => {
    const objSlot = obj.slot ?? -1;
    const highestSlot = highest.slot ?? -1;
    return objSlot > highestSlot ? obj : highest;
  }, cellObjects[0]);
  
  // Remove and reorganize
  return removeObjectFromHex(objects, toRemove.id);
}

// ===========================================
// Object Updates
// ===========================================

/**
 * Update object properties by ID
 */
function updateObject(
  objects: MapObject[] | null | undefined,
  objectId: ObjectId,
  updates: ObjectUpdate
): MapObject[] {
  if (!objects || !Array.isArray(objects)) return [];
  
  return objects.map(obj => {
    if (obj.id === objectId) {
      return { ...obj, ...updates };
    }
    return obj;
  });
}

// ===========================================
// Area Checking
// ===========================================

/**
 * Check if an area is occupied by any object (excluding optional exception)
 */
function isAreaFree(
  objects: MapObject[] | null | undefined,
  x: number,
  y: number,
  width: number,
  height: number,
  excludeId: ObjectId | null = null
): boolean {
  if (!objects || !Array.isArray(objects)) return true;
  
  for (const obj of objects) {
    if (excludeId && obj.id === excludeId) continue;
    
    const size = obj.size || { width: 1, height: 1 };
    const pos = obj.position;
    
    // Check if rectangles overlap
    const objRight = pos.x + size.width;
    const objBottom = pos.y + size.height;
    const areaRight = x + width;
    const areaBottom = y + height;
    
    const overlaps = !(objRight <= x || pos.x >= areaRight || 
                      objBottom <= y || pos.y >= areaBottom);
    
    if (overlaps) return false;
  }
  
  return true;
}

/**
 * Check if an object can be resized to new dimensions
 */
function canResizeObject(
  objects: MapObject[],
  objectId: ObjectId,
  newWidth: number,
  newHeight: number,
  maxSize: number = 5
): boolean {
  if (newWidth < 1 || newHeight < 1) return false;
  if (newWidth > maxSize || newHeight > maxSize) return false;
  
  const object = objects.find(obj => obj.id === objectId);
  if (!object) return false;
  
  // Check if new size would overlap with other objects
  return isAreaFree(objects, object.position.x, object.position.y, newWidth, newHeight, objectId);
}

// ===========================================
// Alignment Utilities
// ===========================================

/**
 * Calculate the nearest edge alignment based on pointer position within a cell
 */
function calculateEdgeAlignment(
  pointerX: number,
  pointerY: number,
  gridX: number,
  gridY: number,
  threshold: number = 0.3
): ObjectAlignment {
  // Calculate position within the cell (0-1 range)
  const offsetX = pointerX - gridX;
  const offsetY = pointerY - gridY;
  
  // Check edges in order of priority
  if (offsetY < threshold) return 'north';
  if (offsetY > (1 - threshold)) return 'south';
  if (offsetX < threshold) return 'west';
  if (offsetX > (1 - threshold)) return 'east';
  
  return 'center';
}

/**
 * Get the position offset for a given alignment
 */
function getAlignmentOffset(alignment: ObjectAlignment): AlignmentOffset {
  switch (alignment) {
    case 'north': return { offsetX: 0, offsetY: -0.5 };
    case 'south': return { offsetX: 0, offsetY: 0.5 };
    case 'east': return { offsetX: 0.5, offsetY: 0 };
    case 'west': return { offsetX: -0.5, offsetY: 0 };
    case 'center':
    default: return { offsetX: 0, offsetY: 0 };
  }
}

// ===========================================
// Unified Placement API
// ===========================================

/**
 * Place an object at the specified position.
 * Handles both grid (single object per cell) and hex (up to 4 objects per cell) maps.
 */
function placeObject(
  objects: MapObject[],
  typeId: string,
  x: number,
  y: number,
  options: PlacementOptions
): PlacementResult {
  const { mapType, alignment = 'center' } = options;
  
  if (mapType === 'hex') {
    // Hex: use multi-object placement with slot assignment
    const result = addObjectToHex(objects, typeId, x, y);
    if (result.success) {
      const newObject = result.objects[result.objects.length - 1];
      return { ...result, object: newObject };
    }
    return result;
  }
  
  // Grid: single object per cell
  const objectType = getObjectType(typeId);
  if (objectType.isUnknown) {
    return { 
      objects, 
      success: false, 
      error: `Unknown object type: ${typeId}` 
    };
  }
  
  const existing = getObjectAtPosition(objects, x, y);
  if (existing) {
    return { 
      objects, 
      success: false, 
      error: `Cell (${x}, ${y}) is occupied` 
    };
  }
  
  const newObject: MapObject = {
    id: generateObjectId(),
    type: typeId,
    position: { x, y },
    size: { width: 1, height: 1 },
    label: objectType.label,
    linkedNote: null,
    alignment
  };
  
  return { 
    objects: [...objects, newObject], 
    success: true,
    object: newObject
  };
}

/**
 * Remove object(s) at the specified position.
 * - Grid maps: removes all objects at position (typically just one)
 * - Hex maps: removes one object (highest slot), reorganizes remaining slots
 */
function eraseObjectAt(
  objects: MapObject[] | null | undefined,
  x: number,
  y: number,
  mapType: MapType
): RemovalResult {
  if (!objects || !Array.isArray(objects)) {
    return { objects: [], success: false };
  }
  
  // Check if any object exists at position
  const existing = getObjectAtPosition(objects, x, y);
  if (!existing) {
    return { objects, success: false };
  }
  
  if (mapType === 'hex') {
    // Hex: remove one object (highest slot), reorganize remaining
    const newObjects = removeOneObjectFromHex(objects, x, y);
    // Find what was removed by comparing arrays
    const removed = objects.find(o => !newObjects.some(n => n.id === o.id));
    return { 
      objects: newObjects, 
      success: true,
      removed
    };
  }
  
  // Grid: remove all objects at position
  const newObjects = removeObjectAtPosition(objects, x, y);
  return { 
    objects: newObjects, 
    success: true,
    removed: existing
  };
}

/**
 * Check if an object can be placed at the specified position.
 */
function canPlaceObjectAt(
  objects: MapObject[] | null | undefined,
  x: number,
  y: number,
  mapType: MapType
): boolean {
  if (mapType === 'hex') {
    return canAddObjectToCell(objects as MapObject[], x, y);
  }
  // Grid: check if cell is empty
  return getObjectAtPosition(objects, x, y) === null;
}

// ===========================================
// Exports
// ===========================================

return { 
  // Core operations
  getObjectType,
  generateObjectId,
  getObjectAtPosition,
  updateObject,
  isAreaFree,
  canResizeObject,
  
  // Grid-specific operations (legacy, prefer unified API)
  addObject,
  removeObject,
  removeObjectAtPosition,
  removeObjectsInRectangle,
  calculateEdgeAlignment,
  getAlignmentOffset,
  
  // Hex-specific operations (internal, prefer unified API)
  addObjectToHex,
  removeObjectFromHex,
  removeOneObjectFromHex,
  
  // Unified API (preferred for new code)
  placeObject,
  eraseObjectAt,
  canPlaceObjectAt
};
```

# badgeRenderer

```ts
/**
 * Badge Renderer Module
 *
 * Renders indicator badges on map objects:
 * - Note link badge (linked to Obsidian note)
 * - Custom tooltip indicator
 * - Object link indicator (inter-object linking)
 *
 * All functions are pure - they draw to the provided canvas context
 * without side effects.
 */

interface BadgePosition {
  screenX: number;
  screenY: number;
  objectWidth: number;
  objectHeight: number;
}

interface BadgeConfig {
  scaledSize: number;
}

/**
 * Renders a note link badge in the top-right corner of an object.
 * Shows a blue circle with a scroll emoji for objects linked to notes.
 */
function renderNoteLinkBadge(
  ctx: CanvasRenderingContext2D,
  position: BadgePosition,
  config: BadgeConfig
): void {
  const { screenX, screenY, objectWidth, objectHeight } = position;
  const { scaledSize } = config;

  const maxBadgeSize = Math.min(objectWidth, objectHeight) * 0.3;
  const badgeSize = Math.min(maxBadgeSize, Math.max(8, scaledSize * 0.25));
  const badgeX = screenX + objectWidth - badgeSize - 3;
  const badgeY = screenY + 3;

  ctx.fillStyle = 'rgba(74, 158, 255, 0.9)';
  ctx.beginPath();
  ctx.arc(badgeX + badgeSize / 2, badgeY + badgeSize / 2, badgeSize / 2, 0, Math.PI * 2);
  ctx.fill();

  const badgeFontSize = badgeSize * 0.7;
  ctx.font = `${badgeFontSize}px 'Noto Emoji', 'Noto Sans Symbols 2', monospace`;
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('\u{1F4DC}', badgeX + badgeSize / 2, badgeY + badgeSize / 2);
}

/**
 * Renders a custom tooltip indicator in the bottom-right corner.
 * Shows a small blue dot with white border for objects with custom tooltips.
 */
function renderTooltipIndicator(
  ctx: CanvasRenderingContext2D,
  position: BadgePosition,
  config: BadgeConfig
): void {
  const { screenX, screenY, objectWidth, objectHeight } = position;
  const { scaledSize } = config;

  const indicatorSize = Math.max(4, scaledSize * 0.12);
  const indicatorX = screenX + objectWidth - indicatorSize - 2;
  const indicatorY = screenY + objectHeight - indicatorSize - 2;

  ctx.fillStyle = '#4a9eff';
  ctx.beginPath();
  ctx.arc(indicatorX + indicatorSize / 2, indicatorY + indicatorSize / 2, indicatorSize / 2, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 1;
  ctx.stroke();
}

/**
 * Renders an object link indicator in the top-left corner.
 * Shows a green circle with chain link emoji for inter-object links.
 */
function renderObjectLinkIndicator(
  ctx: CanvasRenderingContext2D,
  position: BadgePosition,
  config: BadgeConfig
): void {
  const { screenX, screenY } = position;
  const { scaledSize } = config;

  const linkSize = Math.max(6, scaledSize * 0.15);
  const linkX = screenX + 2;
  const linkY = screenY + 2;

  ctx.fillStyle = '#10b981';
  ctx.beginPath();
  ctx.arc(linkX + linkSize / 2, linkY + linkSize / 2, linkSize / 2, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Draw chain link icon
  const iconSize = linkSize * 0.6;
  ctx.font = `${iconSize}px 'Noto Emoji', 'Noto Sans Symbols 2', monospace`;
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('\u{1F517}', linkX + linkSize / 2, linkY + linkSize / 2);
}

return {
  renderNoteLinkBadge,
  renderTooltipIndicator,
  renderObjectLinkIndicator
};

```

# textLabelRenderer

```ts
/**
 * Text Label Renderer Module
 *
 * Renders text labels on the map canvas with rotation support,
 * stroke outline for readability, and customizable fonts.
 */

import type { TextLabel } from '#types/objects/note.types';

interface TextLabelRenderContext {
  ctx: CanvasRenderingContext2D;
  zoom: number;
  getFontCss: (fontFace: string) => string;
}

interface ScreenPosition {
  screenX: number;
  screenY: number;
}

/**
 * Renders a single text label at the given screen position.
 * Handles rotation, font styling, and stroke outline for readability.
 */
function renderTextLabel(
  label: TextLabel,
  position: ScreenPosition,
  context: TextLabelRenderContext
): void {
  const { ctx, zoom, getFontCss } = context;
  const { screenX, screenY } = position;

  ctx.save();

  ctx.translate(screenX, screenY);
  ctx.rotate(((label.rotation || 0) * Math.PI) / 180);

  const fontSize = label.fontSize * zoom;
  const fontFamily = getFontCss(label.fontFace || 'sans');
  ctx.font = `${fontSize}px ${fontFamily}`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Draw stroke outline for readability
  ctx.strokeStyle = '#000000';
  ctx.lineWidth = 3;
  ctx.lineJoin = 'round';
  ctx.strokeText(label.content, 0, 0);

  // Draw fill
  ctx.fillStyle = label.color || '#ffffff';
  ctx.fillText(label.content, 0, 0);

  ctx.restore();
}

/**
 * Renders all text labels for a layer.
 * Skips rendering if showCoordinates is enabled or textLabels visibility is off.
 */
function renderTextLabels(
  labels: TextLabel[],
  context: TextLabelRenderContext,
  geometry: { worldToScreen: (x: number, y: number, offsetX: number, offsetY: number, zoom: number) => ScreenPosition },
  viewState: { offsetX: number; offsetY: number; zoom: number }
): void {
  const { offsetX, offsetY, zoom } = viewState;

  for (const label of labels) {
    const position = geometry.worldToScreen(
      label.position.x,
      label.position.y,
      offsetX,
      offsetY,
      zoom
    );
    renderTextLabel(label, position, context);
  }
}

return {
  renderTextLabel,
  renderTextLabels
};

```

# backgroundRenderer

```ts
/**
 * Background Renderer Module
 *
 * Renders background images for hex maps, handling proper positioning,
 * scaling, and opacity based on hex grid bounds.
 */

interface HexBounds {
  maxCol: number;
  maxRow: number;
}

interface BackgroundImageConfig {
  path: string;
  offsetX?: number;
  offsetY?: number;
  opacity?: number;
}

interface HexGeometryLike {
  hexSize: number;
  sqrt3: number;
  hexToWorld: (q: number, r: number) => { worldX: number; worldY: number };
}

interface RenderBackgroundContext {
  ctx: CanvasRenderingContext2D;
  offsetX: number;
  offsetY: number;
  zoom: number;
}

/**
 * Renders a background image for a hex map.
 * Centers the image based on hex grid bounds and applies offset/opacity settings.
 *
 * @param bgImage - The loaded HTMLImageElement
 * @param config - Background image configuration (path, offsets, opacity)
 * @param hexBounds - The hex grid bounds (maxCol, maxRow)
 * @param hexGeometry - The hex geometry instance
 * @param orientation - Hex orientation ('flat' or 'pointy')
 * @param context - Render context with canvas context and view state
 * @param offsetToAxial - Function to convert offset coords to axial
 */
function renderHexBackgroundImage(
  bgImage: HTMLImageElement,
  config: BackgroundImageConfig,
  hexBounds: HexBounds,
  hexGeometry: HexGeometryLike,
  orientation: string,
  context: RenderBackgroundContext,
  offsetToAxial: (col: number, row: number, orientation: string) => { q: number; r: number }
): void {
  const { ctx, offsetX, offsetY, zoom } = context;

  // Calculate world bounds from hex grid corners
  let minWorldX = Infinity, maxWorldX = -Infinity;
  let minWorldY = Infinity, maxWorldY = -Infinity;

  const corners = [
    { col: 0, row: 0 },
    { col: hexBounds.maxCol - 1, row: 0 },
    { col: 0, row: hexBounds.maxRow - 1 },
    { col: hexBounds.maxCol - 1, row: hexBounds.maxRow - 1 }
  ];

  for (const corner of corners) {
    const { q, r } = offsetToAxial(corner.col, corner.row, orientation);
    const worldPos = hexGeometry.hexToWorld(q, r);

    if (worldPos.worldX < minWorldX) minWorldX = worldPos.worldX;
    if (worldPos.worldX > maxWorldX) maxWorldX = worldPos.worldX;
    if (worldPos.worldY < minWorldY) minWorldY = worldPos.worldY;
    if (worldPos.worldY > maxWorldY) maxWorldY = worldPos.worldY;
  }

  // Add hex extent padding
  const hexExtentX = hexGeometry.hexSize;
  const hexExtentY = hexGeometry.hexSize * hexGeometry.sqrt3 / 2;

  minWorldX -= hexExtentX;
  maxWorldX += hexExtentX;
  minWorldY -= hexExtentY;
  maxWorldY += hexExtentY;

  // Calculate center of world bounds
  const worldCenterX = (minWorldX + maxWorldX) / 2;
  const worldCenterY = (minWorldY + maxWorldY) / 2;

  // Get image dimensions
  const imgWidth = bgImage.naturalWidth;
  const imgHeight = bgImage.naturalHeight;

  // Apply image offsets
  const imgOffsetX = config.offsetX ?? 0;
  const imgOffsetY = config.offsetY ?? 0;

  // Calculate screen position
  const screenCenterX = offsetX + worldCenterX * zoom;
  const screenCenterY = offsetY + worldCenterY * zoom;
  const screenX = screenCenterX - (imgWidth * zoom) / 2 + (imgOffsetX * zoom);
  const screenY = screenCenterY - (imgHeight * zoom) / 2 + (imgOffsetY * zoom);

  // Apply opacity if needed
  const opacity = config.opacity ?? 1;
  if (opacity < 1) {
    ctx.save();
    ctx.globalAlpha = opacity;
  }

  // Draw the background image
  ctx.drawImage(bgImage, screenX, screenY, imgWidth * zoom, imgHeight * zoom);

  // Restore opacity
  if (opacity < 1) {
    ctx.restore();
  }
}

return {
  renderHexBackgroundImage
};

```

# gridFogRenderer

```ts
/**
 * Grid Fog Renderer Module
 *
 * Renders fog of war for grid (square) maps with optional blur effects.
 * Handles edge cell detection, multi-pass blur rendering, and interior grid lines.
 */

interface FogCell {
  col: number;
  row: number;
}

interface GridFogRenderContext {
  ctx: CanvasRenderingContext2D;
  fogCtx: CanvasRenderingContext2D | null;
  offsetX: number;
  offsetY: number;
  scaledSize: number;
}

interface GridFogRenderOptions {
  fowOpacity: number;
  fowBlurEnabled: boolean;
  blurRadius: number;
  useGlobalAlpha: boolean;
}

/**
 * Identifies which fog cells are edge cells (adjacent to non-fogged cells).
 */
function identifyEdgeCells(
  fogCells: FogCell[],
  foggedSet: Set<string>,
  visibleBounds: { minCol: number; maxCol: number; minRow: number; maxRow: number }
): { visibleFogCells: FogCell[]; edgeCells: FogCell[] } {
  const { minCol, maxCol, minRow, maxRow } = visibleBounds;
  const visibleFogCells: FogCell[] = [];
  const edgeCells: FogCell[] = [];

  for (const fogCell of fogCells) {
    const { col, row } = fogCell;

    // Skip cells outside visible bounds
    if (col < minCol || col > maxCol || row < minRow || row > maxRow) {
      continue;
    }

    visibleFogCells.push({ col, row });

    // Check if this is an edge cell (has at least one non-fogged neighbor)
    const isEdge = !foggedSet.has(`${col - 1},${row}`) ||
                   !foggedSet.has(`${col + 1},${row}`) ||
                   !foggedSet.has(`${col},${row - 1}`) ||
                   !foggedSet.has(`${col},${row + 1}`);

    if (isEdge) {
      edgeCells.push({ col, row });
    }
  }

  return { visibleFogCells, edgeCells };
}

/**
 * Renders blur passes for edge cells (the soft fog edge effect).
 */
function renderBlurPasses(
  edgeCells: FogCell[],
  context: GridFogRenderContext,
  options: GridFogRenderOptions
): void {
  const { ctx, fogCtx, offsetX, offsetY, scaledSize } = context;
  const { fowOpacity, blurRadius } = options;

  if (edgeCells.length === 0 || blurRadius <= 0) return;

  const baseOpacity = fowOpacity;
  const numPasses = 8;
  const cellRadius = scaledSize / 2;
  const maxRadius = cellRadius + blurRadius;

  const targetCtx = fogCtx || ctx;
  const useFilterFallback = !fogCtx;
  const filterBlurAmount = blurRadius / numPasses;

  for (let i = 0; i < numPasses; i++) {
    const t = i / (numPasses - 1);
    const radius = maxRadius - (blurRadius * t);
    const opacity = 0.50 + (0.30 * t);

    if (useFilterFallback) {
      const passBlur = filterBlurAmount * (1.5 - t);
      targetCtx.filter = passBlur > 0.5 ? `blur(${passBlur}px)` : 'none';
    }

    targetCtx.beginPath();
    for (const { col, row } of edgeCells) {
      const centerX = offsetX + col * scaledSize + scaledSize / 2;
      const centerY = offsetY + row * scaledSize + scaledSize / 2;
      targetCtx.moveTo(centerX + radius, centerY);
      targetCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    }
    targetCtx.globalAlpha = baseOpacity * opacity;
    targetCtx.fill();
  }

  if (useFilterFallback) {
    ctx.filter = 'none';
  }
}

/**
 * Renders the solid fog rectangles for all visible fog cells.
 */
function renderFogCells(
  visibleFogCells: FogCell[],
  context: GridFogRenderContext
): void {
  const { ctx, offsetX, offsetY, scaledSize } = context;

  ctx.beginPath();
  for (const { col, row } of visibleFogCells) {
    const centerX = offsetX + col * scaledSize + scaledSize / 2;
    const centerY = offsetY + row * scaledSize + scaledSize / 2;
    const halfSize = scaledSize / 2;
    ctx.rect(centerX - halfSize, centerY - halfSize, scaledSize, scaledSize);
  }
  ctx.fill();
}

/**
 * Renders subtle interior grid lines between adjacent fog cells.
 */
function renderInteriorGridLines(
  visibleFogCells: FogCell[],
  foggedSet: Set<string>,
  context: GridFogRenderContext,
  zoom: number
): void {
  const { ctx, offsetX, offsetY, scaledSize } = context;

  if (visibleFogCells.length <= 1) return;

  const drawnLines = new Set<string>();
  const interiorLineWidth = Math.max(1, 1 * zoom * 0.5);
  const halfWidth = interiorLineWidth / 2;

  ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';

  for (const { col, row } of visibleFogCells) {
    const screenX = offsetX + col * scaledSize;
    const screenY = offsetY + row * scaledSize;

    // Right edge (vertical line)
    if (foggedSet.has(`${col + 1},${row}`)) {
      const lineKey = `v:${col + 1},${row}`;
      if (!drawnLines.has(lineKey)) {
        ctx.fillRect(screenX + scaledSize - halfWidth, screenY, interiorLineWidth, scaledSize);
        drawnLines.add(lineKey);
      }
    }

    // Bottom edge (horizontal line)
    if (foggedSet.has(`${col},${row + 1}`)) {
      const lineKey = `h:${col},${row + 1}`;
      if (!drawnLines.has(lineKey)) {
        ctx.fillRect(screenX, screenY + scaledSize - halfWidth, scaledSize, interiorLineWidth);
        drawnLines.add(lineKey);
      }
    }
  }
}

/**
 * Main entry point for rendering grid fog of war.
 * Orchestrates edge detection, blur passes, solid fog, and interior lines.
 */
function renderGridFog(
  fogCells: FogCell[],
  context: GridFogRenderContext,
  options: GridFogRenderOptions,
  visibleBounds: { minCol: number; maxCol: number; minRow: number; maxRow: number },
  zoom: number
): void {
  const foggedSet = new Set(fogCells.map(c => `${c.col},${c.row}`));

  // Identify visible and edge cells
  const { visibleFogCells, edgeCells } = identifyEdgeCells(
    fogCells,
    foggedSet,
    visibleBounds
  );

  // Render blur passes for edge cells
  if (options.fowBlurEnabled && options.blurRadius > 0) {
    renderBlurPasses(edgeCells, context, options);
    context.ctx.globalAlpha = options.useGlobalAlpha ? options.fowOpacity : 1;
  }

  // Render solid fog cells
  renderFogCells(visibleFogCells, context);

  // Render interior grid lines
  renderInteriorGridLines(visibleFogCells, foggedSet, context, zoom);
}

return {
  identifyEdgeCells,
  renderBlurPasses,
  renderFogCells,
  renderInteriorGridLines,
  renderGridFog
};

```

# hexFogRenderer

```ts
/**
 * Hex Fog Renderer Module
 *
 * Renders fog of war for hex maps with optional blur effects.
 * Handles edge cell detection, multi-pass blur rendering, and interior hex outlines.
 */

interface FogCell {
  col: number;
  row: number;
}

interface EdgeCell extends FogCell {
  q: number;
  r: number;
}

interface HexGeometryLike {
  hexSize: number;
  getHexVertices: (q: number, r: number) => Array<{ worldX: number; worldY: number }>;
  hexToWorld: (q: number, r: number) => { worldX: number; worldY: number };
  getNeighbors: (q: number, r: number) => Array<{ q: number; r: number }>;
}

interface GeometryLike {
  worldToScreen: (worldX: number, worldY: number, offsetX: number, offsetY: number, zoom: number) => { screenX: number; screenY: number };
}

interface HexFogRenderContext {
  ctx: CanvasRenderingContext2D;
  fogCtx: CanvasRenderingContext2D | null;
  offsetX: number;
  offsetY: number;
  zoom: number;
}

interface HexFogRenderOptions {
  fowOpacity: number;
  fowBlurEnabled: boolean;
  blurRadius: number;
  useGlobalAlpha: boolean;
}

/**
 * Identifies which fog cells are edge cells (adjacent to non-fogged cells).
 */
function identifyHexEdgeCells(
  fogCells: FogCell[],
  foggedSet: Set<string>,
  visibleBounds: { minCol: number; maxCol: number; minRow: number; maxRow: number },
  hexGeometry: HexGeometryLike,
  orientation: string,
  offsetToAxial: (col: number, row: number, orientation: string) => { q: number; r: number },
  axialToOffset: (q: number, r: number, orientation: string) => { col: number; row: number }
): { visibleFogCells: FogCell[]; edgeCells: EdgeCell[] } {
  const { minCol, maxCol, minRow, maxRow } = visibleBounds;
  const visibleFogCells: FogCell[] = [];
  const edgeCells: EdgeCell[] = [];

  for (const fogCell of fogCells) {
    const { col, row } = fogCell;

    // Skip cells outside visible bounds
    if (col < minCol || col > maxCol || row < minRow || row > maxRow) {
      continue;
    }

    visibleFogCells.push({ col, row });

    // Check if this is an edge cell (has at least one non-fogged neighbor)
    const { q, r } = offsetToAxial(col, row, orientation);
    const neighbors = hexGeometry.getNeighbors(q, r);
    const isEdge = neighbors.some(n => {
      const { col: nCol, row: nRow } = axialToOffset(n.q, n.r, orientation);
      return !foggedSet.has(`${nCol},${nRow}`);
    });

    if (isEdge) {
      edgeCells.push({ col, row, q, r });
    }
  }

  return { visibleFogCells, edgeCells };
}

/**
 * Traces a hex path on the given canvas context.
 */
function traceHexPath(
  ctx: CanvasRenderingContext2D,
  q: number,
  r: number,
  scale: number,
  hexGeometry: HexGeometryLike,
  geometry: GeometryLike,
  context: { offsetX: number; offsetY: number; zoom: number }
): void {
  const { offsetX, offsetY, zoom } = context;
  const vertices = hexGeometry.getHexVertices(q, r);

  if (scale === 1.0) {
    const first = geometry.worldToScreen(vertices[0].worldX, vertices[0].worldY, offsetX, offsetY, zoom);
    ctx.moveTo(first.screenX, first.screenY);
    for (let i = 1; i < vertices.length; i++) {
      const vertex = geometry.worldToScreen(vertices[i].worldX, vertices[i].worldY, offsetX, offsetY, zoom);
      ctx.lineTo(vertex.screenX, vertex.screenY);
    }
  } else {
    const center = hexGeometry.hexToWorld(q, r);
    const screenCenter = geometry.worldToScreen(center.worldX, center.worldY, offsetX, offsetY, zoom);

    const scaledVertices = vertices.map(v => {
      const screen = geometry.worldToScreen(v.worldX, v.worldY, offsetX, offsetY, zoom);
      return {
        screenX: screenCenter.screenX + (screen.screenX - screenCenter.screenX) * scale,
        screenY: screenCenter.screenY + (screen.screenY - screenCenter.screenY) * scale
      };
    });

    ctx.moveTo(scaledVertices[0].screenX, scaledVertices[0].screenY);
    for (let i = 1; i < scaledVertices.length; i++) {
      ctx.lineTo(scaledVertices[i].screenX, scaledVertices[i].screenY);
    }
  }
  ctx.closePath();
}

/**
 * Renders blur passes for edge cells (the soft fog edge effect).
 */
function renderHexBlurPasses(
  edgeCells: EdgeCell[],
  context: HexFogRenderContext,
  options: HexFogRenderOptions,
  hexGeometry: HexGeometryLike,
  geometry: GeometryLike
): void {
  const { ctx, fogCtx, offsetX, offsetY, zoom } = context;
  const { fowOpacity, blurRadius } = options;

  if (edgeCells.length === 0 || blurRadius <= 0) return;

  const baseOpacity = fowOpacity;
  const numPasses = 8;
  const maxExpansion = blurRadius / (hexGeometry.hexSize * zoom);

  const targetCtx = fogCtx || ctx;
  const useFilterFallback = !fogCtx;
  const filterBlurAmount = blurRadius / numPasses;

  for (let i = 0; i < numPasses; i++) {
    const t = i / (numPasses - 1);
    const scale = 1.0 + (maxExpansion * (1.0 - t));
    const opacity = 0.50 + (0.30 * t);

    if (useFilterFallback) {
      const passBlur = filterBlurAmount * (1.5 - t);
      targetCtx.filter = passBlur > 0.5 ? `blur(${passBlur}px)` : 'none';
    }

    targetCtx.beginPath();
    for (const { q, r } of edgeCells) {
      traceHexPath(targetCtx, q, r, scale, hexGeometry, geometry, { offsetX, offsetY, zoom });
    }
    targetCtx.globalAlpha = baseOpacity * opacity;
    targetCtx.fill();
  }

  if (useFilterFallback) {
    ctx.filter = 'none';
  }
}

/**
 * Renders the solid fog hexes for all visible fog cells.
 */
function renderHexFogCells(
  visibleFogCells: FogCell[],
  context: HexFogRenderContext,
  hexGeometry: HexGeometryLike,
  geometry: GeometryLike,
  orientation: string,
  offsetToAxial: (col: number, row: number, orientation: string) => { q: number; r: number }
): void {
  const { ctx, offsetX, offsetY, zoom } = context;

  ctx.beginPath();
  for (const { col, row } of visibleFogCells) {
    const { q, r } = offsetToAxial(col, row, orientation);
    traceHexPath(ctx, q, r, 1.0, hexGeometry, geometry, { offsetX, offsetY, zoom });
  }
  ctx.fill();
}

/**
 * Renders subtle interior hex outlines between adjacent fog cells.
 */
function renderInteriorHexOutlines(
  visibleFogCells: FogCell[],
  foggedSet: Set<string>,
  context: HexFogRenderContext,
  hexGeometry: HexGeometryLike,
  geometry: GeometryLike,
  orientation: string,
  offsetToAxial: (col: number, row: number, orientation: string) => { q: number; r: number },
  axialToOffset: (q: number, r: number, orientation: string) => { col: number; row: number }
): void {
  const { ctx, offsetX, offsetY, zoom } = context;

  if (visibleFogCells.length <= 1) return;

  ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
  ctx.lineWidth = Math.max(1, 1 * zoom);

  for (const { col, row } of visibleFogCells) {
    const { q, r } = offsetToAxial(col, row, orientation);

    const neighbors = hexGeometry.getNeighbors(q, r);
    const hasFoggedNeighbor = neighbors.some(n => {
      const { col: nCol, row: nRow } = axialToOffset(n.q, n.r, orientation);
      return foggedSet.has(`${nCol},${nRow}`);
    });

    if (hasFoggedNeighbor) {
      const vertices = hexGeometry.getHexVertices(q, r);

      ctx.beginPath();
      const first = geometry.worldToScreen(vertices[0].worldX, vertices[0].worldY, offsetX, offsetY, zoom);
      ctx.moveTo(first.screenX, first.screenY);

      for (let i = 1; i < vertices.length; i++) {
        const vertex = geometry.worldToScreen(vertices[i].worldX, vertices[i].worldY, offsetX, offsetY, zoom);
        ctx.lineTo(vertex.screenX, vertex.screenY);
      }

      ctx.closePath();
      ctx.stroke();
    }
  }
}

/**
 * Main entry point for rendering hex fog of war.
 * Orchestrates edge detection, blur passes, solid fog, and interior outlines.
 */
function renderHexFog(
  fogCells: FogCell[],
  context: HexFogRenderContext,
  options: HexFogRenderOptions,
  visibleBounds: { minCol: number; maxCol: number; minRow: number; maxRow: number },
  hexGeometry: HexGeometryLike,
  geometry: GeometryLike,
  orientation: string,
  offsetToAxial: (col: number, row: number, orientation: string) => { q: number; r: number },
  axialToOffset: (q: number, r: number, orientation: string) => { col: number; row: number }
): void {
  const foggedSet = new Set(fogCells.map(c => `${c.col},${c.row}`));

  // Identify visible and edge cells
  const { visibleFogCells, edgeCells } = identifyHexEdgeCells(
    fogCells,
    foggedSet,
    visibleBounds,
    hexGeometry,
    orientation,
    offsetToAxial,
    axialToOffset
  );

  // Render blur passes for edge cells
  if (options.fowBlurEnabled && options.blurRadius > 0) {
    renderHexBlurPasses(edgeCells, context, options, hexGeometry, geometry);
    context.ctx.globalAlpha = options.useGlobalAlpha ? options.fowOpacity : 1;
  }

  // Render solid fog cells
  renderHexFogCells(visibleFogCells, context, hexGeometry, geometry, orientation, offsetToAxial);

  // Render interior hex outlines
  renderInteriorHexOutlines(
    visibleFogCells,
    foggedSet,
    context,
    hexGeometry,
    geometry,
    orientation,
    offsetToAxial,
    axialToOffset
  );
}

return {
  identifyHexEdgeCells,
  traceHexPath,
  renderHexBlurPasses,
  renderHexFogCells,
  renderInteriorHexOutlines,
  renderHexFog
};

```

# fogRenderer

```ts
/**
 * Fog Renderer Module (Orchestrator)
 *
 * Orchestrates fog of war rendering for both hex and grid maps.
 * Handles fog settings, fill style setup, blur configuration, and dispatches
 * to the appropriate grid or hex fog renderer.
 */

interface FogCell {
  col: number;
  row: number;
}

interface FogOfWar {
  enabled: boolean;
  foggedCells?: FogCell[];
}

interface FogSettings {
  fowColor: string;
  fowOpacity: number;
  fowImagePath?: string;
  fowBlurEnabled: boolean;
  fowBlurFactor: number;
}

interface FogRenderContext {
  ctx: CanvasRenderingContext2D;
  fogCanvas: HTMLCanvasElement | null;
  width: number;
  height: number;
  offsetX: number;
  offsetY: number;
  zoom: number;
  scaledSize: number;
  northDirection: number;
}

interface GridGeometryLike {
  cellSize: number;
}

interface HexGeometryLike {
  hexSize: number;
  getHexVertices: (q: number, r: number) => Array<{ worldX: number; worldY: number }>;
  hexToWorld: (q: number, r: number) => { worldX: number; worldY: number };
  getNeighbors: (q: number, r: number) => Array<{ q: number; r: number }>;
}

interface GeometryLike {
  worldToScreen: (worldX: number, worldY: number, offsetX: number, offsetY: number, zoom: number) => { screenX: number; screenY: number };
}

interface MapBounds {
  hexBounds?: { maxCol: number; maxRow: number };
  dimensions?: { width: number; height: number };
}

type RenderGridFogFn = (
  fogCells: FogCell[],
  context: { ctx: CanvasRenderingContext2D; fogCtx: CanvasRenderingContext2D | null; offsetX: number; offsetY: number; scaledSize: number },
  options: { fowOpacity: number; fowBlurEnabled: boolean; blurRadius: number; useGlobalAlpha: boolean },
  visibleBounds: { minCol: number; maxCol: number; minRow: number; maxRow: number },
  zoom: number
) => void;

type RenderHexFogFn = (
  fogCells: FogCell[],
  context: { ctx: CanvasRenderingContext2D; fogCtx: CanvasRenderingContext2D | null; offsetX: number; offsetY: number; zoom: number },
  options: { fowOpacity: number; fowBlurEnabled: boolean; blurRadius: number; useGlobalAlpha: boolean },
  visibleBounds: { minCol: number; maxCol: number; minRow: number; maxRow: number },
  hexGeometry: HexGeometryLike,
  geometry: GeometryLike,
  orientation: string,
  offsetToAxial: (col: number, row: number, orientation: string) => { q: number; r: number },
  axialToOffset: (q: number, r: number, orientation: string) => { col: number; row: number }
) => void;

/**
 * Extracts fog settings from effective settings object.
 */
function getFogSettings(effectiveSettings: Record<string, unknown>): FogSettings {
  return {
    fowColor: (effectiveSettings.fogOfWarColor as string) || '#000000',
    fowOpacity: (effectiveSettings.fogOfWarOpacity as number) ?? 0.9,
    fowImagePath: effectiveSettings.fogOfWarImage as string | undefined,
    fowBlurEnabled: (effectiveSettings.fogOfWarBlurEnabled as boolean) ?? false,
    fowBlurFactor: (effectiveSettings.fogOfWarBlurFactor as number) ?? 0.08,
  };
}

/**
 * Creates fog fill style - either solid color or image pattern.
 */
function createFogFillStyle(
  ctx: CanvasRenderingContext2D,
  fowColor: string,
  fowImagePath: string | undefined,
  getCachedImage: (path: string) => HTMLImageElement | null
): { fillStyle: string | CanvasPattern; useGlobalAlpha: boolean } {
  let fillStyle: string | CanvasPattern = fowColor;
  const useGlobalAlpha = true;

  if (fowImagePath) {
    const fowImage = getCachedImage(fowImagePath);
    if (fowImage && fowImage.complete && fowImage.naturalWidth > 0) {
      try {
        const pattern = ctx.createPattern(fowImage, 'repeat');
        if (pattern) {
          fillStyle = pattern;
        }
      } catch (_e) {
        // Pattern creation failed, use solid color
      }
    }
  }

  return { fillStyle, useGlobalAlpha };
}

/**
 * Calculates blur radius based on cell size and blur factor.
 */
function calculateBlurRadius(
  fowBlurEnabled: boolean,
  fowBlurFactor: number,
  cellSize: number,
  zoom: number
): number {
  if (!fowBlurEnabled) return 0;
  return cellSize * fowBlurFactor * zoom;
}

/**
 * Sets up the fog canvas for blur effects.
 * Returns the fog context if blur is enabled and canvas is available.
 */
function setupFogCanvas(
  fogCanvas: HTMLCanvasElement | null,
  fowBlurEnabled: boolean,
  blurRadius: number,
  width: number,
  height: number,
  northDirection: number,
  fowColor: string,
  fowImagePath: string | undefined,
  getCachedImage: (path: string) => HTMLImageElement | null
): CanvasRenderingContext2D | null {
  if (!fogCanvas || !fowBlurEnabled || blurRadius <= 0) return null;

  const fogCtx = fogCanvas.getContext('2d');
  if (!fogCtx) return null;

  if (fogCanvas.width !== width || fogCanvas.height !== height) {
    fogCanvas.width = width;
    fogCanvas.height = height;
  }

  const cssBlurAmount = Math.max(4, blurRadius * 0.6);
  fogCanvas.style.filter = `blur(${cssBlurAmount}px)`;

  fogCtx.clearRect(0, 0, width, height);

  fogCtx.save();
  fogCtx.translate(width / 2, height / 2);
  fogCtx.rotate((northDirection * Math.PI) / 180);
  fogCtx.translate(-width / 2, -height / 2);

  fogCtx.fillStyle = fowColor;

  if (fowImagePath) {
    const fowImage = getCachedImage(fowImagePath);
    if (fowImage && fowImage.complete && fowImage.naturalWidth > 0) {
      const fogPattern = fogCtx.createPattern(fowImage, 'repeat');
      if (fogPattern) {
        fogCtx.fillStyle = fogPattern;
      }
    }
  }

  return fogCtx;
}

/**
 * Calculates visible bounds for grid maps.
 */
function calculateGridVisibleBounds(
  width: number,
  height: number,
  offsetX: number,
  offsetY: number,
  scaledSize: number,
  dimensions?: { width: number; height: number }
): { minCol: number; maxCol: number; minRow: number; maxRow: number } {
  let visibleMinCol = Math.floor((0 - offsetX) / scaledSize) - 1;
  let visibleMaxCol = Math.ceil((width - offsetX) / scaledSize) + 1;
  let visibleMinRow = Math.floor((0 - offsetY) / scaledSize) - 1;
  let visibleMaxRow = Math.ceil((height - offsetY) / scaledSize) + 1;

  const maxBound = dimensions ? Math.max(dimensions.width, dimensions.height) : 200;
  visibleMinCol = Math.max(0, visibleMinCol);
  visibleMaxCol = Math.min(maxBound, visibleMaxCol);
  visibleMinRow = Math.max(0, visibleMinRow);
  visibleMaxRow = Math.min(maxBound, visibleMaxRow);

  return { minCol: visibleMinCol, maxCol: visibleMaxCol, minRow: visibleMinRow, maxRow: visibleMaxRow };
}

/**
 * Calculates visible bounds for hex maps.
 */
function calculateHexVisibleBounds(
  hexBounds?: { maxCol: number; maxRow: number }
): { minCol: number; maxCol: number; minRow: number; maxRow: number } {
  const bounds = hexBounds || { maxCol: 100, maxRow: 100 };
  return {
    minCol: 0,
    maxCol: bounds.maxCol,
    minRow: 0,
    maxRow: bounds.maxRow,
  };
}

/**
 * Main entry point for rendering fog of war.
 * Handles all setup and dispatches to the appropriate renderer.
 */
function renderFog(
  fow: FogOfWar,
  context: FogRenderContext,
  settings: FogSettings,
  mapBounds: MapBounds,
  isHexMap: boolean,
  hexGeometry: HexGeometryLike | null,
  gridGeometry: GridGeometryLike | null,
  geometry: GeometryLike,
  orientation: string,
  getCachedImage: (path: string) => HTMLImageElement | null,
  renderGridFog: RenderGridFogFn,
  renderHexFog: RenderHexFogFn,
  offsetToAxial: (col: number, row: number, orientation: string) => { q: number; r: number },
  axialToOffset: (q: number, r: number, orientation: string) => { col: number; row: number }
): void {
  if (!fow.enabled || !fow.foggedCells?.length) return;

  const { ctx, fogCanvas, width, height, offsetX, offsetY, zoom, scaledSize, northDirection } = context;
  const { fowColor, fowOpacity, fowImagePath, fowBlurEnabled, fowBlurFactor } = settings;

  // Create fill style
  const { fillStyle, useGlobalAlpha } = createFogFillStyle(ctx, fowColor, fowImagePath, getCachedImage);

  // Calculate blur radius
  const cellSize = isHexMap && hexGeometry ? hexGeometry.hexSize : (gridGeometry?.cellSize ?? 32);
  const blurRadius = calculateBlurRadius(fowBlurEnabled, fowBlurFactor, cellSize, zoom);

  // Setup fog canvas for blur
  const fogCtx = setupFogCanvas(
    fogCanvas,
    fowBlurEnabled,
    blurRadius,
    width,
    height,
    northDirection,
    fowColor,
    fowImagePath,
    getCachedImage
  );

  // Set main context fill style
  ctx.fillStyle = fillStyle;

  const previousGlobalAlpha = ctx.globalAlpha;
  if (useGlobalAlpha) {
    ctx.globalAlpha = fowOpacity;
  }

  // Calculate visible bounds and render
  if (isHexMap && hexGeometry) {
    const visibleBounds = calculateHexVisibleBounds(mapBounds.hexBounds);

    renderHexFog(
      fow.foggedCells,
      { ctx, fogCtx, offsetX, offsetY, zoom },
      { fowOpacity, fowBlurEnabled, blurRadius, useGlobalAlpha },
      visibleBounds,
      hexGeometry,
      geometry,
      orientation,
      offsetToAxial,
      axialToOffset
    );
  } else {
    const visibleBounds = calculateGridVisibleBounds(width, height, offsetX, offsetY, scaledSize, mapBounds.dimensions);

    renderGridFog(
      fow.foggedCells,
      { ctx, fogCtx, offsetX, offsetY, scaledSize },
      { fowOpacity, fowBlurEnabled, blurRadius, useGlobalAlpha },
      visibleBounds,
      zoom
    );
  }

  // Cleanup
  if (fogCtx) {
    fogCtx.restore();
  }

  if (useGlobalAlpha) {
    ctx.globalAlpha = previousGlobalAlpha;
  }
}

/**
 * Clears the fog canvas when fog is disabled or not needed.
 */
function clearFogCanvas(fogCanvas: HTMLCanvasElement | null): void {
  if (!fogCanvas) return;

  const fogCtx = fogCanvas.getContext('2d');
  if (fogCtx) {
    fogCtx.clearRect(0, 0, fogCanvas.width, fogCanvas.height);
    fogCanvas.style.filter = 'none';
  }
}

return {
  getFogSettings,
  createFogFillStyle,
  calculateBlurRadius,
  setupFogCanvas,
  calculateGridVisibleBounds,
  calculateHexVisibleBounds,
  clearFogCanvas,
  renderFog,
};

```

# objectRenderer

```ts
/**
 * Object Renderer Module
 *
 * Renders map objects (icons, characters, tokens) on the canvas.
 * Handles fog visibility, multi-object hex slots, rotation, and badge indicators.
 */

interface MapObject {
  id: string;
  type: string;
  position: { x: number; y: number };
  size?: { width: number; height: number };
  color?: string;
  rotation?: number;
  scale?: number;
  alignment?: 'center' | 'north' | 'south' | 'east' | 'west';
  slot?: number;
  linkedNote?: string;
  customTooltip?: string;
  linkedObject?: string;
}

interface ObjectTypeDef {
  id: string;
  char?: string;
  icon?: string;
}

interface MapLayer {
  objects: MapObject[];
  fogOfWar?: {
    enabled: boolean;
  };
}

interface GeometryLike {
  toOffsetCoords: (x: number, y: number) => { col: number; row: number };
  gridToScreen: (x: number, y: number, offsetX: number, offsetY: number, zoom: number) => { screenX: number; screenY: number };
}

interface ObjectRenderContext {
  ctx: CanvasRenderingContext2D;
  offsetX: number;
  offsetY: number;
  zoom: number;
  scaledSize: number;
}

interface ObjectRenderDeps {
  getObjectType: (typeId: string) => ObjectTypeDef | null;
  getRenderChar: (objType: ObjectTypeDef) => { char: string; isIcon: boolean };
  isCellFogged: (layer: MapLayer, col: number, row: number) => boolean;
  getObjectsInCell: (objects: MapObject[], x: number, y: number) => MapObject[];
  getSlotOffset: (slot: number, count: number, orientation: string) => { offsetX: number; offsetY: number };
  getMultiObjectScale: (count: number) => number;
  renderNoteLinkBadge: (ctx: CanvasRenderingContext2D, position: { screenX: number; screenY: number; objectWidth: number; objectHeight: number }, config: { scaledSize: number }) => void;
  renderTooltipIndicator: (ctx: CanvasRenderingContext2D, position: { screenX: number; screenY: number; objectWidth: number; objectHeight: number }, config: { scaledSize: number }) => void;
  renderObjectLinkIndicator: (ctx: CanvasRenderingContext2D, position: { screenX: number; screenY: number; objectWidth: number; objectHeight: number }, config: { scaledSize: number }) => void;
}

/**
 * Checks if an object is hidden under fog of war.
 */
function isObjectUnderFog(
  obj: MapObject,
  layer: MapLayer,
  geometry: GeometryLike,
  isHexMap: boolean,
  isCellFogged: (layer: MapLayer, col: number, row: number) => boolean
): boolean {
  if (!layer.fogOfWar?.enabled) return false;

  const size = obj.size || { width: 1, height: 1 };
  const baseOffset = geometry.toOffsetCoords(obj.position.x, obj.position.y);

  if (isHexMap) {
    return isCellFogged(layer, baseOffset.col, baseOffset.row);
  }

  // Grid maps: check all cells the object occupies
  for (let dx = 0; dx < size.width; dx++) {
    for (let dy = 0; dy < size.height; dy++) {
      if (isCellFogged(layer, baseOffset.col + dx, baseOffset.row + dy)) {
        return true;
      }
    }
  }

  return false;
}

/**
 * Calculates object screen position, handling multi-object hex slots.
 */
function calculateObjectPosition(
  obj: MapObject,
  allObjects: MapObject[],
  geometry: GeometryLike,
  context: ObjectRenderContext,
  isHexMap: boolean,
  orientation: string,
  deps: Pick<ObjectRenderDeps, 'getObjectsInCell' | 'getSlotOffset' | 'getMultiObjectScale'>
): { screenX: number; screenY: number; objectWidth: number; objectHeight: number } {
  const { offsetX, offsetY, zoom, scaledSize } = context;
  const size = obj.size || { width: 1, height: 1 };

  let { screenX, screenY } = geometry.gridToScreen(obj.position.x, obj.position.y, offsetX, offsetY, zoom);
  let objectWidth = size.width * scaledSize;
  let objectHeight = size.height * scaledSize;

  // Multi-object support for hex maps
  if (isHexMap) {
    const cellObjects = deps.getObjectsInCell(allObjects, obj.position.x, obj.position.y);
    const objectCount = cellObjects.length;

    if (objectCount > 1) {
      const multiScale = deps.getMultiObjectScale(objectCount);
      objectWidth *= multiScale;
      objectHeight *= multiScale;

      let effectiveSlot = obj.slot;
      if (effectiveSlot === undefined || effectiveSlot === null) {
        effectiveSlot = cellObjects.findIndex(o => o.id === obj.id);
      }

      const { offsetX: slotOffsetX, offsetY: slotOffsetY } = deps.getSlotOffset(
        effectiveSlot,
        objectCount,
        orientation
      );

      const hexCenterX = screenX + scaledSize / 2;
      const hexCenterY = screenY + scaledSize / 2;
      const hexWidth = scaledSize * 2;
      const objectCenterX = hexCenterX + slotOffsetX * hexWidth;
      const objectCenterY = hexCenterY + slotOffsetY * hexWidth;

      screenX = objectCenterX - objectWidth / 2;
      screenY = objectCenterY - objectHeight / 2;
    }
  }

  // Apply alignment offset
  const alignment = obj.alignment || 'center';
  if (alignment !== 'center') {
    const halfCell = scaledSize / 2;
    switch (alignment) {
      case 'north': screenY -= halfCell; break;
      case 'south': screenY += halfCell; break;
      case 'east': screenX += halfCell; break;
      case 'west': screenX -= halfCell; break;
    }
  }

  return { screenX, screenY, objectWidth, objectHeight };
}

/**
 * Renders a single object on the canvas.
 */
function renderSingleObject(
  ctx: CanvasRenderingContext2D,
  obj: MapObject,
  objType: ObjectTypeDef,
  position: { screenX: number; screenY: number; objectWidth: number; objectHeight: number },
  scaledSize: number,
  getRenderChar: (objType: ObjectTypeDef) => { char: string; isIcon: boolean }
): void {
  const { screenX, screenY, objectWidth, objectHeight } = position;

  const centerX = screenX + objectWidth / 2;
  const centerY = screenY + objectHeight / 2;

  const objectScale = obj.scale ?? 1.0;
  const fontSize = Math.min(objectWidth, objectHeight) * 0.8 * objectScale;

  const rotation = obj.rotation || 0;
  if (rotation !== 0) {
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate((rotation * Math.PI) / 180);
    ctx.translate(-centerX, -centerY);
  }

  const { char: renderChar, isIcon } = getRenderChar(objType);

  if (isIcon) {
    ctx.font = `${fontSize}px rpgawesome`;
  } else {
    ctx.font = `${fontSize}px 'Noto Emoji', 'Noto Sans Symbols 2', monospace`;
  }

  ctx.strokeStyle = '#000000';
  ctx.lineWidth = Math.max(2, fontSize * 0.08);
  ctx.strokeText(renderChar, centerX, centerY);

  ctx.fillStyle = obj.color || '#ffffff';
  ctx.fillText(renderChar, centerX, centerY);

  if (rotation !== 0) {
    ctx.restore();
  }
}

/**
 * Renders object badge indicators (note link, tooltip, object link).
 */
function renderObjectBadges(
  ctx: CanvasRenderingContext2D,
  obj: MapObject,
  position: { screenX: number; screenY: number; objectWidth: number; objectHeight: number },
  scaledSize: number,
  deps: Pick<ObjectRenderDeps, 'renderNoteLinkBadge' | 'renderTooltipIndicator' | 'renderObjectLinkIndicator'>
): void {
  // Draw note badge if object has linkedNote
  if (obj.linkedNote && obj.type !== 'note_pin') {
    deps.renderNoteLinkBadge(ctx, position, { scaledSize });
  }

  // Draw note indicator for custom tooltip
  if (obj.customTooltip) {
    deps.renderTooltipIndicator(ctx, position, { scaledSize });
  }

  // Draw link indicator for inter-object links
  if (obj.linkedObject) {
    deps.renderObjectLinkIndicator(ctx, position, { scaledSize });
  }
}

/**
 * Main entry point for rendering all objects on the map.
 */
function renderObjects(
  layer: MapLayer,
  context: ObjectRenderContext,
  geometry: GeometryLike,
  isHexMap: boolean,
  orientation: string,
  deps: ObjectRenderDeps
): void {
  if (!layer.objects || layer.objects.length === 0) return;

  const { ctx, scaledSize } = context;

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (const obj of layer.objects) {
    const objType = deps.getObjectType(obj.type);
    if (!objType) continue;

    // Skip if under fog
    if (isObjectUnderFog(obj, layer, geometry, isHexMap, deps.isCellFogged)) {
      continue;
    }

    // Calculate position
    const position = calculateObjectPosition(
      obj,
      layer.objects,
      geometry,
      context,
      isHexMap,
      orientation,
      deps
    );

    // Render the object
    renderSingleObject(ctx, obj, objType, position, scaledSize, deps.getRenderChar);

    // Render badges
    renderObjectBadges(ctx, obj, position, scaledSize, deps);
  }
}

return {
  isObjectUnderFog,
  calculateObjectPosition,
  renderSingleObject,
  renderObjectBadges,
  renderObjects,
};

```

# selectionRenderer

```ts
/**
 * Selection Renderer Module
 *
 * Renders selection indicators for text labels and objects.
 * Handles selection rectangles, corner handles, and resize mode overlays.
 */

interface TextLabel {
  id: string;
  content: string;
  position: { x: number; y: number };
  fontSize: number;
  fontFace?: string;
  rotation?: number;
}

interface MapObject {
  id: string;
  type: string;
  position: { x: number; y: number };
  size?: { width: number; height: number };
  alignment?: 'center' | 'north' | 'south' | 'east' | 'west';
  slot?: number;
}

interface SelectedItem {
  id: string;
  type: 'text' | 'object';
}

interface GeometryLike {
  worldToScreen: (worldX: number, worldY: number, offsetX: number, offsetY: number, zoom: number) => { screenX: number; screenY: number };
  gridToScreen: (x: number, y: number, offsetX: number, offsetY: number, zoom: number) => { screenX: number; screenY: number };
}

interface HexGeometryLike {
  hexToWorld: (q: number, r: number) => { worldX: number; worldY: number };
}

interface SelectionRenderContext {
  ctx: CanvasRenderingContext2D;
  offsetX: number;
  offsetY: number;
  zoom: number;
  scaledSize: number;
}

interface SelectionRenderDeps {
  getFontCss: (fontFace: string) => string;
  getObjectsInCell: (objects: MapObject[], x: number, y: number) => MapObject[];
  getSlotOffset: (slot: number, count: number, orientation: string) => { offsetX: number; offsetY: number };
  getMultiObjectScale: (count: number) => number;
}

const SELECTION_COLOR = '#4a9eff';
const SELECTION_LINE_WIDTH = 2;
const SELECTION_DASH = [5, 3];
const HANDLE_SIZE_NORMAL = 8;
const HANDLE_SIZE_RESIZE = 14;

/**
 * Renders selection indicator for a single text label.
 */
function renderTextLabelSelection(
  ctx: CanvasRenderingContext2D,
  label: TextLabel,
  geometry: GeometryLike,
  context: SelectionRenderContext,
  getFontCss: (fontFace: string) => string
): void {
  const { offsetX, offsetY, zoom } = context;

  ctx.save();

  const { screenX, screenY } = geometry.worldToScreen(label.position.x, label.position.y, offsetX, offsetY, zoom);

  ctx.translate(screenX, screenY);
  ctx.rotate(((label.rotation || 0) * Math.PI) / 180);

  const fontSize = label.fontSize * zoom;
  const fontFamily = getFontCss(label.fontFace || 'sans');
  ctx.font = `${fontSize}px ${fontFamily}`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const metrics = ctx.measureText(label.content);
  const textWidth = metrics.width;
  const textHeight = fontSize * 1.2;

  // Draw dashed selection rectangle
  ctx.strokeStyle = SELECTION_COLOR;
  ctx.lineWidth = SELECTION_LINE_WIDTH;
  ctx.setLineDash(SELECTION_DASH);
  ctx.strokeRect(-textWidth/2 - 4, -textHeight/2 - 2, textWidth + 8, textHeight + 4);

  // Draw corner handles
  ctx.setLineDash([]);
  ctx.fillStyle = SELECTION_COLOR;
  const handleSize = 6;

  ctx.fillRect(-textWidth/2 - 4 - handleSize/2, -textHeight/2 - 2 - handleSize/2, handleSize, handleSize);
  ctx.fillRect(textWidth/2 + 4 - handleSize/2, -textHeight/2 - 2 - handleSize/2, handleSize, handleSize);
  ctx.fillRect(-textWidth/2 - 4 - handleSize/2, textHeight/2 + 2 - handleSize/2, handleSize, handleSize);
  ctx.fillRect(textWidth/2 + 4 - handleSize/2, textHeight/2 + 2 - handleSize/2, handleSize, handleSize);

  ctx.restore();
}

/**
 * Renders selection indicators for all selected text labels.
 */
function renderTextLabelSelections(
  selectedItems: SelectedItem[],
  textLabels: TextLabel[],
  context: SelectionRenderContext,
  geometry: GeometryLike,
  getFontCss: (fontFace: string) => string
): void {
  const selectedTextLabels = selectedItems.filter(item => item.type === 'text');
  if (selectedTextLabels.length === 0 || !textLabels) return;

  for (const selectedItem of selectedTextLabels) {
    const label = textLabels.find(l => l.id === selectedItem.id);
    if (label) {
      renderTextLabelSelection(context.ctx, label, geometry, context, getFontCss);
    }
  }
}

/**
 * Calculates object selection position for hex maps.
 */
function calculateHexObjectSelectionPosition(
  object: MapObject,
  allObjects: MapObject[],
  hexGeometry: HexGeometryLike,
  context: SelectionRenderContext,
  orientation: string,
  deps: Pick<SelectionRenderDeps, 'getObjectsInCell' | 'getSlotOffset' | 'getMultiObjectScale'>
): { screenX: number; screenY: number; objectWidth: number; objectHeight: number; cellWidth: number; cellHeight: number } {
  const { offsetX, offsetY, zoom, scaledSize } = context;
  const size = object.size || { width: 1, height: 1 };
  const alignment = object.alignment || 'center';

  const { worldX, worldY } = hexGeometry.hexToWorld(object.position.x, object.position.y);

  const cellObjects = deps.getObjectsInCell(allObjects, object.position.x, object.position.y);
  const objectCount = cellObjects.length;

  let objectWidth = size.width * scaledSize;
  let objectHeight = size.height * scaledSize;
  const cellWidth = scaledSize;
  const cellHeight = scaledSize;

  if (objectCount > 1) {
    const multiScale = deps.getMultiObjectScale(objectCount);
    objectWidth *= multiScale;
    objectHeight *= multiScale;
  }

  let centerScreenX = offsetX + worldX * zoom;
  let centerScreenY = offsetY + worldY * zoom;

  if (objectCount > 1) {
    const effectiveSlot = object.slot ?? cellObjects.findIndex(o => o.id === object.id);
    const { offsetX: slotOffsetX, offsetY: slotOffsetY } = deps.getSlotOffset(
      effectiveSlot,
      objectCount,
      orientation
    );
    const hexWidth = scaledSize * 2;
    centerScreenX += slotOffsetX * hexWidth;
    centerScreenY += slotOffsetY * hexWidth;
  }

  if (alignment !== 'center') {
    const halfCell = scaledSize / 2;
    switch (alignment) {
      case 'north': centerScreenY -= halfCell; break;
      case 'south': centerScreenY += halfCell; break;
      case 'east': centerScreenX += halfCell; break;
      case 'west': centerScreenX -= halfCell; break;
    }
  }

  const screenX = centerScreenX - objectWidth / 2;
  const screenY = centerScreenY - objectHeight / 2;

  return { screenX, screenY, objectWidth, objectHeight, cellWidth, cellHeight };
}

/**
 * Calculates object selection position for grid maps.
 */
function calculateGridObjectSelectionPosition(
  object: MapObject,
  geometry: GeometryLike,
  context: SelectionRenderContext
): { screenX: number; screenY: number; objectWidth: number; objectHeight: number; cellWidth: number; cellHeight: number } {
  const { offsetX, offsetY, zoom, scaledSize } = context;
  const size = object.size || { width: 1, height: 1 };
  const alignment = object.alignment || 'center';

  const gridPos = geometry.gridToScreen(object.position.x, object.position.y, offsetX, offsetY, zoom);
  let screenX = gridPos.screenX;
  let screenY = gridPos.screenY;

  if (alignment !== 'center') {
    const halfCell = scaledSize / 2;
    switch (alignment) {
      case 'north': screenY -= halfCell; break;
      case 'south': screenY += halfCell; break;
      case 'east': screenX += halfCell; break;
      case 'west': screenX -= halfCell; break;
    }
  }

  const objectWidth = size.width * scaledSize;
  const objectHeight = size.height * scaledSize;
  const cellWidth = scaledSize;
  const cellHeight = scaledSize;

  return { screenX, screenY, objectWidth, objectHeight, cellWidth, cellHeight };
}

/**
 * Renders resize mode overlay showing occupied cells.
 */
function renderResizeOverlay(
  ctx: CanvasRenderingContext2D,
  object: MapObject,
  screenX: number,
  screenY: number,
  cellWidth: number,
  cellHeight: number
): void {
  const size = object.size || { width: 1, height: 1 };

  ctx.fillStyle = 'rgba(74, 158, 255, 0.15)';
  for (let dx = 0; dx < size.width; dx++) {
    for (let dy = 0; dy < size.height; dy++) {
      const cellScreenX = screenX + dx * cellWidth;
      const cellScreenY = screenY + dy * cellHeight;
      ctx.fillRect(cellScreenX + 2, cellScreenY + 2, cellWidth - 4, cellHeight - 4);
    }
  }
}

/**
 * Renders selection rectangle and corner handles for an object.
 */
function renderObjectSelectionRectangle(
  ctx: CanvasRenderingContext2D,
  screenX: number,
  screenY: number,
  objectWidth: number,
  objectHeight: number,
  isResizeMode: boolean
): void {
  // Draw selection rectangle
  ctx.strokeStyle = SELECTION_COLOR;
  ctx.lineWidth = SELECTION_LINE_WIDTH;
  ctx.setLineDash(SELECTION_DASH);
  ctx.strokeRect(screenX + 2, screenY + 2, objectWidth - 4, objectHeight - 4);

  // Draw corner handles
  ctx.setLineDash([]);
  ctx.fillStyle = SELECTION_COLOR;
  const handleSize = isResizeMode ? HANDLE_SIZE_RESIZE : HANDLE_SIZE_NORMAL;

  ctx.fillRect(screenX + 2 - handleSize/2, screenY + 2 - handleSize/2, handleSize, handleSize);
  ctx.fillRect(screenX + objectWidth - 2 - handleSize/2, screenY + 2 - handleSize/2, handleSize, handleSize);
  ctx.fillRect(screenX + 2 - handleSize/2, screenY + objectHeight - 2 - handleSize/2, handleSize, handleSize);
  ctx.fillRect(screenX + objectWidth - 2 - handleSize/2, screenY + objectHeight - 2 - handleSize/2, handleSize, handleSize);
}

/**
 * Renders selection indicator for a single object.
 */
function renderObjectSelection(
  ctx: CanvasRenderingContext2D,
  object: MapObject,
  allObjects: MapObject[],
  geometry: GeometryLike,
  hexGeometry: HexGeometryLike | null,
  context: SelectionRenderContext,
  isHexMap: boolean,
  isResizeMode: boolean,
  orientation: string,
  deps: Pick<SelectionRenderDeps, 'getObjectsInCell' | 'getSlotOffset' | 'getMultiObjectScale'>
): void {
  let position: { screenX: number; screenY: number; objectWidth: number; objectHeight: number; cellWidth: number; cellHeight: number };

  if (isHexMap && hexGeometry) {
    position = calculateHexObjectSelectionPosition(object, allObjects, hexGeometry, context, orientation, deps);
  } else {
    position = calculateGridObjectSelectionPosition(object, geometry, context);
  }

  const { screenX, screenY, objectWidth, objectHeight, cellWidth, cellHeight } = position;

  // Draw occupied cells overlay in resize mode
  if (isResizeMode) {
    renderResizeOverlay(ctx, object, screenX, screenY, cellWidth, cellHeight);
  }

  // Draw selection rectangle and handles
  renderObjectSelectionRectangle(ctx, screenX, screenY, objectWidth, objectHeight, isResizeMode);
}

/**
 * Renders selection indicators for all selected objects.
 */
function renderObjectSelections(
  selectedItems: SelectedItem[],
  objects: MapObject[],
  context: SelectionRenderContext,
  geometry: GeometryLike,
  hexGeometry: HexGeometryLike | null,
  isHexMap: boolean,
  isResizeMode: boolean,
  orientation: string,
  deps: Pick<SelectionRenderDeps, 'getObjectsInCell' | 'getSlotOffset' | 'getMultiObjectScale'>
): void {
  const selectedObjects = selectedItems.filter(item => item.type === 'object');
  if (selectedObjects.length === 0 || !objects) return;

  const showResizeOverlay = isResizeMode && selectedObjects.length === 1;

  for (const selectedItem of selectedObjects) {
    const object = objects.find(obj => obj.id === selectedItem.id);
    if (object) {
      renderObjectSelection(
        context.ctx,
        object,
        objects,
        geometry,
        hexGeometry,
        context,
        isHexMap,
        showResizeOverlay,
        orientation,
        deps
      );
    }
  }
}

/**
 * Main entry point for rendering all selection indicators.
 */
function renderSelections(
  selectedItems: SelectedItem[],
  textLabels: TextLabel[] | undefined,
  objects: MapObject[] | undefined,
  context: SelectionRenderContext,
  geometry: GeometryLike,
  hexGeometry: HexGeometryLike | null,
  isHexMap: boolean,
  isResizeMode: boolean,
  orientation: string,
  showCoordinates: boolean,
  visibility: { textLabels?: boolean; objects?: boolean },
  deps: SelectionRenderDeps
): void {
  if (selectedItems.length === 0 || showCoordinates) return;

  // Render text label selections
  if (textLabels && visibility.textLabels !== false) {
    renderTextLabelSelections(selectedItems, textLabels, context, geometry, deps.getFontCss);
  }

  // Render object selections
  if (objects && visibility.objects !== false) {
    renderObjectSelections(
      selectedItems,
      objects,
      context,
      geometry,
      hexGeometry,
      isHexMap,
      isResizeMode,
      orientation,
      deps
    );
  }
}

return {
  renderTextLabelSelection,
  renderTextLabelSelections,
  calculateHexObjectSelectionPosition,
  calculateGridObjectSelectionPosition,
  renderResizeOverlay,
  renderObjectSelectionRectangle,
  renderObjectSelection,
  renderObjectSelections,
  renderSelections,
};

```

# curveMath

```ts
/**
 * curveMath.ts
 *
 * Pure math functions for curve operations:
 * - Point simplification (Ramer-Douglas-Peucker algorithm)
 * - Catmull-Rom spline to Bezier conversion
 * - Distance/hit testing calculations
 * - Bounding box calculation
 *
 * All functions are stateless and side-effect free.
 */

import type { CurvePoint, BezierSegment, CurveBounds } from '#types/core/curve.types';

// ===========================================================================
// Point Simplification (Ramer-Douglas-Peucker)
// ===========================================================================

/**
 * Simplify a path using the Ramer-Douglas-Peucker algorithm.
 *
 * This reduces the number of points in a path while preserving its shape.
 * Points that are within epsilon distance of the line between their
 * neighbors are removed.
 *
 * @param points - Array of points to simplify
 * @param epsilon - Distance threshold (larger = more simplification)
 * @returns Simplified array of points
 */
function simplifyPath(points: CurvePoint[], epsilon: number): CurvePoint[] {
  if (points.length < 3) {
    return [...points];
  }

  return rdpSimplify(points, 0, points.length - 1, epsilon);
}

/**
 * Recursive RDP implementation.
 */
function rdpSimplify(
  points: CurvePoint[],
  startIdx: number,
  endIdx: number,
  epsilon: number
): CurvePoint[] {
  // Find the point with maximum distance from the line
  let maxDist = 0;
  let maxIdx = startIdx;

  const start = points[startIdx];
  const end = points[endIdx];

  for (let i = startIdx + 1; i < endIdx; i++) {
    const dist = perpendicularDistance(points[i], start, end);
    if (dist > maxDist) {
      maxDist = dist;
      maxIdx = i;
    }
  }

  // If max distance is greater than epsilon, recursively simplify
  if (maxDist > epsilon) {
    // Recursive call on both sides
    const left = rdpSimplify(points, startIdx, maxIdx, epsilon);
    const right = rdpSimplify(points, maxIdx, endIdx, epsilon);

    // Concatenate results (exclude duplicate point at maxIdx)
    return [...left.slice(0, -1), ...right];
  }

  // All points between start and end are within epsilon
  return [start, end];
}

/**
 * Calculate perpendicular distance from a point to a line segment.
 */
function perpendicularDistance(
  point: CurvePoint,
  lineStart: CurvePoint,
  lineEnd: CurvePoint
): number {
  const dx = lineEnd[0] - lineStart[0];
  const dy = lineEnd[1] - lineStart[1];
  const lenSq = dx * dx + dy * dy;

  if (lenSq === 0) {
    // Start and end are the same point
    return Math.hypot(point[0] - lineStart[0], point[1] - lineStart[1]);
  }

  // Calculate cross product to get area of parallelogram
  const cross = Math.abs(
    (point[0] - lineStart[0]) * dy - (point[1] - lineStart[1]) * dx
  );

  // Divide by base length to get height (perpendicular distance)
  return cross / Math.sqrt(lenSq);
}

// ===========================================================================
// Catmull-Rom to Bezier Conversion
// ===========================================================================

/**
 * Convert Catmull-Rom spline control points to cubic Bezier segments.
 *
 * Catmull-Rom splines pass through all control points, making them
 * ideal for freehand drawing. This converts them to Bezier curves
 * for Canvas rendering.
 *
 * @param points - Control points the curve passes through
 * @param tension - Smoothness factor (0 = sharp corners, 1 = very smooth)
 * @param closed - Whether the curve forms a closed loop
 * @returns Array of cubic Bezier segments
 */
function catmullRomToBezier(
  points: CurvePoint[],
  tension: number,
  closed: boolean
): BezierSegment[] {
  if (points.length < 2) {
    return [];
  }

  if (points.length === 2) {
    // Two points = straight line, use linear interpolation
    return [{
      start: points[0],
      cp1: [
        points[0][0] + (points[1][0] - points[0][0]) / 3,
        points[0][1] + (points[1][1] - points[0][1]) / 3,
      ],
      cp2: [
        points[0][0] + (points[1][0] - points[0][0]) * 2 / 3,
        points[0][1] + (points[1][1] - points[0][1]) * 2 / 3,
      ],
      end: points[1],
    }];
  }

  const segments: BezierSegment[] = [];
  const n = points.length;

  // Alpha factor for Catmull-Rom to Bezier conversion
  // Higher tension = more influence from tangent vectors
  const alpha = tension / 6;

  const numSegments = closed ? n : n - 1;

  for (let i = 0; i < numSegments; i++) {
    // Get the four control points for this segment
    // For Catmull-Rom, we need point before, current, next, and after next
    const p0 = points[closed ? (i - 1 + n) % n : Math.max(0, i - 1)];
    const p1 = points[i];
    const p2 = points[(i + 1) % n];
    const p3 = points[closed ? (i + 2) % n : Math.min(n - 1, i + 2)];

    // Calculate Bezier control points using Catmull-Rom formulas
    const cp1: CurvePoint = [
      p1[0] + alpha * (p2[0] - p0[0]),
      p1[1] + alpha * (p2[1] - p0[1]),
    ];

    const cp2: CurvePoint = [
      p2[0] - alpha * (p3[0] - p1[0]),
      p2[1] - alpha * (p3[1] - p1[1]),
    ];

    segments.push({
      start: p1,
      cp1,
      cp2,
      end: p2,
    });
  }

  return segments;
}

// ===========================================================================
// Bounding Box Calculation
// ===========================================================================

/**
 * Calculate axis-aligned bounding box for a set of points.
 *
 * @param points - Points to calculate bounds for
 * @returns Bounding box or null if no points
 */
function getCurveBounds(points: CurvePoint[]): CurveBounds | null {
  if (points.length === 0) {
    return null;
  }

  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;

  for (const [x, y] of points) {
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x);
    maxY = Math.max(maxY, y);
  }

  return { minX, minY, maxX, maxY };
}

// ===========================================================================
// Distance Calculations
// ===========================================================================

/**
 * Calculate distance from a point to a line segment.
 *
 * Returns the shortest distance from the point to any point on the
 * line segment (not the infinite line).
 *
 * @param point - The query point
 * @param lineStart - Start of line segment
 * @param lineEnd - End of line segment
 * @returns Distance from point to nearest point on segment
 */
function distanceToLineSegment(
  point: CurvePoint,
  lineStart: CurvePoint,
  lineEnd: CurvePoint
): number {
  const [px, py] = point;
  const [x1, y1] = lineStart;
  const [x2, y2] = lineEnd;

  const dx = x2 - x1;
  const dy = y2 - y1;
  const lenSq = dx * dx + dy * dy;

  if (lenSq === 0) {
    // Segment is a point
    return Math.hypot(px - x1, py - y1);
  }

  // Calculate projection parameter t
  // t = 0 -> closest to start, t = 1 -> closest to end
  let t = ((px - x1) * dx + (py - y1) * dy) / lenSq;
  t = Math.max(0, Math.min(1, t)); // Clamp to segment

  // Calculate closest point on segment
  const closestX = x1 + t * dx;
  const closestY = y1 + t * dy;

  return Math.hypot(px - closestX, py - closestY);
}

// ===========================================================================
// Bezier Curve Evaluation
// ===========================================================================

/**
 * Evaluate a cubic Bezier curve at parameter t.
 *
 * Uses De Casteljau's algorithm for numerical stability.
 *
 * @param segment - Bezier segment to evaluate
 * @param t - Parameter (0 = start, 1 = end)
 * @returns Point on curve at parameter t
 */
function evaluateBezier(segment: BezierSegment, t: number): CurvePoint {
  // Clamp t to [0, 1]
  const tc = Math.max(0, Math.min(1, t));
  const mt = 1 - tc;

  // Cubic Bezier formula: B(t) = (1-t)P0 + 3(1-t)tP1 + 3(1-t)tP2 + tP3
  const mt2 = mt * mt;
  const mt3 = mt2 * mt;
  const t2 = tc * tc;
  const t3 = t2 * tc;

  const x =
    mt3 * segment.start[0] +
    3 * mt2 * tc * segment.cp1[0] +
    3 * mt * t2 * segment.cp2[0] +
    t3 * segment.end[0];

  const y =
    mt3 * segment.start[1] +
    3 * mt2 * tc * segment.cp1[1] +
    3 * mt * t2 * segment.cp2[1] +
    t3 * segment.end[1];

  return [x, y];
}

// ===========================================================================
// Hit Testing
// ===========================================================================

/**
 * Find the closest point on a Bezier segment to a query point.
 *
 * Uses iterative subdivision for reasonable accuracy.
 *
 * @param segment - Bezier segment to test
 * @param point - Query point
 * @returns Closest point, distance, and parameter t
 */
function closestPointOnBezier(
  segment: BezierSegment,
  point: CurvePoint
): { point: CurvePoint; distance: number; t: number } {
  const SUBDIVISIONS = 20;
  let minDist = Infinity;
  let minT = 0;
  let minPoint: CurvePoint = segment.start;

  // Sample the curve at regular intervals
  for (let i = 0; i <= SUBDIVISIONS; i++) {
    const t = i / SUBDIVISIONS;
    const curvePoint = evaluateBezier(segment, t);
    const dist = Math.hypot(
      point[0] - curvePoint[0],
      point[1] - curvePoint[1]
    );

    if (dist < minDist) {
      minDist = dist;
      minT = t;
      minPoint = curvePoint;
    }
  }

  // Refine with binary search around the best t
  let low = Math.max(0, minT - 1 / SUBDIVISIONS);
  let high = Math.min(1, minT + 1 / SUBDIVISIONS);

  for (let i = 0; i < 10; i++) {
    const mid1 = low + (high - low) / 3;
    const mid2 = low + (high - low) * 2 / 3;

    const p1 = evaluateBezier(segment, mid1);
    const p2 = evaluateBezier(segment, mid2);

    const d1 = Math.hypot(point[0] - p1[0], point[1] - p1[1]);
    const d2 = Math.hypot(point[0] - p2[0], point[1] - p2[1]);

    if (d1 < d2) {
      high = mid2;
      if (d1 < minDist) {
        minDist = d1;
        minT = mid1;
        minPoint = p1;
      }
    } else {
      low = mid1;
      if (d2 < minDist) {
        minDist = d2;
        minT = mid2;
        minPoint = p2;
      }
    }
  }

  return {
    point: minPoint,
    distance: minDist,
    t: minT,
  };
}

/**
 * Check if a point is within threshold distance of a curve.
 *
 * @param curvePoints - Control points of the curve
 * @param point - Query point
 * @param threshold - Maximum distance to consider "near"
 * @param tension - Curve smoothing (for Catmull-Rom conversion)
 * @returns True if point is near curve
 */
function isPointNearCurve(
  curvePoints: CurvePoint[],
  point: CurvePoint,
  threshold: number,
  tension: number
): boolean {
  if (curvePoints.length === 0) {
    return false;
  }

  if (curvePoints.length === 1) {
    const dist = Math.hypot(
      point[0] - curvePoints[0][0],
      point[1] - curvePoints[0][1]
    );
    return dist <= threshold;
  }

  // Convert to Bezier and check each segment
  const segments = catmullRomToBezier(curvePoints, tension, false);

  for (const segment of segments) {
    const { distance } = closestPointOnBezier(segment, point);
    if (distance <= threshold) {
      return true;
    }
  }

  return false;
}

// ===========================================================================
// Exports (Datacore module format)
// ===========================================================================

return {
  simplifyPath,
  catmullRomToBezier,
  getCurveBounds,
  distanceToLineSegment,
  closestPointOnBezier,
  isPointNearCurve,
  evaluateBezier,
};

```

# curveRenderer

```ts
/**
 * curveRenderer.ts
 *
 * Renders freehand curves on the canvas.
 * Curves are stored as Catmull-Rom control points and rendered as Bezier curves.
 *
 * RENDERING NOTES:
 * - Curves are stored in world coordinates (pixel units)
 * - Rendering uses offset-based view state for consistency with other renderers
 * - Stroke width can optionally scale with zoom
 * - Uses lineCap/lineJoin = 'round' for smooth appearance
 */

// Type-only imports
import type { Curve, CurveRenderOptions, BezierSegment, CurvePoint } from '#types/core/curve.types';

/**
 * View state used by renderers (offset-based).
 * x, y are offset values, zoom is the scale factor.
 */
interface RendererViewState {
  x: number;  // Offset X (already calculated from center)
  y: number;  // Offset Y (already calculated from center)
  zoom: number;
}

// Datacore imports
const { catmullRomToBezier } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "curveMath")) as {
  catmullRomToBezier: (points: CurvePoint[], tension: number, closed: boolean) => BezierSegment[];
};

// Default render options
const DEFAULT_OPTIONS: CurveRenderOptions = {
  lineCap: 'round',
  lineJoin: 'round',
  scaleStrokeWithZoom: true,
};

/**
 * Render a single curve on the canvas.
 *
 * @param ctx - Canvas rendering context
 * @param curve - Curve to render
 * @param viewState - Renderer view state with offset and zoom
 * @param options - Rendering options
 */
function renderCurve(
  ctx: CanvasRenderingContext2D,
  curve: Curve,
  viewState: RendererViewState,
  options: CurveRenderOptions = {}
): void {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const { points, color, opacity = 1, strokeWidth = 2, smoothing = 0.5, closed = false, filled = false } = curve;

  if (points.length < 2) {
    return;
  }

  // Convert Catmull-Rom control points to Bezier segments
  const segments = catmullRomToBezier(points, smoothing, closed);

  if (segments.length === 0) {
    return;
  }

  // Calculate screen coordinates using offset-based view state
  // This is the same formula used by other renderers (gridRenderer, hexRenderer)
  // worldPoint * zoom + offset = screenPoint
  const toScreen = (x: number, y: number) => ({
    x: x * viewState.zoom + viewState.x,
    y: y * viewState.zoom + viewState.y,
  });

  // Begin path
  ctx.beginPath();

  // Move to start of first segment
  const start = toScreen(segments[0].start[0], segments[0].start[1]);
  ctx.moveTo(start.x, start.y);

  // Draw each Bezier segment
  for (const segment of segments) {
    const cp1 = toScreen(segment.cp1[0], segment.cp1[1]);
    const cp2 = toScreen(segment.cp2[0], segment.cp2[1]);
    const end = toScreen(segment.end[0], segment.end[1]);
    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
  }

  // Close path if needed
  if (closed) {
    ctx.closePath();
  }

  // Set up stroke style
  const previousAlpha = ctx.globalAlpha;
  ctx.globalAlpha = previousAlpha * opacity;

  // Calculate stroke width (optionally scaled with zoom)
  const scaledWidth = opts.scaleStrokeWithZoom
    ? strokeWidth * viewState.zoom
    : strokeWidth;

  // Fill if closed and filled
  if (closed && filled) {
    ctx.fillStyle = color;
    ctx.fill();
  }

  // Stroke the curve
  ctx.strokeStyle = color;
  ctx.lineWidth = scaledWidth;
  ctx.lineCap = opts.lineCap!;
  ctx.lineJoin = opts.lineJoin!;
  ctx.stroke();

  // Restore alpha
  ctx.globalAlpha = previousAlpha;
}

/**
 * Render all curves on the canvas.
 *
 * @param ctx - Canvas rendering context
 * @param curves - Curves to render
 * @param viewState - Renderer view state with offset and zoom
 * @param options - Rendering options
 */
function renderCurves(
  ctx: CanvasRenderingContext2D,
  curves: Curve[] | null | undefined,
  viewState: RendererViewState,
  options: CurveRenderOptions = {}
): void {
  if (!curves || curves.length === 0) {
    return;
  }

  for (const curve of curves) {
    renderCurve(ctx, curve, viewState, options);
  }
}

/**
 * Render a preview curve during drawing (before it's finalized).
 * Uses slightly different styling for visual feedback.
 *
 * @param ctx - Canvas rendering context
 * @param points - Raw points being drawn
 * @param color - Stroke color
 * @param strokeWidth - Line width
 * @param viewState - Renderer view state with offset and zoom
 */
function renderCurvePreview(
  ctx: CanvasRenderingContext2D,
  points: [number, number][],
  color: string,
  strokeWidth: number,
  viewState: RendererViewState
): void {
  if (points.length < 2) {
    return;
  }

  // For preview, draw as simple polyline (smoother performance during drawing)
  const toScreen = (x: number, y: number) => ({
    x: x * viewState.zoom + viewState.x,
    y: y * viewState.zoom + viewState.y,
  });

  ctx.beginPath();
  const start = toScreen(points[0][0], points[0][1]);
  ctx.moveTo(start.x, start.y);

  for (let i = 1; i < points.length; i++) {
    const pt = toScreen(points[i][0], points[i][1]);
    ctx.lineTo(pt.x, pt.y);
  }

  ctx.strokeStyle = color;
  ctx.lineWidth = strokeWidth * viewState.zoom;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.stroke();
}

/**
 * Render selection highlight for a curve.
 *
 * @param ctx - Canvas rendering context
 * @param curve - Curve to highlight
 * @param viewState - Renderer view state with offset and zoom
 * @param highlightColor - Color for the highlight
 */
function renderCurveHighlight(
  ctx: CanvasRenderingContext2D,
  curve: Curve,
  viewState: RendererViewState,
  highlightColor: string = '#4dabf7'
): void {
  const { points, smoothing = 0.5, closed = false } = curve;

  if (points.length < 2) {
    return;
  }

  const segments = catmullRomToBezier(points, smoothing, closed);

  if (segments.length === 0) {
    return;
  }

  const toScreen = (x: number, y: number) => ({
    x: x * viewState.zoom + viewState.x,
    y: y * viewState.zoom + viewState.y,
  });

  // Draw thicker outline in highlight color
  ctx.beginPath();
  const start = toScreen(segments[0].start[0], segments[0].start[1]);
  ctx.moveTo(start.x, start.y);

  for (const segment of segments) {
    const cp1 = toScreen(segment.cp1[0], segment.cp1[1]);
    const cp2 = toScreen(segment.cp2[0], segment.cp2[1]);
    const end = toScreen(segment.end[0], segment.end[1]);
    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
  }

  if (closed) {
    ctx.closePath();
  }

  ctx.strokeStyle = highlightColor;
  ctx.lineWidth = ((curve.strokeWidth ?? 2) + 4) * viewState.zoom;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.stroke();

  // Draw control point indicators
  ctx.fillStyle = highlightColor;
  const handleSize = 6;
  for (const point of points) {
    const screen = toScreen(point[0], point[1]);
    ctx.beginPath();
    ctx.arc(screen.x, screen.y, handleSize, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ===========================================================================
// Exports (Datacore module format)
// ===========================================================================

return {
  renderCurve,
  renderCurves,
  renderCurvePreview,
  renderCurveHighlight,
};

```

# fontOptions

```ts
/**
 * fontOptions.ts - Cross-platform font definitions for text labels
 */

import type { HexColor } from '#types/core/common.types';

/** Font option definition */
interface FontOption {
  id: string;
  name: string;
  css: string;
}

/**
 * Font options with CSS font stacks optimized for cross-platform compatibility
 * Each stack prioritizes system fonts and falls back gracefully
 */
const FONT_OPTIONS: FontOption[] = [
  {
    id: 'sans',
    name: 'Sans-Serif',
    css: 'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif'
  },
  {
    id: 'serif',
    name: 'Serif',
    css: 'Georgia, Cambria, "Times New Roman", Times, serif'
  },
  {
    id: 'mono',
    name: 'Monospace',
    css: '"Courier New", Courier, "Liberation Mono", monospace'
  },
  {
    id: 'script',
    name: 'Script',
    css: '"Brush Script MT", "Bradley Hand", "Segoe Script", "Lucida Handwriting", "Apple Chancery", cursive'
  },
  {
    id: 'cinzel',
    name: 'Cinzel',
    css: '"Cinzel", serif'
  },
  {
    id: 'IM Fell English',
    name: 'IM Fell English',
    css: '"IM Fell English", serif'
  },
  {
    id: 'MedievalSharp',
    name: 'MedievalSharp',
    css: '"MedievalSharp", cursive'
  },
  {
    id: 'Pirata One',
    name: 'Pirata One',
    css: '"Pirata One", cursive'
  },
];

/** Default font settings for new text labels */
const DEFAULT_FONT = 'sans';
const DEFAULT_FONT_SIZE = 16;
const DEFAULT_TEXT_COLOR: HexColor = '#ffffff';

/** Font size constraints */
const FONT_SIZE_MIN = 8;
const FONT_SIZE_MAX = 72;
const FONT_SIZE_STEP = 2;

/**
 * Get CSS font family string by font ID
 */
function getFontCss(fontId: string): string {
  const font = FONT_OPTIONS.find(f => f.id === fontId);
  return font ? font.css : FONT_OPTIONS[0].css;
}

/**
 * Get font option by ID
 */
function getFontOption(fontId: string): FontOption {
  return FONT_OPTIONS.find(f => f.id === fontId) || FONT_OPTIONS[0];
}

return {
  FONT_OPTIONS,
  DEFAULT_FONT,
  DEFAULT_FONT_SIZE,
  DEFAULT_TEXT_COLOR,
  FONT_SIZE_MIN,
  FONT_SIZE_MAX,
  FONT_SIZE_STEP,
  getFontCss,
  getFontOption
};

```

# gridRenderer

```ts
/**
 * gridRenderer.ts
 * Pure functions for rendering grid-based maps
 * 
 * All functions are stateless and side-effect free (except canvas drawing)
 * Designed to work with GridGeometry instances
 * 
 * RENDERING NOTE: Many functions use ctx.fillRect() instead of ctx.stroke()
 * to work around a rendering bug in Obsidian's Live Preview mode where
 * CodeMirror's canvas operations can corrupt the strokeStyle state.
 */

// Type-only imports
import type { Point, GridStyle } from '#types/core/geometry.types';
import type {
  ViewState,
  CanvasDimensions,
  RenderCell,
  Edge,
  InteriorGridStyle,
  EdgeStyle,
  BorderTheme,
  CellLookup,
  BuildCellLookupFn,
  CalculateBordersFn,
  IGridRenderer
} from '#types/core/rendering.types';

// ===========================================
// Grid Renderer Module
// ===========================================

const gridRenderer = {
  /**
   * Whether this renderer supports segment (partial cell) rendering.
   * Grid maps support segments, hex maps do not.
   */
  supportsSegments: true,

  /**
   * Calculate the scaled cell size for the current zoom level.
   */
  getScaledSize(geometry: IGridRenderer, zoom: number): number {
    return geometry.getScaledCellSize(zoom);
  },

  /**
   * Calculate viewport offset for grid maps.
   * Grid maps multiply center by scaled cell size.
   */
  calculateViewportOffset(
    geometry: IGridRenderer,
    center: { x: number; y: number },
    canvasSize: { width: number; height: number },
    zoom: number
  ): { offsetX: number; offsetY: number } {
    const scaledSize = geometry.getScaledCellSize(zoom);
    return {
      offsetX: canvasSize.width / 2 - center.x * scaledSize,
      offsetY: canvasSize.height / 2 - center.y * scaledSize,
    };
  },

  /**
   * Render background image for grid maps.
   * Grid maps don't support background images - this is a no-op.
   */
  renderBackgroundImage(): void {
    // Grid maps don't render background images
  },

  /**
   * Render grid overlay lines
   */
  renderGrid(
    ctx: CanvasRenderingContext2D,
    geometry: IGridRenderer,
    viewState: ViewState,
    canvasDimensions: CanvasDimensions,
    showGrid: boolean,
    style: GridStyle = {}
  ): void {
    if (!showGrid) return;
    
    const { lineColor = '#333333', lineWidth = 1 } = style;
    
    // Use geometry's built-in drawGrid method which handles rotation
    geometry.drawGrid(
      ctx,
      viewState.x,
      viewState.y,
      canvasDimensions.width,
      canvasDimensions.height,
      viewState.zoom,
      { lineColor, lineWidth }
    );
  },

  /**
   * Render painted cells
   */
  renderPaintedCells(
    ctx: CanvasRenderingContext2D,
    cells: RenderCell[],
    geometry: IGridRenderer,
    viewState: ViewState
  ): void {
    if (!cells || cells.length === 0) return;
    
    const scaledSize = geometry.getScaledCellSize(viewState.zoom);
    
    // Separate cells by whether they have custom opacity
    const fullOpacityCells: RenderCell[] = [];
    const customOpacityCells: RenderCell[] = [];
    
    for (const cell of cells) {
      const opacity = cell.opacity ?? 1;
      if (opacity === 1) {
        fullOpacityCells.push(cell);
      } else {
        customOpacityCells.push(cell);
      }
    }
    
    // Draw full opacity cells grouped by color (efficient batch rendering)
    if (fullOpacityCells.length > 0) {
      const cellsByColor: Record<string, RenderCell[]> = {};
      for (const cell of fullOpacityCells) {
        const color = cell.color;
        if (!cellsByColor[color]) {
          cellsByColor[color] = [];
        }
        cellsByColor[color].push(cell);
      }
      
      for (const [color, cellGroup] of Object.entries(cellsByColor)) {
        geometry.drawCells(ctx, cellGroup, viewState.x, viewState.y, viewState.zoom, color);
      }
    }
    
    // Draw cells with custom opacity individually
    if (customOpacityCells.length > 0) {
      const previousAlpha = ctx.globalAlpha;
      for (const cell of customOpacityCells) {
        const opacity = cell.opacity ?? 1;
        ctx.globalAlpha = previousAlpha * opacity;
        ctx.fillStyle = cell.color;
        const { screenX, screenY } = geometry.gridToScreen(cell.x, cell.y, viewState.x, viewState.y, viewState.zoom);
        ctx.fillRect(screenX, screenY, scaledSize, scaledSize);
      }
      ctx.globalAlpha = previousAlpha;
    }
  },

  /**
   * Render interior grid lines between adjacent painted cells
   * These are drawn on top of painted cells to restore grid visibility
   * Uses fillRect instead of stroke for iOS/CodeMirror compatibility
   */
  renderInteriorGridLines(
    ctx: CanvasRenderingContext2D,
    cells: RenderCell[],
    geometry: IGridRenderer,
    viewState: ViewState,
    style: InteriorGridStyle = {}
  ): void {
    if (!cells || cells.length === 0) return;
    
    const { lineColor = '#666666', lineWidth = 1, interiorRatio = 0.5 } = style;
    const scaledSize = geometry.getScaledCellSize(viewState.zoom);
    const actualLineWidth = Math.max(1, lineWidth * interiorRatio);
    const halfWidth = actualLineWidth / 2;
    
    // Build lookup set for O(1) cell existence checks
    const cellSet = new Set(cells.map(c => `${c.x},${c.y}`));
    
    // Track which interior lines we've already drawn to avoid duplicates
    const drawnLines = new Set<string>();
    
    ctx.fillStyle = lineColor;
    
    for (const cell of cells) {
      const { screenX, screenY } = geometry.gridToScreen(
        cell.x,
        cell.y,
        viewState.x,
        viewState.y,
        viewState.zoom
      );
      
      // Check right neighbor - draw vertical line between them
      const rightKey = `${cell.x + 1},${cell.y}`;
      if (cellSet.has(rightKey)) {
        const lineKey = `v:${cell.x + 1},${cell.y}`;
        if (!drawnLines.has(lineKey)) {
          // Vertical line using fillRect
          ctx.fillRect(
            screenX + scaledSize - halfWidth,
            screenY,
            actualLineWidth,
            scaledSize
          );
          drawnLines.add(lineKey);
        }
      }
      
      // Check bottom neighbor - draw horizontal line between them
      const bottomKey = `${cell.x},${cell.y + 1}`;
      if (cellSet.has(bottomKey)) {
        const lineKey = `h:${cell.x},${cell.y + 1}`;
        if (!drawnLines.has(lineKey)) {
          // Horizontal line using fillRect
          ctx.fillRect(
            screenX,
            screenY + scaledSize - halfWidth,
            scaledSize,
            actualLineWidth
          );
          drawnLines.add(lineKey);
        }
      }
    }
  },

  /**
   * Render painted edges (custom colored grid lines)
   * 
   * Edges are rendered after cells and before cell borders, appearing
   * as colored overlays on specific grid lines.
   */
  renderEdges(
    ctx: CanvasRenderingContext2D,
    edges: Edge[],
    geometry: IGridRenderer,
    viewState: ViewState,
    style: EdgeStyle = {}
  ): void {
    if (!edges || edges.length === 0) return;
    
    const scaledSize = geometry.getScaledCellSize(viewState.zoom);
    // Edge thickness: slightly thicker than grid lines for visibility
    // Use 2.5x grid line width, clamped between 2 and borderWidth
    const baseWidth = style.lineWidth ?? 1;
    const edgeWidth = Math.min(Math.max(2, baseWidth * 2.5), style.borderWidth ?? 4);
    const halfWidth = edgeWidth / 2;
    
    for (const edge of edges) {
      // Skip malformed edges
      if (!edge || typeof edge.x !== 'number' || typeof edge.y !== 'number' || !edge.side || !edge.color) {
        continue;
      }
      
      const { screenX, screenY } = geometry.gridToScreen(
        edge.x,
        edge.y,
        viewState.x,
        viewState.y,
        viewState.zoom
      );
      
      // Apply opacity if specified (multiply with current globalAlpha)
      const edgeOpacity = edge.opacity ?? 1;
      const previousAlpha = ctx.globalAlpha;
      if (edgeOpacity < 1) {
        ctx.globalAlpha = previousAlpha * edgeOpacity;
      }

      ctx.fillStyle = edge.color;

      // Edges are stored normalized as 'right' or 'bottom' only
      if (edge.side === 'right') {
        // Right edge of cell (x,y) - vertical line at x+1 boundary
        ctx.fillRect(
          screenX + scaledSize - halfWidth,
          screenY - halfWidth,
          edgeWidth,
          scaledSize + edgeWidth
        );
      } else if (edge.side === 'bottom') {
        // Bottom edge of cell (x,y) - horizontal line at y+1 boundary
        ctx.fillRect(
          screenX - halfWidth,
          screenY + scaledSize - halfWidth,
          scaledSize + edgeWidth,
          edgeWidth
        );
      }

      // Restore previous opacity
      if (edgeOpacity < 1) {
        ctx.globalAlpha = previousAlpha;
      }
    }
  },

  /**
   * Render smart borders for painted cells using fill-based rendering
   * 
   * NOTE: This uses ctx.fillRect() instead of ctx.stroke() to work around
   * a rendering bug in Obsidian's Live Preview mode where CodeMirror's
   * canvas operations can corrupt the strokeStyle state.
   */
  renderCellBorders(
    ctx: CanvasRenderingContext2D,
    cells: RenderCell[],
    geometry: IGridRenderer,
    viewState: ViewState,
    buildCellLookup: BuildCellLookupFn,
    calculateBorders: CalculateBordersFn,
    theme: BorderTheme
  ): void {
    if (!cells || cells.length === 0) return;
    
    const scaledSize = geometry.getScaledCellSize(viewState.zoom);
    const cellLookup = buildCellLookup(cells);
    const borderWidth = theme.borderWidth;
    const halfWidth = borderWidth / 2;
    
    // Use fillStyle instead of strokeStyle for fill-based rendering
    ctx.fillStyle = theme.border;
    
    for (const cell of cells) {
      const { screenX, screenY } = geometry.gridToScreen(
        cell.x,
        cell.y,
        viewState.x,
        viewState.y,
        viewState.zoom
      );
      
      // Calculate which borders this cell needs
      const borders = calculateBorders(cellLookup, cell.x, cell.y);
      
      // Draw each border as a filled rectangle
      for (const side of borders) {
        switch (side) {
          case 'top':
            ctx.fillRect(
              screenX - halfWidth,
              screenY - halfWidth,
              scaledSize + borderWidth,
              borderWidth
            );
            break;
          case 'right':
            ctx.fillRect(
              screenX + scaledSize - halfWidth,
              screenY - halfWidth,
              borderWidth,
              scaledSize + borderWidth
            );
            break;
          case 'bottom':
            ctx.fillRect(
              screenX - halfWidth,
              screenY + scaledSize - halfWidth,
              scaledSize + borderWidth,
              borderWidth
            );
            break;
          case 'left':
            ctx.fillRect(
              screenX - halfWidth,
              screenY - halfWidth,
              borderWidth,
              scaledSize + borderWidth
            );
            break;
        }
      }
    }
  },

  /**
   * Render selection highlight for a cell using fill-based rendering
   * 
   * NOTE: This uses ctx.fillRect() instead of ctx.strokeRect() to work around
   * a rendering bug in Obsidian's Live Preview mode where CodeMirror's
   * canvas operations can corrupt the strokeStyle state.
   */
  renderCellHighlight(
    ctx: CanvasRenderingContext2D,
    cell: Point,
    geometry: IGridRenderer,
    viewState: ViewState,
    isResizeMode: boolean
  ): void {
    const scaledSize = geometry.getScaledCellSize(viewState.zoom);
    
    const { screenX, screenY } = geometry.gridToScreen(
      cell.x,
      cell.y,
      viewState.x,
      viewState.y,
      viewState.zoom
    );
    
    // Selection border - draw as 4 filled rectangles instead of strokeRect
    const color = isResizeMode ? '#ff6b6b' : '#4dabf7';
    const lineWidth = 2;
    const halfWidth = lineWidth / 2;
    
    ctx.fillStyle = color;
    
    // Top border
    ctx.fillRect(
      screenX - halfWidth,
      screenY - halfWidth,
      scaledSize + lineWidth,
      lineWidth
    );
    // Bottom border
    ctx.fillRect(
      screenX - halfWidth,
      screenY + scaledSize - halfWidth,
      scaledSize + lineWidth,
      lineWidth
    );
    // Left border
    ctx.fillRect(
      screenX - halfWidth,
      screenY - halfWidth,
      lineWidth,
      scaledSize + lineWidth
    );
    // Right border
    ctx.fillRect(
      screenX + scaledSize - halfWidth,
      screenY - halfWidth,
      lineWidth,
      scaledSize + lineWidth
    );
    
    // Corner handles for resize mode (grid cells don't resize, but kept for API consistency)
    if (isResizeMode) {
      const handleSize = 8;
      ctx.fillStyle = '#ff6b6b';
      
      // Top-left
      ctx.fillRect(screenX - handleSize/2, screenY - handleSize/2, handleSize, handleSize);
      // Top-right
      ctx.fillRect(screenX + scaledSize - handleSize/2, screenY - handleSize/2, handleSize, handleSize);
      // Bottom-left
      ctx.fillRect(screenX - handleSize/2, screenY + scaledSize - handleSize/2, handleSize, handleSize);
      // Bottom-right
      ctx.fillRect(screenX + scaledSize - handleSize/2, screenY + scaledSize - handleSize/2, handleSize, handleSize);
    }
  }
};

return { gridRenderer };
```

# hexRenderer

```ts
/**
 * hexRenderer.ts
 * Pure functions for rendering hexagonal maps
 * 
 * All functions are stateless and side-effect free (except canvas drawing)
 * Designed to work with HexGeometry instances
 */

// Type-only imports
import type { Point, GridStyle } from '#types/core/geometry.types';
import type {
  ViewState,
  CanvasDimensions,
  RenderHexCell,
  BorderTheme,
  CellLookup,
  BuildCellLookupFn,
  CalculateBordersFn,
  IHexRenderer
} from '#types/core/rendering.types';

// Datacore imports for background image rendering
const { renderHexBackgroundImage } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "backgroundRenderer")) as {
  renderHexBackgroundImage: (
    bgImage: HTMLImageElement,
    config: { path: string; offsetX?: number; offsetY?: number; opacity?: number },
    hexBounds: { maxCol: number; maxRow: number },
    hexGeometry: { hexSize: number; sqrt3: number; hexToWorld: (q: number, r: number) => { worldX: number; worldY: number } },
    orientation: string,
    context: { ctx: CanvasRenderingContext2D; offsetX: number; offsetY: number; zoom: number },
    offsetToAxial: (col: number, row: number, orientation: string) => { q: number; r: number }
  ) => void;
};

const { offsetToAxial } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "offsetCoordinates")) as {
  offsetToAxial: (col: number, row: number, orientation: string) => { q: number; r: number };
};

// ===========================================
// Hex Renderer Module
// ===========================================

const hexRenderer = {
  /**
   * Whether this renderer supports segment (partial cell) rendering.
   * Hex maps do not support segments.
   */
  supportsSegments: false,

  /**
   * Calculate the scaled cell size for the current zoom level.
   */
  getScaledSize(geometry: IHexRenderer, zoom: number): number {
    return geometry.getScaledCellSize(zoom);
  },

  /**
   * Calculate viewport offset for hex maps.
   * Hex maps multiply center by zoom only (center is in world coordinates).
   */
  calculateViewportOffset(
    _geometry: IHexRenderer,
    center: { x: number; y: number },
    canvasSize: { width: number; height: number },
    zoom: number
  ): { offsetX: number; offsetY: number } {
    return {
      offsetX: canvasSize.width / 2 - center.x * zoom,
      offsetY: canvasSize.height / 2 - center.y * zoom,
    };
  },

  /**
   * Render background image for hex maps.
   * Centers the image based on hex grid bounds.
   */
  renderBackgroundImage(
    ctx: CanvasRenderingContext2D,
    geometry: IHexRenderer,
    bgImage: HTMLImageElement | null,
    bgConfig: { path: string; offsetX?: number; offsetY?: number; opacity?: number } | undefined,
    hexBounds: { maxCol: number; maxRow: number } | undefined,
    orientation: string,
    offsetX: number,
    offsetY: number,
    zoom: number
  ): void {
    if (!bgImage || !bgConfig?.path || !hexBounds) return;
    if (!bgImage.complete) return;

    renderHexBackgroundImage(
      bgImage,
      bgConfig,
      hexBounds,
      geometry as unknown as { hexSize: number; sqrt3: number; hexToWorld: (q: number, r: number) => { worldX: number; worldY: number } },
      orientation,
      { ctx, offsetX, offsetY, zoom },
      offsetToAxial
    );
  },

  /**
   * Render hex grid overlay
   */
  renderGrid(
    ctx: CanvasRenderingContext2D,
    geometry: IHexRenderer,
    viewState: ViewState,
    canvasDimensions: CanvasDimensions,
    showGrid: boolean,
    style: GridStyle = {}
  ): void {
    if (!showGrid) return;
    
    const { lineColor = '#333333', lineWidth = 1 } = style;
    
    // Use geometry's built-in drawGrid method which handles rotation
    geometry.drawGrid(
      ctx,
      viewState.x,
      viewState.y,
      canvasDimensions.width,
      canvasDimensions.height,
      viewState.zoom,
      { lineColor, lineWidth }
    );
  },

  /**
   * Render painted hexes
   */
  renderPaintedCells(
    ctx: CanvasRenderingContext2D,
    cells: RenderHexCell[],
    geometry: IHexRenderer,
    viewState: ViewState
  ): void {
    if (!cells || cells.length === 0) return;
    
    const previousAlpha = ctx.globalAlpha;

    for (const cell of cells) {
      // Apply opacity if specified (multiply with current globalAlpha)
      const opacity = cell.opacity ?? 1;
      if (opacity < 1) {
        ctx.globalAlpha = previousAlpha * opacity;
      }

      geometry.drawHex(
        ctx,
        cell.q,
        cell.r,
        viewState.x,
        viewState.y,
        viewState.zoom,
        cell.color
      );

      // Restore previous opacity
      if (opacity < 1) {
        ctx.globalAlpha = previousAlpha;
      }
    }
  },

  /**
   * Render smart borders for painted hexes
   * NOTE: Hex maps don't use smart borders like grid maps
   * This is a no-op for API consistency with gridRenderer
   */
  renderCellBorders(
    _ctx: CanvasRenderingContext2D,
    _cells: RenderHexCell[],
    _geometry: IHexRenderer,
    _viewState: ViewState,
    _buildCellLookup: BuildCellLookupFn<RenderHexCell>,
    _calculateBorders: CalculateBordersFn,
    _theme: BorderTheme
  ): void {
    // Hex rendering already draws complete hex shapes, no separate borders needed
    // This method exists for API consistency with gridRenderer
  },

  /**
   * Render selection highlight for a hex
   */
  renderCellHighlight(
    ctx: CanvasRenderingContext2D,
    cell: Point,
    geometry: IHexRenderer,
    viewState: ViewState,
    isResizeMode: boolean
  ): void {
    // Selection border (thicker for hex to be visible)
    // Use fillStyle since drawHexOutline now uses fill-based rendering
    ctx.fillStyle = isResizeMode ? '#ff6b6b' : '#4dabf7';
    const lineWidth = 3;
    
    // cell.x maps to q, cell.y maps to r for hex coordinates
    geometry.drawHexOutline(
      ctx,
      cell.x,
      cell.y,
      viewState.x,
      viewState.y,
      viewState.zoom,
      lineWidth
    );
  }
};

return { hexRenderer };
```

# cellAccessor

```ts
/**
 * cellAccessor.ts
 * 
 * Pure functions for cell data operations.
 * Provides a Point-based API that abstracts coordinate differences between
 * grid and hex geometries.
 * 
 * ABSTRACTION BOUNDARY:
 * - Public API uses Point {x, y} for all coordinate inputs/outputs
 * - Storage uses native formats: {x, y} for grid, {q, r} for hex
 * - This module handles translation between the two
 * 
 * Higher-level code (hooks, components) only sees Point.
 * Storage and geometry internals use native coordinates.
 * 
 * NOTE: Some functions are exported for API completeness even if not currently
 * used externally (normalizeCoords, getCellCoords, cellExists, removeCells, getCellFill).
 */

/* eslint-disable @typescript-eslint/no-unused-vars */

// Type-only imports - stripped at runtime
import type { Point } from '#types/core/geometry.types';
import type {
  Cell,
  GridCell,
  HexCell,
  SegmentGridCell,
  SegmentName,
  SegmentMap,
  CellMap,
  CellKey,
  CellUpdate,
  LocalCellPosition,
  AnyCoords
} from '#types/core/cell.types';
import type { IGeometry } from '#types/core/geometry.types';

// Re-export types for consumers
export type {
  Cell,
  GridCell,
  HexCell,
  SegmentGridCell,
  SegmentName,
  SegmentMap,
  CellMap,
  CellKey,
  CellUpdate,
  LocalCellPosition,
  Point
};

// Datacore imports
// Import geometry classes for instanceof checks
const { GridGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "GridGeometry")) as {
  GridGeometry: new (...args: unknown[]) => IGeometry
};
const { HexGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "HexGeometry")) as {
  HexGeometry: new (...args: unknown[]) => IGeometry
};

// Import segment constants
const { SEGMENT_NAMES } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants")) as {
  SEGMENT_NAMES: readonly SegmentName[]
};

// ============================================================================
// GEOMETRY TYPE DETECTION
// ============================================================================

/**
 * Check if geometry is grid-based (square cells)
 */
function isGridGeometry(geometry: IGeometry): boolean {
  return geometry instanceof GridGeometry;
}

/**
 * Check if geometry is hex-based
 */
function isHexGeometry(geometry: IGeometry): boolean {
  return geometry instanceof HexGeometry;
}

// ============================================================================
// TYPE GUARDS (re-implemented locally to avoid import issues at runtime)
// ============================================================================

/**
 * Check if cell is a grid cell (has x, y)
 */
function isGridCell(cell: Cell): cell is GridCell {
  return 'x' in cell && 'y' in cell;
}

/**
 * Check if cell is a hex cell (has q, r)
 */
function isHexCell(cell: Cell): cell is HexCell {
  return 'q' in cell && 'r' in cell;
}

/**
 * Check if cell has partial fill (segments)
 */
function hasSegments(cell: Cell): cell is SegmentGridCell {
  return isGridCell(cell) && 
    cell.segments !== undefined && 
    Object.keys(cell.segments).length > 0;
}

/**
 * Check if cell is a simple (full) cell
 */
function isSimpleCell(cell: Cell): boolean {
  return !hasSegments(cell);
}

// ============================================================================
// COORDINATE TRANSLATION (Internal)
// ============================================================================

/**
 * Convert Point to native storage format based on geometry.
 * Grid: {x, y}, Hex: {q, r}
 */
function pointToNative(point: Point, geometry: IGeometry): { x: number; y: number } | { q: number; r: number } {
  if (isGridGeometry(geometry)) {
    return { x: point.x, y: point.y };
  }
  return { q: point.x, r: point.y };
}

/**
 * Convert native cell coordinates to Point.
 */
function cellToPoint(cell: Cell): Point {
  if (isGridCell(cell)) {
    return { x: cell.x, y: cell.y };
  }
  return { x: cell.q, y: cell.r };
}

/**
 * Normalize any coordinate format to Point.
 */
function normalizeToPoint(coords: AnyCoords): Point {
  return {
    x: coords.x ?? coords.gridX ?? coords.q ?? coords.col ?? 0,
    y: coords.y ?? coords.gridY ?? coords.r ?? coords.row ?? 0
  };
}

/**
 * Normalize any coordinate format to native storage format.
 */
function normalizeCoords(coords: AnyCoords, geometry: IGeometry): { x: number; y: number } | { q: number; r: number } {
  const point = normalizeToPoint(coords);
  return pointToNative(point, geometry);
}

// ============================================================================
// CELL KEY GENERATION
// ============================================================================

/**
 * Generate a stable string key for cell lookup.
 * Uses Point coordinates for consistency.
 */
function cellKey(coords: Point, geometry: IGeometry): CellKey {
  if (isGridGeometry(geometry)) {
    return `${coords.x},${coords.y}`;
  }
  return `${coords.x},${coords.y}`;  // Same format, geometry interprets meaning
}

/**
 * Get cell key from a cell object.
 */
function cellKeyFromCell(cell: Cell, geometry: IGeometry): CellKey {
  return cellKey(cellToPoint(cell), geometry);
}

/**
 * Extract coordinates from a cell as Point.
 */
function getCellCoords(cell: Cell, _geometry: IGeometry): Point {
  return cellToPoint(cell);
}

// ============================================================================
// CELL QUERY
// ============================================================================

/**
 * Find cell at coordinates.
 * @param coords - Point coordinates
 * @returns Cell or null if not found
 */
function getCellAt(cells: Cell[], coords: Point, geometry: IGeometry): Cell | null {
  return cells.find(cell => geometry.cellMatchesCoords(cell, coords)) || null;
}

/**
 * Get index of cell at coordinates.
 */
function getCellIndex(cells: Cell[], coords: Point, geometry: IGeometry): number {
  return cells.findIndex(cell => geometry.cellMatchesCoords(cell, coords));
}

/**
 * Check if cell exists at coordinates.
 */
function cellExists(cells: Cell[], coords: Point, geometry: IGeometry): boolean {
  return getCellIndex(cells, coords, geometry) !== -1;
}

/**
 * Build lookup map for O(1) cell queries.
 */
function buildCellMap(cells: Cell[], geometry: IGeometry): CellMap {
  const map: CellMap = new Map();
  for (const cell of cells) {
    map.set(cellKeyFromCell(cell, geometry), cell);
  }
  return map;
}

// ============================================================================
// CELL MODIFICATION (Immutable - returns new arrays)
// ============================================================================

/**
 * Set cell color/opacity at coordinates (add or update).
 * @param coords - Point coordinates
 * @returns New cells array
 */
function setCell(
  cells: Cell[],
  coords: Point,
  color: string,
  opacity: number,
  geometry: IGeometry
): Cell[] {
  const index = getCellIndex(cells, coords, geometry);
  
  if (index !== -1) {
    // Update existing cell
    const newCells = [...cells];
    newCells[index] = { ...newCells[index], color, opacity };
    return newCells;
  }
  
  // Create new cell using geometry's factory method
  const newCell = geometry.createCellObject(coords, color);
  newCell.opacity = opacity;
  return [...cells, newCell];
}

/**
 * Remove cell at coordinates.
 * @param coords - Point coordinates
 * @returns New cells array with cell removed
 */
function removeCell(cells: Cell[], coords: Point, geometry: IGeometry): Cell[] {
  return cells.filter(cell => !geometry.cellMatchesCoords(cell, coords));
}

/**
 * Batch set multiple cells (more efficient than repeated setCell).
 * @param cellUpdates - Array of {coords: Point, color, opacity}
 * @returns New cells array with all updates applied
 */
function setCells(
  cells: Cell[],
  cellUpdates: CellUpdate[],
  geometry: IGeometry
): Cell[] {
  // Build map of existing cells for O(1) lookup
  const cellMap: CellMap = new Map();
  for (const cell of cells) {
    cellMap.set(cellKeyFromCell(cell, geometry), cell);
  }
  
  // Apply all updates
  for (const update of cellUpdates) {
    const key = cellKey(update.coords, geometry);
    const existing = cellMap.get(key);
    
    if (existing) {
      // Update existing cell
      cellMap.set(key, { ...existing, color: update.color, opacity: update.opacity });
    } else {
      // Create new cell
      const newCell = geometry.createCellObject(update.coords, update.color);
      newCell.opacity = update.opacity;
      cellMap.set(key, newCell);
    }
  }
  
  return Array.from(cellMap.values());
}

/**
 * Remove multiple cells by coordinates.
 * @param coordsList - Array of Point coordinates to remove
 */
function removeCells(
  cells: Cell[],
  coordsList: Point[],
  geometry: IGeometry
): Cell[] {
  const removeKeys = new Set(coordsList.map(c => cellKey(c, geometry)));
  return cells.filter(cell => !removeKeys.has(cellKeyFromCell(cell, geometry)));
}

/**
 * Remove cells within a rectangular bounds.
 */
function removeCellsInBounds(
  cells: Cell[],
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  _geometry: IGeometry
): Cell[] {
  const minX = Math.min(x1, x2);
  const maxX = Math.max(x1, x2);
  const minY = Math.min(y1, y2);
  const maxY = Math.max(y1, y2);
  
  return cells.filter(cell => {
    const p = cellToPoint(cell);
    return !(p.x >= minX && p.x <= maxX && p.y >= minY && p.y <= maxY);
  });
}

// ============================================================================
// SEGMENT SUPPORT - Partial cell painting (Grid only)
// ============================================================================

/**
 * Get fill color for cell (handles both simple and segment cells).
 */
function getCellFill(cell: Cell | null): string | null {
  if (!cell) return null;
  return cell.color;
}

/**
 * Get array of filled segment names for a cell.
 * Simple cells return all 8 segments; segment cells return only filled ones.
 */
function getFilledSegments(cell: Cell | null): SegmentName[] {
  if (!cell) return [];
  if (isSimpleCell(cell)) {
    // Simple cell = all 8 segments filled
    return [...SEGMENT_NAMES];
  }
  if (hasSegments(cell)) {
    return Object.keys(cell.segments).filter(
      seg => cell.segments[seg as SegmentName]
    ) as SegmentName[];
  }
  return [];
}

/**
 * Normalize cell by collapsing full segment cells to simple cells.
 * If all 8 segments are filled, convert to simple cell.
 * If no segments are filled, return null (cell should be removed).
 */
function normalizeCell(cell: Cell): Cell | null {
  if (!cell) return cell;
  
  if (hasSegments(cell)) {
    const filledCount = Object.keys(cell.segments).filter(
      seg => cell.segments[seg as SegmentName]
    ).length;
    
    if (filledCount === 8) {
      // All segments filled - collapse to simple cell
      const { segments, ...simpleCell } = cell;
      return simpleCell as Cell;
    }
    
    if (filledCount === 0) {
      // No segments filled - remove cell
      return null;
    }
  }
  
  return cell;
}

/**
 * Set segments on a cell (add or update).
 * Grid-only feature - warns and returns unchanged for hex.
 * Auto-collapses to simple cell if all 8 segments are filled.
 * 
 * @param coords - Point coordinates
 * @param segmentList - Array of segment names to fill
 */
function setSegments(
  cells: Cell[],
  coords: Point,
  segmentList: SegmentName[],
  color: string,
  opacity: number,
  geometry: IGeometry
): Cell[] {
  // Grid-only feature check
  if (!isGridGeometry(geometry)) {
    console.warn('setSegments: Segment painting is only supported for grid maps');
    return cells;
  }
  
  const index = getCellIndex(cells, coords, geometry);
  
  if (index !== -1) {
    // Cell exists - update it
    const existingCell = cells[index] as GridCell;
    const newCells = [...cells];
    
    if (isSimpleCell(existingCell)) {
      // Simple cell - if adding all 8 segments, just update color
      if (segmentList.length === 8) {
        newCells[index] = { ...existingCell, color, opacity };
        return newCells;
      }
      // Otherwise just update color (painting on simple cell doesn't remove segments)
      newCells[index] = { ...existingCell, color, opacity };
      return newCells;
    }
    
    // Existing segment cell - merge segments and update color
    const segmentCell = existingCell as SegmentGridCell;
    const mergedSegments: SegmentMap = { ...segmentCell.segments };
    for (const seg of segmentList) {
      if (SEGMENT_NAMES.includes(seg)) {
        mergedSegments[seg] = true;
      }
    }
    
    let newCell: Cell = { ...segmentCell, segments: mergedSegments, color, opacity };
    const normalized = normalizeCell(newCell);
    
    if (normalized === null) {
      // All segments removed - remove cell entirely
      return cells.filter((_, i) => i !== index);
    }
    
    newCells[index] = normalized;
    return newCells;
  }
  
  // Cell doesn't exist - create new segment cell
  const newSegments: SegmentMap = {};
  for (const seg of segmentList) {
    if (SEGMENT_NAMES.includes(seg)) {
      newSegments[seg] = true;
    }
  }
  
  // If all 8 segments, create simple cell instead
  if (Object.keys(newSegments).length === 8) {
    const simpleCell: GridCell = { x: coords.x, y: coords.y, color, opacity };
    return [...cells, simpleCell];
  }
  
  // Create segment cell
  if (Object.keys(newSegments).length === 0) {
    return cells; // No valid segments to add
  }
  
  const segmentCell: SegmentGridCell = { 
    x: coords.x, 
    y: coords.y, 
    segments: newSegments, 
    color, 
    opacity 
  };
  return [...cells, segmentCell];
}

/**
 * Remove segments from a cell.
 * If all segments are removed, removes the cell entirely.
 * 
 * @param coords - Point coordinates
 * @param segmentList - Array of segment names to remove
 */
function removeSegments(
  cells: Cell[],
  coords: Point,
  segmentList: SegmentName[],
  geometry: IGeometry
): Cell[] {
  // Grid-only feature check
  if (!isGridGeometry(geometry)) {
    console.warn('removeSegments: Segment painting is only supported for grid maps');
    return cells;
  }
  
  const index = getCellIndex(cells, coords, geometry);
  if (index === -1) return cells; // Cell doesn't exist
  
  const existingCell = cells[index] as GridCell;
  const newCells = [...cells];
  
  if (isSimpleCell(existingCell)) {
    // Simple cell - convert to segment cell with specified segments removed
    const remainingSegments: SegmentMap = {};
    for (const seg of SEGMENT_NAMES) {
      if (!segmentList.includes(seg)) {
        remainingSegments[seg] = true;
      }
    }
    
    if (Object.keys(remainingSegments).length === 0) {
      // All segments removed - remove cell
      return cells.filter((_, i) => i !== index);
    }
    
    // Create segment cell with remaining segments
    const segmentCell: SegmentGridCell = { 
      x: existingCell.x,
      y: existingCell.y,
      segments: remainingSegments, 
      color: existingCell.color, 
      opacity: existingCell.opacity ?? 1 
    };
    newCells[index] = segmentCell;
    return newCells;
  }
  
  // Existing segment cell - remove specified segments
  const segmentCell = existingCell as SegmentGridCell;
  const updatedSegments: SegmentMap = { ...segmentCell.segments };
  for (const seg of segmentList) {
    delete updatedSegments[seg];
  }
  
  if (Object.keys(updatedSegments).length === 0) {
    // All segments removed - remove cell
    return cells.filter((_, i) => i !== index);
  }
  
  newCells[index] = { ...segmentCell, segments: updatedSegments };
  return newCells;
}

/**
 * Check if neighbor segment is filled (for border calculation).
 * 
 * @param cellMap - Cell lookup map from buildCellMap
 * @param coords - Point coordinates of neighbor cell
 * @param segment - Segment name to check
 */
function neighborSegmentFilled(
  cellMap: CellMap,
  coords: Point,
  segment: SegmentName,
  geometry: IGeometry
): boolean {
  const key = cellKey(coords, geometry);
  const neighbor = cellMap.get(key);
  
  if (!neighbor) return false;
  if (isSimpleCell(neighbor)) return true; // Simple cell = all segments filled
  if (hasSegments(neighbor)) return !!neighbor.segments[segment];
  
  return false;
}

/**
 * Determine which segment a point falls into based on position within a cell.
 * Uses angle from center to determine which of 8 pie-slice segments contains the point.
 * 
 * @param localX - X position within cell (0 to 1, where 0.5 is center)
 * @param localY - Y position within cell (0 to 1, where 0.5 is center)
 */
function getSegmentAtPosition(localX: number, localY: number): SegmentName {
  // Calculate position relative to center
  const dx = localX - 0.5;
  const dy = localY - 0.5;
  
  // Get angle in degrees (0 = right, counterclockwise)
  let angle = Math.atan2(-dy, dx) * (180 / Math.PI);
  if (angle < 0) angle += 360;
  
  // Map angle to segment (each segment is 45)
  if (angle >= 337.5 || angle < 22.5) return 'e';
  if (angle >= 22.5 && angle < 67.5) return 'ne';
  if (angle >= 67.5 && angle < 112.5) return 'n';
  if (angle >= 112.5 && angle < 157.5) return 'nw';
  if (angle >= 157.5 && angle < 202.5) return 'w';
  if (angle >= 202.5 && angle < 247.5) return 'sw';
  if (angle >= 247.5 && angle < 292.5) return 's';
  if (angle >= 292.5 && angle < 337.5) return 'se';
  
  return 'n'; // Fallback
}

/**
 * Calculate local position within a cell from screen coordinates.
 * Returns values from 0 to 1 where (0,0) is top-left and (1,1) is bottom-right.
 */
function getLocalCellPosition(
  screenX: number,
  screenY: number,
  cellScreenX: number,
  cellScreenY: number,
  cellSize: number
): LocalCellPosition {
  const localX = (screenX - cellScreenX) / cellSize;
  const localY = (screenY - cellScreenY) / cellSize;
  
  return {
    localX: Math.max(0, Math.min(1, localX)),
    localY: Math.max(0, Math.min(1, localY))
  };
}

// ============================================================================
// EXPORTS
// ============================================================================

return {
  // Geometry type detection
  isGridGeometry,
  isHexGeometry,
  
  // Type guards
  isGridCell,
  isHexCell,
  hasSegments,
  isSimpleCell,
  
  // Coordinate utilities
  normalizeCoords,
  normalizeToPoint,
  cellKey,
  cellKeyFromCell,
  getCellCoords,
  cellToPoint,
  
  // Query functions
  getCellAt,
  getCellIndex,
  cellExists,
  buildCellMap,
  
  // Modification functions (immutable)
  setCell,
  removeCell,
  setCells,
  removeCells,
  removeCellsInBounds,
  
  // Segment support (partial cell painting)
  getCellFill,
  getFilledSegments,
  normalizeCell,
  setSegments,
  removeSegments,
  neighborSegmentFilled,
  getSegmentAtPosition,
  getLocalCellPosition
};
```

# segmentBorderCalculator

```ts
/**
 * segmentBorderCalculator.ts
 * 
 * Border calculation for segment-based cells (partial cell painting).
 * Determines which borders need to be drawn based on:
 * - Internal edges: Where filled segments meet empty segments within a cell
 * - External edges: Where filled segments meet empty space in adjacent cells
 * 
 * PRINCIPLE: Draw borders wherever filled meets empty.
 */

// Type-only imports
import type { Point } from '#types/core/geometry.types';
import type { SegmentGridCell, Cell, CellMap, SegmentName } from '#types/core/cell.types';
import type { IGridRenderer } from '#types/core/rendering.types';
import type {
  VertexName,
  InternalEdgeKey,
  CrossCellAdjacency
} from '../utils/dmtConstants';

// Datacore imports
const { 
  SEGMENT_NAMES,
  SEGMENT_INTERNAL_ADJACENCY,
  SEGMENT_CROSS_CELL_ADJACENCY
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants")) as {
  SEGMENT_NAMES: readonly SegmentName[];
  SEGMENT_INTERNAL_ADJACENCY: Record<InternalEdgeKey, [SegmentName, SegmentName]>;
  SEGMENT_CROSS_CELL_ADJACENCY: Record<SegmentName, CrossCellAdjacency>;
};

const { 
  hasSegments, 
  isSimpleCell, 
  getFilledSegments,
  buildCellMap,
  cellKey,
  neighborSegmentFilled
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "cellAccessor")) as {
  hasSegments: (cell: Cell) => cell is SegmentGridCell;
  isSimpleCell: (cell: Cell) => boolean;
  getFilledSegments: (cell: Cell) => SegmentName[];
  buildCellMap: (cells: Cell[], geometry: IGridRenderer) => CellMap;
  cellKey: (x: number, y: number) => string;
  neighborSegmentFilled: (cellMap: CellMap, coords: Point, segment: SegmentName, geometry: IGridRenderer) => boolean;
};

// ===========================================
// Local Type Definitions
// ===========================================

/** Internal border edge (center to boundary point) */
export interface InternalBorder {
  from: string;
  to: string;
}

/** External border edge (along cell boundary) */
export interface ExternalBorder {
  segment: SegmentName;
  neighborSegment: SegmentName;
}

/** Combined border calculation result */
export interface SegmentBorders {
  internal: InternalBorder[];
  external: ExternalBorder[];
}

// ============================================================================
// INTERNAL BORDER CALCULATION
// ============================================================================

/**
 * Calculate which internal borders need to be drawn for a segment cell.
 * Internal borders are lines from center to boundary points where
 * filled segments meet empty segments within the same cell.
 */
function getInternalBorders(cell: SegmentGridCell): InternalBorder[] {
  const borders: InternalBorder[] = [];
  const filledSet = new Set(getFilledSegments(cell));
  
  // Check each internal edge (center to boundary point)
  for (const [edgeKey, [seg1, seg2]] of Object.entries(SEGMENT_INTERNAL_ADJACENCY)) {
    const seg1Filled = filledSet.has(seg1);
    const seg2Filled = filledSet.has(seg2);
    
    // Draw border if one is filled and other is empty
    if (seg1Filled !== seg2Filled) {
      // Edge key is like "C-TL", split to get vertex names
      const [from, to] = edgeKey.split('-');
      borders.push({ from, to });
    }
  }
  
  return borders;
}

// ============================================================================
// EXTERNAL BORDER CALCULATION
// ============================================================================

/**
 * Calculate which external borders need to be drawn for a segment cell.
 * External borders are along cell edges where a filled segment has no
 * filled neighbor segment in the adjacent cell.
 * 
 * Border is drawn when:
 * - No neighbor cell exists, OR
 * - Neighbor is segment cell AND adjacent segment is empty
 * 
 * No border when:
 * - Neighbor is simple (full) cell, OR
 * - Neighbor is segment cell AND adjacent segment is filled
 */
function getExternalBorders(
  cell: SegmentGridCell,
  cellMap: CellMap,
  geometry: IGridRenderer
): ExternalBorder[] {
  const borders: ExternalBorder[] = [];
  const filledSegments = getFilledSegments(cell);
  
  for (const segment of filledSegments) {
    const adjacency = SEGMENT_CROSS_CELL_ADJACENCY[segment];
    const neighborX = cell.x + adjacency.dx;
    const neighborY = cell.y + adjacency.dy;
    
    // Check if neighbor segment is filled (using Point-based API)
    const neighborFilled = neighborSegmentFilled(
      cellMap, 
      { x: neighborX, y: neighborY }, 
      adjacency.neighborSegment, 
      geometry
    );
    
    // Need border if neighbor segment is not filled
    if (!neighborFilled) {
      borders.push({ segment, neighborSegment: adjacency.neighborSegment });
    }
  }
  
  return borders;
}

// ============================================================================
// COMBINED BORDER CALCULATION
// ============================================================================

/**
 * Get all borders (internal + external) for a segment cell
 */
function getSegmentBorders(
  cell: SegmentGridCell,
  cellMap: CellMap,
  geometry: IGridRenderer
): SegmentBorders {
  return {
    internal: getInternalBorders(cell),
    external: getExternalBorders(cell, cellMap, geometry)
  };
}

// ============================================================================
// EXPORTS
// ============================================================================

return {
  // Main API
  getSegmentBorders,
  getInternalBorders,
  getExternalBorders
};
```

# segmentRenderer

```ts
/**
 * segmentRenderer.ts
 * 
 * Renders segment-based cells (partial cell painting with 8-triangle subdivision).
 * Segment cells use triangular regions radiating from the cell center to allow
 * diagonal walls, angled corridors, and organic dungeon shapes.
 * 
 * ARCHITECTURE NOTES:
 * - Designed for future optimization (caching, batching by color)
 * - Currently renders each segment as individual triangle path
 * - Performance: Profile before optimizing - triangles are fast in modern browsers
 * 
 * COORDINATE SYSTEM:
 * - Cell origin is top-left corner
 * - Segments radiate from center point
 * - Triangle vertices defined by SEGMENT_VERTICES ratios
 */

// Type-only imports
import type { Point } from '#types/core/geometry.types';
import type { SegmentGridCell, Cell, CellMap, SegmentName } from '#types/core/cell.types';
import type { ViewState, BorderTheme, IGridRenderer } from '#types/core/rendering.types';
import type {
  VertexName,
  VertexRatio
} from '../utils/dmtConstants';

// Datacore imports
const { 
  SEGMENT_VERTICES, 
  SEGMENT_TRIANGLES
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants")) as {
  SEGMENT_VERTICES: Record<VertexName, VertexRatio>;
  SEGMENT_TRIANGLES: Record<SegmentName, [VertexName, VertexName, VertexName]>;
};

const { 
  hasSegments,
  buildCellMap
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "cellAccessor")) as {
  hasSegments: (cell: Cell) => cell is SegmentGridCell;
  buildCellMap: (cells: Cell[], geometry: IGridRenderer) => CellMap;
};

const {
  getInternalBorders,
  getExternalBorders
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "segmentBorderCalculator")) as {
  getInternalBorders: (cell: SegmentGridCell) => InternalBorder[];
  getExternalBorders: (cell: SegmentGridCell, cellMap: CellMap, geometry: IGridRenderer) => ExternalBorder[];
};

// ===========================================
// Local Type Definitions
// ===========================================

/** Pre-calculated vertex positions for a cell */
interface CellVertices {
  [key: string]: Point;
}

/** Internal border edge (center to boundary point) */
interface InternalBorder {
  from: VertexName;
  to: VertexName;
}

/** External border edge (along cell boundary) */
interface ExternalBorder {
  segment: SegmentName;
  neighborSegment: SegmentName;
}

/** Result of separating cells by type */
interface SeparatedCells {
  simpleCells: Cell[];
  segmentCells: SegmentGridCell[];
}

// ============================================================================
// TRIANGLE GEOMETRY HELPERS
// ============================================================================

/**
 * Calculate actual pixel coordinates for a vertex within a cell
 */
function getVertexPosition(
  vertexName: VertexName,
  screenX: number,
  screenY: number,
  cellSize: number
): Point {
  const vertex = SEGMENT_VERTICES[vertexName];
  return {
    x: screenX + vertex.xRatio * cellSize,
    y: screenY + vertex.yRatio * cellSize
  };
}

/**
 * Get all vertex positions for a cell
 * Cached calculation for efficiency when rendering multiple segments
 */
function getCellVertices(
  screenX: number,
  screenY: number,
  cellSize: number
): CellVertices {
  const vertices: CellVertices = {};
  for (const [name, ratios] of Object.entries(SEGMENT_VERTICES)) {
    vertices[name] = {
      x: screenX + ratios.xRatio * cellSize,
      y: screenY + ratios.yRatio * cellSize
    };
  }
  return vertices;
}

/**
 * Draw a single triangle segment as part of a path (no fill - caller handles fill)
 */
function addTriangleToPath(
  ctx: CanvasRenderingContext2D,
  vertices: CellVertices,
  segmentName: SegmentName
): void {
  const [v1Name, v2Name, v3Name] = SEGMENT_TRIANGLES[segmentName];
  const v1 = vertices[v1Name];
  const v2 = vertices[v2Name];
  const v3 = vertices[v3Name];
  
  ctx.moveTo(v1.x, v1.y);
  ctx.lineTo(v2.x, v2.y);
  ctx.lineTo(v3.x, v3.y);
  ctx.closePath();
}

/**
 * Draw a single triangle segment (standalone, with fill)
 */
function drawTriangle(
  ctx: CanvasRenderingContext2D,
  vertices: CellVertices,
  segmentName: SegmentName
): void {
  ctx.beginPath();
  addTriangleToPath(ctx, vertices, segmentName);
  ctx.fill();
}

// ============================================================================
// SEGMENT CELL RENDERING
// ============================================================================

/**
 * Render a single segment cell
 * Uses a single combined path for all filled segments to avoid anti-aliasing
 * gaps between adjacent triangles.
 */
function renderSegmentCell(
  ctx: CanvasRenderingContext2D,
  cell: SegmentGridCell,
  geometry: IGridRenderer,
  viewState: ViewState
): void {
  const cellSize = geometry.getScaledCellSize(viewState.zoom);
  const { screenX, screenY } = geometry.gridToScreen(
    cell.x, cell.y, 
    viewState.x, viewState.y, 
    viewState.zoom
  );
  
  // Pre-calculate all vertices for this cell
  const vertices = getCellVertices(screenX, screenY, cellSize);
  
  // Set fill style
  ctx.fillStyle = cell.color;
  const opacity = cell.opacity ?? 1;
  const previousAlpha = ctx.globalAlpha;
  if (opacity < 1) {
    ctx.globalAlpha = previousAlpha * opacity;
  }

  // Build a single combined path for all filled segments
  // This eliminates anti-aliasing gaps between adjacent triangles
  const filledSegments = (Object.keys(cell.segments) as SegmentName[]).filter(
    seg => cell.segments[seg]
  );

  ctx.beginPath();
  for (const segmentName of filledSegments) {
    addTriangleToPath(ctx, vertices, segmentName);
  }
  ctx.fill();

  // Restore previous opacity
  if (opacity < 1) {
    ctx.globalAlpha = previousAlpha;
  }
}

/**
 * Render all segment cells
 * 
 * OPTIMIZATION HOOKS (for future):
 * - Could batch by color to reduce fillStyle changes
 * - Could cache vertex calculations for static cells
 * - Could use Path2D objects for complex patterns
 */
function renderSegmentCells(
  ctx: CanvasRenderingContext2D,
  cells: SegmentGridCell[],
  geometry: IGridRenderer,
  viewState: ViewState
): void {
  if (!cells || cells.length === 0) return;
  
  // FUTURE OPTIMIZATION: Could group by color here and batch
  // For now, render individually (profile before optimizing)
  
  for (const cell of cells) {
    renderSegmentCell(ctx, cell, geometry, viewState);
  }
}

// ============================================================================
// SEGMENT BORDER RENDERING
// ============================================================================

/**
 * Draw an internal border line (center to boundary point)
 * These are diagonal lines showing where filled segments meet empty segments
 * within the same cell (e.g., TLCenterBR for a diagonal fill).
 * Uses fillRect for iOS compatibility (same as existing border rendering)
 */
function drawInternalBorder(
  ctx: CanvasRenderingContext2D,
  vertices: CellVertices,
  fromVertex: string,
  toVertex: string,
  borderWidth: number
): void {
  const from = vertices[fromVertex];
  const to = vertices[toVertex];
  
  // Calculate line as a thin filled rectangle
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const length = Math.sqrt(dx * dx + dy * dy);
  
  if (length === 0) return;
  
  // Perpendicular direction for width
  const perpX = -dy / length;
  const perpY = dx / length;
  const halfWidth = borderWidth / 2;
  
  // Draw as polygon (rotated rectangle)
  ctx.beginPath();
  ctx.moveTo(from.x + perpX * halfWidth, from.y + perpY * halfWidth);
  ctx.lineTo(to.x + perpX * halfWidth, to.y + perpY * halfWidth);
  ctx.lineTo(to.x - perpX * halfWidth, to.y - perpY * halfWidth);
  ctx.lineTo(from.x - perpX * halfWidth, from.y - perpY * halfWidth);
  ctx.closePath();
  ctx.fill();
}

/**
 * Draw an external border segment (along cell edge)
 * External borders are half-edge length since each segment only touches
 * half of a cell edge.
 */
function drawExternalBorder(
  ctx: CanvasRenderingContext2D,
  vertices: CellVertices,
  segmentName: SegmentName,
  borderWidth: number
): void {
  // Get the two boundary vertices for this segment (excluding center)
  const [, v1Name, v2Name] = SEGMENT_TRIANGLES[segmentName];
  
  // One of these vertices is a corner, one is a midpoint
  // The external edge runs from the midpoint to the corner (or corner to midpoint)
  // that is NOT shared with an adjacent segment's external edge
  
  // For external borders, we draw from the midpoint vertex to the corner vertex
  // The midpoint is always one of: TM, RM, BM, LM
  // The corner is always one of: TL, TR, BR, BL
  
  const v1 = vertices[v1Name];
  const v2 = vertices[v2Name];
  
  // Draw border line as rectangle
  const dx = v2.x - v1.x;
  const dy = v2.y - v1.y;
  const length = Math.sqrt(dx * dx + dy * dy);
  
  if (length === 0) return;
  
  const perpX = -dy / length;
  const perpY = dx / length;
  const halfWidth = borderWidth / 2;
  
  ctx.beginPath();
  ctx.moveTo(v1.x + perpX * halfWidth, v1.y + perpY * halfWidth);
  ctx.lineTo(v2.x + perpX * halfWidth, v2.y + perpY * halfWidth);
  ctx.lineTo(v2.x - perpX * halfWidth, v2.y - perpY * halfWidth);
  ctx.lineTo(v1.x - perpX * halfWidth, v1.y - perpY * halfWidth);
  ctx.closePath();
  ctx.fill();
}

/**
 * Render borders for all segment cells
 */
function renderSegmentBorders(
  ctx: CanvasRenderingContext2D,
  segmentCells: SegmentGridCell[],
  allCells: Cell[],
  geometry: IGridRenderer,
  viewState: ViewState,
  theme: BorderTheme
): void {
  if (!segmentCells || segmentCells.length === 0) return;
  
  const cellSize = geometry.getScaledCellSize(viewState.zoom);
  const cellMap = buildCellMap(allCells, geometry);
  const borderWidth = theme.borderWidth || 2;
  
  ctx.fillStyle = theme.border;
  
  for (const cell of segmentCells) {
    const { screenX, screenY } = geometry.gridToScreen(
      cell.x, cell.y,
      viewState.x, viewState.y,
      viewState.zoom
    );
    
    const vertices = getCellVertices(screenX, screenY, cellSize);
    
    // Draw internal borders (diagonal lines where filled meets empty within cell)
    // These create the diagonal boundaries like TLCenterBR
    const internalBorders = getInternalBorders(cell);
    for (const { from, to } of internalBorders) {
      drawInternalBorder(ctx, vertices, from, to, borderWidth);
    }
    
    // Draw external borders (at cell edges where segments meet empty neighbors)
    const externalBorders = getExternalBorders(cell, cellMap, geometry);
    for (const { segment } of externalBorders) {
      drawExternalBorder(ctx, vertices, segment, borderWidth);
    }
  }
}

// ============================================================================
// CELL FILTERING UTILITIES
// ============================================================================

/**
 * Separate cells into simple and segment cells
 */
function separateCellsByType(cells: Cell[]): SeparatedCells {
  const simpleCells: Cell[] = [];
  const segmentCells: SegmentGridCell[] = [];
  
  for (const cell of cells) {
    if (hasSegments(cell)) {
      segmentCells.push(cell);
    } else {
      simpleCells.push(cell);
    }
  }
  
  return { simpleCells, segmentCells };
}

// ============================================================================
// EXPORTS
// ============================================================================

const segmentRenderer = {
  // Main rendering functions
  renderSegmentCells,
  renderSegmentBorders,
  
  // Cell filtering
  separateCellsByType,
  
  // Lower-level functions (exposed for testing/debugging)
  renderSegmentCell,
  getCellVertices,
  drawTriangle
};

// Export types for consumers
export type {
  CellVertices,
  InternalBorder,
  ExternalBorder,
  SeparatedCells
};

return { segmentRenderer };
```

# useCanvasRenderer

```ts
/**
 * useCanvasRenderer.ts
 *
 * Canvas rendering hook and utilities for the map canvas.
 * Handles grid, cells, objects, text labels, fog of war, and selections.
 */

// Type-only imports
import type { MapData, MapLayer, ViewState } from '#types/core/map.types';
import type { IGeometry, Point } from '#types/core/geometry.types';
import type { Cell, CellMap } from '#types/core/cell.types';
import type { MapObject, ObjectTypeDef } from '#types/objects/object.types';
import type { TextLabel } from '#types/objects/note.types';
import type {
  RenderCanvas,
  UseCanvasRenderer,
  RendererSelectedItem,
  LayerVisibility,
  RendererTheme,
  RendererViewState,
} from '#types/hooks/canvasRenderer.types';

// Datacore imports
const { getTheme, getEffectiveSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsAccessor")) as {
  getTheme: () => RendererTheme;
  getEffectiveSettings: (settings: MapData['settings']) => Record<string, unknown>;
};
const { buildCellLookup, calculateBordersOptimized } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "borderCalculator")) as {
  buildCellLookup: (cells: Cell[]) => CellMap;
  calculateBordersOptimized: (cell: Cell, lookup: CellMap) => { top: boolean; right: boolean; bottom: boolean; left: boolean };
};
const { getObjectType } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "objectOperations")) as {
  getObjectType: (typeId: string) => ObjectTypeDef | null;
};
const { getRenderChar } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "objectTypeResolver")) as {
  getRenderChar: (objType: ObjectTypeDef) => { char: string; isIcon: boolean };
};
const { getCellColor } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "colorOperations")) as {
  getCellColor: (cell: Cell) => string;
};
const { renderNoteLinkBadge, renderTooltipIndicator, renderObjectLinkIndicator } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "badgeRenderer")) as {
  renderNoteLinkBadge: (ctx: CanvasRenderingContext2D, position: { screenX: number; screenY: number; objectWidth: number; objectHeight: number }, config: { scaledSize: number }) => void;
  renderTooltipIndicator: (ctx: CanvasRenderingContext2D, position: { screenX: number; screenY: number; objectWidth: number; objectHeight: number }, config: { scaledSize: number }) => void;
  renderObjectLinkIndicator: (ctx: CanvasRenderingContext2D, position: { screenX: number; screenY: number; objectWidth: number; objectHeight: number }, config: { scaledSize: number }) => void;
};
const { renderTextLabels } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "textLabelRenderer")) as {
  renderTextLabels: (labels: TextLabel[], context: { ctx: CanvasRenderingContext2D; zoom: number; getFontCss: (fontFace: string) => string }, geometry: { worldToScreen: (x: number, y: number, offsetX: number, offsetY: number, zoom: number) => { screenX: number; screenY: number } }, viewState: { offsetX: number; offsetY: number; zoom: number }) => void;
};
const { renderHexBackgroundImage } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "backgroundRenderer")) as {
  renderHexBackgroundImage: (bgImage: HTMLImageElement, config: { path: string; offsetX?: number; offsetY?: number; opacity?: number }, hexBounds: { maxCol: number; maxRow: number }, hexGeometry: { hexSize: number; sqrt3: number; hexToWorld: (q: number, r: number) => { worldX: number; worldY: number } }, orientation: string, context: { ctx: CanvasRenderingContext2D; offsetX: number; offsetY: number; zoom: number }, offsetToAxial: (col: number, row: number, orientation: string) => { q: number; r: number }) => void;
};
const { renderGridFog } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "gridFogRenderer")) as {
  renderGridFog: (fogCells: Array<{ col: number; row: number }>, context: { ctx: CanvasRenderingContext2D; fogCtx: CanvasRenderingContext2D | null; offsetX: number; offsetY: number; scaledSize: number }, options: { fowOpacity: number; fowBlurEnabled: boolean; blurRadius: number; useGlobalAlpha: boolean }, visibleBounds: { minCol: number; maxCol: number; minRow: number; maxRow: number }, zoom: number) => void;
};
const { renderHexFog } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "hexFogRenderer")) as {
  renderHexFog: (fogCells: Array<{ col: number; row: number }>, context: { ctx: CanvasRenderingContext2D; fogCtx: CanvasRenderingContext2D | null; offsetX: number; offsetY: number; zoom: number }, options: { fowOpacity: number; fowBlurEnabled: boolean; blurRadius: number; useGlobalAlpha: boolean }, visibleBounds: { minCol: number; maxCol: number; minRow: number; maxRow: number }, hexGeometry: { hexSize: number; getHexVertices: (q: number, r: number) => Array<{ worldX: number; worldY: number }>; hexToWorld: (q: number, r: number) => { worldX: number; worldY: number }; getNeighbors: (q: number, r: number) => Array<{ q: number; r: number }> }, geometry: { worldToScreen: (worldX: number, worldY: number, offsetX: number, offsetY: number, zoom: number) => { screenX: number; screenY: number } }, orientation: string, offsetToAxial: (col: number, row: number, orientation: string) => { q: number; r: number }, axialToOffset: (q: number, r: number, orientation: string) => { col: number; row: number }) => void;
};
const { getFogSettings, clearFogCanvas, renderFog } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "fogRenderer")) as {
  getFogSettings: (effectiveSettings: Record<string, unknown>) => { fowColor: string; fowOpacity: number; fowImagePath?: string; fowBlurEnabled: boolean; fowBlurFactor: number };
  clearFogCanvas: (fogCanvas: HTMLCanvasElement | null) => void;
  renderFog: (fow: { enabled: boolean; foggedCells?: Array<{ col: number; row: number }> }, context: { ctx: CanvasRenderingContext2D; fogCanvas: HTMLCanvasElement | null; width: number; height: number; offsetX: number; offsetY: number; zoom: number; scaledSize: number; northDirection: number }, settings: { fowColor: string; fowOpacity: number; fowImagePath?: string; fowBlurEnabled: boolean; fowBlurFactor: number }, mapBounds: { hexBounds?: { maxCol: number; maxRow: number }; dimensions?: { width: number; height: number } }, isHexMap: boolean, hexGeometry: { hexSize: number; getHexVertices: (q: number, r: number) => Array<{ worldX: number; worldY: number }>; hexToWorld: (q: number, r: number) => { worldX: number; worldY: number }; getNeighbors: (q: number, r: number) => Array<{ q: number; r: number }> } | null, gridGeometry: { cellSize: number } | null, geometry: { worldToScreen: (worldX: number, worldY: number, offsetX: number, offsetY: number, zoom: number) => { screenX: number; screenY: number } }, orientation: string, getCachedImage: (path: string) => HTMLImageElement | null, renderGridFog: typeof renderGridFog, renderHexFog: typeof renderHexFog, offsetToAxial: (col: number, row: number, orientation: string) => { q: number; r: number }, axialToOffset: (q: number, r: number, orientation: string) => { col: number; row: number }) => void;
};
const { renderObjects } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "objectRenderer")) as {
  renderObjects: (layer: MapLayer, context: { ctx: CanvasRenderingContext2D; offsetX: number; offsetY: number; zoom: number; scaledSize: number }, geometry: IGeometry, isHexMap: boolean, orientation: string, deps: { getObjectType: typeof getObjectType; getRenderChar: typeof getRenderChar; isCellFogged: typeof isCellFogged; getObjectsInCell: typeof getObjectsInCell; getSlotOffset: typeof getSlotOffset; getMultiObjectScale: typeof getMultiObjectScale; renderNoteLinkBadge: typeof renderNoteLinkBadge; renderTooltipIndicator: typeof renderTooltipIndicator; renderObjectLinkIndicator: typeof renderObjectLinkIndicator }) => void;
};
const { renderSelections } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "selectionRenderer")) as {
  renderSelections: (selectedItems: RendererSelectedItem[], textLabels: TextLabel[] | undefined, objects: MapObject[] | undefined, context: { ctx: CanvasRenderingContext2D; offsetX: number; offsetY: number; zoom: number; scaledSize: number }, geometry: IGeometry, hexGeometry: { hexToWorld: (q: number, r: number) => { worldX: number; worldY: number } } | null, isHexMap: boolean, isResizeMode: boolean, orientation: string, showCoordinates: boolean, visibility: { textLabels?: boolean; objects?: boolean }, deps: { getFontCss: typeof getFontCss; getObjectsInCell: typeof getObjectsInCell; getSlotOffset: typeof getSlotOffset; getMultiObjectScale: typeof getMultiObjectScale }) => void;
};
const { renderCurves } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "curveRenderer")) as {
  renderCurves: (ctx: CanvasRenderingContext2D, curves: Array<{ id: string; points: [number, number][]; color: string; opacity?: number; strokeWidth?: number; smoothing?: number; closed?: boolean; filled?: boolean }> | null | undefined, viewState: RendererViewState) => void;
};
const { getFontCss } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "fontOptions")) as {
  getFontCss: (fontFace: string) => string;
};
const { GridGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "GridGeometry")) as {
  GridGeometry: new (cellSize: number) => IGeometry & { cellSize: number; getScaledCellSize: (zoom: number) => number };
};
const { HexGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "HexGeometry")) as {
  HexGeometry: new (hexSize: number, orientation: string, hexBounds: { maxCol: number; maxRow: number } | null) => IGeometry & {
    hexSize: number;
    sqrt3: number;
    getScaledHexSize: (zoom: number) => number;
    getHexVertices: (q: number, r: number) => Array<{ worldX: number; worldY: number }>;
    hexToWorld: (q: number, r: number) => { worldX: number; worldY: number };
    getNeighbors: (q: number, r: number) => Array<{ q: number; r: number }>;
  };
};

interface Renderer {
  // Polymorphic properties
  supportsSegments: boolean;

  // Polymorphic methods for viewport calculation
  getScaledSize: (geometry: IGeometry, zoom: number) => number;
  calculateViewportOffset: (geometry: IGeometry, center: { x: number; y: number }, canvasSize: { width: number; height: number }, zoom: number) => { offsetX: number; offsetY: number };

  // Optional background image rendering (hex only)
  renderBackgroundImage: (ctx: CanvasRenderingContext2D, geometry: IGeometry, bgImage: HTMLImageElement | null, bgConfig: { path: string; offsetX?: number; offsetY?: number; opacity?: number } | undefined, hexBounds: { maxCol: number; maxRow: number } | undefined, orientation: string, offsetX: number, offsetY: number, zoom: number) => void;

  // Grid/cell rendering
  renderGrid: (ctx: CanvasRenderingContext2D, geometry: IGeometry, viewState: RendererViewState, dimensions: { width: number; height: number }, showGrid: boolean, options: { lineColor: string; lineWidth: number }) => void;
  renderPaintedCells: (ctx: CanvasRenderingContext2D, cells: Cell[], geometry: IGeometry, viewState: RendererViewState) => void;
  renderCellBorders: (ctx: CanvasRenderingContext2D, cells: Cell[], geometry: IGeometry, viewState: RendererViewState, getLookup: () => CellMap, calculateBorders: typeof calculateBordersOptimized, options: { border: string; borderWidth: number }) => void;
  renderInteriorGridLines?: (ctx: CanvasRenderingContext2D, cells: Cell[], geometry: IGeometry, viewState: RendererViewState, options: { lineColor: string; lineWidth: number; interiorRatio: number }) => void;
  renderEdges?: (ctx: CanvasRenderingContext2D, edges: unknown[], geometry: IGeometry, viewState: RendererViewState, options: { lineWidth: number; borderWidth: number }) => void;
}

const { gridRenderer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "gridRenderer")) as { gridRenderer: Renderer };
const { hexRenderer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "hexRenderer")) as { hexRenderer: Renderer };
const { segmentRenderer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "segmentRenderer")) as {
  segmentRenderer: {
    separateCellsByType: (cells: Cell[]) => { simpleCells: Cell[]; segmentCells: Cell[] };
    renderSegmentCells: (ctx: CanvasRenderingContext2D, cells: Cell[], geometry: IGeometry, viewState: RendererViewState) => void;
    renderSegmentBorders: (ctx: CanvasRenderingContext2D, segmentCells: Cell[], allCells: Cell[], geometry: IGeometry, viewState: RendererViewState, options: { border: string; borderWidth: number }) => void;
  };
};
const { getCachedImage } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "imageOperations")) as {
  getCachedImage: (path: string) => HTMLImageElement | null;
};
const { getSlotOffset, getMultiObjectScale, getObjectsInCell } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "hexSlotPositioner")) as {
  getSlotOffset: (slot: number, count: number, orientation: string) => { offsetX: number; offsetY: number };
  getMultiObjectScale: (count: number) => number;
  getObjectsInCell: (objects: MapObject[], x: number, y: number) => MapObject[];
};
const { offsetToAxial, axialToOffset } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "offsetCoordinates")) as {
  offsetToAxial: (col: number, row: number, orientation: string) => { q: number; r: number };
  axialToOffset: (q: number, r: number, orientation: string) => { col: number; row: number };
};
const { getActiveLayer, getLayerBelow, isCellFogged } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor")) as {
  getActiveLayer: (mapData: MapData) => MapLayer;
  getLayerBelow: (mapData: MapData, layerId: string) => MapLayer | null;
  isCellFogged: (layer: MapLayer, col: number, row: number) => boolean;
};

/**
 * Get appropriate renderer for geometry type.
 * Uses geometry.type discriminator instead of instanceof.
 */
function getRenderer(geometry: IGeometry): Renderer {
  return geometry.type === 'hex' ? hexRenderer : gridRenderer;
}

/** Options for rendering layer content */
interface RenderLayerContentOptions {
  opacity?: number;
}

/**
 * Render a layer's cells, borders, and edges (but not objects or text labels).
 * Used for both active layer rendering and ghost layer transparency.
 */
function renderLayerCellsAndEdges(
  ctx: CanvasRenderingContext2D,
  layer: MapLayer,
  geometry: IGeometry,
  viewState: RendererViewState,
  theme: RendererTheme,
  renderer: Renderer,
  options: RenderLayerContentOptions = {}
): void {
  const { opacity = 1 } = options;

  // Apply opacity if needed
  const previousAlpha = ctx.globalAlpha;
  if (opacity < 1) {
    ctx.globalAlpha = opacity;
  }

  // Draw filled cells
  if (layer.cells && layer.cells.length > 0) {
    const cellsWithColor = layer.cells.map(cell => ({
      ...cell,
      color: getCellColor(cell)
    }));

    const { simpleCells, segmentCells } = segmentRenderer.separateCellsByType(cellsWithColor);

    if (simpleCells.length > 0) {
      renderer.renderPaintedCells(ctx, simpleCells, geometry, viewState);
    }

    if (segmentCells.length > 0 && renderer.supportsSegments) {
      segmentRenderer.renderSegmentCells(ctx, segmentCells, geometry, viewState);
    }

    if (renderer.renderInteriorGridLines && cellsWithColor.length > 0) {
      renderer.renderInteriorGridLines(ctx, cellsWithColor, geometry, viewState, {
        lineColor: theme.grid.lines,
        lineWidth: theme.grid.lineWidth || 1,
        interiorRatio: 0.5
      });
    }

    const allCellsLookup = buildCellLookup(cellsWithColor);

    if (simpleCells.length > 0) {
      renderer.renderCellBorders(
        ctx,
        simpleCells,
        geometry,
        viewState,
        () => allCellsLookup,
        calculateBordersOptimized,
        {
          border: theme.cells.border,
          borderWidth: theme.cells.borderWidth
        }
      );
    }

    if (segmentCells.length > 0 && renderer.supportsSegments) {
      segmentRenderer.renderSegmentBorders(
        ctx,
        segmentCells,
        cellsWithColor,
        geometry,
        viewState,
        {
          border: theme.cells.border,
          borderWidth: theme.cells.borderWidth
        }
      );
    }
  }

  // Draw painted edges (grid maps only)
  if (layer.edges && layer.edges.length > 0 && renderer.supportsSegments && renderer.renderEdges) {
    renderer.renderEdges(ctx, layer.edges, geometry, viewState, {
      lineWidth: 1,
      borderWidth: theme.cells.borderWidth
    });
  }

  // Restore opacity
  if (opacity < 1) {
    ctx.globalAlpha = previousAlpha;
  }
}

const renderCanvas: RenderCanvas = (canvas, fogCanvas, mapData, geometry, selectedItems = [], isResizeMode = false, theme = null, showCoordinates = false, layerVisibility = null) => {
  if (!canvas) return;

  // Normalize selectedItems to array (backward compatibility)
  const itemsArray: RendererSelectedItem[] = Array.isArray(selectedItems) ? selectedItems : (selectedItems ? [selectedItems] : []);

  // Default layer visibility
  const visibility: LayerVisibility = layerVisibility || { objects: true, textLabels: true, hexCoordinates: true };

  // Get theme with current settings (use provided theme or fetch global)
  const THEME = theme || getTheme();

  // Extract active layer data (supports layer schema v2)
  const activeLayer = getActiveLayer(mapData);

  const ctx = canvas.getContext('2d');
  if (!ctx) return;

  const { width, height } = canvas;
  const { viewState, northDirection } = mapData;
  const { zoom, center } = viewState;

  // Clear canvas
  ctx.fillStyle = THEME.grid.background;
  ctx.fillRect(0, 0, width, height);

  // Save context and apply rotation
  ctx.save();

  // Translate to center, rotate, translate back
  ctx.translate(width / 2, height / 2);
  ctx.rotate((northDirection * Math.PI) / 180);
  ctx.translate(-width / 2, -height / 2);

  // Get appropriate renderer for this geometry
  const renderer = getRenderer(geometry);

  // Calculate viewport using renderer's polymorphic method
  const scaledSize = renderer.getScaledSize(geometry, zoom);
  const { offsetX, offsetY } = renderer.calculateViewportOffset(
    geometry,
    center,
    { width, height },
    zoom
  );

  // Draw background image (hex maps only - grid renderer is no-op)
  const bgImage = mapData.backgroundImage?.path ? getCachedImage(mapData.backgroundImage.path) : null;
  renderer.renderBackgroundImage(
    ctx,
    geometry,
    bgImage,
    mapData.backgroundImage,
    mapData.hexBounds,
    mapData.orientation || 'flat',
    offsetX,
    offsetY,
    zoom
  );

  // Create renderer viewState object
  const rendererViewState: RendererViewState = {
    x: offsetX,
    y: offsetY,
    zoom: zoom
  };

  // iOS defensive: Reset canvas state
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = 'source-over';

  // Reset clipping region
  ctx.save();
  ctx.beginPath();
  const largeClip = Math.max(width, height) * 4;
  ctx.rect(-largeClip, -largeClip, largeClip * 2, largeClip * 2);
  ctx.clip();
  ctx.restore();

  // Draw grid lines
  renderer.renderGrid(ctx, geometry, rendererViewState, { width, height }, true, {
    lineColor: THEME.grid.lines,
    lineWidth: THEME.grid.lineWidth || 1
  });

  // Draw ghost layer (layer below) if enabled
  if (activeLayer.showLayerBelow) {
    const layerBelow = getLayerBelow(mapData, activeLayer.id);
    if (layerBelow) {
      const ghostOpacity = activeLayer.layerBelowOpacity ?? 0.25;
      renderLayerCellsAndEdges(ctx, layerBelow, geometry, rendererViewState, THEME, renderer, {
        opacity: ghostOpacity
      });
    }
  }

  // Draw active layer cells and edges
  renderLayerCellsAndEdges(ctx, activeLayer, geometry, rendererViewState, THEME, renderer);

  // Draw freehand curves
  if (activeLayer.curves && activeLayer.curves.length > 0) {
    renderCurves(ctx, activeLayer.curves, rendererViewState);
  }

  // Draw objects
  if (activeLayer.objects && activeLayer.objects.length > 0 && !showCoordinates && visibility.objects) {
    const isHexMap = geometry.type === 'hex';
    renderObjects(
      activeLayer,
      { ctx, offsetX, offsetY, zoom, scaledSize },
      geometry,
      isHexMap,
      mapData.orientation || 'flat',
      {
        getObjectType,
        getRenderChar,
        isCellFogged,
        getObjectsInCell,
        getSlotOffset,
        getMultiObjectScale,
        renderNoteLinkBadge,
        renderTooltipIndicator,
        renderObjectLinkIndicator,
      }
    );
  }

  // Draw text labels
  if (activeLayer.textLabels && activeLayer.textLabels.length > 0 && !showCoordinates && visibility.textLabels) {
    renderTextLabels(
      activeLayer.textLabels,
      { ctx, zoom, getFontCss },
      geometry,
      { offsetX, offsetY, zoom }
    );
  }

  // =========================================================================
  // FOG OF WAR RENDERING
  // =========================================================================

  const fow = activeLayer.fogOfWar;
  const effectiveSettings = getEffectiveSettings(mapData.settings) as Record<string, unknown>;
  const fowBlurEnabled = (effectiveSettings?.fogOfWarBlurEnabled as boolean) ?? false;

  // Clear fog canvas if fog not needed
  if (!fow?.enabled || !fow?.foggedCells?.length || !fowBlurEnabled) {
    clearFogCanvas(fogCanvas);
  }

  if (fow && fow.enabled && fow.foggedCells?.length) {
    const fogSettings = getFogSettings(effectiveSettings);
    const isHexMap = geometry.type === 'hex';
    const hexGeom = isHexMap ? geometry as InstanceType<typeof HexGeometry> : null;
    const gridGeom = !isHexMap ? geometry as InstanceType<typeof GridGeometry> : null;

    renderFog(
      activeLayer.fogOfWar,
      { ctx, fogCanvas, width, height, offsetX, offsetY, zoom, scaledSize, northDirection },
      fogSettings,
      { hexBounds: mapData.hexBounds, dimensions: mapData.dimensions },
      isHexMap,
      hexGeom,
      gridGeom,
      geometry,
      mapData.orientation || 'flat',
      getCachedImage,
      renderGridFog,
      renderHexFog,
      offsetToAxial,
      axialToOffset
    );
  }

  // Draw selection indicators
  const isHexMapForSelection = geometry.type === 'hex';
  const hexGeomForSelection = isHexMapForSelection ? geometry as InstanceType<typeof HexGeometry> : null;
  renderSelections(
    itemsArray,
    activeLayer.textLabels,
    activeLayer.objects,
    { ctx, offsetX, offsetY, zoom, scaledSize },
    geometry,
    hexGeomForSelection,
    isHexMapForSelection,
    isResizeMode,
    mapData.orientation || 'flat',
    showCoordinates,
    visibility,
    {
      getFontCss,
      getObjectsInCell,
      getSlotOffset,
      getMultiObjectScale,
    }
  );

  // Restore context
  ctx.restore();
};

const useCanvasRenderer: UseCanvasRenderer = (canvasRef, fogCanvasRef, mapData, geometry, selectedItems = [], isResizeMode = false, theme = null, showCoordinates = false, layerVisibility = null) => {
  dc.useEffect(() => {
    if (mapData && geometry && canvasRef.current) {
      const fogCanvas = fogCanvasRef?.current || null;
      renderCanvas(canvasRef.current, fogCanvas, mapData, geometry, selectedItems, isResizeMode, theme, showCoordinates, layerVisibility);
    }
  }, [mapData, geometry, selectedItems, isResizeMode, theme, canvasRef, fogCanvasRef, showCoordinates, layerVisibility]);
};

return { useCanvasRenderer, renderCanvas };

```

# useCanvasInteraction

```ts
/**
 * useCanvasInteraction.ts
 *
 * Custom hook that handles all canvas interaction state and logic including:
 * - Pan state (mouse pan, touch pan, space key pan)
 * - Zoom state (wheel zoom, pinch zoom)
 * - Coordinate transformation helpers
 * - Touch event helpers
 *
 * This hook manages the viewport state (zoom, center) and provides
 * helper functions for coordinate conversions that depend on viewport.
 */

// Type-only imports
import type { Point, IGeometry } from '#types/core/geometry.types';
import type { MapData, ViewState } from '#types/core/map.types';
import type {
  PanStart,
  TouchCenter,
  ClientCoords,
  WorldCoords,
  OnViewStateChangeCallback,
  UseCanvasInteractionResult,
} from '#types/hooks/canvasInteraction.types';

// Datacore imports
interface DefaultConstants {
  minZoom: number;
}

const { DEFAULTS } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants")) as {
  DEFAULTS: DefaultConstants;
};

interface GridGeometryConstructor {
  new (...args: unknown[]): IGeometry & {
    getScaledCellSize: (zoom: number) => number;
  };
}

const { GridGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "GridGeometry")) as {
  GridGeometry: GridGeometryConstructor;
};

interface CanvasRef {
  current: HTMLCanvasElement | null;
}

function useCanvasInteraction(
  canvasRef: CanvasRef,
  mapData: MapData | null,
  geometry: (IGeometry & { getScaledCellSize?: (zoom: number) => number }) | null,
  onViewStateChange: OnViewStateChangeCallback = () => {},
  focused: boolean
): UseCanvasInteractionResult {
  const [isPanning, setIsPanning] = dc.useState<boolean>(false);
  const [isTouchPanning, setIsTouchPanning] = dc.useState<boolean>(false);
  const [panStart, setPanStart] = dc.useState<PanStart | null>(null);
  const [touchPanStart, setTouchPanStart] = dc.useState<TouchCenter | null>(null);

  const [initialPinchDistance, setInitialPinchDistance] = dc.useState<number | null>(null);

  const [spaceKeyPressed, setSpaceKeyPressed] = dc.useState<boolean>(false);

  // Track recent touch to ignore synthetic mouse events
  const lastTouchTimeRef = dc.useRef<number>(0);

  const getClientCoords = (e: PointerEvent | MouseEvent | TouchEvent): ClientCoords => {
    const touchEvent = e as TouchEvent;
    if (touchEvent.touches && touchEvent.touches.length > 0) {
      return {
        clientX: touchEvent.touches[0].clientX,
        clientY: touchEvent.touches[0].clientY
      };
    } else if (touchEvent.changedTouches && touchEvent.changedTouches.length > 0) {
      return {
        clientX: touchEvent.changedTouches[0].clientX,
        clientY: touchEvent.changedTouches[0].clientY
      };
    } else {
      const mouseEvent = e as MouseEvent;
      return {
        clientX: mouseEvent.clientX,
        clientY: mouseEvent.clientY
      };
    }
  };

  const getTouchCenter = (touches: TouchList): TouchCenter | null => {
    if (touches.length < 2) return null;
    return {
      x: (touches[0].clientX + touches[1].clientX) / 2,
      y: (touches[0].clientY + touches[1].clientY) / 2
    };
  };

  const getTouchDistance = (touches: TouchList): number | null => {
    if (touches.length < 2) return null;
    const dx = touches[1].clientX - touches[0].clientX;
    const dy = touches[1].clientY - touches[0].clientY;
    return Math.sqrt(dx * dx + dy * dy);
  };

  const screenToGrid = (clientX: number, clientY: number): Point | null => {
    if (!mapData) return null;
    if (!geometry) return null;
    if (!canvasRef.current) return null;

    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();

    let x = clientX - rect.left;
    let y = clientY - rect.top;

    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    x *= scaleX;
    y *= scaleY;

    const { viewState, northDirection } = mapData;
    const { zoom, center } = viewState;

    if (northDirection !== 0) {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      x -= centerX;
      y -= centerY;

      const angleRad = (-northDirection * Math.PI) / 180;
      const rotatedX = x * Math.cos(angleRad) - y * Math.sin(angleRad);
      const rotatedY = x * Math.sin(angleRad) + y * Math.cos(angleRad);

      x = rotatedX + centerX;
      y = rotatedY + centerY;
    }

    let offsetX: number, offsetY: number;
    if (geometry instanceof GridGeometry) {
      const gridGeometry = geometry as { getScaledCellSize: (zoom: number) => number };
      const scaledCellSize = gridGeometry.getScaledCellSize(zoom);
      offsetX = canvas.width / 2 - center.x * scaledCellSize;
      offsetY = canvas.height / 2 - center.y * scaledCellSize;
    } else {
      offsetX = canvas.width / 2 - center.x * zoom;
      offsetY = canvas.height / 2 - center.y * zoom;
    }

    const worldX = (x - offsetX) / zoom;
    const worldY = (y - offsetY) / zoom;

    return geometry.worldToGrid(worldX, worldY);
  };

  const screenToWorld = (clientX: number, clientY: number): WorldCoords | null => {
    if (!mapData) return null;
    if (!geometry) return null;
    if (!canvasRef.current) return null;

    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();

    let x = clientX - rect.left;
    let y = clientY - rect.top;

    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    x *= scaleX;
    y *= scaleY;

    const { viewState, northDirection } = mapData;
    const { zoom, center } = viewState;

    let offsetX: number, offsetY: number;
    if (geometry instanceof GridGeometry) {
      const gridGeometry = geometry as { getScaledCellSize: (zoom: number) => number };
      const scaledCellSize = gridGeometry.getScaledCellSize(zoom);
      offsetX = canvas.width / 2 - center.x * scaledCellSize;
      offsetY = canvas.height / 2 - center.y * scaledCellSize;
    } else {
      offsetX = canvas.width / 2 - center.x * zoom;
      offsetY = canvas.height / 2 - center.y * zoom;
    }

    if (northDirection !== 0) {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      x -= centerX;
      y -= centerY;

      const angleRad = (-northDirection * Math.PI) / 180;
      const rotatedX = x * Math.cos(angleRad) - y * Math.sin(angleRad);
      const rotatedY = x * Math.sin(angleRad) + y * Math.cos(angleRad);

      x = rotatedX + centerX;
      y = rotatedY + centerY;
    }

    const worldX = (x - offsetX) / zoom;
    const worldY = (y - offsetY) / zoom;

    return { worldX, worldY };
  };

  const handleWheel = (e: WheelEvent): void => {
    e.preventDefault();

    if (!mapData) return;
    if (!geometry) return;
    if (!canvasRef.current) return;

    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const delta = e.deltaY > 0 ? -0.1 : 0.1;
    const newZoom = Math.max(DEFAULTS.minZoom, Math.min(4, mapData.viewState.zoom + delta));

    const { viewState } = mapData;
    const { zoom: oldZoom, center: oldCenter } = viewState;

    const gridGeometry = geometry as { getScaledCellSize: (zoom: number) => number };
    const scaledGridSize = gridGeometry.getScaledCellSize(oldZoom);
    const offsetX = canvas.width / 2 - oldCenter.x * scaledGridSize;
    const offsetY = canvas.height / 2 - oldCenter.y * scaledGridSize;

    const worldX = (mouseX - offsetX) / scaledGridSize;
    const worldY = (mouseY - offsetY) / scaledGridSize;

    const newScaledGridSize = gridGeometry.getScaledCellSize(newZoom);
    const newOffsetX = mouseX - worldX * newScaledGridSize;
    const newOffsetY = mouseY - worldY * newScaledGridSize;

    const newCenterX = (canvas.width / 2 - newOffsetX) / newScaledGridSize;
    const newCenterY = (canvas.height / 2 - newOffsetY) / newScaledGridSize;

    onViewStateChange({
      zoom: newZoom,
      center: { x: newCenterX, y: newCenterY }
    });
  };

  const startPan = (clientX: number, clientY: number): void => {
    if (!mapData) return;
    setIsPanning(true);
    setPanStart({
      x: clientX,
      y: clientY,
      centerX: mapData.viewState.center.x,
      centerY: mapData.viewState.center.y
    });
  };

  const updatePan = (clientX: number, clientY: number): void => {
    if (!isPanning || !panStart || !mapData) return;
    if (!geometry) return;

    const deltaX = clientX - panStart.x;
    const deltaY = clientY - panStart.y;

    const { viewState, northDirection } = mapData;
    const { zoom, center } = viewState;

    const angleRad = (-northDirection * Math.PI) / 180;
    const rotatedDeltaX = deltaX * Math.cos(angleRad) - deltaY * Math.sin(angleRad);
    const rotatedDeltaY = deltaX * Math.sin(angleRad) + deltaY * Math.cos(angleRad);

    let gridDeltaX: number, gridDeltaY: number;
    if (geometry instanceof GridGeometry) {
      const gridGeometry = geometry as { getScaledCellSize: (zoom: number) => number };
      const scaledGridSize = gridGeometry.getScaledCellSize(zoom);
      gridDeltaX = -rotatedDeltaX / scaledGridSize;
      gridDeltaY = -rotatedDeltaY / scaledGridSize;
    } else {
      gridDeltaX = -rotatedDeltaX / zoom;
      gridDeltaY = -rotatedDeltaY / zoom;
    }

    onViewStateChange({
      zoom: viewState.zoom,
      center: {
        x: center.x + gridDeltaX,
        y: center.y + gridDeltaY
      }
    });

    setPanStart({ x: clientX, y: clientY, centerX: center.x + gridDeltaX, centerY: center.y + gridDeltaY });
  };

  const stopPan = (): void => {
    setIsPanning(false);
    setPanStart(null);
  };

  const startTouchPan = (center: TouchCenter): void => {
    setIsTouchPanning(true);
    setTouchPanStart(center);
  };

  const updateTouchPan = (touches: TouchList): void => {
    if (!isTouchPanning || !touchPanStart || !mapData) return;
    if (!geometry) return;

    const center = getTouchCenter(touches);
    const distance = getTouchDistance(touches);
    if (!center || !distance) return;

    const deltaX = center.x - touchPanStart.x;
    const deltaY = center.y - touchPanStart.y;

    const { viewState, northDirection } = mapData;
    const { zoom, center: viewCenter } = viewState;

    const angleRad = (-northDirection * Math.PI) / 180;
    const rotatedDeltaX = deltaX * Math.cos(angleRad) - deltaY * Math.sin(angleRad);
    const rotatedDeltaY = deltaX * Math.sin(angleRad) + deltaY * Math.cos(angleRad);

    let gridDeltaX: number, gridDeltaY: number;
    if (geometry instanceof GridGeometry) {
      const gridGeometry = geometry as { getScaledCellSize: (zoom: number) => number };
      const scaledGridSize = gridGeometry.getScaledCellSize(zoom);
      gridDeltaX = -rotatedDeltaX / scaledGridSize;
      gridDeltaY = -rotatedDeltaY / scaledGridSize;
    } else {
      gridDeltaX = -rotatedDeltaX / zoom;
      gridDeltaY = -rotatedDeltaY / zoom;
    }
    let newZoom = zoom;
    if (initialPinchDistance) {
      const scale = distance / initialPinchDistance;
      newZoom = Math.max(DEFAULTS.minZoom, Math.min(4, zoom * scale));
    }

    onViewStateChange({
      zoom: newZoom,
      center: {
        x: viewCenter.x + gridDeltaX,
        y: viewCenter.y + gridDeltaY
      }
    });

    setTouchPanStart(center);
    setInitialPinchDistance(distance);
  };

  const stopTouchPan = (): void => {
    setIsTouchPanning(false);
    setTouchPanStart(null);
    setInitialPinchDistance(null);
  };

  dc.useEffect(() => {
    if (!focused) {
      if (spaceKeyPressed) {
        setSpaceKeyPressed(false);
        if (isPanning) {
          stopPan();
        }
      }
      return;
    }

    const handleSpaceDown = (e: KeyboardEvent): void => {
      const target = e.target as HTMLElement;
      if (e.key === ' ' && target.tagName !== 'INPUT' && target.tagName !== 'TEXTAREA') {
        e.preventDefault();
        setSpaceKeyPressed(true);
      }
    };

    const handleSpaceUp = (e: KeyboardEvent): void => {
      if (e.key === ' ') {
        setSpaceKeyPressed(false);
        if (isPanning) {
          stopPan();
        }
      }
    };

    window.addEventListener('keydown', handleSpaceDown);
    window.addEventListener('keyup', handleSpaceUp);
    return () => {
      window.removeEventListener('keydown', handleSpaceDown);
      window.removeEventListener('keyup', handleSpaceUp);
    };
  }, [focused, isPanning, spaceKeyPressed]);

  return {
    isPanning,
    isTouchPanning,
    panStart,
    touchPanStart,
    spaceKeyPressed,
    initialPinchDistance,
    lastTouchTimeRef,

    getClientCoords,
    getTouchCenter,
    getTouchDistance,
    screenToGrid,
    screenToWorld,

    handleWheel,

    startPan,
    updatePan,
    stopPan,
    startTouchPan,
    updateTouchPan,
    stopTouchPan,

    setIsPanning,
    setIsTouchPanning,
    setPanStart,
    setTouchPanStart,
    setInitialPinchDistance,
    setSpaceKeyPressed
  };
}

return { useCanvasInteraction };

```

# textLabelOperations

```ts
/**
 * textLabelOperations.ts
 * 
 * Pure functions for text label manipulation.
 * Text labels are free-floating text elements positioned in world space.
 */

// Type-only imports
import type { Point } from '#types/core/geometry.types';
import type { HexColor } from '#types/settings/settings.types';

// ===========================================
// Type Definitions
// ===========================================

/** Unique text label identifier */
export type TextLabelId = string;

/** Font face options */
export type FontFace = 'sans' | 'serif' | 'mono' | 'script' | 'fantasy';

/** Text label styling options */
export interface TextLabelOptions {
  fontSize?: number;
  fontFace?: FontFace;
  color?: HexColor;
}

/** Text label data structure */
export interface TextLabel {
  id: TextLabelId;
  content: string;
  position: Point;
  rotation: number;
  fontSize: number;
  fontFace: FontFace;
  color: HexColor;
}

/** Partial text label for updates */
export type TextLabelUpdate = Partial<Omit<TextLabel, 'id'>>;

// ===========================================
// Constants
// ===========================================

/** Maximum allowed content length */
const MAX_CONTENT_LENGTH = 200;

// ===========================================
// ID Generation
// ===========================================

/**
 * Generate a unique ID for a text label
 */
function generateTextLabelId(): TextLabelId {
  return 'text-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
}

// ===========================================
// Text Label Operations
// ===========================================

/**
 * Add a new text label
 */
function addTextLabel(
  labels: TextLabel[] | null | undefined,
  content: string,
  x: number,
  y: number,
  options: TextLabelOptions = {}
): TextLabel[] {
  // Validate content
  const trimmed = content.trim();
  if (!trimmed || trimmed.length === 0) {
    console.warn('Cannot add empty text label');
    return labels || [];
  }
  
  if (trimmed.length > MAX_CONTENT_LENGTH) {
    console.warn(`Text label content exceeds ${MAX_CONTENT_LENGTH} character limit`);
    return labels || [];
  }
  
  const newLabel: TextLabel = {
    id: generateTextLabelId(),
    content: trimmed,
    position: { x, y },
    rotation: 0,
    fontSize: options.fontSize || 16,
    fontFace: options.fontFace || 'sans',
    color: options.color || '#ffffff'
  };
  
  return [...(labels || []), newLabel];
}

/**
 * Update an existing text label
 */
function updateTextLabel(
  labels: TextLabel[] | null | undefined,
  id: TextLabelId,
  updates: TextLabelUpdate
): TextLabel[] {
  if (!labels || !Array.isArray(labels)) return [];
  
  return labels.map(label => 
    label.id === id ? { ...label, ...updates } : label
  );
}

/**
 * Remove a text label by ID
 */
function removeTextLabel(
  labels: TextLabel[] | null | undefined,
  id: TextLabelId
): TextLabel[] {
  if (!labels || !Array.isArray(labels)) return [];
  return labels.filter(label => label.id !== id);
}

// ===========================================
// Hit Detection
// ===========================================

/**
 * Check if a point is inside a rotated rectangle (for text label hit detection)
 */
function isPointInRotatedRect(
  px: number,
  py: number,
  rectX: number,
  rectY: number,
  rectWidth: number,
  rectHeight: number,
  rotation: number
): boolean {
  // Translate point to rectangle's local space (centered at origin)
  const dx = px - rectX;
  const dy = py - rectY;
  
  // Rotate point by negative rotation to "unrotate" it
  const angleRad = (-rotation * Math.PI) / 180;
  const cos = Math.cos(angleRad);
  const sin = Math.sin(angleRad);
  const rotatedX = dx * cos - dy * sin;
  const rotatedY = dx * sin + dy * cos;
  
  // Check if point is inside the axis-aligned rectangle
  const halfWidth = rectWidth / 2;
  const halfHeight = rectHeight / 2;
  
  return Math.abs(rotatedX) <= halfWidth && Math.abs(rotatedY) <= halfHeight;
}

/**
 * Find text label at given coordinates using proper bounding box collision
 */
function getTextLabelAtPosition(
  labels: TextLabel[] | null | undefined,
  x: number,
  y: number,
  ctx: CanvasRenderingContext2D | null = null
): TextLabel | null {
  if (!labels || !Array.isArray(labels)) return null;
  
  // Create temporary canvas context if none provided
  let tempCanvas: HTMLCanvasElement | null = null;
  let context = ctx;
  if (!context) {
    tempCanvas = document.createElement('canvas');
    context = tempCanvas.getContext('2d');
    if (!context) return null;
  }
  
  // Font family mapping
  const fontMap: Record<FontFace, string> = {
    'sans': 'system-ui, -apple-system, sans-serif',
    'serif': 'Georgia, Times, serif',
    'mono': '"Courier New", monospace',
    'script': '"Brush Script MT", cursive',
    'fantasy': 'Impact, sans-serif'
  };
  
  // Check labels in reverse order (top to bottom, most recent first)
  for (let i = labels.length - 1; i >= 0; i--) {
    const label = labels[i];
    
    // Set font to measure text accurately
    const fontSize = label.fontSize || 16;
    const fontFace = label.fontFace || 'sans';
    const fontFamily = fontMap[fontFace] || 'sans-serif';
    
    context.font = `${fontSize}px ${fontFamily}`;
    
    // Measure text to get bounding box
    const metrics = context.measureText(label.content);
    const textWidth = metrics.width;
    const textHeight = fontSize * 1.2; // Same multiplier as renderer
    
    // Add padding (same as selection box: 4px horizontal, 2px vertical)
    const paddingX = 4;
    const paddingY = 2;
    const boundingWidth = textWidth + paddingX * 2;
    const boundingHeight = textHeight + paddingY * 2;
    
    // Check if point is inside the rotated bounding box
    if (isPointInRotatedRect(
      x, y,
      label.position.x, label.position.y,
      boundingWidth, boundingHeight,
      label.rotation || 0
    )) {
      return label;
    }
  }
  
  return null;
}

/**
 * Remove all text labels within a rectangular area (for clear area tool)
 */
function removeTextLabelsInRectangle(
  labels: TextLabel[] | null | undefined,
  x1: number,
  y1: number,
  x2: number,
  y2: number
): TextLabel[] {
  if (!labels || !Array.isArray(labels)) return [];
  
  const minX = Math.min(x1, x2);
  const maxX = Math.max(x1, x2);
  const minY = Math.min(y1, y2);
  const maxY = Math.max(y1, y2);
  
  return labels.filter(label => {
    return !(label.position.x >= minX && label.position.x <= maxX && 
             label.position.y >= minY && label.position.y <= maxY);
  });
}

// ===========================================
// Exports
// ===========================================

return {
  generateTextLabelId,
  addTextLabel,
  updateTextLabel,
  removeTextLabel,
  getTextLabelAtPosition,
  removeTextLabelsInRectangle
};
```

# screenPositionUtils

```ts
/**
 * screenPositionUtils.ts - Shared screen position calculations for objects
 */

import type { MapData } from '#types/core/map.types';
import type { MapObject, ObjectAlignment } from '#types/objects/object.types';
import type { IGeometry } from '#types/core/geometry.types';

/** Screen position result */
interface ScreenPosition {
  screenX: number;
  screenY: number;
  objectWidth: number;
  objectHeight: number;
}

/** Screen offset */
interface ScreenOffset {
  x: number;
  y: number;
}

/** Container reference type */
interface ContainerRef {
  current: HTMLElement | null;
}

/** Extended geometry with hex-specific methods */
interface HexGeometryLike extends IGeometry {
  hexSize: number;
  hexToWorld: (q: number, r: number) => { worldX: number; worldY: number };
}

/**
 * Calculate an object's screen position accounting for zoom, pan, rotation, alignment, and container positioning
 * @returns Screen position data or null if inputs invalid
 */
function calculateObjectScreenPosition(
  object: MapObject,
  canvas: HTMLCanvasElement,
  mapData: MapData,
  geometry: IGeometry,
  containerRef: ContainerRef | null = null
): ScreenPosition | null {
  if (!mapData || !canvas || !geometry) {
    return null;
  }

  const { gridSize, viewState, northDirection, mapType } = mapData;
  const { zoom, center } = viewState;
  const size = object.size || { width: 1, height: 1 };
  const alignment = object.alignment || 'center';

  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;

  let offsetX: number, offsetY: number, screenX: number, screenY: number;
  let objectWidth: number, objectHeight: number;

  if (mapType === 'hex') {
    const hexGeom = geometry as HexGeometryLike;
    const { worldX, worldY } = hexGeom.hexToWorld(object.position.x, object.position.y);

    const hexSize = hexGeom.hexSize;
    objectWidth = size.width * hexSize * zoom;
    objectHeight = size.height * hexSize * zoom;

    offsetX = centerX - center.x * zoom;
    offsetY = centerY - center.y * zoom;

    screenX = offsetX + worldX * zoom;
    screenY = offsetY + worldY * zoom;

    screenX += getAlignmentScreenOffset(alignment, hexSize, zoom).x;
    screenY += getAlignmentScreenOffset(alignment, hexSize, zoom).y;
  } else {
    const scaledGridSize = gridSize * zoom;
    offsetX = centerX - center.x * scaledGridSize;
    offsetY = centerY - center.y * scaledGridSize;

    screenX = offsetX + (object.position.x + size.width / 2) * scaledGridSize;
    screenY = offsetY + (object.position.y + size.height / 2) * scaledGridSize;

    screenX += getAlignmentScreenOffset(alignment, scaledGridSize, 1).x;
    screenY += getAlignmentScreenOffset(alignment, scaledGridSize, 1).y;

    objectWidth = size.width * scaledGridSize;
    objectHeight = size.height * scaledGridSize;
  }

  if (northDirection !== 0) {
    const relX = screenX - centerX;
    const relY = screenY - centerY;

    const angleRad = (northDirection * Math.PI) / 180;
    const rotatedX = relX * Math.cos(angleRad) - relY * Math.sin(angleRad);
    const rotatedY = relX * Math.sin(angleRad) + relY * Math.cos(angleRad);

    screenX = centerX + rotatedX;
    screenY = centerY + rotatedY;
  }

  const rect = canvas.getBoundingClientRect();
  const container = containerRef?.current || canvas.parentElement;
  if (!container) return null;

  const containerRect = container.getBoundingClientRect();

  const canvasOffsetX = rect.left - containerRect.left;
  const canvasOffsetY = rect.top - containerRect.top;

  const scaleX = rect.width / canvas.width;
  const scaleY = rect.height / canvas.height;

  return {
    screenX: (screenX * scaleX) + canvasOffsetX,
    screenY: (screenY * scaleY) + canvasOffsetY,
    objectWidth: objectWidth * scaleX,
    objectHeight: objectHeight * scaleY
  };
}

/**
 * Calculate screen space offset for edge alignment
 */
function getAlignmentScreenOffset(
  alignment: ObjectAlignment,
  cellSize: number,
  zoom: number
): ScreenOffset {
  const halfCell = (cellSize * zoom) / 2;

  switch (alignment) {
    case 'north': return { x: 0, y: -halfCell };
    case 'south': return { x: 0, y: halfCell };
    case 'east': return { x: halfCell, y: 0 };
    case 'west': return { x: -halfCell, y: 0 };
    case 'center':
    default: return { x: 0, y: 0 };
  }
}

/**
 * Apply inverse rotation transformation to coordinates
 * Used when converting screen/canvas coordinates back to world/grid coordinates
 */
function applyInverseRotation(
  x: number,
  y: number,
  canvasWidth: number,
  canvasHeight: number,
  northDirection: number
): ScreenOffset {
  if (northDirection === 0) {
    return { x, y };
  }

  const centerX = canvasWidth / 2;
  const centerY = canvasHeight / 2;

  const translatedX = x - centerX;
  const translatedY = y - centerY;

  const angleRad = (-northDirection * Math.PI) / 180;
  const rotatedX = translatedX * Math.cos(angleRad) - translatedY * Math.sin(angleRad);
  const rotatedY = translatedX * Math.sin(angleRad) + translatedY * Math.cos(angleRad);

  return {
    x: rotatedX + centerX,
    y: rotatedY + centerY
  };
}

return { calculateObjectScreenPosition, applyInverseRotation, getAlignmentScreenOffset };

```

# noteOperations

```ts
/**
 * noteOperations.ts
 * 
 * Operations for managing note links and vault note indexing.
 * Interfaces with Obsidian's vault API for note discovery and navigation.
 */

// Type-only imports
import type { NoteIndexEntry } from '#types/objects/note.types';
import type { TFile, TAbstractFile, App } from 'obsidian';

// Global app reference from Obsidian
declare const app: App;

// ===========================================
// Note Index Functions
// ===========================================

/**
 * Build an index of all markdown notes in the vault.
 * Returns array of note paths suitable for autocomplete.
 */
async function buildNoteIndex(): Promise<NoteIndexEntry[]> {
  try {
    const markdownFiles = app.vault.getMarkdownFiles();
    
    // Return array of paths without the .md extension for cleaner display
    // Store full path for actual linking
    return markdownFiles.map(file => ({
      path: file.path,           // Full path with .md
      displayName: file.basename // Name without extension
    }));
  } catch (error) {
    console.error('[buildNoteIndex] Error indexing vault notes:', error);
    return [];
  }
}

/**
 * Get note suggestions for autocomplete.
 * Returns array of display names only.
 */
async function getNoteDisplayNames(): Promise<string[]> {
  const index = await buildNoteIndex();
  return index.map(note => note.displayName);
}

/**
 * Get full note path from display name.
 */
async function getFullPathFromDisplayName(displayName: string): Promise<string | null> {
  const index = await buildNoteIndex();
  const match = index.find(note => note.displayName === displayName);
  return match ? match.path : null;
}

/**
 * Get display name from full path.
 */
function getDisplayNameFromPath(fullPath: string | null | undefined): string {
  if (!fullPath) return '';
  // Remove .md extension and get just the filename
  return fullPath.replace(/\.md$/, '').split('/').pop() || '';
}

// ===========================================
// Note Navigation
// ===========================================

/**
 * Open a note in a new tab using Obsidian API.
 */
async function openNoteInNewTab(notePath: string | null | undefined): Promise<boolean> {
  if (!notePath) {
    console.warn('[openNoteInNewTab] No note path provided');
    return false;
  }
  
  try {
    // Open in new tab (third parameter true = new leaf)
    // Second parameter empty string means no source file for relative links
    await app.workspace.openLinkText(notePath.replace(/\.md$/, ''), '', true);
    return true;
  } catch (error) {
    console.error('[openNoteInNewTab] Error opening note:', error);
    return false;
  }
}

// ===========================================
// Validation
// ===========================================

/**
 * Validate that a note path exists in the vault.
 */
async function isValidNotePath(notePath: string | null | undefined): Promise<boolean> {
  if (!notePath) return false;
  
  try {
    const file = app.vault.getAbstractFileByPath(notePath);
    return file !== null && file !== undefined;
  } catch (error) {
    console.error('[isValidNotePath] Error validating path:', error);
    return false;
  }
}

// ===========================================
// Formatting
// ===========================================

/**
 * Format a note path for display (remove .md, show just basename).
 */
function formatNoteForDisplay(notePath: string | null | undefined): string {
  if (!notePath) return '';
  return getDisplayNameFromPath(notePath);
}

// ===========================================
// Exports
// ===========================================

return {
  buildNoteIndex,
  getNoteDisplayNames,
  getFullPathFromDisplayName,
  getDisplayNameFromPath,
  openNoteInNewTab,
  isValidNotePath,
  formatNoteForDisplay
};
```

# LinkedNoteHoverOverlays

```jsx
// components/LinkedNoteHoverOverlays.jsx - Invisible hover links for objects with linked notes
const { calculateObjectScreenPosition } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "screenPositionUtils"));
const { openNoteInNewTab } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "noteOperations"));

const LinkedNoteHoverOverlays = ({ canvasRef, mapData, selectedItem, geometry }) => {
  // Don't render anything if prerequisites aren't met
  if (!canvasRef.current || !mapData?.objects || !geometry) return null;
  
  // Filter: must have linkedNote AND not be currently selected
  const objectsWithLinks = mapData.objects.filter(obj => {
    return obj.linkedNote && 
           typeof obj.linkedNote === 'string' && 
           !(selectedItem?.type === 'object' && selectedItem?.id === obj.id);
  });
  
  return (
    <>
      {objectsWithLinks.map(obj => {
        const position = calculateObjectScreenPosition(obj, canvasRef.current, mapData, geometry);
        if (!position) return null;
        
        const { screenX, screenY, objectWidth, objectHeight } = position;
        
        const notePath = obj.linkedNote.replace(/\.md$/, '');
        if (!notePath) return null;
        
        // Touch handling state (local to each overlay)
        let touchStartTime = null;
        let touchTimer = null;
        
        const handleTouchStart = (e) => {
          touchStartTime = Date.now();
          
          // Set up long-press detection (500ms)
          touchTimer = setTimeout(() => {
            // Long press detected - open note
            openNoteInNewTab(obj.linkedNote);
            touchStartTime = null; // Prevent click from also firing
          }, 500);
        };
        
        const handleTouchEnd = (e) => {
          if (touchTimer) {
            clearTimeout(touchTimer);
            touchTimer = null;
          }
          
          // If it was a quick tap (not a long press), let it pass through
          if (touchStartTime && (Date.now() - touchStartTime < 500)) {
            // Quick tap - pass through to canvas
            e.preventDefault();
            e.stopPropagation();
            
            // Dispatch both mousedown and mouseup to complete the click
            const mouseDownEvent = new MouseEvent('mousedown', {
              bubbles: true,
              cancelable: true,
              view: window,
              clientX: e.changedTouches[0].clientX,
              clientY: e.changedTouches[0].clientY,
              screenX: e.changedTouches[0].screenX,
              screenY: e.changedTouches[0].screenY
            });
            
            const mouseUpEvent = new MouseEvent('mouseup', {
              bubbles: true,
              cancelable: true,
              view: window,
              clientX: e.changedTouches[0].clientX,
              clientY: e.changedTouches[0].clientY,
              screenX: e.changedTouches[0].screenX,
              screenY: e.changedTouches[0].screenY
            });
            
            canvasRef.current.dispatchEvent(mouseDownEvent);
            // Small delay to ensure mousedown is processed first
            setTimeout(() => {
              canvasRef.current.dispatchEvent(mouseUpEvent);
            }, 0);
          }
          
          touchStartTime = null;
        };
        
        const handleTouchCancel = () => {
          if (touchTimer) {
            clearTimeout(touchTimer);
            touchTimer = null;
          }
          touchStartTime = null;
        };
        
        return (
          <div
            key={`hover-link-${obj.id}`}
            className="dmt-object-hover-link"
            style={{
              position: 'absolute',
              left: `${screenX - objectWidth / 2}px`,
              top: `${screenY - objectHeight / 2}px`,
              width: `${objectWidth}px`,
              height: `${objectHeight}px`,
              zIndex: 10
            }}
            onClickCapture={(e) => {
              if (e.ctrlKey || e.metaKey) {
                // Ctrl/Cmd+Click: Open note
                e.preventDefault();
                e.stopPropagation();
                openNoteInNewTab(obj.linkedNote);
              } else {
                // Regular click: Pass through to canvas for tool interaction
                e.preventDefault();
                e.stopPropagation();
                
                // Create synthetic mousedown and mouseup events for canvas
                const mouseDownEvent = new MouseEvent('mousedown', {
                  bubbles: true,
                  cancelable: true,
                  view: window,
                  clientX: e.clientX,
                  clientY: e.clientY,
                  screenX: e.screenX,
                  screenY: e.screenY,
                  button: e.button,
                  buttons: e.buttons
                });
                
                const mouseUpEvent = new MouseEvent('mouseup', {
                  bubbles: true,
                  cancelable: true,
                  view: window,
                  clientX: e.clientX,
                  clientY: e.clientY,
                  screenX: e.screenX,
                  screenY: e.screenY,
                  button: e.button,
                  buttons: e.buttons
                });
                
                canvasRef.current.dispatchEvent(mouseDownEvent);
                // Small delay to ensure mousedown is processed first
                setTimeout(() => {
                  canvasRef.current.dispatchEvent(mouseUpEvent);
                }, 0);
              }
            }}
            onTouchStart={handleTouchStart}
            onTouchEnd={handleTouchEnd}
            onTouchCancel={handleTouchCancel}
          >
            <dc.Link link={dc.resolvePath(notePath)} />
          </div>
        );
      })}
    </>
  );
};

return { LinkedNoteHoverOverlays };
```

# MapContext

```tsx
/**
 * MapContext.tsx
 * Provides shared map state and operations to all layers via Context
 */

// Type-only imports
import type { MapStateContextValue, MapOperationsContextValue } from '#types/contexts/context.types';

// Create contexts with proper typing
const MapStateContext = dc.createContext<MapStateContextValue | null>(null);
const MapOperationsContext = dc.createContext<MapOperationsContextValue | null>(null);

/**
 * Hook to access shared map state
 * @returns Map state (canvasRef, mapData, geometry, coordinate utils)
 * @throws If used outside MapStateProvider
 */
function useMapState(): MapStateContextValue {
  const context = dc.useContext(MapStateContext);
  if (!context) {
    throw new Error('useMapState must be used within MapStateProvider');
  }
  return context;
}

/**
 * Hook to access map operations
 * @returns Map operations (getObjectAtPosition, addObject, etc.)
 * @throws If used outside MapOperationsProvider
 */
function useMapOperations(): MapOperationsContextValue {
  const context = dc.useContext(MapOperationsContext);
  if (!context) {
    throw new Error('useMapOperations must be used within MapOperationsProvider');
  }
  return context;
}

/** Props for MapStateProvider */
interface MapStateProviderProps {
  value: MapStateContextValue;
  children: React.ReactNode;
}

/**
 * Provider component for map state
 * Wraps children and provides read-only map state via Context
 */
const MapStateProvider: React.FC<MapStateProviderProps> = ({ value, children }) => {
  return (
    <MapStateContext.Provider value={value}>
      {children}
    </MapStateContext.Provider>
  );
};

/** Props for MapOperationsProvider */
interface MapOperationsProviderProps {
  value: MapOperationsContextValue;
  children: React.ReactNode;
}

/**
 * Provider component for map operations
 * Wraps children and provides map operation functions via Context
 */
const MapOperationsProvider: React.FC<MapOperationsProviderProps> = ({ value, children }) => {
  return (
    <MapOperationsContext.Provider value={value}>
      {children}
    </MapOperationsContext.Provider>
  );
};

// Datacore export
return {
  MapStateProvider,
  MapOperationsProvider,
  useMapState,
  useMapOperations,
  MapStateContext,
  MapOperationsContext
};

```

# MapSelectionContext

```tsx
/**
 * MapSelectionContext.tsx
 * Shared selection state for coordinating between layers
 * Allows multiple layers (ObjectLayer, TextLayer) to share selection state
 *
 * Supports both single and multi-selection:
 * - Single selection: click on object/text label
 * - Multi-selection: area select tool (two-click rectangle)
 */

// ===========================================
// Types
// ===========================================

/** Selected item types */
export type SelectableItemType = 'object' | 'text' | 'notePin';

/** A selected item */
export interface SelectedItem {
  type: SelectableItemType;
  id: string;
  data: Record<string, unknown>;
}

/** World position for area select start */
export interface AreaSelectPosition {
  worldX: number;
  worldY: number;
}

/** Drag start position */
export interface DragStartPosition {
  x: number;
  y: number;
  worldX?: number;
  worldY?: number;
}

/** Group drag offset for a single item */
export interface GroupDragOffset {
  type: SelectableItemType;
  gridOffsetX: number;
  gridOffsetY: number;
  worldOffsetX: number;
  worldOffsetY: number;
}

/** Layer visibility settings */
export interface LayerVisibility {
  objects: boolean;
  textLabels: boolean;
  hexCoordinates: boolean;
}

/** Mouse position */
export interface MousePosition {
  x: number;
  y: number;
}

/** Hovered object info */
export interface HoveredObject {
  id: string;
  type: string;
  [key: string]: unknown;
}

/** Item update for updateSelectedItemsData */
export interface ItemUpdate {
  id: string;
  [key: string]: unknown;
}

/** Initial state for batch history during group drag */
export interface GroupDragInitialState {
  objects: unknown[];
  textLabels: unknown[];
}

/** MapSelectionContext value shape */
export interface MapSelectionContextValue {
  // Multi-select state
  selectedItems: SelectedItem[];
  setSelectedItems: React.Dispatch<React.SetStateAction<SelectedItem[]>>;
  hasMultiSelection: boolean;
  selectionCount: number;

  // Selection helpers
  selectItem: (item: SelectedItem | null) => void;
  selectMultiple: (items: SelectedItem[] | null) => void;
  addToSelection: (item: SelectedItem | null) => void;
  removeFromSelection: (id: string) => void;
  clearSelection: () => void;
  isSelected: (id: string) => boolean;
  updateSelectedItemsData: (updates: ItemUpdate[]) => void;

  // Area select state
  areaSelectStart: AreaSelectPosition | null;
  setAreaSelectStart: React.Dispatch<React.SetStateAction<AreaSelectPosition | null>>;

  // Backward compatibility
  selectedItem: SelectedItem | null;
  setSelectedItem: (item: SelectedItem | null) => void;

  // Drag state
  isDraggingSelection: boolean;
  setIsDraggingSelection: React.Dispatch<React.SetStateAction<boolean>>;
  dragStart: DragStartPosition | null;
  setDragStart: React.Dispatch<React.SetStateAction<DragStartPosition | null>>;
  isResizeMode: boolean;
  setIsResizeMode: React.Dispatch<React.SetStateAction<boolean>>;

  // Group drag state
  groupDragOffsetsRef: React.MutableRefObject<Map<string, GroupDragOffset>>;
  groupDragInitialStateRef: React.MutableRefObject<GroupDragInitialState | null>;
  isGroupDragging: boolean;

  // Hover state
  hoveredObject: HoveredObject | null;
  setHoveredObject: React.Dispatch<React.SetStateAction<HoveredObject | null>>;
  mousePosition: MousePosition | null;
  setMousePosition: React.Dispatch<React.SetStateAction<MousePosition | null>>;

  // Note pin modal state
  showNoteLinkModal: boolean;
  setShowNoteLinkModal: React.Dispatch<React.SetStateAction<boolean>>;
  pendingNotePinId: string | null;
  setPendingNotePinId: React.Dispatch<React.SetStateAction<string | null>>;
  editingNoteObjectId: string | null;
  setEditingNoteObjectId: React.Dispatch<React.SetStateAction<string | null>>;

  // Coordinate overlay state
  showCoordinates: boolean;
  setShowCoordinates: React.Dispatch<React.SetStateAction<boolean>>;

  // Layer visibility
  layerVisibility: LayerVisibility;
}

// ===========================================
// Context
// ===========================================

const MapSelectionContext = dc.createContext<MapSelectionContextValue | null>(null);

/**
 * Hook to access shared selection state
 * @returns Selection state and setters
 * @throws If used outside MapSelectionProvider
 */
function useMapSelection(): MapSelectionContextValue {
  const context = dc.useContext(MapSelectionContext);
  if (!context) {
    throw new Error('useMapSelection must be used within MapSelectionProvider');
  }
  return context;
}

// ===========================================
// Provider Props
// ===========================================

interface MapSelectionProviderProps {
  children: React.ReactNode;
  layerVisibility?: Partial<LayerVisibility>;
}

/**
 * Provider component for shared selection state
 * Wraps children and provides selection coordination via Context
 */
const MapSelectionProvider: React.FC<MapSelectionProviderProps> = ({ children, layerVisibility }) => {
  // ============================================================================
  // SELECTION STATE (refactored for multi-select support)
  // ============================================================================

  // Primary selection state - array of selected items
  const [selectedItems, setSelectedItems] = dc.useState<SelectedItem[]>([]);

  // Area select tool state - first corner position for two-click selection
  const [areaSelectStart, setAreaSelectStart] = dc.useState<AreaSelectPosition | null>(null);

  // ============================================================================
  // SELECTION HELPERS
  // ============================================================================

  /**
   * Select a single item (clears any existing selection)
   */
  const selectItem = dc.useCallback((item: SelectedItem | null): void => {
    if (item) {
      setSelectedItems([item]);
    } else {
      setSelectedItems([]);
    }
  }, []);

  /**
   * Select multiple items (replaces existing selection)
   */
  const selectMultiple = dc.useCallback((items: SelectedItem[] | null): void => {
    setSelectedItems(items || []);
  }, []);

  /**
   * Add item to current selection
   */
  const addToSelection = dc.useCallback((item: SelectedItem | null): void => {
    if (!item) return;
    setSelectedItems(prev => {
      // Don't add duplicates
      if (prev.some(i => i.id === item.id)) return prev;
      return [...prev, item];
    });
  }, []);

  /**
   * Remove item from current selection
   */
  const removeFromSelection = dc.useCallback((id: string): void => {
    setSelectedItems(prev => prev.filter(item => item.id !== id));
  }, []);

  /**
   * Clear all selection
   */
  const clearSelection = dc.useCallback((): void => {
    setSelectedItems([]);
  }, []);

  /**
   * Check if an item is selected
   */
  const isSelected = dc.useCallback((id: string): boolean => {
    return selectedItems.some(item => item.id === id);
  }, [selectedItems]);

  /**
   * Update the data for selected items (used during drag to keep selection in sync)
   */
  const updateSelectedItemsData = dc.useCallback((updates: ItemUpdate[]): void => {
    if (!updates || updates.length === 0) return;

    const updateMap = new Map(updates.map(u => [u.id, u]));

    setSelectedItems(prev => prev.map(item => {
      const update = updateMap.get(item.id);
      if (update) {
        return {
          ...item,
          data: { ...item.data, ...update }
        };
      }
      return item;
    }));
  }, []);

  // ============================================================================
  // COMPUTED PROPERTIES
  // ============================================================================

  // Backward compatibility: single selected item (null if 0 or 2+ selected)
  const selectedItem = selectedItems.length === 1 ? selectedItems[0] : null;

  // Multi-selection flag
  const hasMultiSelection = selectedItems.length > 1;

  // Selection count
  const selectionCount = selectedItems.length;

  // ============================================================================
  // BACKWARD COMPATIBILITY - setSelectedItem wrapper
  // ============================================================================

  /**
   * Backward-compatible setter that wraps selectItem
   */
  const setSelectedItem = dc.useCallback((item: SelectedItem | null): void => {
    selectItem(item);
  }, [selectItem]);

  // ============================================================================
  // DRAG STATE (extended for group drag)
  // ============================================================================

  const [isDraggingSelection, setIsDraggingSelection] = dc.useState<boolean>(false);
  const [dragStart, setDragStart] = dc.useState<DragStartPosition | null>(null);
  const [isResizeMode, setIsResizeMode] = dc.useState<boolean>(false);

  // Group drag: ref to store offsets for all selected items during multi-select drag
  const groupDragOffsetsRef = dc.useRef<Map<string, GroupDragOffset>>(new Map());

  // Initial state ref for batch history (stores objects and textLabels before drag)
  const groupDragInitialStateRef = dc.useRef<GroupDragInitialState | null>(null);

  // Computed: are we dragging a multi-selection?
  const isGroupDragging = isDraggingSelection && hasMultiSelection;

  // ============================================================================
  // HOVER STATE
  // ============================================================================

  const [hoveredObject, setHoveredObject] = dc.useState<HoveredObject | null>(null);
  const [mousePosition, setMousePosition] = dc.useState<MousePosition | null>(null);

  // ============================================================================
  // NOTE PIN MODAL STATE
  // ============================================================================

  const [showNoteLinkModal, setShowNoteLinkModal] = dc.useState<boolean>(false);
  const [pendingNotePinId, setPendingNotePinId] = dc.useState<string | null>(null);
  const [editingNoteObjectId, setEditingNoteObjectId] = dc.useState<string | null>(null);

  // ============================================================================
  // COORDINATE OVERLAY STATE
  // ============================================================================

  const [showCoordinates, setShowCoordinates] = dc.useState<boolean>(false);

  // ============================================================================
  // LAYER VISIBILITY
  // ============================================================================

  const effectiveLayerVisibility: LayerVisibility = {
    objects: true,
    textLabels: true,
    hexCoordinates: true,
    ...layerVisibility
  };

  // ============================================================================
  // CONTEXT VALUE
  // ============================================================================

  const value: MapSelectionContextValue = {
    // Multi-select state
    selectedItems,
    setSelectedItems,
    hasMultiSelection,
    selectionCount,

    // Selection helpers
    selectItem,
    selectMultiple,
    addToSelection,
    removeFromSelection,
    clearSelection,
    isSelected,
    updateSelectedItemsData,

    // Area select state
    areaSelectStart,
    setAreaSelectStart,

    // Backward compatibility
    selectedItem,
    setSelectedItem,

    // Drag state
    isDraggingSelection,
    setIsDraggingSelection,
    dragStart,
    setDragStart,
    isResizeMode,
    setIsResizeMode,

    // Group drag state
    groupDragOffsetsRef,
    groupDragInitialStateRef,
    isGroupDragging,

    // Hover state
    hoveredObject,
    setHoveredObject,
    mousePosition,
    setMousePosition,

    // Note pin modal state
    showNoteLinkModal,
    setShowNoteLinkModal,
    pendingNotePinId,
    setPendingNotePinId,
    editingNoteObjectId,
    setEditingNoteObjectId,

    // Coordinate overlay state
    showCoordinates,
    setShowCoordinates,

    // Layer visibility
    layerVisibility: effectiveLayerVisibility
  };

  return (
    <MapSelectionContext.Provider value={value}>
      {children}
    </MapSelectionContext.Provider>
  );
};

return { MapSelectionProvider, useMapSelection };

```

# ObjectLinkingContext

```tsx
/**
 * ObjectLinkingContext.tsx
 * State management for the inter-object linking workflow.
 * Tracks when user is in "linking mode" and which object they're linking from.
 */

import type { Point } from '#types/core/geometry.types';

// ===========================================
// Types
// ===========================================

/** Source object info when starting a link */
export interface LinkingSource {
  layerId: string;
  objectId: string;
  position: Point;
  objectType: string;
}

/** ObjectLinkingContext value shape */
export interface ObjectLinkingContextValue {
  isLinkingMode: boolean;
  linkingFrom: LinkingSource | null;
  startLinking: (source: LinkingSource) => void;
  cancelLinking: () => void;
}

// ===========================================
// Context
// ===========================================

const ObjectLinkingContext = dc.createContext<ObjectLinkingContextValue | null>(null);

/**
 * Hook to access linking state
 * @returns Linking state and actions
 * @throws If used outside ObjectLinkingProvider
 */
function useLinkingMode(): ObjectLinkingContextValue {
  const context = dc.useContext(ObjectLinkingContext);
  if (!context) {
    throw new Error('useLinkingMode must be used within ObjectLinkingProvider');
  }
  return context;
}

// ===========================================
// Provider
// ===========================================

interface ObjectLinkingProviderProps {
  children: React.ReactNode;
}

/**
 * Provider component for linking workflow state.
 * Wraps children and provides linking coordination via Context.
 */
const ObjectLinkingProvider: React.FC<ObjectLinkingProviderProps> = ({ children }) => {
  const [linkingFrom, setLinkingFrom] = dc.useState<LinkingSource | null>(null);

  const startLinking = dc.useCallback((source: LinkingSource): void => {
    setLinkingFrom(source);
  }, []);

  const cancelLinking = dc.useCallback((): void => {
    setLinkingFrom(null);
  }, []);

  const value = dc.useMemo((): ObjectLinkingContextValue => ({
    isLinkingMode: linkingFrom !== null,
    linkingFrom,
    startLinking,
    cancelLinking
  }), [linkingFrom, startLinking, cancelLinking]);

  return (
    <ObjectLinkingContext.Provider value={value}>
      {children}
    </ObjectLinkingContext.Provider>
  );
};

return { ObjectLinkingProvider, useLinkingMode };

```

# rotationOperations

```ts
// Standard rotation positions (45 increments)
const ROTATION_STEPS = [0, 45, 90, 135, 180, 225, 270, 315] as const;
const ROTATION_INCREMENT = 45;

/**
 * Get the next rotation value in the cycle.
 * Handles non-standard values by snapping to 0.
 */
function getNextRotation(currentRotation: number): number {
	const currentIndex = ROTATION_STEPS.indexOf(currentRotation as typeof ROTATION_STEPS[number]);
	if (currentIndex === -1) {
		// Non-standard value, snap to 0
		return ROTATION_STEPS[0];
	}
	return ROTATION_STEPS[(currentIndex + 1) % ROTATION_STEPS.length];
}

/**
 * Rotate by increment (for bulk operations).
 * Works with any current value, not just standard positions.
 */
function rotateByIncrement(currentRotation: number): number {
	return (currentRotation + ROTATION_INCREMENT) % 360;
}

return { ROTATION_STEPS, ROTATION_INCREMENT, getNextRotation, rotateByIncrement };

```

# EventHandlerContext

```tsx
/**
 * EventHandlerContext.tsx
 *
 * Provides a registration system for event handlers from different layers.
 * Layers register their handlers (object, text, drawing, notePin, panZoom)
 * and the EventCoordinationLayer uses these to route pointer events.
 *
 * This enables clean separation: each layer owns its handlers,
 * EventCoordinationLayer owns the routing logic.
 */

// ===========================================
// Types
// ===========================================

/** Layer types that can register handlers */
export type HandlerLayerType =
  | 'object'
  | 'text'
  | 'drawing'
  | 'notePin'
  | 'panZoom'
  | 'fog'
  | 'areaSelect'
  | 'measure'
  | 'alignment'
  | 'imageAlignment'
  | 'diagonalFill';

/** Generic handler function type */
export type HandlerFunction = (...args: unknown[]) => unknown;

/** Handler set for a layer */
export interface LayerHandlers {
  handlePointerDown?: HandlerFunction;
  handlePointerMove?: HandlerFunction;
  handlePointerUp?: HandlerFunction;
  handleWheel?: HandlerFunction;
  handleClick?: HandlerFunction;
  handleDoubleClick?: HandlerFunction;
  handleKeyDown?: HandlerFunction;
  handleKeyUp?: HandlerFunction;
  [key: string]: HandlerFunction | undefined;
}

/** All registered handlers by layer type */
export type HandlersRegistry = Partial<Record<HandlerLayerType, LayerHandlers>>;

/** EventHandlerContext value shape */
export interface EventHandlerContextValue {
  registerHandlers: (layerType: HandlerLayerType, handlers: LayerHandlers) => void;
  unregisterHandlers: (layerType: HandlerLayerType) => void;
  getHandlers: (layerType: HandlerLayerType) => LayerHandlers | null;
  getAllHandlers: () => HandlersRegistry;
}

// ===========================================
// Context
// ===========================================

const EventHandlerContext = dc.createContext<EventHandlerContextValue | null>(null);

/**
 * Hook for layers to register their event handlers
 * @returns Registration and access functions
 * @throws If used outside EventHandlerProvider
 */
function useEventHandlerRegistration(): EventHandlerContextValue {
  const context = dc.useContext(EventHandlerContext);
  if (!context) {
    throw new Error('useEventHandlerRegistration must be used within EventHandlerProvider');
  }
  return context;
}

/**
 * Hook for EventCoordinationLayer to access all registered handlers
 * @returns Registration and access functions
 * @throws If used outside EventHandlerProvider
 */
function useRegisteredHandlers(): EventHandlerContextValue {
  const context = dc.useContext(EventHandlerContext);
  if (!context) {
    throw new Error('useRegisteredHandlers must be used within EventHandlerProvider');
  }
  return context;
}

// ===========================================
// Provider
// ===========================================

interface EventHandlerProviderProps {
  children: React.ReactNode;
}

/**
 * Provider component that manages handler registration
 * Wraps the entire layer system to provide registration capabilities
 */
const EventHandlerProvider: React.FC<EventHandlerProviderProps> = ({ children }) => {
  // Store handlers by layer type
  const handlersRef = dc.useRef<HandlersRegistry>({});

  /**
   * Register handlers for a specific layer type
   */
  const registerHandlers = dc.useCallback((layerType: HandlerLayerType, handlers: LayerHandlers): void => {
    handlersRef.current[layerType] = handlers;
  }, []);

  /**
   * Unregister handlers for a specific layer type
   */
  const unregisterHandlers = dc.useCallback((layerType: HandlerLayerType): void => {
    delete handlersRef.current[layerType];
  }, []);

  /**
   * Get handlers for a specific layer type
   */
  const getHandlers = dc.useCallback((layerType: HandlerLayerType): LayerHandlers | null => {
    return handlersRef.current[layerType] || null;
  }, []);

  /**
   * Get all registered handlers
   */
  const getAllHandlers = dc.useCallback((): HandlersRegistry => {
    return handlersRef.current;
  }, []);

  const contextValue = dc.useMemo<EventHandlerContextValue>(() => ({
    registerHandlers,
    unregisterHandlers,
    getHandlers,
    getAllHandlers
  }), [registerHandlers, unregisterHandlers, getHandlers, getAllHandlers]);

  return (
    <EventHandlerContext.Provider value={contextValue}>
      {children}
    </EventHandlerContext.Provider>
  );
};

return {
  EventHandlerProvider,
  useEventHandlerRegistration,
  useRegisteredHandlers,
  EventHandlerContext
};

```

# useObjectInteractions

```ts
/**
 * useObjectInteractions.ts
 *
 * Custom hook for managing object interactions including:
 * - Object placement on click
 * - Object selection
 * - Object dragging with grid snapping
 * - Object resizing with corner handles
 * - Hover state management
 * - Object note and color management
 * - Button position calculations for object UI
 */

// Type-only imports
import type { Point, IGeometry } from '#types/core/geometry.types';
import type { MapData, MapLayer } from '#types/core/map.types';
import type { MapObject } from '#types/objects/object.types';
import type { ToolId } from '#types/tools/tool.types';
import type {
  ResizeCorner,
  ObjectDragStart,
  ButtonPosition,
  MousePosition,
  UseObjectInteractionsResult,
} from '#types/hooks/objectInteractions.types';
import type { SelectedItem } from '#types/hooks/groupDrag.types';

// Datacore imports
const { getNextRotation } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "rotationOperations")) as {
  getNextRotation: (currentRotation: number) => number
};

// Context types
interface MapStateValue {
  geometry: (IGeometry & {
    cellSize: number;
    hexSize?: number;
    isWithinBounds?: (x: number, y: number) => boolean;
    getScaledCellSize?: (zoom: number) => number;
    hexToWorld?: (x: number, y: number) => { worldX: number; worldY: number };
    gridToScreen?: (x: number, y: number, offsetX: number, offsetY: number, zoom: number) => { screenX: number; screenY: number };
    gridToWorld?: (x: number, y: number) => { worldX: number; worldY: number };
    worldToGrid?: (worldX: number, worldY: number) => Point;
    width?: number;
    toOffsetCoords: (x: number, y: number) => { col: number; row: number };
  }) | null;
  canvasRef: { current: HTMLCanvasElement | null };
  containerRef: { current: HTMLElement | null };
  mapData: MapData | null;
  screenToGrid: (clientX: number, clientY: number) => Point | null;
  screenToWorld: (clientX: number, clientY: number) => { worldX: number; worldY: number } | null;
  getClientCoords: (e: PointerEvent | MouseEvent | TouchEvent) => { clientX: number; clientY: number };
  GridGeometry: unknown;
}

interface MapOperationsValue {
  getObjectAtPosition: (objects: MapObject[], x: number, y: number) => MapObject | null;
  addObject: (objects: MapObject[], type: string, x: number, y: number) => MapObject[];
  updateObject: (objects: MapObject[], id: string, updates: Partial<MapObject>) => MapObject[];
  removeObject: (objects: MapObject[], id: string) => MapObject[];
  isAreaFree: (objects: MapObject[], x: number, y: number, width: number, height: number, excludeId?: string) => boolean;
  onObjectsChange: (objects: MapObject[], skipHistory?: boolean) => void;
}

interface MapSelectionValue {
  selectedItem: SelectedItem | null;
  setSelectedItem: (item: SelectedItem | null) => void;
  isDraggingSelection: boolean;
  setIsDraggingSelection: (value: boolean) => void;
  dragStart: ObjectDragStart | null;
  setDragStart: (value: ObjectDragStart | null) => void;
  isResizeMode: boolean;
  setIsResizeMode: (value: boolean) => void;
  hoveredObject: MapObject | null;
  setHoveredObject: (obj: MapObject | null) => void;
  mousePosition: MousePosition | null;
  setMousePosition: (pos: MousePosition | null) => void;
}

interface ScreenPositionResult {
  screenX: number;
  screenY: number;
  objectWidth: number;
  objectHeight: number;
}

const { calculateObjectScreenPosition: calculateScreenPos, applyInverseRotation } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "screenPositionUtils")) as {
  calculateObjectScreenPosition: (object: MapObject, canvas: HTMLCanvasElement, mapData: MapData, geometry: IGeometry) => ScreenPositionResult | null;
  applyInverseRotation: (x: number, y: number, width: number, height: number, angle: number) => { x: number; y: number };
};

const { useMapState, useMapOperations } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext")) as {
  useMapState: () => MapStateValue;
  useMapOperations: () => MapOperationsValue;
};

const { useMapSelection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSelectionContext")) as {
  useMapSelection: () => MapSelectionValue;
};

const { calculateEdgeAlignment, getAlignmentOffset, placeObject, canPlaceObjectAt, removeObjectFromHex, generateObjectId } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "objectOperations")) as {
  calculateEdgeAlignment: (fractionalX: number, fractionalY: number, gridX: number, gridY: number) => string;
  getAlignmentOffset: (alignment: string, cellSize: number) => { x: number; y: number };
  placeObject: (objects: MapObject[], type: string, x: number, y: number, options: { mapType: string; alignment?: string }) => { success: boolean; objects: MapObject[] };
  canPlaceObjectAt: (objects: MapObject[], x: number, y: number, mapType: string) => boolean;
  removeObjectFromHex: (objects: MapObject[], id: string) => MapObject[];
  generateObjectId: () => string;
};

const { getClickedObjectInCell, getObjectsInCell, canAddObjectToCell, assignSlot } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "hexSlotPositioner")) as {
  getClickedObjectInCell: (objects: MapObject[], x: number, y: number, offsetX: number, offsetY: number, orientation: string) => MapObject | null;
  getObjectsInCell: (objects: MapObject[], x: number, y: number) => MapObject[];
  canAddObjectToCell: (objects: MapObject[], x: number, y: number) => boolean;
  assignSlot: (occupiedSlots: number[]) => number;
};

const { HexGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "HexGeometry")) as {
  HexGeometry: new (...args: unknown[]) => IGeometry;
};

const { getActiveLayer, isCellFogged } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor")) as {
  getActiveLayer: (mapData: MapData) => MapLayer;
  isCellFogged: (layer: MapLayer, col: number, row: number) => boolean;
};

const useObjectInteractions = (
  currentTool: ToolId,
  selectedObjectType: string | null,
  onAddCustomColor: ((color: string) => void) | undefined,
  customColors: string[]
): UseObjectInteractionsResult => {
  const {
    geometry,
    canvasRef,
    containerRef,
    mapData,
    screenToGrid,
    screenToWorld,
    getClientCoords,
    GridGeometry
  } = useMapState();

  const {
    getObjectAtPosition,
    addObject,
    updateObject,
    removeObject,
    isAreaFree,
    onObjectsChange
  } = useMapOperations();

  const {
    selectedItem,
    setSelectedItem,
    isDraggingSelection,
    setIsDraggingSelection,
    dragStart,
    setDragStart,
    isResizeMode,
    setIsResizeMode,
    hoveredObject,
    setHoveredObject,
    mousePosition,
    setMousePosition
  } = useMapSelection();

  const [isResizing, setIsResizing] = dc.useState<boolean>(false);
  const [resizeCorner, setResizeCorner] = dc.useState<ResizeCorner>(null);
  const resizeInitialStateRef = dc.useRef<MapObject[] | null>(null);
  const dragInitialStateRef = dc.useRef<MapObject[] | null>(null);

  const [edgeSnapMode, setEdgeSnapMode] = dc.useState<boolean>(false);
  const longPressTimerRef = dc.useRef<ReturnType<typeof setTimeout> | null>(null);
  const altKeyPressedRef = dc.useRef<boolean>(false);

  const objectColorBtnRef = dc.useRef<HTMLButtonElement | null>(null);
  const pendingObjectCustomColorRef = dc.useRef<string | null>(null);

  dc.useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent): void => {
      if (e.key === 'Alt' && !altKeyPressedRef.current) {
        altKeyPressedRef.current = true;
        if (currentTool === 'addObject' || selectedItem?.type === 'object') {
          setEdgeSnapMode(true);
        }
      }
    };

    const handleKeyUp = (e: KeyboardEvent): void => {
      if (e.key === 'Alt') {
        altKeyPressedRef.current = false;
        setEdgeSnapMode(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [selectedItem, currentTool]);

  dc.useEffect(() => {
    return () => {
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current);
      }
    };
  }, []);

  const prevToolRef = dc.useRef<ToolId>(currentTool);
  dc.useEffect(() => {
    if (!selectedItem || selectedItem.type !== 'object') {
      setEdgeSnapMode(false);
    }

    if (prevToolRef.current !== currentTool && selectedItem) {
      if (currentTool !== 'select') {
        setSelectedItem(null);
        setEdgeSnapMode(false);
      }
    }
    prevToolRef.current = currentTool;
  }, [currentTool, selectedItem, setSelectedItem]);

  const getClickedCorner = dc.useCallback((
    clientX: number,
    clientY: number,
    object: MapObject
  ): ResizeCorner => {
    if (!object || !mapData) return null;
    if (!geometry) return null;
    if (!canvasRef.current) return null;

    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();

    let x = clientX - rect.left;
    let y = clientY - rect.top;

    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    x *= scaleX;
    y *= scaleY;

    const { viewState, northDirection, mapType } = mapData;
    const { zoom, center } = viewState;

    let offsetX: number, offsetY: number, objectWidth: number, objectHeight: number;
    if (mapType === 'hex') {
      offsetX = canvas.width / 2 - center.x * zoom;
      offsetY = canvas.height / 2 - center.y * zoom;

      const hexSize = geometry.hexSize!;
      const size = object.size || { width: 1, height: 1 };
      objectWidth = size.width * hexSize * zoom;
      objectHeight = size.height * hexSize * zoom;
    } else {
      const scaledGridSize = geometry.getScaledCellSize!(zoom);
      offsetX = canvas.width / 2 - center.x * scaledGridSize;
      offsetY = canvas.height / 2 - center.y * scaledGridSize;

      const size = object.size || { width: 1, height: 1 };
      objectWidth = size.width * scaledGridSize;
      objectHeight = size.height * scaledGridSize;
    }

    const rotated = applyInverseRotation(x, y, canvas.width, canvas.height, northDirection);
    x = rotated.x;
    y = rotated.y;

    let screenX: number, screenY: number;
    if (mapType === 'hex') {
      const { worldX, worldY } = geometry.hexToWorld!(object.position.x, object.position.y);
      screenX = offsetX + worldX * zoom;
      screenY = offsetY + worldY * zoom;

      screenX -= objectWidth / 2;
      screenY -= objectHeight / 2;
    } else {
      const pos = geometry.gridToScreen!(object.position.x, object.position.y, offsetX, offsetY, zoom);
      screenX = pos.screenX;
      screenY = pos.screenY;
    }

    const handleSize = isResizeMode ? 14 : 8;
    const hitMargin = handleSize / 2 + 4;

    const corners = [
      { name: 'tl' as const, cx: screenX + 2, cy: screenY + 2 },
      { name: 'tr' as const, cx: screenX + objectWidth - 2, cy: screenY + 2 },
      { name: 'bl' as const, cx: screenX + 2, cy: screenY + objectHeight - 2 },
      { name: 'br' as const, cx: screenX + objectWidth - 2, cy: screenY + objectHeight - 2 }
    ];

    for (const corner of corners) {
      const dx = x - corner.cx;
      const dy = y - corner.cy;
      if (Math.abs(dx) <= hitMargin && Math.abs(dy) <= hitMargin) {
        return corner.name;
      }
    }

    return null;
  }, [mapData, isResizeMode, canvasRef, geometry]);

  const handleObjectPlacement = dc.useCallback((
    gridX: number,
    gridY: number,
    clientX: number,
    clientY: number
  ): boolean => {
    if (currentTool !== 'addObject' || !selectedObjectType) {
      return false;
    }

    if (geometry && geometry.isWithinBounds) {
      if (!geometry.isWithinBounds(gridX, gridY)) {
        return true;
      }
    }

    const mapType = mapData!.mapType || 'grid';

    if (!canPlaceObjectAt(getActiveLayer(mapData!).objects || [], gridX, gridY, mapType)) {
      return true;
    }

    let alignment = 'center';
    if (mapType === 'grid' && edgeSnapMode && clientX !== undefined && clientY !== undefined) {
      const worldCoords = screenToWorld(clientX, clientY);
      if (worldCoords && geometry) {
        const cellSize = mapData!.gridSize || geometry.cellSize;
        const fractionalX = worldCoords.worldX / cellSize;
        const fractionalY = worldCoords.worldY / cellSize;
        alignment = calculateEdgeAlignment(fractionalX, fractionalY, gridX, gridY);
      }
    }

    const result = placeObject(
      getActiveLayer(mapData!).objects || [],
      selectedObjectType,
      gridX,
      gridY,
      { mapType, alignment }
    );

    if (result.success) {
      onObjectsChange(result.objects);
    }
    return true;
  }, [currentTool, selectedObjectType, mapData, geometry, edgeSnapMode, onObjectsChange, screenToWorld]);

  const handleObjectSelection = dc.useCallback((
    clientX: number,
    clientY: number,
    gridX: number,
    gridY: number
  ): boolean => {
    if (currentTool !== 'select') {
      return false;
    }

    if (selectedItem?.type === 'object' && isResizeMode) {
      const selectedObject = getActiveLayer(mapData!).objects?.find((obj: MapObject) => obj.id === selectedItem.id);
      if (selectedObject) {
        const corner = getClickedCorner(clientX, clientY, selectedObject);
        if (corner) {
          resizeInitialStateRef.current = [...(getActiveLayer(mapData!).objects || [])];
          setIsResizing(true);
          setResizeCorner(corner);
          setDragStart({ x: clientX, y: clientY, gridX, gridY, object: { ...selectedObject } });
          return true;
        }
      }
    }

    let object: MapObject | null = null;
    if (mapData!.mapType === 'hex' && geometry instanceof HexGeometry) {
      const cellObjects = getObjectsInCell(getActiveLayer(mapData!).objects || [], gridX, gridY);

      if (cellObjects.length > 1) {
        const worldCoords = screenToWorld(clientX, clientY);
        if (worldCoords && geometry.hexToWorld) {
          const { worldX: hexCenterX, worldY: hexCenterY } = geometry.hexToWorld(gridX, gridY);
          const hexWidth = geometry.hexSize! * 2;
          const clickOffsetX = (worldCoords.worldX - hexCenterX) / hexWidth;
          const clickOffsetY = (worldCoords.worldY - hexCenterY) / hexWidth;

          object = getClickedObjectInCell(
            getActiveLayer(mapData!).objects || [],
            gridX,
            gridY,
            clickOffsetX,
            clickOffsetY,
            mapData!.orientation || 'flat'
          );
        }
      } else if (cellObjects.length === 1) {
        object = cellObjects[0];
      }
    } else {
      object = getObjectAtPosition(getActiveLayer(mapData!).objects || [], gridX, gridY);
    }

    if (object) {
      const activeLayer = getActiveLayer(mapData!);
      if (activeLayer.fogOfWar?.enabled) {
        const objOffset = geometry!.toOffsetCoords(object.position.x, object.position.y);
        if (isCellFogged(activeLayer, objOffset.col, objOffset.row)) {
          object = null;
        }
      }
    }

    if (object) {
      const isAlreadySelected = selectedItem?.type === 'object' && selectedItem.id === object.id;

      if (isAlreadySelected) {
        if (longPressTimerRef.current) {
          clearTimeout(longPressTimerRef.current);
        }

        if (mapData!.mapType !== 'hex') {
          longPressTimerRef.current = setTimeout(() => {
            setEdgeSnapMode(prev => !prev);

            if (navigator.vibrate) {
              navigator.vibrate(50);
            }

            longPressTimerRef.current = null;
          }, 500);
        }

        dragInitialStateRef.current = [...(getActiveLayer(mapData!).objects || [])];
        setIsDraggingSelection(true);
        const offsetX = gridX - object.position.x;
        const offsetY = gridY - object.position.y;
        setDragStart({ x: clientX, y: clientY, gridX, gridY, offsetX, offsetY });
        setIsResizeMode(false);
      } else {
        setSelectedItem({ type: 'object', id: object.id, data: object });
        setIsResizeMode(false);

        dragInitialStateRef.current = [...(getActiveLayer(mapData!).objects || [])];
        setIsDraggingSelection(true);
        const offsetX = gridX - object.position.x;
        const offsetY = gridY - object.position.y;
        setDragStart({
          x: clientX,
          y: clientY,
          gridX,
          gridY,
          offsetX,
          offsetY,
          objectId: object.id
        });

        if (longPressTimerRef.current) {
          clearTimeout(longPressTimerRef.current);
        }

        if (mapData!.mapType !== 'hex') {
          longPressTimerRef.current = setTimeout(() => {
            setEdgeSnapMode(true);

            if (navigator.vibrate) {
              navigator.vibrate(50);
            }

            longPressTimerRef.current = null;
          }, 500);
        }
      }

      return true;
    }

    return false;
  }, [currentTool, selectedObjectType, selectedItem, isResizeMode, mapData, geometry,
    getObjectAtPosition, setSelectedItem, setIsDraggingSelection, setDragStart, setIsResizing, screenToWorld, getClickedCorner
  ]);

  const handleObjectDragging = dc.useCallback((e: PointerEvent | MouseEvent | TouchEvent): boolean => {
    const isDraggingObject = selectedItem?.type === 'object' || dragStart?.objectId;
    if (!isDraggingSelection || !isDraggingObject || !dragStart || !mapData) {
      return false;
    }

    const objectId = selectedItem?.id || dragStart.objectId;

    const { clientX, clientY } = getClientCoords(e);

    if (longPressTimerRef.current) {
      const dx = clientX - dragStart.x;
      const dy = clientY - dragStart.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > 5) {
        clearTimeout(longPressTimerRef.current);
        longPressTimerRef.current = null;
      }
    }

    e.preventDefault();
    e.stopPropagation();

    const coords = screenToGrid(clientX, clientY);
    if (!coords) return true;

    const { x, y } = coords;

    const offsetX = dragStart.offsetX || 0;
    const offsetY = dragStart.offsetY || 0;
    const targetX = x - offsetX;
    const targetY = y - offsetY;

    if (x !== dragStart.gridX || y !== dragStart.gridY) {
      const currentObject = getActiveLayer(mapData).objects?.find((o: MapObject) => o.id === objectId);
      if (!currentObject) return true;

      const isMovingWithinSameCell = currentObject.position.x === targetX && currentObject.position.y === targetY;

      if (mapData.mapType === 'hex' && !isMovingWithinSameCell) {
        const targetCellObjects = getObjectsInCell(getActiveLayer(mapData).objects || [], targetX, targetY);

        if (targetCellObjects.length >= 4) {
          return true;
        }

        const targetSlots = targetCellObjects.map((o: MapObject) => o.slot ?? 0);
        const newSlot = assignSlot(targetSlots);

        let updatedObjects = removeObjectFromHex(getActiveLayer(mapData).objects, objectId!);

        updatedObjects = [...updatedObjects, {
          ...currentObject,
          position: { x: targetX, y: targetY },
          slot: newSlot
        }];

        onObjectsChange(updatedObjects, true);

        setDragStart({ x: clientX, y: clientY, gridX: x, gridY: y, offsetX, offsetY, objectId });
        const movedObject = updatedObjects.find((obj: MapObject) => obj.id === objectId);
        if (movedObject) {
          setSelectedItem({
            type: 'object',
            id: objectId!
          });
        }
      } else {
        const existingObj = getObjectAtPosition(getActiveLayer(mapData).objects || [], targetX, targetY);

        if (!existingObj || existingObj.id === objectId) {
          let alignment = 'center';
          if (edgeSnapMode) {
            const worldCoords = screenToWorld(clientX, clientY);
            if (worldCoords && geometry?.worldToGrid) {
              const fractionalX = worldCoords.worldX / (mapData.gridSize || geometry.cellSize);
              const fractionalY = worldCoords.worldY / (mapData.gridSize || geometry.cellSize);
              alignment = calculateEdgeAlignment(fractionalX, fractionalY, targetX, targetY);
            }
          }

          const updatedObjects = updateObject(
            getActiveLayer(mapData).objects,
            objectId!,
            { position: { x: targetX, y: targetY }, alignment }
          );
          onObjectsChange(updatedObjects, true);

          setDragStart({ x: clientX, y: clientY, gridX: x, gridY: y, offsetX, offsetY, objectId });
          const updatedObject = updatedObjects.find((obj: MapObject) => obj.id === objectId);
          if (updatedObject) {
            setSelectedItem({
              type: 'object',
              id: objectId!
            });
          }
        }
      }
    }
    return true;
  }, [isDraggingSelection, selectedItem, dragStart, mapData, edgeSnapMode, geometry,
    getClientCoords, screenToGrid, screenToWorld, updateObject, onObjectsChange, setDragStart, setSelectedItem, getObjectAtPosition]);

  const handleObjectResizing = dc.useCallback((e: PointerEvent | MouseEvent | TouchEvent): boolean => {
    if (!isResizing || !dragStart || !mapData || selectedItem?.type !== 'object') {
      return false;
    }

    e.preventDefault();
    e.stopPropagation();

    const { clientX, clientY } = getClientCoords(e);
    const coords = screenToGrid(clientX, clientY);
    if (!coords) return true;

    const { x, y } = coords;
    const originalObject = dragStart.object!;
    const originalPos = originalObject.position;
    const originalSize = originalObject.size || { width: 1, height: 1 };

    let newX = originalPos.x;
    let newY = originalPos.y;
    let newWidth = originalSize.width;
    let newHeight = originalSize.height;

    switch (resizeCorner) {
      case 'tl':
        newX = Math.min(x, originalPos.x + originalSize.width - 1);
        newY = Math.min(y, originalPos.y + originalSize.height - 1);
        newWidth = originalPos.x + originalSize.width - newX;
        newHeight = originalPos.y + originalSize.height - newY;
        break;
      case 'tr':
        newY = Math.min(y, originalPos.y + originalSize.height - 1);
        newWidth = Math.max(1, x - originalPos.x + 1);
        newHeight = originalPos.y + originalSize.height - newY;
        break;
      case 'bl':
        newX = Math.min(x, originalPos.x + originalSize.width - 1);
        newWidth = originalPos.x + originalSize.width - newX;
        newHeight = Math.max(1, y - originalPos.y + 1);
        break;
      case 'br':
        newWidth = Math.max(1, x - originalPos.x + 1);
        newHeight = Math.max(1, y - originalPos.y + 1);
        break;
    }

    newWidth = Math.min(newWidth, 5);
    newHeight = Math.min(newHeight, 5);

    let finalWidth = newWidth;
    let finalHeight = newHeight;
    let finalX = newX;
    let finalY = newY;
    let resizeSucceeded = false;

    if (isAreaFree(getActiveLayer(mapData).objects, newX, newY, newWidth, newHeight, selectedItem.id)) {
      resizeSucceeded = true;
    }

    if (!resizeSucceeded && newWidth !== originalSize.width) {
      if (isAreaFree(getActiveLayer(mapData).objects, newX, originalPos.y, newWidth, originalSize.height, selectedItem.id)) {
        finalWidth = newWidth;
        finalHeight = originalSize.height;
        finalX = newX;
        finalY = originalPos.y;
        resizeSucceeded = true;
      }
    }

    if (!resizeSucceeded && newHeight !== originalSize.height) {
      if (isAreaFree(getActiveLayer(mapData).objects, originalPos.x, newY, originalSize.width, newHeight, selectedItem.id)) {
        finalWidth = originalSize.width;
        finalHeight = newHeight;
        finalX = originalPos.x;
        finalY = newY;
        resizeSucceeded = true;
      }
    }

    if (resizeSucceeded) {
      const updatedObjects = updateObject(
        getActiveLayer(mapData).objects,
        selectedItem.id,
        {
          position: { x: finalX, y: finalY },
          size: { width: finalWidth, height: finalHeight }
        }
      );
      onObjectsChange(updatedObjects, true);

      const updatedObject = updatedObjects.find((obj: MapObject) => obj.id === selectedItem.id);
      if (updatedObject) {
        setSelectedItem({
          ...selectedItem,
          id: selectedItem.id
        });
      }
    }
    return true;
  }, [isResizing, dragStart, mapData, selectedItem, resizeCorner,
    getClientCoords, screenToGrid, isAreaFree, updateObject, onObjectsChange, setSelectedItem]
  );

  const handleHoverUpdate = dc.useCallback((e: PointerEvent | MouseEvent): void => {
    const touchEvent = e as unknown as TouchEvent;
    if (!touchEvent.touches && mapData && getActiveLayer(mapData).objects) {
      const { clientX, clientY } = getClientCoords(e);
      const coords = screenToGrid(clientX, clientY);
      if (coords) {
        let obj: MapObject | null = null;

        const { x, y } = coords;

        if (mapData.mapType === 'hex' && geometry instanceof HexGeometry) {
          const worldCoords = screenToWorld(clientX, clientY);
          if (worldCoords) {
            const hexCenter = geometry.gridToWorld!(x, y);
            const clickOffsetX = (worldCoords.worldX - hexCenter.worldX) / geometry.width!;
            const clickOffsetY = (worldCoords.worldY - hexCenter.worldY) / geometry.width!;

            obj = getClickedObjectInCell(
              getActiveLayer(mapData).objects,
              x, y,
              clickOffsetX, clickOffsetY,
              mapData.orientation || 'flat'
            );
          }
        }

        if (!obj) {
          obj = getObjectAtPosition(getActiveLayer(mapData).objects, x, y);
        }

        if (obj) {
          const activeLayer = getActiveLayer(mapData);
          if (activeLayer.fogOfWar?.enabled) {
            const objOffset = geometry!.toOffsetCoords(obj.position.x, obj.position.y);
            if (isCellFogged(activeLayer, objOffset.col, objOffset.row)) {
              obj = null;
            }
          }
        }

        setHoveredObject(obj);

        const container = containerRef.current;
        if (container) {
          const rect = container.getBoundingClientRect();
          const relativeX = clientX - rect.left;
          const relativeY = clientY - rect.top;
          setMousePosition({ x: relativeX, y: relativeY });
        }
      } else {
        setHoveredObject(null);
      }
    }
  }, [mapData, geometry, getClientCoords, screenToGrid, screenToWorld, getObjectAtPosition, setHoveredObject, setMousePosition, containerRef]
  );

  const stopObjectDragging = dc.useCallback((): boolean => {
    const isDraggingObject = selectedItem?.type === 'object' || dragStart?.objectId;
    if (isDraggingSelection && isDraggingObject) {
      if (longPressTimerRef.current) {
        clearTimeout(longPressTimerRef.current);
        longPressTimerRef.current = null;
      }

      setIsDraggingSelection(false);
      setDragStart(null);

      if (dragInitialStateRef.current !== null) {
        onObjectsChange(getActiveLayer(mapData!).objects, false);
        dragInitialStateRef.current = null;
      }
      return true;
    }
    return false;
  }, [isDraggingSelection, selectedItem, dragStart, setIsDraggingSelection, setDragStart, onObjectsChange, mapData]);

  const stopObjectResizing = dc.useCallback((): boolean => {
    if (isResizing) {
      setIsResizing(false);
      setResizeCorner(null);
      setDragStart(null);

      if (resizeInitialStateRef.current !== null) {
        onObjectsChange(getActiveLayer(mapData!).objects, false);
        resizeInitialStateRef.current = null;
      }
      return true;
    }
    return false;
  }, [isResizing, setIsResizing, setResizeCorner, setDragStart, onObjectsChange, mapData]
  );

  const handleObjectKeyDown = dc.useCallback((e: KeyboardEvent): boolean => {
    if (selectedItem?.type !== 'object') {
      return false;
    }

    if (e.key === 'r' || e.key === 'R') {
      e.preventDefault();
      const currentObject = getActiveLayer(mapData!).objects?.find((obj: MapObject) => obj.id === selectedItem.id);
      const currentRotation = currentObject?.rotation || 0;
      const nextRotation = getNextRotation(currentRotation);

      const updatedObjects = updateObject(
        getActiveLayer(mapData!).objects,
        selectedItem.id,
        { rotation: nextRotation }
      );
      onObjectsChange(updatedObjects);

      return true;
    }

    if (e.key === 'Delete' || e.key === 'Backspace') {
      e.preventDefault();
      const updatedObjects = removeObject(getActiveLayer(mapData!).objects, selectedItem.id);
      onObjectsChange(updatedObjects);
      setSelectedItem(null);
      setIsResizeMode(false);
      return true;
    }

    if (e.key === 'Escape' && isResizeMode) {
      e.preventDefault();
      setIsResizeMode(false);
      return true;
    }

    return false;
  }, [selectedItem, isResizeMode, mapData, removeObject, updateObject, onObjectsChange, setSelectedItem, setIsResizeMode]
  );

  const handleObjectWheel = dc.useCallback((e: WheelEvent): boolean => {
    if (selectedItem?.type !== 'object' || !mapData) {
      return false;
    }

    const coords = screenToGrid(e.clientX, e.clientY);
    if (!coords) return false;

    const { x, y } = coords;
    const selectedObject = getActiveLayer(mapData).objects.find((obj: MapObject) => obj.id === selectedItem.id);
    if (!selectedObject) return false;

    const isOverObject = x >= selectedObject.position.x &&
                     x < selectedObject.position.x + (selectedObject.size?.width || 1) &&
                     y >= selectedObject.position.y &&
                     y < selectedObject.position.y + (selectedObject.size?.height || 1);

    if (!isOverObject) return false;

    e.preventDefault();

    const currentScale = selectedObject.scale ?? 1.0;
    const delta = e.deltaY > 0 ? -0.05 : 0.05;
    const newScale = Math.max(0.25, Math.min(1.3, currentScale + delta));

    if (newScale !== currentScale) {
      const updatedObjects = updateObject(getActiveLayer(mapData).objects, selectedItem.id, { scale: newScale });
      onObjectsChange(updatedObjects);
    }

    return true;
  }, [selectedItem, mapData, screenToGrid, updateObject, onObjectsChange]);

  const calculateLabelButtonPosition = dc.useCallback((): ButtonPosition => {
    if (selectedItem?.type !== 'object' || !mapData || !canvasRef.current) {
      return { x: 0, y: 0 };
    }

    const object = getActiveLayer(mapData).objects.find((obj: MapObject) => obj.id === selectedItem.id);
    if (!object) return { x: 0, y: 0 };

    const pos = calculateScreenPos(object, canvasRef.current, mapData, geometry!);
    if (!pos) return { x: 0, y: 0 };

    const { screenX, screenY, objectWidth, objectHeight } = pos;
    const buttonOffset = 4;

    const buttonX = screenX + (objectWidth / 2) + buttonOffset;
    const buttonY = screenY - (objectHeight / 2) - buttonOffset - 22;

    return { x: buttonX, y: buttonY };
  }, [selectedItem, mapData, canvasRef, geometry]
  );

  const calculateLinkNoteButtonPosition = dc.useCallback((): ButtonPosition => {
    if (selectedItem?.type !== 'object' || !mapData || !canvasRef.current) {
      return { x: 0, y: 0 };
    }

    const object = getActiveLayer(mapData).objects.find((obj: MapObject) => obj.id === selectedItem.id);
    if (!object) return { x: 0, y: 0 };

    const pos = calculateScreenPos(object, canvasRef.current, mapData, geometry!);
    if (!pos) return { x: 0, y: 0 };

    const { screenX, screenY, objectWidth, objectHeight } = pos;
    const buttonOffset = 4;
    const buttonHeight = 44;
    const minSpacing = 8;

    let buttonY = screenY + (objectHeight / 2) + buttonOffset;

    const addEditNoteButtonBottom = screenY - (objectHeight / 2) - buttonOffset - 22 + buttonHeight;

    if (buttonY - 22 < addEditNoteButtonBottom + minSpacing) {
      buttonY = addEditNoteButtonBottom + minSpacing + 22;
    }

    const buttonX = screenX + (objectWidth / 2) + buttonOffset;

    return { x: buttonX, y: buttonY - 22 };
  }, [selectedItem, mapData, canvasRef, geometry]
  );

  const calculateResizeButtonPosition = dc.useCallback((): ButtonPosition => {
    if (selectedItem?.type !== 'object' || !mapData || !canvasRef.current) {
      return { x: 0, y: 0 };
    }

    const object = getActiveLayer(mapData).objects.find((obj: MapObject) => obj.id === selectedItem.id);
    if (!object) return { x: 0, y: 0 };

    const pos = calculateScreenPos(object, canvasRef.current, mapData, geometry!);
    if (!pos) return { x: 0, y: 0 };

    const { screenX, screenY, objectWidth, objectHeight } = pos;
    const buttonOffset = 4;
    const buttonSize = 44;

    const buttonX = screenX - (objectWidth / 2) - buttonOffset - buttonSize;
    const buttonY = screenY - (objectHeight / 2) - buttonOffset - 22;

    return { x: buttonX, y: buttonY };
  }, [selectedItem, mapData, canvasRef, geometry]
  );

  const calculateObjectColorButtonPosition = dc.useCallback((): ButtonPosition => {
    if (selectedItem?.type !== 'object' || !mapData || !canvasRef.current) {
      return { x: 0, y: 0 };
    }

    const object = getActiveLayer(mapData).objects.find((obj: MapObject) => obj.id === selectedItem.id);
    if (!object) return { x: 0, y: 0 };

    const pos = calculateScreenPos(object, canvasRef.current, mapData, geometry!);
    if (!pos) return { x: 0, y: 0 };

    const { screenX, screenY, objectWidth, objectHeight } = pos;
    const buttonOffset = 4;
    const buttonSize = 44;
    const buttonHeight = 44;
    const minSpacing = 8;

    let buttonY = screenY + (objectHeight / 2) + buttonOffset;

    const resizeButtonBottom = screenY - (objectHeight / 2) - buttonOffset - 22 + buttonHeight;

    if (buttonY - 22 < resizeButtonBottom + minSpacing) {
      buttonY = resizeButtonBottom + minSpacing + 22;
    }

    const buttonX = screenX - (objectWidth / 2) - buttonOffset - buttonSize;

    return { x: buttonX, y: buttonY - 22 };
  }, [selectedItem, mapData, canvasRef, geometry]
  );

  const handleNoteSubmit = dc.useCallback((content: string, editingObjectId: string): void => {
    if (editingObjectId && mapData) {
      const updatedObjects = updateObject(
        getActiveLayer(mapData).objects,
        editingObjectId,
        { customTooltip: content && content.trim() ? content.trim() : undefined }
      );
      onObjectsChange(updatedObjects);
    }
  }, [mapData, onObjectsChange, updateObject]
  );

  const handleObjectColorSelect = dc.useCallback((color: string): void => {
    if (selectedItem?.type === 'object' && mapData) {
      const updatedObjects = updateObject(
        getActiveLayer(mapData).objects,
        selectedItem.id,
        { color: color }
      );
      onObjectsChange(updatedObjects);
    }
  }, [selectedItem, mapData, updateObject, onObjectsChange]
  );

  const handleObjectColorReset = dc.useCallback((setShowObjectColorPicker: (show: boolean) => void): void => {
    handleObjectColorSelect('#ffffff');
    setShowObjectColorPicker(false);
  }, [handleObjectColorSelect]);

  const handleObjectRotation = dc.useCallback((): void => {
    if (!selectedItem || selectedItem.type !== 'object' || !mapData) {
      return;
    }

    const currentObject = getActiveLayer(mapData).objects?.find((obj: MapObject) => obj.id === selectedItem.id);
    const currentRotation = currentObject?.rotation || 0;
    const nextRotation = getNextRotation(currentRotation);

    const updatedObjects = updateObject(
      getActiveLayer(mapData).objects,
      selectedItem.id,
      { rotation: nextRotation }
    );
    onObjectsChange(updatedObjects);
  }, [selectedItem, mapData, updateObject, onObjectsChange]);

  const handleObjectDeletion = dc.useCallback((): void => {
    if (!selectedItem || selectedItem.type !== 'object' || !mapData) {
      return;
    }

    const updatedObjects = removeObject(getActiveLayer(mapData).objects, selectedItem.id);
    onObjectsChange(updatedObjects);
    setSelectedItem(null);
  }, [selectedItem, mapData, removeObject, onObjectsChange, setSelectedItem]);

  const handleObjectDuplicate = dc.useCallback((): void => {
    if (!selectedItem || selectedItem.type !== 'object' || !mapData) {
      return;
    }

    const sourceObject = getActiveLayer(mapData).objects.find((obj: MapObject) => obj.id === selectedItem.id);
    if (!sourceObject) return;

    const { mapType } = mapData;
    const { x: sourceX, y: sourceY } = sourceObject.position;

    const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];
    let targetX = sourceX;
    let targetY = sourceY;
    let found = false;

    for (let ring = 1; ring <= 10 && !found; ring++) {
      for (let dir = 0; dir < 4 && !found; dir++) {
        for (let step = 0; step < ring && !found; step++) {
          const checkX = sourceX + directions[dir][0] * ring;
          const checkY = sourceY + directions[dir][1] * (step + 1 - ring);

          if (canPlaceObjectAt(getActiveLayer(mapData).objects, checkX, checkY, mapType)) {
            targetX = checkX;
            targetY = checkY;
            found = true;
          }
        }
      }

      if (!found) {
        for (let dx = -ring; dx <= ring && !found; dx++) {
          for (let dy = -ring; dy <= ring && !found; dy++) {
            if (Math.abs(dx) === ring || Math.abs(dy) === ring) {
              const checkX = sourceX + dx;
              const checkY = sourceY + dy;

              if (canPlaceObjectAt(getActiveLayer(mapData).objects, checkX, checkY, mapType)) {
                targetX = checkX;
                targetY = checkY;
                found = true;
              }
            }
          }
        }
      }
    }

    if (!found) {
      console.warn('No empty space found for duplicate');
      return;
    }

    const newObject: MapObject = {
      ...sourceObject,
      id: generateObjectId(),
      position: { x: targetX, y: targetY }
    };

    if (mapType === 'hex') {
      const occupiedSlots = getActiveLayer(mapData).objects
        .filter((obj: MapObject) => obj.position.x === targetX && obj.position.y === targetY)
        .map((obj: MapObject) => obj.slot)
        .filter((s: number | undefined): s is number => s !== undefined);
      newObject.slot = assignSlot(occupiedSlots);
    }

    const updatedObjects = [...getActiveLayer(mapData).objects, newObject];
    onObjectsChange(updatedObjects);

    setSelectedItem({
      type: 'object',
      id: newObject.id
    });
  }, [selectedItem, mapData, onObjectsChange, setSelectedItem]);

  dc.useEffect(() => {
    if (currentTool !== 'select') {
      setIsResizeMode(false);
    }
  }, [currentTool, setIsResizeMode]);

  return {
    isResizeMode,
    setIsResizeMode,
    isResizing,
    resizeCorner,
    hoveredObject,
    setHoveredObject,
    mousePosition,
    objectColorBtnRef,
    pendingObjectCustomColorRef,
    edgeSnapMode,
    setEdgeSnapMode,
    longPressTimerRef,

    handleObjectPlacement,
    handleObjectSelection,
    handleObjectDragging,
    handleObjectResizing,
    handleObjectWheel,
    handleHoverUpdate,
    stopObjectDragging,
    stopObjectResizing,
    handleObjectKeyDown,
    handleObjectRotation,
    handleObjectDeletion,
    handleObjectDuplicate,

    calculateLabelButtonPosition,
    calculateLinkNoteButtonPosition,
    calculateResizeButtonPosition,
    calculateObjectColorButtonPosition,

    handleNoteSubmit,
    handleObjectColorSelect,
    handleObjectColorReset,

    getClickedCorner
  };
};

return { useObjectInteractions };

```

# TextInputModal

```tsx
/**
 * TextInputModal.tsx
 *
 * Modal dialog for text label entry.
 */

import type { JSX } from 'preact';

/** Props for TextInputModal component */
export interface TextInputModalProps {
  /** Initial text value (for editing existing labels) */
  initialValue?: string;
  /** Callback when text is submitted */
  onSubmit: (text: string) => void;
  /** Callback when modal is cancelled */
  onCancel: () => void;
  /** Modal title */
  title?: string;
  /** Input placeholder text */
  placeholder?: string;
}

const TextInputModal = ({
  initialValue = '',
  onSubmit,
  onCancel,
  title = 'Add Text Label',
  placeholder = 'Enter label text...'
}: TextInputModalProps): React.ReactElement => {
  const [text, setText] = dc.useState(initialValue);
  const inputRef = dc.useRef<HTMLInputElement>(null);

  dc.useEffect(() => {
    if (inputRef.current) {
      inputRef.current.focus();
      // Select all text if editing existing label
      if (initialValue) {
        inputRef.current.select();
      }
    }
  }, []);

  const handleKeyDown = (e: JSX.TargetedKeyboardEvent<HTMLInputElement>): void => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleSubmit();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      onCancel();
    }
  };

  const handleSubmit = (): void => {
    const trimmed = text.trim();
    if (trimmed.length > 0 && trimmed.length <= 200) {
      onSubmit(trimmed);
    }
  };

  // Prevent clicks inside modal from closing it
  const handleModalClick = (e: JSX.TargetedMouseEvent<HTMLDivElement>): void => {
    e.stopPropagation();
  };

  return (
    <div className="dmt-modal-overlay" onClick={onCancel}>
      <div
        className="dmt-modal-content"
        onClick={handleModalClick}
      >
        <h3 className="dmt-modal-title">{title}</h3>

        <input
          ref={inputRef}
          type="text"
          className="dmt-modal-input"
          value={text}
          onChange={(e) => setText((e.target as HTMLInputElement).value)}
          onKeyDown={handleKeyDown}
          maxLength={200}
          placeholder={placeholder}
        />

        <div className="dmt-modal-buttons">
          <button
            className="dmt-modal-btn dmt-modal-btn-cancel"
            onClick={onCancel}
          >
            Cancel
          </button>
          <button
            className="dmt-modal-btn dmt-modal-btn-submit"
            onClick={handleSubmit}
            disabled={text.trim().length === 0}
          >
            {initialValue ? 'Update' : 'Add Label'}
          </button>
        </div>

        <div className="dmt-modal-hint">
          Press Enter to confirm, Esc to cancel
        </div>
      </div>
    </div>
  );
};

return { TextInputModal };

```

# NoteLinkModal

```jsx
const { 
  getNoteDisplayNames,
  getFullPathFromDisplayName,
  getDisplayNameFromPath
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "noteOperations"));

const { getObjectType } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "objectTypeResolver"));

/**
 * Modal for linking notes to objects
 * Similar structure to TextLabelEditor
 */
function NoteLinkModal({ 
  isOpen, 
  onClose, 
  onSave, 
  currentNotePath = null,
  objectType = null
}) {
  const [noteInput, setNoteInput] = dc.useState('');
  const [isLoading, setIsLoading] = dc.useState(false);
  
  // Initialize input with current note display name
  dc.useEffect(() => {
    if (isOpen) {
      const displayName = getDisplayNameFromPath(currentNotePath);
      setNoteInput(displayName);
    }
  }, [isOpen, currentNotePath]);
  
  // Get suggestions callback for AutocompleteInput
  const getSuggestions = dc.useCallback(async (query) => {
    try {
      const allNotes = await getNoteDisplayNames();
      return allNotes;
    } catch (error) {
      console.error('[NoteLinkModal] Error getting suggestions:', error);
      return [];
    }
  }, []);
  
  const handleSave = dc.useCallback(async () => {
    setIsLoading(true);
    
    try {
      if (!noteInput.trim()) {
        // Empty input means remove link
        onSave(null);
        onClose();
        return;
      }
      
      // Convert display name back to full path
      const fullPath = await getFullPathFromDisplayName(noteInput);
      
      if (!fullPath) {
        console.warn('[NoteLinkModal] Note not found:', noteInput);
        // Still save what user typed - they might be creating a new note
        onSave(noteInput + '.md');
      } else {
        onSave(fullPath);
      }
      
      onClose();
    } catch (error) {
      console.error('[NoteLinkModal] Error saving note link:', error);
    } finally {
      setIsLoading(false);
    }
  }, [noteInput, onSave, onClose]);
  
  const handleRemove = dc.useCallback(() => {
    onSave(null);
    onClose();
  }, [onSave, onClose]);
  
  const handleCancel = dc.useCallback(() => {
    onClose();
  }, [onClose]);
  
  const handleInputChange = dc.useCallback((e) => {
    setNoteInput(e.target.value);
  }, []);
  
  // Get object type label for display
  const objectTypeLabel = dc.useMemo(() => {
    if (!objectType) return 'Object';
    const type = getObjectType(objectType);
    return type ? type.label : 'Object';
  }, [objectType]);
  
  if (!isOpen) return null;
  
  return (
    <div class="dmt-modal-overlay" onClick={handleCancel}>
      <div class="dmt-modal-content" onClick={(e) => e.stopPropagation()}>
        <div class="dmt-modal-header">
          <h3>Link Note to {objectTypeLabel}</h3>
        </div>
        
        <div class="dmt-modal-body">
          <div class="dmt-form-group">
            <label class="dmt-form-label">Note Name</label>
            <AutocompleteInput
              value={noteInput}
              onChange={handleInputChange}
              onSelect={(value) => setNoteInput(value)}
              placeholder="Type to search notes..."
              disabled={isLoading}
              getSuggestions={getSuggestions}
              maxSuggestions={10}
            />
          </div>
        </div>
        
        <div class="dmt-modal-footer">
          <button 
            class="dmt-modal-btn dmt-modal-btn-cancel"
            onClick={handleCancel}
            disabled={isLoading}
          >
            Cancel
          </button>
          
          {currentNotePath && (
            <button 
              class="dmt-modal-btn dmt-modal-btn-danger"
              onClick={handleRemove}
              disabled={isLoading}
            >
              Remove Link
            </button>
          )}
          
          <button 
            class="dmt-modal-btn dmt-modal-btn-submit"
            onClick={handleSave}
            disabled={isLoading}
          >
            {isLoading ? 'Saving...' : 'Save'}
          </button>
        </div>
      </div>
    </div>
  );
}

function fuzzyMatch(text, query) {
  if (!query) return true;
  
  const textLower = text.toLowerCase();
  const queryLower = query.toLowerCase();
  
  let queryIndex = 0;
  for (let i = 0; i < textLower.length && queryIndex < queryLower.length; i++) {
    if (textLower[i] === queryLower[queryIndex]) {
      queryIndex++;
    }
  }
  return queryIndex === queryLower.length;
}

function scoreMatch(text, query) {
  if (!query) return 0;
  
  const textLower = text.toLowerCase();
  const queryLower = query.toLowerCase();
  
  if (textLower === queryLower) return 1000;
  if (textLower.startsWith(queryLower)) return 500;
  if (textLower.includes(queryLower)) return 250;
  return 100;
}

function AutocompleteInput({ 
  value, 
  onChange, 
  onSelect,
  placeholder, 
  disabled,
  getSuggestions,
  maxSuggestions = 10
}) {
  const [suggestions, setSuggestions] = dc.useState([]);
  const [showSuggestions, setShowSuggestions] = dc.useState(false);
  const [selectedIndex, setSelectedIndex] = dc.useState(-1);
  const [isLoading, setIsLoading] = dc.useState(false);
  const [userIsTyping, setUserIsTyping] = dc.useState(false);
  
  const containerRef = dc.useRef(null);
  const inputRef = dc.useRef(null);
  const justSelectedRef = dc.useRef(false);
  const suggestionRefs = dc.useRef([]);
  const isKeyboardNavRef = dc.useRef(false);

  // Scroll selected item into view when navigating with keyboard only
  dc.useEffect(() => {
    if (selectedIndex >= 0 && suggestionRefs.current[selectedIndex] && isKeyboardNavRef.current) {
      const element = suggestionRefs.current[selectedIndex];
      const container = element?.parentElement;
      if (container) {
        const elementTop = element.offsetTop;
        const elementBottom = elementTop + element.offsetHeight;
        const containerTop = container.scrollTop;
        const containerBottom = containerTop + container.clientHeight;
        
        if (elementTop < containerTop) {
          container.scrollTop = elementTop;
        } else if (elementBottom > containerBottom) {
          container.scrollTop = elementBottom - container.clientHeight;
        }
      }
      isKeyboardNavRef.current = false;
    }
  }, [selectedIndex]);

  dc.useEffect(() => {
    const loadSuggestions = async () => {
      if (!value || value.length < 1) {
        setSuggestions([]);
        setShowSuggestions(false);
        return;
      }

      if (justSelectedRef.current) {
        justSelectedRef.current = false;
        return;
      }

      setIsLoading(true);
      
      try {
        const allSuggestions = await getSuggestions(value);
        
        const matches = allSuggestions
          .filter(item => fuzzyMatch(item, value))
          .map(item => ({
            text: item,
            score: scoreMatch(item, value)
          }))
          .sort((a, b) => b.score - a.score)
          .slice(0, maxSuggestions)
          .map(item => item.text);

        setSuggestions(matches);
        
        if (userIsTyping) {
          setShowSuggestions(matches.length > 0);
        }
        
        if (matches.length > 0 && selectedIndex >= matches.length) {
          setSelectedIndex(matches.length - 1);
        }
      } catch (error) {
        console.error('Error loading suggestions:', error);
        setSuggestions([]);
      } finally {
        setIsLoading(false);
      }
    };

    loadSuggestions();
  }, [value, getSuggestions, maxSuggestions, userIsTyping]);

  dc.useEffect(() => {
    const handleClickOutside = (event) => {
      if (containerRef.current && !containerRef.current.contains(event.target)) {
        setShowSuggestions(false);
        setSelectedIndex(-1);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleInputChange = (e) => {
    setUserIsTyping(true);
    onChange(e);
  };

  const handleKeyDown = (e) => {
    if (!showSuggestions || suggestions.length === 0) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        isKeyboardNavRef.current = true;
        setSelectedIndex(prev => 
          prev < suggestions.length - 1 ? prev + 1 : prev
        );
        break;
      
      case 'ArrowUp':
        e.preventDefault();
        isKeyboardNavRef.current = true;
        setSelectedIndex(prev => prev > 0 ? prev - 1 : -1);
        break;
      
      case 'Enter':
        if (selectedIndex >= 0) {
          e.preventDefault();
          selectSuggestion(suggestions[selectedIndex]);
        }
        break;
      
      case 'Escape':
        e.preventDefault();
        setShowSuggestions(false);
        setUserIsTyping(false);
        setSelectedIndex(-1);
        break;
    }
  };

  const selectSuggestion = (suggestion) => {
    justSelectedRef.current = true;
    setUserIsTyping(false);
    onChange({ target: { value: suggestion } });
    if (onSelect) onSelect(suggestion);
    setShowSuggestions(false);
    setSelectedIndex(-1);
  };

  const handleFocus = () => {
    if (value && suggestions.length > 0 && userIsTyping) {
      setShowSuggestions(true);
    }
  };

  const handleBlur = () => {
    setTimeout(() => {
      setUserIsTyping(false);
    }, 200);
  };

  return (
    <div ref={containerRef} style={{ position: 'relative' }}>
      <input
        ref={inputRef}
        type="text"
        value={value}
        onChange={handleInputChange}
        onKeyDown={handleKeyDown}
        onFocus={handleFocus}
        onBlur={handleBlur}
        placeholder={placeholder}
        disabled={disabled}
        style={{ 
          width: '100%',
          padding: '10px 12px',
          fontSize: '14px',
          backgroundColor: 'var(--background-primary-alt)',
          color: 'var(--text-normal)',
          border: '1px solid var(--background-modifier-border)',
          borderRadius: '4px',
          boxSizing: 'border-box'
        }}
      />
      
      {showSuggestions && suggestions.length > 0 && (
        <div style={{
          position: 'absolute',
          top: '100%',
          left: 0,
          right: 0,
          marginTop: '4px',
          backgroundColor: 'var(--background-primary)',
          border: '1px solid var(--background-modifier-border)',
          borderRadius: '4px',
          maxHeight: '200px',
          overflowY: 'auto',
          zIndex: 1000,
          boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)'
        }}>
          {suggestions.map((suggestion, index) => (
            <div
              key={suggestion}
              ref={el => suggestionRefs.current[index] = el}
              onClick={() => selectSuggestion(suggestion)}
              onMouseEnter={() => setSelectedIndex(index)}
              style={{
                padding: '8px 12px',
                cursor: 'pointer',
                backgroundColor: index === selectedIndex 
                  ? 'var(--background-modifier-hover)' 
                  : 'transparent',
                fontSize: '14px',
                color: 'var(--text-normal)',
                fontFamily: 'var(--font-monospace)'
              }}
            >
              {suggestion}
            </div>
          ))}
        </div>
      )}
      
      {isLoading && (
        <div style={{
          position: 'absolute',
          right: '12px',
          top: '50%',
          transform: 'translateY(-50%)',
          fontSize: '12px',
          color: 'var(--text-muted)'
        }}>
          Loading...
        </div>
      )}
    </div>
  );
}

return { NoteLinkModal };
```

# ColorPicker

```tsx
/**
 * ColorPicker.tsx
 *
 * Color picker component with custom color support and opacity controls.
 */

import type { JSX } from 'preact';
import type { HexColor } from '#types/core/common.types';

const { getColorPalette, DEFAULT_COLOR } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "colorOperations"));

/** Color definition from palette */
export interface ColorDef {
  id: string;
  color: HexColor;
  label: string;
  opacity?: number;
  isCustom?: boolean;
  isReset?: boolean;
  isAddButton?: boolean;
  isPreview?: boolean;
}

/** Custom color with opacity */
export interface CustomColor {
  id: string;
  color: HexColor;
  label?: string;
  opacity?: number;
}

/** Position for color picker */
export type PickerPosition = 'below' | 'above' | null;

/** Alignment for color picker */
export type PickerAlign = 'left' | 'right';

/** Per-color opacity overrides */
export type ColorOpacityOverrides = Record<string, number>;

/** Props for ColorPicker component */
export interface ColorPickerProps {
  /** Whether the picker is open */
  isOpen: boolean;
  /** Currently selected color */
  selectedColor: HexColor | null;
  /** Callback when a color is selected */
  onColorSelect: (color: HexColor) => void;
  /** Callback to close the picker */
  onClose: () => void;
  /** Callback to reset to default color */
  onReset: () => void;
  /** Custom colors array */
  customColors?: CustomColor[];
  /** Per-map opacity overrides for palette colors */
  paletteColorOpacityOverrides?: ColorOpacityOverrides;
  /** Callback to add a custom color */
  onAddCustomColor?: (color: HexColor) => void;
  /** Callback to delete a custom color */
  onDeleteCustomColor?: (colorId: string) => void;
  /** Callback to update any color's opacity */
  onUpdateColorOpacity?: (colorId: string, opacity: number) => void;
  /** Ref to store pending custom color */
  pendingCustomColorRef?: React.MutableRefObject<HexColor | null>;
  /** Picker title */
  title?: string;
  /** Picker position */
  position?: PickerPosition;
  /** Picker alignment */
  align?: PickerAlign;
  /** Current opacity value (0-1) */
  opacity?: number;
  /** Callback when opacity changes */
  onOpacityChange?: ((opacity: number) => void) | null;
}

const ColorPicker = ({
  isOpen,
  selectedColor,
  onColorSelect,
  onClose,
  onReset,
  customColors = [],
  paletteColorOpacityOverrides = {},
  onAddCustomColor,
  onDeleteCustomColor,
  onUpdateColorOpacity,
  pendingCustomColorRef,
  title = 'Color',
  position = 'below',
  align = 'left',
  opacity = 1,
  onOpacityChange = null
}: ColorPickerProps): React.ReactElement | null => {
  const [previewColor, setPreviewColor] = dc.useState<HexColor | null>(null);
  const [editTargetId, setEditTargetId] = dc.useState<string | null>(null);
  const [editingOpacity, setEditingOpacity] = dc.useState(1);
  const colorInputRef = dc.useRef<HTMLInputElement>(null);
  const longPressTimerRef = dc.useRef<ReturnType<typeof setTimeout> | null>(null);
  const editingOpacityRef = dc.useRef(editingOpacity);
  const editTargetIdRef = dc.useRef(editTargetId);
  const justOpenedEditRef = dc.useRef(false);
  const longPressTriggeredRef = dc.useRef(false);

  editingOpacityRef.current = editingOpacity;
  editTargetIdRef.current = editTargetId;

  const saveOpacityChanges = dc.useCallback(() => {
    const targetId = editTargetIdRef.current;
    const currentOpacity = editingOpacityRef.current;

    if (!targetId) return;

    const customColor = customColors.find(c => c.id === targetId);
    const paletteOverride = paletteColorOpacityOverrides[targetId];
    const originalOpacity = customColor?.opacity ?? paletteOverride ?? 1;

    if (onUpdateColorOpacity && currentOpacity !== originalOpacity) {
      onUpdateColorOpacity(targetId, currentOpacity);
    }

    if (onOpacityChange) {
      onOpacityChange(currentOpacity);
    }
  }, [customColors, paletteColorOpacityOverrides, onUpdateColorOpacity, onOpacityChange]);

  const saveAndCloseEditPanel = dc.useCallback(() => {
    if (!editTargetIdRef.current) return;
    if (justOpenedEditRef.current) return;

    saveOpacityChanges();
    setEditTargetId(null);
  }, [saveOpacityChanges]);

  dc.useEffect(() => {
    if (!isOpen && editTargetIdRef.current) {
      saveOpacityChanges();
      setEditTargetId(null);
    }
  }, [isOpen, saveOpacityChanges]);

  if (!isOpen) return null;

  const handlePickerClick = (e: JSX.TargetedMouseEvent<HTMLDivElement>): void => {
    e.stopPropagation();
  };

  const handlePickerMouseDown = (e: JSX.TargetedMouseEvent<HTMLDivElement>): void => {
    e.stopPropagation();

    if (editTargetId && !(e.target as Element).closest('.dmt-color-edit-panel')) {
      if (!justOpenedEditRef.current) {
        saveAndCloseEditPanel();
      }
    }
  };

  const handlePickerTouch = (e: JSX.TargetedTouchEvent<HTMLDivElement>): void => {
    e.stopPropagation();

    if (editTargetId && !(e.target as Element).closest('.dmt-color-edit-panel')) {
      if (!justOpenedEditRef.current) {
        saveAndCloseEditPanel();
      }
    }
  };

  const handleColorClick = (colorDef: ColorDef): void => {
    if (longPressTriggeredRef.current) {
      longPressTriggeredRef.current = false;
      return;
    }

    onColorSelect(colorDef.color);

    if (onOpacityChange && colorDef.opacity !== undefined) {
      onOpacityChange(colorDef.opacity);
    }
  };

  const handleReset = (e: JSX.TargetedMouseEvent<HTMLButtonElement>): void => {
    e.stopPropagation();
    onReset();
  };

  const handleColorInput = (e: JSX.TargetedEvent<HTMLInputElement, Event>): void => {
    const value = (e.target as HTMLInputElement).value as HexColor;
    setPreviewColor(value);
    if (pendingCustomColorRef) {
      pendingCustomColorRef.current = value;
    }
  };

  const handleAddClick = (): void => {
    setPreviewColor('#888888' as HexColor);
    if (pendingCustomColorRef) {
      pendingCustomColorRef.current = '#888888' as HexColor;
    }
  };

  const handleColorContextMenu = (e: JSX.TargetedMouseEvent<HTMLButtonElement>, colorDef: ColorDef): void => {
    if (colorDef.isReset || colorDef.isAddButton || colorDef.isPreview) return;
    e.preventDefault();
    e.stopPropagation();

    setEditTargetId(colorDef.id);
    setEditingOpacity(colorDef.opacity ?? 1);
    justOpenedEditRef.current = true;
    setTimeout(() => { justOpenedEditRef.current = false; }, 100);
  };

  const handleLongPressStart = (colorDef: ColorDef): void => {
    if (colorDef.isReset || colorDef.isAddButton || colorDef.isPreview) return;
    longPressTriggeredRef.current = false;
    longPressTimerRef.current = setTimeout(() => {
      longPressTriggeredRef.current = true;

      setEditTargetId(colorDef.id);
      setEditingOpacity(colorDef.opacity ?? 1);
      justOpenedEditRef.current = true;
      setTimeout(() => { justOpenedEditRef.current = false; }, 300);
    }, 500);
  };

  const handleLongPressCancel = (): void => {
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  };

  const handleDeleteClick = (e: JSX.TargetedMouseEvent<HTMLButtonElement>, colorId: string): void => {
    e.preventDefault();
    e.stopPropagation();
    if (onDeleteCustomColor) {
      onDeleteCustomColor(colorId);
    }
    setEditTargetId(null);
  };

  const handleEditOpacityChange = (e: JSX.TargetedEvent<HTMLInputElement, Event>): void => {
    e.stopPropagation();
    const newOpacity = parseInt((e.target as HTMLInputElement).value, 10) / 100;
    setEditingOpacity(newOpacity);
  };

  const paletteColors = getColorPalette() as ColorDef[];

  const paletteColorsWithOverrides = paletteColors.map(c => {
    const override = paletteColorOpacityOverrides[c.id];
    return override !== undefined ? { ...c, opacity: override } : c;
  });

  const allColors: ColorDef[] = [
    { id: 'reset', color: '' as HexColor, label: 'Reset to default', isReset: true },
    ...paletteColorsWithOverrides,
    ...customColors.map(c => ({ ...c, label: c.label ?? c.color, isCustom: true })),
    ...(previewColor ? [{
      id: 'preview',
      color: previewColor,
      label: 'Selecting...',
      isPreview: true
    }] : []),
    { id: 'add-custom', color: '' as HexColor, label: 'Add custom color', isAddButton: true }
  ];

  const horizontalStyle = align === 'right'
    ? { right: '0', left: 'auto' }
    : { left: '0' };

  return (
    <div
      className="dmt-color-picker"
      onClick={handlePickerClick}
      onMouseDown={handlePickerMouseDown}
      onTouchStart={handlePickerTouch}
      onTouchMove={handlePickerTouch}
      onTouchEnd={handlePickerTouch}
      style={{
        position: 'absolute',
        ...(position === 'above'
          ? { bottom: 'calc(100% + 8px)', top: 'auto' }
          : { top: 'calc(100% + 8px)' }
        ),
        ...horizontalStyle,
        zIndex: 1501
      }}
    >
      <div className="dmt-color-picker-header">
        <span className="dmt-color-picker-title">{title}</span>
      </div>

      <div className="dmt-color-grid">
        {allColors.map(colorDef => {
          if (colorDef.isReset) {
            return (
              <button
                key={colorDef.id}
                className="dmt-color-swatch dmt-color-swatch-reset"
                onClick={handleReset}
                title={colorDef.label}
              >
                <dc.Icon icon="lucide-circle-x" />
              </button>
            );
          } else if (colorDef.isPreview) {
            return (
              <div
                key={colorDef.id}
                className="dmt-color-swatch dmt-color-swatch-preview"
                style={{ backgroundColor: colorDef.color }}
                title="Selecting..."
              >
                <span className="dmt-color-preview-spinner">
                  <dc.Icon icon="lucide-loader" />
                </span>
              </div>
            );
          } else if (colorDef.isAddButton) {
            return (
              <div
                key={colorDef.id}
                className="dmt-color-swatch dmt-color-swatch-add"
                title={colorDef.label}
                onClick={handleAddClick}
              >
                <input
                  ref={colorInputRef}
                  type="color"
                  className="dmt-color-input-as-button"
                  onInput={handleColorInput}
                  defaultValue={selectedColor || '#ffffff'}
                  aria-label="Add custom color"
                />
                <span className="dmt-color-add-icon-overlay">+</span>
              </div>
            );
          } else {
            const isEditing = editTargetId === colorDef.id;
            const displayOpacity = isEditing ? editingOpacity : (colorDef.opacity ?? 1);
            const hasStoredOpacity = (colorDef.opacity ?? 1) < 1;

            return (
              <div key={colorDef.id} style={{ position: 'relative', display: 'inline-block' }}>
                <button
                  className={`dmt-color-swatch interactive-child ${selectedColor === colorDef.color ? 'dmt-color-swatch-selected' : ''}`}
                  style={{
                    backgroundColor: colorDef.color,
                    opacity: displayOpacity
                  }}
                  onClick={() => handleColorClick(colorDef)}
                  onContextMenu={(e) => handleColorContextMenu(e, colorDef)}
                  onTouchStart={() => handleLongPressStart(colorDef)}
                  onTouchEnd={handleLongPressCancel}
                  onTouchMove={handleLongPressCancel}
                  onMouseDown={handleLongPressCancel}
                  title={colorDef.label + (hasStoredOpacity ? ` (${Math.round((colorDef.opacity ?? 1) * 100)}%)` : '')}
                >
                  {selectedColor === colorDef.color && (
                    <span className="dmt-color-checkmark">
                      <dc.Icon icon="lucide-check" />
                    </span>
                  )}
                </button>

                {isEditing && (
                  <div
                    className="dmt-color-edit-panel"
                    onMouseDown={(e) => e.stopPropagation()}
                    onTouchStart={(e) => e.stopPropagation()}
                  >
                    <div className="dmt-color-edit-opacity">
                      <span className="dmt-color-edit-opacity-label">Opacity</span>
                      <input
                        type="range"
                        min="10"
                        max="100"
                        value={Math.round(editingOpacity * 100)}
                        onChange={handleEditOpacityChange}
                        onInput={handleEditOpacityChange}
                        onMouseDown={(e) => e.stopPropagation()}
                        onTouchStart={(e) => e.stopPropagation()}
                      />
                      <span className="dmt-color-edit-opacity-value">{Math.round(editingOpacity * 100)}%</span>
                    </div>

                    <button
                      className="dmt-color-edit-delete"
                      onClick={(e) => handleDeleteClick(e, colorDef.id)}
                      title="Delete custom color"
                    >
                      <dc.Icon icon="lucide-trash-2" />
                    </button>
                  </div>
                )}
              </div>
            );
          }
        })}
      </div>

      {onOpacityChange && (
        <div className="dmt-color-opacity-section">
          <div className="dmt-color-opacity-header">
            <span className="dmt-color-opacity-label">Opacity</span>
            <span className="dmt-color-opacity-value">{Math.round(opacity * 100)}%</span>
          </div>
          <input
            type="range"
            min="0"
            max="100"
            value={Math.round(opacity * 100)}
            onChange={(e) => onOpacityChange(parseInt((e.target as HTMLInputElement).value, 10) / 100)}
            className="dmt-color-opacity-slider"
          />
        </div>
      )}
    </div>
  );
};

return { ColorPicker, DEFAULT_COLOR };

```

# SelectionToolbar

```jsx
/**
 * SelectionToolbar.jsx
 * 
 * Unified toolbar component that appears below (or above) selected objects/text labels.
 * Consolidates all action buttons into a single horizontal toolbar with context-aware buttons.
 */

const { calculateObjectScreenPosition } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "screenPositionUtils"));
const { openNoteInNewTab } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "noteOperations"));
const { ColorPicker } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ColorPicker"));
const { getActiveLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor"));

/**
 * Calculate bounding box that encompasses all selected items
 */
function calculateMultiSelectBounds(selectedItems, mapData, canvasRef, containerRef, geometry) {
  if (!selectedItems?.length || !canvasRef?.current || !containerRef?.current || !mapData) return null;
  
  const canvas = canvasRef.current;
  const { gridSize, viewState, northDirection } = mapData;
  const { zoom, center } = viewState;
  const scaledGridSize = gridSize * zoom;
  
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const offsetX = centerX - center.x * scaledGridSize;
  const offsetY = centerY - center.y * scaledGridSize;
  
  // Account for canvas position within container - use containerRef for consistency
  const rect = canvas.getBoundingClientRect();
  const containerRect = containerRef.current.getBoundingClientRect();
  const canvasOffsetX = rect.left - containerRect.left;
  const canvasOffsetY = rect.top - containerRect.top;
  const scaleX = rect.width / canvas.width;
  const scaleY = rect.height / canvas.height;
  
  const activeLayer = getActiveLayer(mapData);
  
  let minScreenX = Infinity;
  let minScreenY = Infinity;
  let maxScreenX = -Infinity;
  let maxScreenY = -Infinity;
  
  for (const item of selectedItems) {
    if (item.type === 'object') {
      const obj = activeLayer.objects?.find(o => o.id === item.id);
      if (!obj) continue;
      
      const pos = calculateObjectScreenPosition(obj, canvas, mapData, geometry, containerRef);
      if (!pos) continue;
      
      const left = pos.screenX - pos.objectWidth / 2;
      const right = pos.screenX + pos.objectWidth / 2;
      const top = pos.screenY - pos.objectHeight / 2;
      const bottom = pos.screenY + pos.objectHeight / 2;
      
      minScreenX = Math.min(minScreenX, left);
      maxScreenX = Math.max(maxScreenX, right);
      minScreenY = Math.min(minScreenY, top);
      maxScreenY = Math.max(maxScreenY, bottom);
    } else if (item.type === 'text') {
      const label = activeLayer.textLabels?.find(l => l.id === item.id);
      if (!label) continue;
      
      // Get label position in screen space
      let screenX = offsetX + label.position.x * zoom;
      let screenY = offsetY + label.position.y * zoom;
      
      // Apply canvas rotation if present
      if (northDirection !== 0) {
        const relX = screenX - centerX;
        const relY = screenY - centerY;
        const angleRad = (northDirection * Math.PI) / 180;
        const rotatedX = relX * Math.cos(angleRad) - relY * Math.sin(angleRad);
        const rotatedY = relX * Math.sin(angleRad) + relY * Math.cos(angleRad);
        screenX = centerX + rotatedX;
        screenY = centerY + rotatedY;
      }
      
      // Approximate label bounds
      const fontSize = (label.fontSize || 16) * zoom;
      const approxWidth = fontSize * 3; // Rough estimate
      const approxHeight = fontSize * 1.5;
      
      const left = (screenX * scaleX) + canvasOffsetX - approxWidth / 2;
      const right = (screenX * scaleX) + canvasOffsetX + approxWidth / 2;
      const top = (screenY * scaleY) + canvasOffsetY - approxHeight / 2;
      const bottom = (screenY * scaleY) + canvasOffsetY + approxHeight / 2;
      
      minScreenX = Math.min(minScreenX, left);
      maxScreenX = Math.max(maxScreenX, right);
      minScreenY = Math.min(minScreenY, top);
      maxScreenY = Math.max(maxScreenY, bottom);
    }
  }
  
  if (minScreenX === Infinity) return null;
  
  return {
    screenX: (minScreenX + maxScreenX) / 2,
    screenY: (minScreenY + maxScreenY) / 2,
    width: maxScreenX - minScreenX,
    height: maxScreenY - minScreenY,
    top: minScreenY,
    bottom: maxScreenY
  };
}

/**
 * MultiSelectToolbar Component
 * Shows simplified toolbar for multiple selected items
 */
const MultiSelectToolbar = ({
  selectedItems,
  selectionCount,
  mapData,
  canvasRef,
  containerRef,
  geometry,
  onRotateAll,
  onDuplicateAll,
  onDeleteAll
}) => {
  if (!selectedItems?.length || !mapData || !canvasRef?.current || !containerRef?.current) {
    return null;
  }
  
  // Calculate bounding box of all selected items
  const bounds = calculateMultiSelectBounds(selectedItems, mapData, canvasRef, containerRef, geometry);
  if (!bounds) return null;
  
  // Calculate toolbar dimensions
  const buttonSize = 44;
  const buttonGap = 4;
  const toolbarGap = 4;
  const countBadgeWidth = 80;
  
  // Buttons: Count badge + Rotate All + Duplicate All + Delete All
  const buttonCount = 3;
  const toolbarWidth = countBadgeWidth + buttonGap + buttonCount * buttonSize + (buttonCount - 1) * buttonGap;
  const toolbarHeight = buttonSize;
  
  // Get container bounds for edge detection
  const containerRect = containerRef.current.getBoundingClientRect();
  const containerHeight = containerRect.height;
  
  // Determine if we need to flip above
  const spaceBelow = containerHeight - bounds.bottom;
  const shouldFlipAbove = spaceBelow < toolbarHeight + toolbarGap + 20;
  
  // Calculate toolbar position
  let toolbarX = bounds.screenX - toolbarWidth / 2;
  let toolbarY;
  
  if (shouldFlipAbove) {
    toolbarY = bounds.top - toolbarGap - toolbarHeight;
  } else {
    toolbarY = bounds.bottom + toolbarGap;
  }
  
  // Clamp horizontal position to container bounds
  const minX = 4;
  const maxX = containerRect.width - toolbarWidth - 4;
  toolbarX = Math.max(minX, Math.min(maxX, toolbarX));
  
  // Count objects and text labels
  const objectCount = selectedItems.filter(i => i.type === 'object').length;
  const textCount = selectedItems.filter(i => i.type === 'text').length;
  
  return (
    <div 
      className="dmt-selection-toolbar dmt-multi-select-toolbar"
      style={{
        position: 'absolute',
        left: `${toolbarX}px`,
        top: `${toolbarY}px`,
        pointerEvents: 'auto',
        zIndex: 150
      }}
    >
      {/* Selection count badge */}
      <div className="dmt-selection-count">
        <dc.Icon icon="lucide-box-select" size={14} />
        <span>{selectionCount || selectedItems.length} selected</span>
      </div>
      
      {/* Rotate All */}
      <button
        className="dmt-toolbar-button"
        onClick={onRotateAll}
        title="Rotate All 90"
      >
        <dc.Icon icon="lucide-rotate-cw" />
      </button>
      
      {/* Duplicate All */}
      <button
        className="dmt-toolbar-button"
        onClick={onDuplicateAll}
        title="Duplicate All"
      >
        <dc.Icon icon="lucide-copy" />
      </button>
      
      {/* Delete All */}
      <button
        className="dmt-toolbar-button dmt-toolbar-delete-button"
        onClick={onDeleteAll}
        title="Delete All"
      >
        <dc.Icon icon="lucide-trash-2" />
      </button>
    </div>
  );
};

/**
 * Calculate bounding box for a text label in screen coordinates
 */
function calculateTextLabelBounds(label, canvasRef, containerRef, mapData) {
  if (!label || !canvasRef.current || !containerRef?.current || !mapData) return null;
  
  const canvas = canvasRef.current;
  const { gridSize, viewState, northDirection } = mapData;
  const { zoom, center } = viewState;
  const scaledGridSize = gridSize * zoom;
  
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const offsetX = centerX - center.x * scaledGridSize;
  const offsetY = centerY - center.y * scaledGridSize;
  
  // Get label position in screen space
  let screenX = offsetX + label.position.x * zoom;
  let screenY = offsetY + label.position.y * zoom;
  
  // Apply canvas rotation if present
  if (northDirection !== 0) {
    const relX = screenX - centerX;
    const relY = screenY - centerY;
    const angleRad = (northDirection * Math.PI) / 180;
    const rotatedX = relX * Math.cos(angleRad) - relY * Math.sin(angleRad);
    const rotatedY = relX * Math.sin(angleRad) + relY * Math.cos(angleRad);
    screenX = centerX + rotatedX;
    screenY = centerY + rotatedY;
  }
  
  // Measure text to get bounding box
  const ctx = canvas.getContext('2d');
  const fontSize = label.fontSize * zoom;
  ctx.font = `${fontSize}px sans-serif`;
  const metrics = ctx.measureText(label.content);
  const textWidth = metrics.width;
  const textHeight = fontSize * 1.2;
  
  // Calculate rotated bounding box for the label itself
  const labelAngle = ((label.rotation || 0) * Math.PI) / 180;
  const cos = Math.abs(Math.cos(labelAngle));
  const sin = Math.abs(Math.sin(labelAngle));
  const rotatedWidth = textWidth * cos + textHeight * sin;
  const rotatedHeight = textWidth * sin + textHeight * cos;
  
  // Account for canvas position within container - use containerRef for consistency
  const rect = canvas.getBoundingClientRect();
  const containerRect = containerRef.current.getBoundingClientRect();
  const canvasOffsetX = rect.left - containerRect.left;
  const canvasOffsetY = rect.top - containerRect.top;
  const scaleX = rect.width / canvas.width;
  const scaleY = rect.height / canvas.height;
  
  // Selection box padding
  const paddingX = 4;
  const paddingY = 2;
  
  return {
    screenX: (screenX * scaleX) + canvasOffsetX,
    screenY: (screenY * scaleY) + canvasOffsetY,
    width: (rotatedWidth + paddingX * 2) * scaleX,
    height: (rotatedHeight + paddingY * 2) * scaleY
  };
}

/**
 * SelectionToolbar Component
 */
const SelectionToolbar = ({
  // Selection info
  selectedItem,
  selectedItems,      // Array of all selected items for multi-select
  hasMultiSelection,  // True when multiple items selected
  selectionCount,     // Number of selected items
  mapData,
  canvasRef,
  containerRef,
  geometry,
  
  // Object-specific handlers
  onRotate,
  onLabel,
  onLinkNote,
  onLinkObject,
  onFollowLink,
  onRemoveLink,
  onCopyLink,
  onColorClick,
  onResize,
  onDelete,
  onScaleChange,  // handler for scale slider
  onDuplicate,    // handler for duplicating object
  
  // Multi-select handlers
  onRotateAll,
  onDuplicateAll,
  onDeleteAll,
  
  // Text-specific handlers
  onEdit,
  
  // State
  isResizeMode,
  showColorPicker,
  
  // Color picker props
  currentColor,
  onColorSelect,
  onColorPickerClose,
  onColorReset,
  customColors,
  onAddCustomColor,
  onDeleteCustomColor,
  pendingCustomColorRef,
  colorButtonRef
}) => {
  // Handle multi-select mode
  if (hasMultiSelection && selectedItems?.length > 1) {
    return (
      <MultiSelectToolbar
        selectedItems={selectedItems}
        selectionCount={selectionCount}
        mapData={mapData}
        canvasRef={canvasRef}
        containerRef={containerRef}
        geometry={geometry}
        onRotateAll={onRotateAll}
        onDuplicateAll={onDuplicateAll}
        onDeleteAll={onDeleteAll}
      />
    );
  }
  
  // Don't render if no selection or missing dependencies
  if (!selectedItem || !mapData || !canvasRef?.current || !containerRef?.current) {
    return null;
  }
  
  const isObject = selectedItem.type === 'object';
  const isText = selectedItem.type === 'text';
  
  // Calculate selection bounding box based on type
  let bounds = null;
  
  if (isObject) {
    const object = getActiveLayer(mapData).objects?.find(obj => obj.id === selectedItem.id);
    if (!object) return null;
    
    const pos = calculateObjectScreenPosition(object, canvasRef.current, mapData, geometry, containerRef);
    if (!pos) return null;
    
    bounds = {
      screenX: pos.screenX,
      screenY: pos.screenY,
      width: pos.objectWidth,
      height: pos.objectHeight
    };
  } else if (isText) {
    const label = getActiveLayer(mapData).textLabels?.find(l => l.id === selectedItem.id);
    if (!label) return null;
    
    bounds = calculateTextLabelBounds(label, canvasRef, containerRef, mapData);
    if (!bounds) return null;
  }
  
  if (!bounds) return null;
  
  // Calculate toolbar dimensions
  const buttonSize = 44;
  const buttonGap = 4;
  const toolbarGap = 4; // Gap between selection and toolbar
  const buttonsPerRow = 5;

  // Build button definitions based on selection type
  const hasLinkedObject = !!(isObject && selectedItem.data?.linkedObject);
  const isNotePin = selectedItem.data?.type === 'note_pin';

  const objectButtons = isObject ? [
    { id: 'rotate', icon: 'lucide-rotate-cw', title: 'Rotate 45 (or press R)', onClick: onRotate },
    { id: 'label', icon: 'lucide-sticky-note', title: 'Add/Edit Label', onClick: onLabel, visible: !isNotePin },
    { id: 'duplicate', icon: 'lucide-copy', title: 'Duplicate Object', onClick: onDuplicate },
    { id: 'linkNote', icon: 'lucide-scroll-text', title: selectedItem.data?.linkedNote ? 'Edit linked note' : 'Link note', onClick: onLinkNote },
    { id: 'linkObject', icon: 'lucide-link-2', title: hasLinkedObject ? 'Edit object link' : 'Link to object', onClick: onLinkObject, active: hasLinkedObject },
    { id: 'followLink', icon: 'lucide-arrow-right-circle', title: 'Go to linked object', onClick: onFollowLink, visible: hasLinkedObject },
    { id: 'removeLink', icon: 'lucide-unlink', title: 'Remove object link', onClick: onRemoveLink, visible: hasLinkedObject },
    { id: 'copyLink', icon: 'lucide-link', title: 'Copy link to clipboard', onClick: onCopyLink },
    { id: 'color', icon: 'lucide-palette', title: 'Change Object Color', onClick: onColorClick, isColorButton: true },
    { id: 'resize', icon: 'lucide-scaling', title: 'Resize Object', onClick: onResize },
    { id: 'delete', icon: 'lucide-trash-2', title: 'Delete (or press Delete/Backspace)', onClick: onDelete, isDelete: true }
  ].filter(btn => btn.visible !== false) : [];

  const textButtons = isText ? [
    { id: 'edit', icon: 'lucide-pencil', title: 'Edit Text Label', onClick: onEdit },
    { id: 'rotate', icon: 'lucide-rotate-cw', title: 'Rotate 45 (or press R)', onClick: onRotate },
    { id: 'copyLink', icon: 'lucide-link', title: 'Copy link to clipboard', onClick: onCopyLink },
    { id: 'delete', icon: 'lucide-trash-2', title: 'Delete (or press Delete/Backspace)', onClick: onDelete, isDelete: true }
  ] : [];

  const buttons = isObject ? objectButtons : textButtons;
  const buttonCount = buttons.length;
  const rowCount = Math.ceil(buttonCount / buttonsPerRow);
  const buttonsInFirstRow = Math.min(buttonCount, buttonsPerRow);

  const toolbarWidth = buttonsInFirstRow * buttonSize + (buttonsInFirstRow - 1) * buttonGap;
  const toolbarHeight = rowCount * buttonSize + (rowCount - 1) * buttonGap;
  
  // Get container bounds for edge detection
  const containerRect = containerRef.current.getBoundingClientRect();
  const containerHeight = containerRect.height;
  
  // Calculate linked note display height (if applicable)
  const hasLinkedNote = isObject && selectedItem.data?.linkedNote && typeof selectedItem.data.linkedNote === 'string';
  const linkedNoteHeight = hasLinkedNote ? 32 : 0; // Approximate height of note display
  const linkedNoteGap = hasLinkedNote ? 4 : 0;
  
  // Calculate total height needed below selection
  const totalHeightBelow = toolbarGap + toolbarHeight + linkedNoteGap + linkedNoteHeight;
  
  // Selection box edges
  const selectionBottom = bounds.screenY + bounds.height / 2;
  const selectionTop = bounds.screenY - bounds.height / 2;
  
  // Determine if we need to flip above
  const spaceBelow = containerHeight - selectionBottom;
  const shouldFlipAbove = spaceBelow < totalHeightBelow + 20; // 20px margin
  
  // Calculate toolbar position
  let toolbarX = bounds.screenX - toolbarWidth / 2;
  let toolbarY;
  let linkedNoteY;
  
  if (shouldFlipAbove) {
    toolbarY = selectionTop - toolbarGap - toolbarHeight;
    linkedNoteY = toolbarY - linkedNoteGap - linkedNoteHeight;
  } else {
    toolbarY = selectionBottom + toolbarGap;
    linkedNoteY = toolbarY + toolbarHeight + linkedNoteGap;
  }
  
  // Clamp horizontal position to container bounds
  const minX = 4;
  const maxX = containerRect.width - toolbarWidth - 4;
  toolbarX = Math.max(minX, Math.min(maxX, toolbarX));
  
  // During resize mode, show scale slider instead of action buttons
  if (isResizeMode && isObject) {
    // Read scale from actual object in mapData, not from selectedItem.data which may be stale
    const actualObject = getActiveLayer(mapData).objects?.find(obj => obj.id === selectedItem.id);
    const currentScale = actualObject?.scale ?? 1.0;
    const sliderWidth = 140;
    const sliderHeight = 36;
    const sliderGap = 8;
    
    // Position slider above the selection
    const sliderX = bounds.screenX - sliderWidth / 2;
    const sliderY = selectionTop - sliderGap - sliderHeight;
    
    // Clamp horizontal position
    const clampedSliderX = Math.max(4, Math.min(containerRect.width - sliderWidth - 4, sliderX));
    
    return (
      <div 
        className="dmt-scale-slider-container"
        style={{
          position: 'absolute',
          left: `${clampedSliderX}px`,
          top: `${sliderY}px`,
          width: `${sliderWidth}px`,
          height: `${sliderHeight}px`,
          pointerEvents: 'auto',
          zIndex: 150
        }}
      >
        <div className="dmt-scale-slider-inner">
          <dc.Icon icon="lucide-scaling" size={14} />
          <input
            type="range"
            className="dmt-scale-slider"
            min="25"
            max="130"
            step="5"
            value={Math.round(currentScale * 100)}
            onInput={(e) => {
              const newScale = parseInt(e.target.value) / 100;
              onScaleChange?.(newScale);
            }}
            title={`Scale: ${Math.round(currentScale * 100)}%`}
          />
          <span className="dmt-scale-value">{Math.round(currentScale * 100)}%</span>
        </div>
      </div>
    );
  }
  
  // Don't show toolbar during resize mode for non-objects
  if (isResizeMode) {
    return null;
  }
  
  return (
    <>
      {/* Linked Note Display (for objects with linked notes) */}
      {hasLinkedNote && (
        <div 
          className="dmt-selection-linked-note"
          style={{
            position: 'absolute',
            left: `${bounds.screenX}px`,
            top: `${linkedNoteY}px`,
            transform: 'translateX(-50%)',
            pointerEvents: 'auto',
            zIndex: 150
          }}
        >
          <div className="dmt-note-display-link">
            <dc.Icon icon="lucide-scroll-text" />
            <dc.Link 
              link={dc.resolvePath(selectedItem.data.linkedNote.replace(/\.md$/, ''))}
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                openNoteInNewTab(selectedItem.data.linkedNote);
              }}
            />
            <dc.Icon icon="lucide-external-link" />
          </div>
        </div>
      )}
      
      {/* Toolbar */}
      <div
        className="dmt-selection-toolbar"
        style={{
          position: 'absolute',
          left: `${toolbarX}px`,
          top: `${toolbarY}px`,
          width: `${toolbarWidth}px`,
          pointerEvents: 'auto',
          zIndex: 150
        }}
      >
        {buttons.map((btn) => {
          if (btn.isColorButton) {
            return (
              <div key={btn.id} style={{ position: 'relative', display: 'inline-block' }}>
                <button
                  ref={colorButtonRef}
                  className="dmt-toolbar-button dmt-toolbar-color-button"
                  onClick={(e) => btn.onClick?.(e)}
                  title={btn.title}
                  style={{ backgroundColor: currentColor || '#ffffff' }}
                >
                  <dc.Icon icon={btn.icon} />
                </button>
                {showColorPicker && (
                  <ColorPicker
                    isOpen={showColorPicker}
                    selectedColor={currentColor || '#ffffff'}
                    onColorSelect={onColorSelect}
                    onClose={onColorPickerClose}
                    onReset={onColorReset}
                    customColors={customColors || []}
                    onAddCustomColor={onAddCustomColor}
                    onDeleteCustomColor={onDeleteCustomColor}
                    pendingCustomColorRef={pendingCustomColorRef}
                    title="Object Color"
                    position="above"
                  />
                )}
              </div>
            );
          }

          const className = [
            'dmt-toolbar-button',
            btn.isDelete && 'dmt-toolbar-delete-button',
            btn.active && 'dmt-toolbar-button-active'
          ].filter(Boolean).join(' ');

          return (
            <button
              key={btn.id}
              className={className}
              onClick={(e) => btn.onClick?.(e)}
              title={btn.title}
            >
              <dc.Icon icon={btn.icon} />
            </button>
          );
        })}
      </div>
    </>
  );
};

return { SelectionToolbar };
```

# deepLinkHandler

```ts
/**
 * Deep link parsing and generation for Windrose maps.
 * Format: obsidian://windrose?notePath|mapId,x,y,zoom,layerId
 */

/** Parsed deep link data */
export interface DeepLinkData {
  notePath: string;
  mapId: string;
  x: number;
  y: number;
  zoom: number;
  layerId: string;
}

/** Navigation event detail (extends DeepLinkData with timestamp) */
export interface NavigationEventDetail extends DeepLinkData {
  timestamp: number;
}

/** Protocol prefix for Windrose deep links (uses Obsidian's protocol handler) */
const PROTOCOL = 'obsidian://windrose?';

/** Custom event name for map navigation */
const NAVIGATION_EVENT = 'dmt-navigate-to';

/** Parse a deep link URL into structured data */
function parseDeepLink(url: string): DeepLinkData | null {
  if (!url || typeof url !== 'string') {
    return null;
  }

  if (!url.startsWith(PROTOCOL)) {
    return null;
  }

  const dataStr = url.slice(PROTOCOL.length);
  const pipeIndex = dataStr.indexOf('|');
  if (pipeIndex === -1) {
    return null;
  }

  const notePath = dataStr.slice(0, pipeIndex);
  const coordData = dataStr.slice(pipeIndex + 1);
  const parts = coordData.split(',');

  if (parts.length !== 5) {
    return null;
  }

  const [mapId, xStr, yStr, zoomStr, layerId] = parts;

  if (!notePath || !mapId || !layerId) {
    return null;
  }

  const x = parseFloat(xStr);
  const y = parseFloat(yStr);
  const zoom = parseFloat(zoomStr);

  if (isNaN(x) || isNaN(y) || isNaN(zoom)) {
    return null;
  }

  return {
    notePath,
    mapId,
    x,
    y,
    zoom,
    layerId
  };
}

/**
 * Generate a deep link URL from map location data.
 * @param notePath Path to the note containing the map
 * @param mapId The map identifier
 * @param x X coordinate
 * @param y Y coordinate
 * @param zoom Zoom level
 * @param layerId Layer identifier
 * @returns Deep link URL
 */
function generateDeepLink(
  notePath: string,
  mapId: string,
  x: number,
  y: number,
  zoom: number,
  layerId: string
): string {
  // Round to 2 decimal places for clean URLs
  const roundedX = Math.round(x * 100) / 100;
  const roundedY = Math.round(y * 100) / 100;
  const roundedZoom = Math.round(zoom * 100) / 100;

  return `${PROTOCOL}${notePath}|${mapId},${roundedX},${roundedY},${roundedZoom},${layerId}`;
}

/**
 * Generate a markdown link with display text.
 * @param displayText Text to show for the link
 * @param notePath Path to the note containing the map
 * @param mapId The map identifier
 * @param x X coordinate
 * @param y Y coordinate
 * @param zoom Zoom level
 * @param layerId Layer identifier
 * @returns Markdown link syntax
 */
function generateDeepLinkMarkdown(
  displayText: string,
  notePath: string,
  mapId: string,
  x: number,
  y: number,
  zoom: number,
  layerId: string
): string {
  // Escape brackets in display text (remove them to avoid breaking markdown)
  const escapedText = displayText.replace(/[\[\]]/g, '');
  const url = generateDeepLink(notePath, mapId, x, y, zoom, layerId);
  return `[${escapedText}](${url})`;
}

/**
 * Copy a deep link to clipboard and show a Notice.
 * @param displayText Text to show for the link
 * @param notePath Path to the note containing the map
 * @param mapId The map identifier
 * @param x X coordinate
 * @param y Y coordinate
 * @param zoom Zoom level
 * @param layerId Layer identifier
 */
function copyDeepLinkToClipboard(
  displayText: string,
  notePath: string,
  mapId: string,
  x: number,
  y: number,
  zoom: number,
  layerId: string
): void {
  const markdown = generateDeepLinkMarkdown(displayText, notePath, mapId, x, y, zoom, layerId);

  navigator.clipboard.writeText(markdown).then(() => {
    new Notice('Deep link copied to clipboard');
  }).catch((err: Error) => {
    console.error('Failed to copy link:', err);
    new Notice('Failed to copy link');
  });
}

/**
 * Emit a navigation event for map components to handle.
 * @param data Navigation target data
 */
function emitNavigationEvent(data: DeepLinkData): void {
  const detail: NavigationEventDetail = {
    ...data,
    timestamp: Date.now()
  };

  const event = new CustomEvent(NAVIGATION_EVENT, { detail });
  window.dispatchEvent(event);
}

return {
  PROTOCOL,
  NAVIGATION_EVENT,
  parseDeepLink,
  generateDeepLink,
  generateDeepLinkMarkdown,
  copyDeepLinkToClipboard,
  emitNavigationEvent
};

```

# LinkingModeBanner

```tsx
import type { LinkingSource } from '../context/ObjectLinkingContext.tsx';

const { getObjectType } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "objectTypeResolver"));

interface LinkingModeBannerProps {
  linkingFrom: LinkingSource;
  onCancel: () => void;
}

const LinkingModeBanner = ({ linkingFrom, onCancel }: LinkingModeBannerProps): React.ReactElement => {
  const objectDef = getObjectType(linkingFrom.objectType);
  const objectLabel = objectDef?.label || linkingFrom.objectType;

  dc.useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onCancel();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [onCancel]);

  return (
    <div className="dmt-linking-banner">
      <div className="dmt-linking-banner-content">
        <dc.Icon icon="lucide-link-2" />
        <span>Linking from <strong>{objectLabel}</strong> - click target object</span>
        <button
          className="dmt-linking-banner-cancel"
          onClick={onCancel}
          title="Cancel (Esc)"
        >
          Cancel
        </button>
      </div>
    </div>
  );
};

return { LinkingModeBanner };

```

# ObjectLayer

```tsx
/**
 * ObjectLayer.tsx
 *
 * Handles all object-related interactions:
 * - Object placement
 * - Object selection and dragging
 * - Object resizing
 * - Object color and notes
 * - Hover tooltips
 */

import type { JSX } from 'preact';
import type { ToolId } from '#types/tools/tool.types';
import type { ObjectTypeId, MapObject } from '#types/objects/object.types';
import type { TextLabel } from '#types/objects/note.types';
import type { HexColor } from '#types/core/common.types';
import type { CustomColor } from '../ColorPicker.tsx';

const { useMapState, useMapOperations } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext"));
const { useMapSelection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSelectionContext"));
const { useLinkingMode } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ObjectLinkingContext"));
const { useEventHandlerRegistration } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "EventHandlerContext"));
const { useObjectInteractions } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useObjectInteractions"));
const { TextInputModal } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "TextInputModal"));
const { NoteLinkModal } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "NoteLinkModal"));
const { SelectionToolbar } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "SelectionToolbar"));
const { calculateObjectScreenPosition } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "screenPositionUtils"));
const { getActiveLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor"));
const { copyDeepLinkToClipboard } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "deepLinkHandler"));
const { LinkingModeBanner } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "LinkingModeBanner"));

const { rotateByIncrement } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "rotationOperations")) as {
  rotateByIncrement: (currentRotation: number) => number
};

/** Selected item from context */
interface SelectedItem {
  type: 'object' | 'text' | 'notePin';
  id: string;
  data?: MapObject;
}

/** Cardinal direction indicator positions */
interface CardinalIndicatorPositions {
  north: { x: number; y: number };
  south: { x: number; y: number };
  east: { x: number; y: number };
  west: { x: number; y: number };
}

/** Props for ObjectLayer component */
export interface ObjectLayerProps {
  /** Current active tool */
  currentTool: ToolId;
  /** Currently selected object type */
  selectedObjectType: ObjectTypeId | null;
  /** Callback when objects change */
  onObjectsChange: (objects: MapObject[], suppressHistory?: boolean) => void;
  /** Custom colors array */
  customColors?: CustomColor[];
  /** Callback to add custom color */
  onAddCustomColor?: (color: HexColor) => void;
  /** Callback to delete custom color */
  onDeleteCustomColor?: (colorId: string) => void;
}

const ObjectLayer = ({
  currentTool,
  selectedObjectType,
  onObjectsChange,
  customColors,
  onAddCustomColor,
  onDeleteCustomColor
}: ObjectLayerProps): React.ReactElement | null => {
  const { canvasRef, containerRef, mapData, mapId, notePath, geometry, screenToGrid, screenToWorld, getClientCoords, GridGeometry } = useMapState();
  const { getObjectAtPosition, addObject, updateObject, removeObject, isAreaFree, onObjectsChange: contextOnObjectsChange, onTextLabelsChange, removeTextLabel } = useMapOperations();
  const {
    selectedItem, setSelectedItem,
    selectedItems, isSelected, hasMultiSelection, selectionCount, selectItem, selectMultiple, clearSelection,
    isDraggingSelection, setIsDraggingSelection,
    dragStart, setDragStart,
    isResizeMode, setIsResizeMode,
    hoveredObject, setHoveredObject,
    mousePosition, setMousePosition,
    showNoteLinkModal, setShowNoteLinkModal,
    editingNoteObjectId, setEditingNoteObjectId,
    showCoordinates,
    layerVisibility,
    updateSelectedItemsData
  } = useMapSelection();

  const { isLinkingMode, linkingFrom, startLinking, cancelLinking } = useLinkingMode();

  // Helper for bidirectional link updates (handles same-layer vs cross-layer)
  const applyLinkUpdate = dc.useCallback((
    updates: Array<{ layerId: string; objectId: string; transform: (obj: MapObject) => MapObject }>,
    crossLayerEvent: { name: string; detail: Record<string, unknown> }
  ): void => {
    if (!mapData) return;

    const allOnActiveLayer = updates.every(u => u.layerId === mapData.activeLayerId);

    if (allOnActiveLayer) {
      const activeLayer = getActiveLayer(mapData);
      const updatedObjects = activeLayer.objects?.map((obj: MapObject) => {
        const update = updates.find(u => u.objectId === obj.id);
        return update ? update.transform(obj) : obj;
      });
      if (updatedObjects) {
        onObjectsChange(updatedObjects);
      }
    } else {
      window.dispatchEvent(new CustomEvent(crossLayerEvent.name, { detail: crossLayerEvent.detail }));
    }
  }, [mapData, onObjectsChange]);

  const [showNoteModal, setShowNoteModal] = dc.useState(false);
  const [editingObjectId, setEditingObjectId] = dc.useState<string | null>(null);
  const [showObjectColorPicker, setShowObjectColorPicker] = dc.useState(false);

  const handleScaleChange = dc.useCallback((newScale: number) => {
    if (!selectedItem || selectedItem.type !== 'object' || !mapData?.objects) return;

    const updatedObjects = updateObject(getActiveLayer(mapData).objects, selectedItem.id, { scale: newScale });
    contextOnObjectsChange(updatedObjects);

    const updatedObject = updatedObjects.find((obj: MapObject) => obj.id === selectedItem.id);
    if (updatedObject) {
      setSelectedItem({ ...selectedItem, data: updatedObject });
    }
  }, [selectedItem, mapData, updateObject, contextOnObjectsChange, setSelectedItem]);

  const handleRotateAll = dc.useCallback(() => {
    if (!hasMultiSelection || !mapData) return;

    const activeLayer = getActiveLayer(mapData);
    let updatedObjects = [...(activeLayer.objects || [])];
    let updatedTextLabels = [...(activeLayer.textLabels || [])];

    for (const item of selectedItems) {
      if (item.type === 'object') {
        const idx = updatedObjects.findIndex((o: MapObject) => o.id === item.id);
        if (idx !== -1) {
          const obj = updatedObjects[idx];
          const currentRotation = obj.rotation || 0;
          const nextRotation = rotateByIncrement(currentRotation);
          updatedObjects[idx] = { ...obj, rotation: nextRotation };
        }
      } else if (item.type === 'text') {
        const idx = updatedTextLabels.findIndex((l: { id: string }) => l.id === item.id);
        if (idx !== -1) {
          const label = updatedTextLabels[idx];
          const currentRotation = label.rotation || 0;
          const nextRotation = rotateByIncrement(currentRotation);
          updatedTextLabels[idx] = { ...label, rotation: nextRotation };
        }
      }
    }

    onObjectsChange(updatedObjects, true);
    onTextLabelsChange(updatedTextLabels, false);

    const updates = selectedItems.map((item: SelectedItem) => {
      if (item.type === 'object') {
        const obj = updatedObjects.find((o: MapObject) => o.id === item.id);
        return obj ? { id: item.id, rotation: obj.rotation } : null;
      } else {
        const label = updatedTextLabels.find((l: { id: string; rotation?: number }) => l.id === item.id);
        return label ? { id: item.id, rotation: label.rotation } : null;
      }
    }).filter(Boolean);

    updateSelectedItemsData(updates);
  }, [hasMultiSelection, mapData, selectedItems, onObjectsChange, onTextLabelsChange, updateSelectedItemsData]);

  const handleDuplicateAll = dc.useCallback(() => {
    if (!hasMultiSelection || !mapData) return;

    const activeLayer = getActiveLayer(mapData);
    let updatedObjects = [...(activeLayer.objects || [])];
    let updatedTextLabels = [...(activeLayer.textLabels || [])];
    const newSelectedItems: SelectedItem[] = [];

    const offsetX = 1;
    const offsetY = 0;

    for (const item of selectedItems) {
      if (item.type === 'object') {
        const sourceObj = activeLayer.objects?.find((o: MapObject) => o.id === item.id);
        if (!sourceObj) continue;

        const newId = `obj-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const newObj = {
          ...sourceObj,
          id: newId,
          position: {
            x: sourceObj.position.x + offsetX,
            y: sourceObj.position.y + offsetY
          }
        };
        updatedObjects.push(newObj);
        newSelectedItems.push({ type: 'object', id: newId, data: newObj });
      } else if (item.type === 'text') {
        const sourceLabel = activeLayer.textLabels?.find((l: { id: string }) => l.id === item.id);
        if (!sourceLabel) continue;

        const newId = `text-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const offsetWorld = (mapData.gridSize || 32) * 1;
        const newLabel = {
          ...sourceLabel,
          id: newId,
          position: {
            x: sourceLabel.position.x + offsetWorld,
            y: sourceLabel.position.y
          }
        };
        updatedTextLabels.push(newLabel);
        newSelectedItems.push({ type: 'text', id: newId, data: newLabel });
      }
    }

    onObjectsChange(updatedObjects, true);
    onTextLabelsChange(updatedTextLabels, false);

    if (newSelectedItems.length > 0) {
      selectMultiple(newSelectedItems);
    }
  }, [hasMultiSelection, mapData, selectedItems, contextOnObjectsChange, onTextLabelsChange, selectMultiple]);

  const handleDeleteAll = dc.useCallback(() => {
    if (!hasMultiSelection || !mapData) return;

    const activeLayer = getActiveLayer(mapData);
    const selectedObjectIds = new Set(selectedItems.filter((i: SelectedItem) => i.type === 'object').map((i: SelectedItem) => i.id));
    const selectedTextIds = new Set(selectedItems.filter((i: SelectedItem) => i.type === 'text').map((i: SelectedItem) => i.id));

    const updatedObjects = (activeLayer.objects || []).filter((obj: MapObject) => !selectedObjectIds.has(obj.id));
    const updatedTextLabels = (activeLayer.textLabels || []).filter((label: { id: string }) => !selectedTextIds.has(label.id));

    onObjectsChange(updatedObjects, true);
    onTextLabelsChange(updatedTextLabels, false);

    clearSelection();
  }, [hasMultiSelection, mapData, selectedItems, onObjectsChange, onTextLabelsChange, clearSelection]);

  const handleCopyLink = dc.useCallback(() => {
    if (!selectedItem || !mapData || !mapId || !notePath) return;

    const activeLayer = getActiveLayer(mapData);
    const zoom = mapData.viewState?.zoom ?? 1.0;
    const layerId = mapData.activeLayerId || activeLayer?.id || 'layer_001';

    let displayText = 'Map Location';
    let x = 0;
    let y = 0;

    if (selectedItem.type === 'object') {
      const obj = activeLayer.objects?.find((o: MapObject) => o.id === selectedItem.id);
      if (!obj) return;
      displayText = obj.label || obj.customTooltip || 'Object';
      x = obj.position.x;
      y = obj.position.y;
    } else if (selectedItem.type === 'text') {
      const label = activeLayer.textLabels?.find((l: TextLabel) => l.id === selectedItem.id);
      if (!label) return;
      displayText = label.content || 'Text';
      // Text labels use world coordinates, convert to grid
      const gridSize = mapData.gridSize || 32;
      x = label.position.x / gridSize;
      y = label.position.y / gridSize;
    }

    copyDeepLinkToClipboard(displayText, notePath, mapId, x, y, zoom, layerId);
  }, [selectedItem, mapData, mapId, notePath]);

  const {
    isResizing,
    resizeCorner,
    objectColorBtnRef,
    pendingObjectCustomColorRef,
    edgeSnapMode,
    setEdgeSnapMode,
    longPressTimerRef,
    handleObjectPlacement,
    handleObjectSelection,
    handleObjectDragging,
    handleObjectResizing,
    handleObjectWheel,
    handleHoverUpdate,
    stopObjectDragging,
    stopObjectResizing,
    handleObjectKeyDown,
    handleObjectRotation,
    handleObjectDeletion,
    handleObjectDuplicate,
    handleNoteSubmit,
    handleObjectColorSelect,
    handleObjectColorReset,
    getClickedCorner
  } = useObjectInteractions(currentTool, selectedObjectType, onAddCustomColor, customColors);

  const { registerHandlers, unregisterHandlers } = useEventHandlerRegistration();

  // Wrap handleObjectSelection to intercept clicks when in linking mode
  const wrappedHandleObjectSelection = dc.useCallback((
    clientX: number,
    clientY: number,
    gridX: number,
    gridY: number
  ): boolean => {
    if (isLinkingMode && linkingFrom && mapData) {
      // In linking mode - try to find target object
      const activeLayer = getActiveLayer(mapData);
      const targetObject = activeLayer.objects?.find((obj: MapObject) => {
        return obj.position.x === gridX && obj.position.y === gridY;
      });

      if (targetObject) {
        // Prevent self-linking
        if (targetObject.id === linkingFrom.objectId && mapData.activeLayerId === linkingFrom.layerId) {
          new Notice('Cannot link an object to itself');
          return true;
        }

        // Complete the bidirectional link
        const sourceToTargetLink = {
          layerId: mapData.activeLayerId,
          objectId: targetObject.id,
          position: targetObject.position,
          objectType: targetObject.type
        };

        const targetToSourceLink = {
          layerId: linkingFrom.layerId,
          objectId: linkingFrom.objectId,
          position: linkingFrom.position,
          objectType: linkingFrom.objectType
        };

        applyLinkUpdate(
          [
            { layerId: linkingFrom.layerId, objectId: linkingFrom.objectId, transform: (obj) => ({ ...obj, linkedObject: sourceToTargetLink }) },
            { layerId: mapData.activeLayerId, objectId: targetObject.id, transform: (obj) => ({ ...obj, linkedObject: targetToSourceLink }) }
          ],
          {
            name: 'dmt-create-object-link',
            detail: {
              sourceLayerId: linkingFrom.layerId,
              sourceObjectId: linkingFrom.objectId,
              sourceLink: sourceToTargetLink,
              targetLayerId: mapData.activeLayerId,
              targetObjectId: targetObject.id,
              targetLink: targetToSourceLink
            }
          }
        );

        // Clear linking mode
        cancelLinking();
        new Notice('Objects linked');

        // Select the target object with updated data
        setSelectedItem({
          type: 'object',
          id: targetObject.id,
          data: { ...targetObject, linkedObject: targetToSourceLink }
        });

        return true;
      }
    }

    // Not in linking mode or no target found - use normal selection
    return handleObjectSelection(clientX, clientY, gridX, gridY);
  }, [isLinkingMode, linkingFrom, mapData, handleObjectSelection, applyLinkUpdate, cancelLinking, setSelectedItem]);

  dc.useEffect(() => {
    registerHandlers('object', {
      handleObjectPlacement,
      handleObjectSelection: wrappedHandleObjectSelection,
      handleObjectDragging,
      handleObjectResizing,
      stopObjectDragging,
      stopObjectResizing,
      handleHoverUpdate,
      handleObjectWheel,
      handleObjectKeyDown,
      isResizing,
      resizeCorner,
      edgeSnapMode,
      setEdgeSnapMode
    });

    return () => unregisterHandlers('object');
  }, [
    registerHandlers, unregisterHandlers,
    handleObjectPlacement, wrappedHandleObjectSelection,
    handleObjectDragging, handleObjectResizing,
    stopObjectDragging, stopObjectResizing,
    handleHoverUpdate, handleObjectWheel, handleObjectKeyDown,
    isResizing, resizeCorner,
    edgeSnapMode, setEdgeSnapMode
  ]);

  const handleNoteButtonClick = (e: JSX.TargetedMouseEvent<HTMLElement>): void => {
    if (selectedItem?.type === 'object') {
      e.preventDefault();
      e.stopPropagation();

      if (isDraggingSelection) {
        setIsDraggingSelection(false);
        setDragStart(null);
      }

      setEditingObjectId(selectedItem.id);
      setShowNoteModal(true);
    }
  };

  const handleResizeButtonClick = (e: JSX.TargetedMouseEvent<HTMLElement>): void => {
    if (selectedItem?.type === 'object') {
      e.preventDefault();
      e.stopPropagation();
      setIsResizeMode(true);
    }
  };

  const handleNoteModalSubmit = (content: string): void => {
    handleNoteSubmit(content, editingObjectId);
    setShowNoteModal(false);
    setEditingObjectId(null);
  };

  const handleNoteCancel = (): void => {
    setShowNoteModal(false);
    setEditingObjectId(null);
  };

  const handleObjectColorButtonClick = (e: JSX.TargetedMouseEvent<HTMLElement>): void => {
    if (selectedItem?.type === 'object') {
      e.preventDefault();
      e.stopPropagation();
      setShowObjectColorPicker(!showObjectColorPicker);
    }
  };

  const handleObjectColorPickerClose = (): void => {
    setShowObjectColorPicker(false);
  };

  const handleObjectColorResetWrapper = (): void => {
    handleObjectColorReset(setShowObjectColorPicker);
  };

  const handleEditNoteLink = (objectId: string): void => {
    if (isDraggingSelection) {
      setIsDraggingSelection(false);
      setDragStart(null);
    }

    setEditingNoteObjectId(objectId);
    setShowNoteLinkModal(true);
  };

  const handleNoteLinkSave = (notePath: string): void => {
    if (!mapData || !editingNoteObjectId) return;

    const updatedObjects = getActiveLayer(mapData).objects.map((obj: MapObject) => {
      if (obj.id === editingNoteObjectId) {
        return { ...obj, linkedNote: notePath };
      }
      return obj;
    });

    onObjectsChange(updatedObjects);

    if (selectedItem?.type === 'object' && selectedItem.id === editingNoteObjectId) {
      const updatedObject = updatedObjects.find((obj: MapObject) => obj.id === editingNoteObjectId);
      if (updatedObject) {
        setSelectedItem({ ...selectedItem, data: updatedObject });
      }
    }

    setShowNoteLinkModal(false);
    setEditingNoteObjectId(null);
  };

  const handleNoteLinkCancel = (): void => {
    setShowNoteLinkModal(false);
    setEditingNoteObjectId(null);
  };

  const handleLinkObject = dc.useCallback(() => {
    if (!selectedItem || selectedItem.type !== 'object' || !mapData) return;

    const activeLayer = getActiveLayer(mapData);
    const obj = activeLayer.objects?.find((o: MapObject) => o.id === selectedItem.id);
    if (!obj) return;

    startLinking({
      layerId: mapData.activeLayerId,
      objectId: obj.id,
      position: obj.position,
      objectType: obj.type
    });
  }, [selectedItem, mapData, startLinking]);

  const handleFollowLink = dc.useCallback(() => {
    if (!selectedItem || selectedItem.type !== 'object' || !mapData || !mapId || !notePath) return;

    const obj = selectedItem.data as MapObject;
    if (!obj?.linkedObject) return;

    const { layerId, objectId } = obj.linkedObject;

    const targetLayer = mapData.layers.find(l => l.id === layerId);
    if (!targetLayer) {
      new Notice('Linked layer no longer exists');
      return;
    }

    const targetObject = targetLayer.objects?.find((o: MapObject) => o.id === objectId);
    if (!targetObject) {
      new Notice('Linked object no longer exists');
      return;
    }

    // Navigate to the target (DungeonMapTracker handles layer switching + panning)
    window.dispatchEvent(new CustomEvent('dmt-navigate-to', {
      detail: {
        notePath,
        mapId,
        x: targetObject.position.x,
        y: targetObject.position.y,
        zoom: 1.175,
        layerId,
        timestamp: Date.now()
      }
    }));

    // Select the target object immediately (we already have its data)
    setSelectedItem({
      type: 'object',
      id: targetObject.id,
      data: targetObject
    });
  }, [selectedItem, mapData, mapId, notePath, setSelectedItem]);

  const handleRemoveLink = dc.useCallback(() => {
    if (!selectedItem || selectedItem.type !== 'object' || !mapData) return;

    const obj = selectedItem.data as MapObject;
    if (!obj?.linkedObject) return;

    const { layerId: targetLayerId, objectId: targetObjectId } = obj.linkedObject;
    const sourceLayerId = mapData.activeLayerId;
    const sourceObjectId = selectedItem.id;

    const removeLinkedObject = (o: MapObject): MapObject => {
      const { linkedObject: _removed, ...rest } = o;
      return rest as MapObject;
    };

    applyLinkUpdate(
      [
        { layerId: sourceLayerId, objectId: sourceObjectId, transform: removeLinkedObject },
        { layerId: targetLayerId, objectId: targetObjectId, transform: removeLinkedObject }
      ],
      {
        name: 'dmt-remove-object-link',
        detail: { sourceLayerId, sourceObjectId, targetLayerId, targetObjectId }
      }
    );

    const { linkedObject: _removed, ...restData } = obj;
    setSelectedItem({
      type: 'object',
      id: selectedItem.id,
      data: restData as MapObject
    });

    new Notice('Link removed');
  }, [selectedItem, mapData, applyLinkUpdate, setSelectedItem]);

  dc.useEffect(() => {
    if (!showObjectColorPicker) return;

    const handleClickOutside = (e: MouseEvent | TouchEvent): void => {
      const target = e.target as Element;
      const pickerElement = target.closest('.dmt-color-picker');
      const buttonElement = target.closest('.dmt-object-color-button');

      if (!pickerElement && !buttonElement) {
        if (pendingObjectCustomColorRef.current && onAddCustomColor) {
          onAddCustomColor(pendingObjectCustomColorRef.current);
          handleObjectColorSelect(pendingObjectCustomColorRef.current);
          pendingObjectCustomColorRef.current = null;
        }

        handleObjectColorPickerClose();
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    document.addEventListener('touchstart', handleClickOutside);

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('touchstart', handleClickOutside);
    };
  }, [showObjectColorPicker]);

  if (showCoordinates || !layerVisibility.objects) {
    return null;
  }

  const getCardinalIndicatorPositions = (selectedObject: MapObject): CardinalIndicatorPositions | null => {
    if (!selectedObject || !canvasRef.current || !containerRef.current || !mapData) {
      return null;
    }

    const screenPos = calculateObjectScreenPosition(selectedObject, canvasRef.current, mapData, geometry);

    if (!screenPos) return null;

    const { screenX, screenY, objectWidth, objectHeight } = screenPos;
    const indicatorSize = 12;
    const gap = 6;

    return {
      north: {
        x: screenX - indicatorSize / 2,
        y: screenY - objectHeight / 2 - gap - indicatorSize
      },
      south: {
        x: screenX - indicatorSize / 2,
        y: screenY + objectHeight / 2 + gap
      },
      east: {
        x: screenX + objectWidth / 2 + gap,
        y: screenY - indicatorSize / 2
      },
      west: {
        x: screenX - objectWidth / 2 - gap - indicatorSize,
        y: screenY - indicatorSize / 2
      }
    };
  };

  const selectedObject = selectedItem?.type === 'object' && mapData?.objects
    ? getActiveLayer(mapData).objects.find((obj: MapObject) => obj.id === selectedItem.id)
    : null;

  const indicatorPositions = edgeSnapMode && selectedObject && mapData?.mapType !== 'hex'
    ? getCardinalIndicatorPositions(selectedObject)
    : null;

  return (
    <>
      {/* Linking Mode Banner */}
      {isLinkingMode && linkingFrom && (
        <LinkingModeBanner
          linkingFrom={linkingFrom}
          onCancel={cancelLinking}
        />
      )}

      {edgeSnapMode && selectedItem?.type === 'object' && indicatorPositions && (
        <>
          <div
            className="dmt-edge-snap-indicator north"
            style={{
              position: 'absolute',
              left: `${indicatorPositions.north.x}px`,
              top: `${indicatorPositions.north.y}px`,
              width: 0,
              height: 0,
              borderLeft: '6px solid transparent',
              borderRight: '6px solid transparent',
              borderBottom: '8px solid var(--interactive-accent, #4a9eff)',
              filter: 'drop-shadow(0 0 3px var(--interactive-accent, #4a9eff))',
              pointerEvents: 'none',
              zIndex: 1000
            }}
          />
          <div
            className="dmt-edge-snap-indicator south"
            style={{
              position: 'absolute',
              left: `${indicatorPositions.south.x}px`,
              top: `${indicatorPositions.south.y}px`,
              width: 0,
              height: 0,
              borderLeft: '6px solid transparent',
              borderRight: '6px solid transparent',
              borderTop: '8px solid var(--interactive-accent, #4a9eff)',
              filter: 'drop-shadow(0 0 3px var(--interactive-accent, #4a9eff))',
              pointerEvents: 'none',
              zIndex: 1000
            }}
          />
          <div
            className="dmt-edge-snap-indicator east"
            style={{
              position: 'absolute',
              left: `${indicatorPositions.east.x}px`,
              top: `${indicatorPositions.east.y}px`,
              width: 0,
              height: 0,
              borderTop: '6px solid transparent',
              borderBottom: '6px solid transparent',
              borderLeft: '8px solid var(--interactive-accent, #4a9eff)',
              filter: 'drop-shadow(0 0 3px var(--interactive-accent, #4a9eff))',
              pointerEvents: 'none',
              zIndex: 1000
            }}
          />
          <div
            className="dmt-edge-snap-indicator west"
            style={{
              position: 'absolute',
              left: `${indicatorPositions.west.x}px`,
              top: `${indicatorPositions.west.y}px`,
              width: 0,
              height: 0,
              borderTop: '6px solid transparent',
              borderBottom: '6px solid transparent',
              borderRight: '8px solid var(--interactive-accent, #4a9eff)',
              filter: 'drop-shadow(0 0 3px var(--interactive-accent, #4a9eff))',
              pointerEvents: 'none',
              zIndex: 1000
            }}
          />
        </>
      )}

      {((selectedItem?.type === 'object' || hasMultiSelection) && !isDraggingSelection) && (
        <SelectionToolbar
          selectedItem={selectedItem}
          selectedItems={selectedItems}
          hasMultiSelection={hasMultiSelection}
          selectionCount={selectionCount}
          mapData={mapData}
          canvasRef={canvasRef}
          containerRef={containerRef}
          geometry={geometry}
          onRotate={handleObjectRotation}
          onDuplicate={handleObjectDuplicate}
          onLabel={handleNoteButtonClick}
          onLinkNote={() => handleEditNoteLink(selectedItem?.id)}
          onLinkObject={handleLinkObject}
          onFollowLink={handleFollowLink}
          onRemoveLink={handleRemoveLink}
          onCopyLink={handleCopyLink}
          onColorClick={handleObjectColorButtonClick}
          onResize={handleResizeButtonClick}
          onDelete={handleObjectDeletion}
          onScaleChange={handleScaleChange}
          onRotateAll={handleRotateAll}
          onDuplicateAll={handleDuplicateAll}
          onDeleteAll={handleDeleteAll}
          isResizeMode={isResizeMode}
          showColorPicker={showObjectColorPicker}
          currentColor={selectedItem?.data?.color}
          onColorSelect={handleObjectColorSelect}
          onColorPickerClose={handleObjectColorPickerClose}
          onColorReset={handleObjectColorResetWrapper}
          customColors={customColors}
          onAddCustomColor={onAddCustomColor}
          onDeleteCustomColor={onDeleteCustomColor}
          pendingCustomColorRef={pendingObjectCustomColorRef}
          colorButtonRef={objectColorBtnRef}
        />
      )}

      {showNoteModal && editingObjectId && mapData && (
        <TextInputModal
          onSubmit={handleNoteModalSubmit}
          onCancel={handleNoteCancel}
          title={`Note for ${getActiveLayer(mapData).objects.find((obj: MapObject) => obj.id === editingObjectId)?.label || 'Object'}`}
          placeholder="Add a custom note..."
          initialValue={getActiveLayer(mapData).objects.find((obj: MapObject) => obj.id === editingObjectId)?.customTooltip || ''}
        />
      )}

      {showNoteLinkModal && mapData && (
        <NoteLinkModal
          isOpen={showNoteLinkModal}
          onClose={handleNoteLinkCancel}
          onSave={handleNoteLinkSave}
          currentNotePath={
            editingNoteObjectId
              ? getActiveLayer(mapData).objects?.find((obj: MapObject) => obj.id === editingNoteObjectId)?.linkedNote || null
              : null
          }
          objectType={
            editingNoteObjectId
              ? getActiveLayer(mapData).objects?.find((obj: MapObject) => obj.id === editingNoteObjectId)?.type || null
              : null
          }
        />
      )}

      {hoveredObject && mousePosition && hoveredObject.type !== 'note_pin' && (
        <div
          className="dmt-object-tooltip"
          style={{
            position: 'absolute',
            left: mousePosition.x + 20,
            top: mousePosition.y + 25,
            pointerEvents: 'none',
            zIndex: 1000
          }}
        >
          {hoveredObject.customTooltip
            ? `${hoveredObject.label} - ${hoveredObject.customTooltip}`
            : hoveredObject.label
          }
        </div>
      )}
    </>
  );
};

return { ObjectLayer };

```

# edgeOperations

```ts
/**
 * edgeOperations.ts
 * 
 * Pure functions for edge manipulation in grid maps.
 * Edges represent painted grid lines between cells.
 * 
 * EDGE DATA STRUCTURE:
 * {
 *   id: string,      // Unique identifier
 *   x: number,       // Cell x coordinate
 *   y: number,       // Cell y coordinate
 *   side: string,    // 'right' | 'bottom' (normalized form)
 *   color: string,   // Hex color code
 *   opacity?: number // Optional opacity (0-1)
 * }
 * 
 * NORMALIZATION:
 * Each physical edge between two cells has two possible representations:
 * - "right edge of cell (5,3)" === "left edge of cell (6,3)"
 * - "bottom edge of cell (5,3)" === "top edge of cell (5,4)"
 * 
 * To avoid duplicates, we normalize to always use 'right' and 'bottom' sides:
 * - 'left' edges become 'right' edges of the cell to the left (x-1)
 * - 'top' edges become 'bottom' edges of the cell above (y-1)
 */

// Type-only imports
import type { HexColor } from '#types/settings/settings.types';

// ===========================================
// Type Definitions
// ===========================================

/** Raw edge side (user input) */
export type EdgeSideInput = 'top' | 'right' | 'bottom' | 'left';

/** Normalized edge side (storage) */
export type EdgeSideNormalized = 'right' | 'bottom';

/** Unique edge identifier */
export type EdgeId = string;

/** Edge data structure */
export interface Edge {
  id: EdgeId;
  x: number;
  y: number;
  side: EdgeSideNormalized;
  color: HexColor;
  opacity?: number;
}

/** Normalized edge coordinates (without id) */
export interface NormalizedEdge {
  x: number;
  y: number;
  side: EdgeSideNormalized;
}

/** Edge for generation (without id) */
export interface EdgeTemplate {
  x: number;
  y: number;
  side: EdgeSideNormalized;
  color: HexColor | null;
}

/** Partial edge for updates */
export type EdgeUpdate = Partial<Omit<Edge, 'id'>>;

// ===========================================
// Normalization
// ===========================================

/**
 * Normalize edge to canonical representation.
 * Converts 'left' to 'right' of adjacent cell, 'top' to 'bottom' of adjacent cell.
 * This ensures each physical edge has exactly one storage representation.
 */
function normalizeEdge(x: number, y: number, side: EdgeSideInput): NormalizedEdge {
  switch (side) {
    case 'left':
      // Left edge of (x,y) = Right edge of (x-1,y)
      return { x: x - 1, y, side: 'right' };
    case 'top':
      // Top edge of (x,y) = Bottom edge of (x,y-1)
      return { x, y: y - 1, side: 'bottom' };
    default:
      // 'right' and 'bottom' are already canonical
      return { x, y, side: side as EdgeSideNormalized };
  }
}

// ===========================================
// ID Generation
// ===========================================

/**
 * Generate unique edge ID
 */
function generateEdgeId(): EdgeId {
  return 'edge-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
}

// ===========================================
// Single Edge Operations
// ===========================================

/**
 * Find edge at position (handles normalization internally)
 */
function getEdgeAt(
  edges: Edge[] | null | undefined,
  x: number,
  y: number,
  side: EdgeSideInput
): Edge | null {
  if (!edges || !Array.isArray(edges)) return null;
  
  const normalized = normalizeEdge(x, y, side);
  return edges.find(e => 
    e.x === normalized.x && 
    e.y === normalized.y && 
    e.side === normalized.side
  ) || null;
}

/**
 * Add edge or update color if edge already exists
 */
function addEdge(
  edges: Edge[] | null | undefined,
  x: number,
  y: number,
  side: EdgeSideInput,
  color: HexColor,
  opacity: number = 1
): Edge[] {
  // Validate inputs - return unchanged array if invalid
  if (typeof x !== 'number' || typeof y !== 'number' || !side || !color) {
    return edges || [];
  }
  
  const edgeArray = edges || [];
  const normalized = normalizeEdge(x, y, side);
  const existing = getEdgeAt(edgeArray, x, y, side);
  
  if (existing) {
    // Update existing edge color and opacity
    return edgeArray.map(e => 
      e.id === existing.id ? { ...e, color, opacity } : e
    );
  }
  
  // Add new edge
  return [...edgeArray, {
    id: generateEdgeId(),
    x: normalized.x,
    y: normalized.y,
    side: normalized.side,
    color,
    opacity
  }];
}

/**
 * Remove edge at position
 */
function removeEdge(
  edges: Edge[] | null | undefined,
  x: number,
  y: number,
  side: EdgeSideInput
): Edge[] {
  if (!edges || !Array.isArray(edges)) return [];
  
  const normalized = normalizeEdge(x, y, side);
  return edges.filter(e => 
    !(e.x === normalized.x && 
      e.y === normalized.y && 
      e.side === normalized.side)
  );
}

/**
 * Remove edge by ID
 */
function removeEdgeById(edges: Edge[] | null | undefined, edgeId: EdgeId): Edge[] {
  if (!edges || !Array.isArray(edges)) return [];
  return edges.filter(e => e.id !== edgeId);
}

/**
 * Update edge properties by ID
 */
function updateEdge(
  edges: Edge[] | null | undefined,
  edgeId: EdgeId,
  updates: EdgeUpdate
): Edge[] {
  if (!edges || !Array.isArray(edges)) return [];
  
  return edges.map(e => {
    if (e.id === edgeId) {
      return { ...e, ...updates };
    }
    return e;
  });
}

// ===========================================
// Line Operations (Edge Line Tool)
// ===========================================

/**
 * Generate edges for a horizontal or vertical line between two intersection points.
 * Used for the edge line tool to paint multiple edges at once.
 * 
 * Intersection points are at grid corners (where 4 cells meet).
 * - A vertical line from (x, y1) to (x, y2) paints 'right' edges of column x-1
 * - A horizontal line from (x1, y) to (x2, y) paints 'bottom' edges of row y-1
 */
function generateEdgeLine(
  startX: number,
  startY: number,
  endX: number,
  endY: number,
  color: HexColor | null
): EdgeTemplate[] {
  const result: EdgeTemplate[] = [];
  
  if (startX === endX) {
    // Vertical line at intersection column startX
    // This paints the 'right' edges of cells in column (startX - 1)
    const minY = Math.min(startY, endY);
    const maxY = Math.max(startY, endY);
    const cellX = startX - 1; // The cell column whose right edges we're painting
    
    // Paint edges from minY to maxY-1 (edges between intersections)
    for (let y = minY; y < maxY; y++) {
      const normalized = normalizeEdge(cellX, y, 'right');
      result.push({ 
        x: normalized.x, 
        y: normalized.y, 
        side: normalized.side, 
        color 
      });
    }
  } else if (startY === endY) {
    // Horizontal line at intersection row startY
    // This paints the 'bottom' edges of cells in row (startY - 1)
    const minX = Math.min(startX, endX);
    const maxX = Math.max(startX, endX);
    const cellY = startY - 1; // The cell row whose bottom edges we're painting
    
    // Paint edges from minX to maxX-1 (edges between intersections)
    for (let x = minX; x < maxX; x++) {
      const normalized = normalizeEdge(x, cellY, 'bottom');
      result.push({ 
        x: normalized.x, 
        y: normalized.y, 
        side: normalized.side, 
        color 
      });
    }
  }
  // If neither same x nor same y, return empty (diagonal not supported)
  
  return result;
}

/**
 * Merge new edges into existing edges array.
 * Handles duplicates by updating color of existing edges.
 */
function mergeEdges(edges: Edge[] | null | undefined, newEdges: EdgeTemplate[]): Edge[] {
  let result = [...(edges || [])];
  
  for (const edge of newEdges) {
    if (edge.color !== null) {
      result = addEdge(result, edge.x, edge.y, edge.side, edge.color);
    }
  }
  
  return result;
}

/**
 * Remove edges along a line between two intersection points
 */
function removeEdgeLine(
  edges: Edge[] | null | undefined,
  startX: number,
  startY: number,
  endX: number,
  endY: number
): Edge[] {
  // Generate the edges that would be in this line (color doesn't matter for removal)
  const lineEdges = generateEdgeLine(startX, startY, endX, endY, null);
  
  let result = [...(edges || [])];
  for (const edge of lineEdges) {
    result = removeEdge(result, edge.x, edge.y, edge.side);
  }
  
  return result;
}

// ===========================================
// Query Operations
// ===========================================

/**
 * Get all edges adjacent to a specific cell.
 * Useful for highlighting or bulk operations.
 */
function getEdgesForCell(
  edges: Edge[] | null | undefined,
  x: number,
  y: number
): Edge[] {
  if (!edges || !Array.isArray(edges)) return [];
  
  return edges.filter(e => {
    // Check if edge is one of the 4 edges of this cell
    // Right edge of (x,y)
    if (e.x === x && e.y === y && e.side === 'right') return true;
    // Bottom edge of (x,y)
    if (e.x === x && e.y === y && e.side === 'bottom') return true;
    // Left edge of (x,y) = Right edge of (x-1,y)
    if (e.x === x - 1 && e.y === y && e.side === 'right') return true;
    // Top edge of (x,y) = Bottom edge of (x,y-1)
    if (e.x === x && e.y === y - 1 && e.side === 'bottom') return true;
    
    return false;
  });
}

// ===========================================
// Bulk Operations
// ===========================================

/**
 * Clear all edges from the array
 */
function clearAllEdges(): Edge[] {
  return [];
}

// ===========================================
// Exports
// ===========================================

return {
  // Normalization
  normalizeEdge,
  
  // ID generation
  generateEdgeId,
  
  // Single edge operations
  getEdgeAt,
  addEdge,
  removeEdge,
  removeEdgeById,
  updateEdge,
  
  // Line operations (for edge line tool)
  generateEdgeLine,
  mergeEdges,
  removeEdgeLine,
  
  // Query operations
  getEdgesForCell,
  
  // Bulk operations
  clearAllEdges
};
```

# curveOperations

```ts
/**
 * curveOperations.ts
 *
 * Pure functions for curve CRUD operations.
 * Similar pattern to edgeOperations.ts.
 *
 * CURVE DATA STRUCTURE:
 * {
 *   id: string,           // Unique identifier
 *   points: CurvePoint[], // Control points [[x,y], ...]
 *   color: string,        // Hex color code
 *   opacity?: number,     // Optional opacity (0-1)
 *   strokeWidth?: number, // Line width
 *   smoothing?: number,   // Catmull-Rom tension
 *   closed?: boolean      // Whether curve is closed
 * }
 */

// Type-only imports
import type {
  Curve,
  CurveId,
  CurvePoint,
  CurveTemplate,
  CurveUpdate,
  CurveBounds,
} from '#types/core/curve.types';

// Datacore imports
const { getCurveBounds, isPointNearCurve } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "curveMath")) as {
  getCurveBounds: (points: CurvePoint[]) => CurveBounds | null;
  isPointNearCurve: (points: CurvePoint[], point: CurvePoint, threshold: number, tension: number) => boolean;
};

// ===========================================================================
// ID Generation
// ===========================================================================

/**
 * Generate a unique curve ID
 */
function generateCurveId(): CurveId {
  return 'curve-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
}

// ===========================================================================
// CRUD Operations
// ===========================================================================

/**
 * Add a new curve to the array.
 * Generates a unique ID for the curve.
 *
 * @param curves - Existing curves array (or null/undefined)
 * @param template - Curve data without ID
 * @returns New array with the added curve
 */
function addCurve(
  curves: Curve[] | null | undefined,
  template: CurveTemplate
): Curve[] {
  const curveArray = curves || [];

  const newCurve: Curve = {
    id: generateCurveId(),
    ...template,
  };

  return [...curveArray, newCurve];
}

/**
 * Remove a curve by ID.
 *
 * @param curves - Existing curves array
 * @param curveId - ID of curve to remove
 * @returns New array without the removed curve
 */
function removeCurve(
  curves: Curve[] | null | undefined,
  curveId: CurveId
): Curve[] {
  if (!curves || !Array.isArray(curves)) return [];
  return curves.filter(c => c.id !== curveId);
}

/**
 * Update curve properties by ID.
 *
 * @param curves - Existing curves array
 * @param curveId - ID of curve to update
 * @param updates - Partial curve properties to update
 * @returns New array with the updated curve
 */
function updateCurve(
  curves: Curve[] | null | undefined,
  curveId: CurveId,
  updates: CurveUpdate
): Curve[] {
  if (!curves || !Array.isArray(curves)) return [];

  return curves.map(curve => {
    if (curve.id === curveId) {
      return { ...curve, ...updates };
    }
    return curve;
  });
}

/**
 * Get a curve by ID.
 *
 * @param curves - Curves array to search
 * @param curveId - ID to find
 * @returns The curve or null if not found
 */
function getCurveById(
  curves: Curve[] | null | undefined,
  curveId: CurveId
): Curve | null {
  if (!curves || !Array.isArray(curves)) return null;
  return curves.find(c => c.id === curveId) || null;
}

// ===========================================================================
// Query Operations
// ===========================================================================

/**
 * Get all curves that overlap with a bounding box.
 *
 * @param curves - Curves to search
 * @param bounds - Bounding box to check
 * @returns Curves that overlap the bounds
 */
function getCurvesInBounds(
  curves: Curve[] | null | undefined,
  bounds: CurveBounds
): Curve[] {
  if (!curves || !Array.isArray(curves)) return [];

  return curves.filter(curve => {
    const curveBounds = getCurveBounds(curve.points);
    if (!curveBounds) return false;

    // Check if bounding boxes overlap
    return !(
      curveBounds.maxX < bounds.minX ||
      curveBounds.minX > bounds.maxX ||
      curveBounds.maxY < bounds.minY ||
      curveBounds.minY > bounds.maxY
    );
  });
}

/**
 * Find the first curve near a point (for selection).
 *
 * @param curves - Curves to search
 * @param point - Query point [x, y]
 * @param threshold - Maximum distance to consider "near"
 * @param tension - Curve smoothing (for Catmull-Rom)
 * @returns First curve within threshold or null
 */
function getCurveAtPoint(
  curves: Curve[] | null | undefined,
  point: CurvePoint,
  threshold: number,
  tension: number
): Curve | null {
  if (!curves || !Array.isArray(curves)) return null;

  for (const curve of curves) {
    const curveTension = curve.smoothing ?? tension;
    if (isPointNearCurve(curve.points, point, threshold, curveTension)) {
      return curve;
    }
  }

  return null;
}

// ===========================================================================
// Bulk Operations
// ===========================================================================

/**
 * Clear all curves.
 *
 * @returns Empty array
 */
function clearAllCurves(): Curve[] {
  return [];
}

// ===========================================================================
// Exports (Datacore module format)
// ===========================================================================

return {
  generateCurveId,
  addCurve,
  removeCurve,
  updateCurve,
  getCurveById,
  getCurvesInBounds,
  getCurveAtPoint,
  clearAllCurves,
};

```

# useDrawingTools

```ts
/**
 * useDrawingTools.ts
 *
 * Custom hook for managing drawing tools (paint, rectangle, circle, clear area, edge paint).
 * Handles all drawing-related state and operations including:
 * - Paint tool (draw/erase) with cell tracking
 * - Edge paint tool for painting grid edges
 * - Rectangle drawing
 * - Circle drawing
 * - Clear area tool
 * - Batched history management for strokes
 */

// Type-only imports
import type { ToolId } from '#types/tools/tool.types';
import type { Point, IGeometry } from '#types/core/geometry.types';
import type { Cell, SegmentName } from '#types/core/cell.types';
import type { MapData, MapLayer } from '#types/core/map.types';
import type { Edge } from '#types/core/edge.types';
import type { MapObject } from '#types/objects/object.types';
import type { TextLabel } from '#types/core/textLabel.types';
import type { Curve, CurvePoint, CurveTemplate } from '#types/core/curve.types';
import type {
  PreviewSettings,
  RectangleStart,
  CircleStart,
  EdgeLineStart,
  PendingEndPoint,
  ShapeHoverPosition,
  SegmentPickerCell,
  SegmentHoverInfo,
  DragStartContext,
  UseDrawingToolsResult,
} from '#types/hooks/drawingTools.types';
import type { EdgeInfo } from '#types/contexts/context.types';

// Datacore imports
// Context types - inline until contexts are fully typed
interface MapStateValue {
  geometry: (IGeometry & { cellSize: number; screenToEdge?: (worldX: number, worldY: number, threshold: number) => EdgeInfo | null }) | null;
  canvasRef: { current: HTMLCanvasElement | null };
  mapData: MapData | null;
  screenToGrid: (clientX: number, clientY: number) => Point | null;
  screenToWorld: (clientX: number, clientY: number) => { worldX: number; worldY: number } | null;
  getClientCoords: (e: PointerEvent | MouseEvent | TouchEvent) => { clientX: number; clientY: number };
  GridGeometry: GridGeometryConstructor;
}

interface GridGeometryConstructor {
  new (...args: unknown[]): IGeometry & {
    cellSize: number;
    screenToEdge: (worldX: number, worldY: number, threshold: number) => EdgeInfo | null;
    worldToGrid: (worldX: number, worldY: number) => Point;
  };
}

interface MapOperationsValue {
  onCellsChange: (cells: Cell[], skipHistory?: boolean) => void;
  onObjectsChange: (objects: MapObject[]) => void;
  onTextLabelsChange: (labels: TextLabel[]) => void;
  onEdgesChange: (edges: Edge[], skipHistory?: boolean) => void;
  onCurvesChange?: (curves: Curve[], skipHistory?: boolean) => void;
  getTextLabelAtPosition: (labels: TextLabel[], worldX: number, worldY: number, ctx: CanvasRenderingContext2D | null) => TextLabel | null;
  removeTextLabel: (labels: TextLabel[], id: string) => TextLabel[];
  getObjectAtPosition: (objects: MapObject[], x: number, y: number) => MapObject | null;
  removeObjectAtPosition: (objects: MapObject[], x: number, y: number) => MapObject[];
  removeObjectsInRectangle: (objects: MapObject[], x1: number, y1: number, x2: number, y2: number) => MapObject[];
}

const { useMapState, useMapOperations } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext")) as {
  useMapState: () => MapStateValue;
  useMapOperations: () => MapOperationsValue;
};

const { addEdge, removeEdge, getEdgeAt, generateEdgeLine, mergeEdges } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "edgeOperations")) as {
  addEdge: (edges: Edge[], x: number, y: number, side: string, color: string, opacity: number) => Edge[];
  removeEdge: (edges: Edge[], x: number, y: number, side: string) => Edge[];
  getEdgeAt: (edges: Edge[], x: number, y: number, side: string) => Edge | null;
  generateEdgeLine: (x1: number, y1: number, x2: number, y2: number, color: string) => Edge[];
  mergeEdges: (existing: Edge[], newEdges: Edge[]) => Edge[];
};

interface EraseResult {
  success: boolean;
  objects: MapObject[];
}

const { eraseObjectAt } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "objectOperations")) as {
  eraseObjectAt: (objects: MapObject[], x: number, y: number, mapType: string) => EraseResult;
};

const { getActiveLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor")) as {
  getActiveLayer: (mapData: MapData) => MapLayer;
};

const { simplifyPath } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "curveMath")) as {
  simplifyPath: (points: CurvePoint[], epsilon: number) => CurvePoint[];
};

const { addCurve, removeCurve, getCurveAtPoint } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "curveOperations")) as {
  addCurve: (curves: Curve[], template: CurveTemplate) => Curve[];
  removeCurve: (curves: Curve[], curveId: string) => Curve[];
  getCurveAtPoint: (curves: Curve[], point: CurvePoint, threshold: number, tension: number) => Curve | null;
};

interface CellUpdate {
  coords: Point;
  color: string;
  opacity: number;
}

const {
  setCell: accessorSetCell,
  removeCell: accessorRemoveCell,
  setCells,
  removeCellsInBounds,
  getCellIndex,
  setSegments,
  removeSegments,
  getSegmentAtPosition,
  getLocalCellPosition
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "cellAccessor")) as {
  setCell: (cells: Cell[], coords: Point, color: string, opacity: number, geometry: IGeometry) => Cell[];
  removeCell: (cells: Cell[], coords: Point, geometry: IGeometry) => Cell[];
  setCells: (cells: Cell[], updates: CellUpdate[], geometry: IGeometry) => Cell[];
  removeCellsInBounds: (cells: Cell[], x1: number, y1: number, x2: number, y2: number, geometry: IGeometry) => Cell[];
  getCellIndex: (cells: Cell[], coords: Point, geometry: IGeometry) => number;
  setSegments: (cells: Cell[], coords: Point, segments: SegmentName[], color: string, opacity: number, geometry: IGeometry) => Cell[];
  removeSegments: (cells: Cell[], coords: Point, segments: SegmentName[], geometry: IGeometry) => Cell[];
  getSegmentAtPosition: (localX: number, localY: number) => SegmentName;
  getLocalCellPosition: (worldX: number, worldY: number, cellX: number, cellY: number, cellSize: number) => { localX: number; localY: number };
};

/**
 * Hook for managing drawing tools
 */
const useDrawingTools = (
  currentTool: ToolId,
  selectedColor: string,
  selectedOpacity: number = 1,
  previewSettings: PreviewSettings = { kbmEnabled: true, touchEnabled: false }
): UseDrawingToolsResult => {
  const {
    geometry,
    canvasRef,
    mapData,
    screenToGrid,
    screenToWorld,
    getClientCoords,
    GridGeometry
  } = useMapState();

  const {
    onCellsChange,
    onObjectsChange,
    onTextLabelsChange,
    onEdgesChange,
    onCurvesChange,
    getTextLabelAtPosition,
    removeTextLabel,
    getObjectAtPosition,
    removeObjectsInRectangle
  } = useMapOperations();

  const [isDrawing, setIsDrawing] = dc.useState<boolean>(false);
  const [processedCells, setProcessedCells] = dc.useState<Set<string>>(new Set());
  const [processedEdges, setProcessedEdges] = dc.useState<Set<string>>(new Set());
  const [processedSegments, setProcessedSegments] = dc.useState<Set<string>>(new Set());
  const [rectangleStart, setRectangleStart] = dc.useState<RectangleStart | null>(null);
  const [circleStart, setCircleStart] = dc.useState<CircleStart | null>(null);
  const [edgeLineStart, setEdgeLineStart] = dc.useState<EdgeLineStart | null>(null);

  const [shapeHoverPosition, setShapeHoverPosition] = dc.useState<ShapeHoverPosition>(null);
  const [touchConfirmPending, setTouchConfirmPending] = dc.useState<boolean>(false);
  const [pendingEndPoint, setPendingEndPoint] = dc.useState<PendingEndPoint | null>(null);

  const [segmentPickerOpen, setSegmentPickerOpen] = dc.useState<boolean>(false);
  const [segmentPickerCell, setSegmentPickerCell] = dc.useState<SegmentPickerCell | null>(null);
  const [segmentPickerExistingCell, setSegmentPickerExistingCell] = dc.useState<Cell | null>(null);

  const [savedSegments, setSavedSegments] = dc.useState<SegmentName[]>([]);
  const [rememberSegments, setRememberSegments] = dc.useState<boolean>(true);

  const [segmentHoverInfo, setSegmentHoverInfo] = dc.useState<SegmentHoverInfo | null>(null);

  // Freehand drawing state
  const [isFreehandDrawing, setIsFreehandDrawing] = dc.useState<boolean>(false);
  const [freehandPreviewPoints, setFreehandPreviewPoints] = dc.useState<CurvePoint[]>([]);

  // Track initial state for batched history
  const strokeInitialStateRef = dc.useRef<Cell[] | null>(null);
  const strokeInitialEdgesRef = dc.useRef<Edge[] | null>(null);
  const strokeInitialCurvesRef = dc.useRef<Curve[] | null>(null);

  const toggleCell = (coords: Point, shouldFill: boolean, dragStart: DragStartContext | null = null): void => {
    if (!mapData || !geometry) return;

    const activeLayer = getActiveLayer(mapData);

    const q = (coords as { q?: number }).q !== undefined ? (coords as { q: number }).q : coords.x;
    const r = (coords as { r?: number }).r !== undefined ? (coords as { r: number }).r : coords.y;

    if ((geometry as { isWithinBounds?: (q: number, r: number) => boolean }).isWithinBounds &&
        !(geometry as { isWithinBounds: (q: number, r: number) => boolean }).isWithinBounds(q, r)) {
      return;
    }

    const isBatchedStroke = strokeInitialStateRef.current !== null;

    if (shouldFill) {
      const newCells = accessorSetCell(activeLayer.cells, coords, selectedColor, selectedOpacity, geometry);
      onCellsChange(newCells, isBatchedStroke);
    } else {
      const { clientX, clientY } = dragStart || { clientX: 0, clientY: 0 };
      const worldCoords = screenToWorld(clientX, clientY);
      if (worldCoords) {
        const canvas = canvasRef.current;
        const ctx = canvas ? canvas.getContext('2d') : null;
        const textLabel = getTextLabelAtPosition(
          activeLayer.textLabels || [],
          worldCoords.worldX,
          worldCoords.worldY,
          ctx
        );
        if (textLabel) {
          const newLabels = removeTextLabel(activeLayer.textLabels || [], textLabel.id);
          onTextLabelsChange(newLabels);
          return;
        }

        if (geometry instanceof GridGeometry && onEdgesChange) {
          const edgeGeometry = geometry as { screenToEdge: (worldX: number, worldY: number, threshold: number) => EdgeInfo | null };
          const edgeInfo = edgeGeometry.screenToEdge(worldCoords.worldX, worldCoords.worldY, 0.15);
          if (edgeInfo) {
            const edgeKey = `${edgeInfo.x},${edgeInfo.y},${edgeInfo.side}`;

            if (!processedEdges.has(edgeKey)) {
              const existingEdge = getEdgeAt(activeLayer.edges || [], edgeInfo.x, edgeInfo.y, edgeInfo.side);
              if (existingEdge) {
                if (strokeInitialEdgesRef.current === null) {
                  strokeInitialEdgesRef.current = [...(activeLayer.edges || [])];
                }
                setProcessedEdges((prev: Set<string>) => new Set([...prev, edgeKey]));
                const newEdges = removeEdge(activeLayer.edges || [], edgeInfo.x, edgeInfo.y, edgeInfo.side);
                onEdgesChange(newEdges, isBatchedStroke);
                return;
              }
            }
          }
        }

        // Check for curves to erase
        if (onCurvesChange) {
          const curves = activeLayer.curves || [];
          if (curves.length > 0) {
            const point: CurvePoint = [worldCoords.worldX, worldCoords.worldY];
            const curveAtPoint = getCurveAtPoint(curves, point, 10, 0.5);
            if (curveAtPoint) {
              if (strokeInitialCurvesRef.current === null) {
                strokeInitialCurvesRef.current = [...curves];
              }
              const newCurves = removeCurve(curves, curveAtPoint.id);
              onCurvesChange(newCurves, isBatchedStroke);
              return;
            }
          }
        }
      }

      const coordX = coords.x;
      const coordY = coords.y;
      const obj = getObjectAtPosition(activeLayer.objects || [], coordX, coordY);
      if (obj) {
        const mapType = mapData.mapType || 'grid';
        const result = eraseObjectAt(activeLayer.objects || [], coordX, coordY, mapType);
        if (result.success) {
          onObjectsChange(result.objects);
        }
      } else if (getCellIndex(activeLayer.cells, coords, geometry) !== -1) {
        const newCells = accessorRemoveCell(activeLayer.cells, coords, geometry);
        onCellsChange(newCells, isBatchedStroke);
      }
    }
  };

  const toggleEdge = (worldX: number, worldY: number, shouldPaint: boolean): void => {
    if (!mapData || !geometry || !onEdgesChange) return;

    if (!(geometry instanceof GridGeometry)) return;

    const activeLayer = getActiveLayer(mapData);

    const edgeGeometry = geometry as { screenToEdge: (worldX: number, worldY: number, threshold: number) => EdgeInfo | null };
    const edgeInfo = edgeGeometry.screenToEdge(worldX, worldY, 0.15);
    if (!edgeInfo) return;

    const { x, y, side } = edgeInfo;

    const isBatchedStroke = strokeInitialEdgesRef.current !== null;

    if (shouldPaint) {
      const newEdges = addEdge(activeLayer.edges || [], x, y, side, selectedColor, selectedOpacity);
      onEdgesChange(newEdges, isBatchedStroke);
    } else {
      const newEdges = removeEdge(activeLayer.edges || [], x, y, side);
      onEdgesChange(newEdges, isBatchedStroke);
    }
  };

  const processEdgeDuringDrag = (e: PointerEvent | MouseEvent | TouchEvent): void => {
    if (!geometry || !(geometry instanceof GridGeometry)) return;

    const { clientX, clientY } = getClientCoords(e);
    const worldCoords = screenToWorld(clientX, clientY);
    if (!worldCoords) return;

    const edgeGeometry = geometry as { screenToEdge: (worldX: number, worldY: number, threshold: number) => EdgeInfo | null };
    const edgeInfo = edgeGeometry.screenToEdge(worldCoords.worldX, worldCoords.worldY, 0.15);
    if (!edgeInfo) return;

    const edgeKey = `${edgeInfo.x},${edgeInfo.y},${edgeInfo.side}`;

    if (processedEdges.has(edgeKey)) return;

    setProcessedEdges((prev: Set<string>) => new Set([...prev, edgeKey]));

    const shouldPaint = currentTool === 'edgeDraw';
    toggleEdge(worldCoords.worldX, worldCoords.worldY, shouldPaint);
  };

  const startEdgeDrawing = (e: PointerEvent | MouseEvent | TouchEvent): void => {
    if (!mapData) return;

    const activeLayer = getActiveLayer(mapData);

    setIsDrawing(true);
    setProcessedEdges(new Set());
    strokeInitialEdgesRef.current = [...(activeLayer.edges || [])];
    processEdgeDuringDrag(e);
  };

  const stopEdgeDrawing = (): void => {
    if (!isDrawing) return;

    const activeLayer = getActiveLayer(mapData!);

    setIsDrawing(false);
    setProcessedEdges(new Set());

    if (strokeInitialEdgesRef.current !== null && mapData && onEdgesChange) {
      onEdgesChange(activeLayer.edges || [], false);
      strokeInitialEdgesRef.current = null;
    }
  };

  const toggleSegment = (worldX: number, worldY: number): void => {
    if (!mapData || !geometry) return;

    if (!(geometry instanceof GridGeometry)) return;

    const activeLayer = getActiveLayer(mapData);

    const gridGeometry = geometry as { worldToGrid: (worldX: number, worldY: number) => Point; cellSize: number };
    const gridCoords = gridGeometry.worldToGrid(worldX, worldY);
    const cellX = gridCoords.x;
    const cellY = gridCoords.y;

    const cellWorldX = cellX * gridGeometry.cellSize;
    const cellWorldY = cellY * gridGeometry.cellSize;
    const localX = (worldX - cellWorldX) / gridGeometry.cellSize;
    const localY = (worldY - cellWorldY) / gridGeometry.cellSize;

    const segment = getSegmentAtPosition(localX, localY);

    const segmentKey = `${cellX},${cellY},${segment}`;

    if (processedSegments.has(segmentKey)) return;

    setProcessedSegments((prev: Set<string>) => new Set([...prev, segmentKey]));

    const isBatchedStroke = strokeInitialStateRef.current !== null;

    const newCells = setSegments(
      activeLayer.cells,
      { x: cellX, y: cellY },
      [segment],
      selectedColor,
      selectedOpacity,
      geometry
    );
    onCellsChange(newCells, isBatchedStroke);
  };

  const processSegmentDuringDrag = (e: PointerEvent | MouseEvent | TouchEvent): void => {
    if (!geometry || !(geometry instanceof GridGeometry)) return;

    const { clientX, clientY } = getClientCoords(e);
    const worldCoords = screenToWorld(clientX, clientY);
    if (!worldCoords) return;

    toggleSegment(worldCoords.worldX, worldCoords.worldY);
  };

  const startSegmentDrawing = (e: PointerEvent | MouseEvent | TouchEvent): void => {
    if (!mapData) return;

    const activeLayer = getActiveLayer(mapData);

    setIsDrawing(true);
    setProcessedSegments(new Set());
    strokeInitialStateRef.current = [...activeLayer.cells];
    processSegmentDuringDrag(e);
  };

  const stopSegmentDrawing = (): void => {
    if (!isDrawing) return;

    const activeLayer = getActiveLayer(mapData!);

    setIsDrawing(false);
    setProcessedSegments(new Set());

    if (strokeInitialStateRef.current !== null && mapData) {
      onCellsChange(activeLayer.cells, false);
      strokeInitialStateRef.current = null;
    }
  };

  const openSegmentPicker = (cellX: number, cellY: number): void => {
    if (!mapData || !geometry) return;

    const activeLayer = getActiveLayer(mapData);

    const existingCell = activeLayer.cells.find((c: Cell) => {
      const cx = (c as { x?: number }).x;
      const cy = (c as { y?: number }).y;
      return cx === cellX && cy === cellY;
    });

    setSegmentPickerCell({ x: cellX, y: cellY });
    setSegmentPickerExistingCell(existingCell || null);
    setSegmentPickerOpen(true);
  };

  const closeSegmentPicker = (): void => {
    setSegmentPickerOpen(false);
    setSegmentPickerCell(null);
    setSegmentPickerExistingCell(null);
  };

  const applySegmentSelection = (selectedSegments: SegmentName[], shouldRemember: boolean = true): void => {
    if (!mapData || !geometry || !segmentPickerCell) return;

    if (shouldRemember) {
      setSavedSegments(selectedSegments);
      setRememberSegments(true);
    } else {
      setRememberSegments(false);
    }

    const activeLayer = getActiveLayer(mapData);

    let newCells = activeLayer.cells.filter((c: Cell) => {
      const cx = (c as { x?: number }).x;
      const cy = (c as { y?: number }).y;
      return !(cx === segmentPickerCell.x && cy === segmentPickerCell.y);
    });

    if (selectedSegments.length > 0) {
      const coords = { x: segmentPickerCell.x, y: segmentPickerCell.y };

      newCells = setSegments(
        newCells,
        coords,
        selectedSegments,
        selectedColor,
        selectedOpacity,
        geometry
      );
    }

    onCellsChange(newCells);

    closeSegmentPicker();
  };

  // ===========================================
  // Freehand Drawing Operations
  // ===========================================

  /** Minimum distance between captured points (world units) */
  const MIN_POINT_DISTANCE = 3;
  /** RDP simplification epsilon */
  const SIMPLIFY_EPSILON = 2;
  /** Minimum points needed to create a curve */
  const MIN_CURVE_POINTS = 3;
  /** Default stroke width for curves */
  const DEFAULT_STROKE_WIDTH = 2;
  /** Default smoothing factor */
  const DEFAULT_SMOOTHING = 0.5;

  const startFreehandDrawing = (e: PointerEvent | MouseEvent | TouchEvent): void => {
    if (!mapData || !onCurvesChange) return;

    const { clientX, clientY } = getClientCoords(e);
    const world = screenToWorld(clientX, clientY);
    if (!world) return;

    const activeLayer = getActiveLayer(mapData);
    strokeInitialCurvesRef.current = [...(activeLayer.curves || [])];

    const point: CurvePoint = [world.worldX, world.worldY];
    setFreehandPreviewPoints([point]);
    setIsFreehandDrawing(true);
  };

  const continueFreehandDrawing = (e: PointerEvent | MouseEvent | TouchEvent): void => {
    if (!isFreehandDrawing) return;

    const { clientX, clientY } = getClientCoords(e);
    const world = screenToWorld(clientX, clientY);
    if (!world) return;

    const point: CurvePoint = [world.worldX, world.worldY];

    setFreehandPreviewPoints((prev) => {
      if (prev.length === 0) return [point];

      const lastPoint = prev[prev.length - 1];
      const dist = Math.hypot(point[0] - lastPoint[0], point[1] - lastPoint[1]);

      if (dist >= MIN_POINT_DISTANCE) {
        return [...prev, point];
      }
      return prev;
    });
  };

  const finishFreehandDrawing = (): void => {
    if (!isFreehandDrawing || !mapData || !onCurvesChange) {
      cancelFreehandDrawing();
      return;
    }

    // Need enough points to make a curve
    if (freehandPreviewPoints.length < MIN_CURVE_POINTS) {
      cancelFreehandDrawing();
      return;
    }

    // Simplify the path
    const simplifiedPoints = simplifyPath(freehandPreviewPoints, SIMPLIFY_EPSILON);

    // Need at least 2 points after simplification
    if (simplifiedPoints.length < 2) {
      cancelFreehandDrawing();
      return;
    }

    // Check if shape should auto-close (end point near start point)
    const CLOSE_THRESHOLD = 15; // World units
    const startPoint = simplifiedPoints[0];
    const endPoint = simplifiedPoints[simplifiedPoints.length - 1];
    const closingDistance = Math.hypot(
      endPoint[0] - startPoint[0],
      endPoint[1] - startPoint[1]
    );
    const isClosedShape = closingDistance < CLOSE_THRESHOLD && simplifiedPoints.length >= 3;

    // Create curve template
    const template: CurveTemplate = {
      points: simplifiedPoints,
      color: selectedColor,
      opacity: selectedOpacity,
      strokeWidth: DEFAULT_STROKE_WIDTH,
      smoothing: DEFAULT_SMOOTHING,
      closed: isClosedShape,
      filled: isClosedShape,
    };

    // Get current curves from active layer
    const activeLayer = getActiveLayer(mapData);
    const currentCurves = activeLayer.curves || [];

    // Add new curve
    const newCurves = addCurve(currentCurves, template);

    // Update map data (not skipping history since this is the final action)
    onCurvesChange(newCurves, false);

    // Reset state
    setIsFreehandDrawing(false);
    setFreehandPreviewPoints([]);
    strokeInitialCurvesRef.current = null;
  };

  const cancelFreehandDrawing = (): void => {
    setIsFreehandDrawing(false);
    setFreehandPreviewPoints([]);
    strokeInitialCurvesRef.current = null;
  };

  const fillEdgeLine = (x1: number, y1: number, x2: number, y2: number): void => {
    if (!mapData || !onEdgesChange) return;
    if (!(geometry instanceof GridGeometry)) return;

    const activeLayer = getActiveLayer(mapData);

    const dx = Math.abs(x2 - x1);
    const dy = Math.abs(y2 - y1);

    let lineX1: number, lineY1: number, lineX2: number, lineY2: number;

    if (dx >= dy) {
      lineX1 = x1;
      lineY1 = y1;
      lineX2 = x2;
      lineY2 = y1;
    } else {
      lineX1 = x1;
      lineY1 = y1;
      lineX2 = x1;
      lineY2 = y2;
    }

    const newEdgesData = generateEdgeLine(lineX1, lineY1, lineX2, lineY2, selectedColor);

    const newEdges = mergeEdges(activeLayer.edges || [], newEdgesData);
    onEdgesChange(newEdges);
  };

  const fillRectangle = (x1: number, y1: number, x2: number, y2: number): void => {
    if (!mapData) return;
    if (!geometry) return;

    const activeLayer = getActiveLayer(mapData);

    const cellsInRect = geometry.getCellsInRectangle(x1, y1, x2, y2);

    const cellUpdates: CellUpdate[] = cellsInRect.map((cellCoords: Point) => ({
      coords: cellCoords,
      color: selectedColor,
      opacity: selectedOpacity
    }));

    const newCells = setCells(activeLayer.cells, cellUpdates, geometry);
    onCellsChange(newCells);
  };

  const fillCircle = (edgeX: number, edgeY: number, centerX: number, centerY: number): void => {
    if (!mapData) return;

    if (!geometry) return;

    const activeLayer = getActiveLayer(mapData);

    // Use Chebyshev distance (max of |dx|, |dy|) so diagonal drags
    // give the same radius as orthogonal drags of the same cell count
    const radius = Math.max(Math.abs(edgeX - centerX), Math.abs(edgeY - centerY));
    const cellsInCircle = geometry.getCellsInCircle(centerX, centerY, radius);

    const cellUpdates: CellUpdate[] = cellsInCircle.map((cellCoords: Point) => ({
      coords: cellCoords,
      color: selectedColor,
      opacity: selectedOpacity
    }));

    const newCells = setCells(activeLayer.cells, cellUpdates, geometry);
    onCellsChange(newCells);
  };

  const clearRectangle = (x1: number, y1: number, x2: number, y2: number): void => {
    if (!mapData) return;

    if (!geometry) return;

    const activeLayer = getActiveLayer(mapData);

    const newObjects = removeObjectsInRectangle(activeLayer.objects || [], x1, y1, x2, y2);
    onObjectsChange(newObjects);

    const minX = Math.min(x1, x2);
    const maxX = Math.max(x1, x2);
    const minY = Math.min(y1, y2);
    const maxY = Math.max(y1, y2);

    const { worldX: worldMinX, worldY: worldMinY } = geometry.gridToWorld(minX, minY);
    const { worldX: worldMaxX, worldY: worldMaxY } = geometry.gridToWorld(maxX + 1, maxY + 1);

    const newTextLabels = (activeLayer.textLabels || []).filter((label: TextLabel) => {
      return !(label.position.x >= worldMinX && label.position.x <= worldMaxX &&
               label.position.y >= worldMinY && label.position.y <= worldMaxY);
    });
    onTextLabelsChange(newTextLabels);

    const newCells = removeCellsInBounds(activeLayer.cells, x1, y1, x2, y2, geometry);
    onCellsChange(newCells);
  };

  const processCellDuringDrag = (e: PointerEvent | MouseEvent | TouchEvent, dragStart: DragStartContext | null = null): void => {
    const { clientX, clientY } = getClientCoords(e);
    const coords = screenToGrid(clientX, clientY);
    if (!coords) return;

    const cellKey = coords.x !== undefined
      ? `${coords.x},${coords.y}`
      : `${(coords as { q: number }).q},${(coords as { r: number }).r}`;

    if (processedCells.has(cellKey)) return;

    setProcessedCells((prev: Set<string>) => new Set([...prev, cellKey]));

    const shouldFill = currentTool === 'draw';
    toggleCell(coords, shouldFill, { clientX, clientY });
  };

  const startDrawing = (e: PointerEvent | MouseEvent | TouchEvent, dragStart: DragStartContext | null = null): void => {
    if (!mapData) return;

    const activeLayer = getActiveLayer(mapData);

    setIsDrawing(true);
    setProcessedCells(new Set());
    setProcessedEdges(new Set());
    strokeInitialStateRef.current = [...activeLayer.cells];
    strokeInitialEdgesRef.current = null;
    processCellDuringDrag(e, dragStart);
  };

  const stopDrawing = (): void => {
    if (!isDrawing) return;

    const activeLayer = getActiveLayer(mapData!);

    setIsDrawing(false);
    setProcessedCells(new Set());
    setProcessedEdges(new Set());

    if (strokeInitialStateRef.current !== null && mapData) {
      onCellsChange(activeLayer.cells, false);
      strokeInitialStateRef.current = null;
    }
    if (strokeInitialEdgesRef.current !== null && mapData && onEdgesChange) {
      onEdgesChange(activeLayer.edges || [], false);
      strokeInitialEdgesRef.current = null;
    }
  };

  const updateShapeHover = dc.useCallback((gridX: number, gridY: number): void => {
    if (touchConfirmPending) return;

    const hasStart = (currentTool === 'circle' && circleStart) ||
                     ((currentTool === 'rectangle' || currentTool === 'clearArea') && rectangleStart) ||
                     (currentTool === 'edgeLine' && edgeLineStart);

    if (hasStart) {
      setShapeHoverPosition({ x: gridX, y: gridY });
    }
  }, [currentTool, circleStart, rectangleStart, edgeLineStart, touchConfirmPending]);

  const updateEdgeLineHover = dc.useCallback((intX: number, intY: number): void => {
    if (touchConfirmPending) return;
    if (currentTool === 'edgeLine' && edgeLineStart) {
      setShapeHoverPosition({ x: intX, y: intY });
    }
  }, [currentTool, edgeLineStart, touchConfirmPending]);

  const updateSegmentHover = dc.useCallback((cellX: number, cellY: number, localX: number, localY: number): void => {
    if (isDrawing) {
      setSegmentHoverInfo(null);
      return;
    }

    if (currentTool !== 'segmentDraw') {
      setSegmentHoverInfo(null);
      return;
    }

    const segment = getSegmentAtPosition(localX, localY);

    if (segment) {
      setSegmentHoverInfo({ cellX, cellY, segment });
    } else {
      setSegmentHoverInfo(null);
    }
  }, [currentTool, isDrawing]);

  dc.useEffect(() => {
    if (currentTool !== 'segmentDraw') {
      setSegmentHoverInfo(null);
    }
  }, [currentTool]);

  const clearSegmentHover = dc.useCallback((): void => {
    setSegmentHoverInfo(null);
  }, []);

  const isPointInShapeBounds = dc.useCallback((x: number, y: number): boolean => {
    if (!pendingEndPoint) return false;

    if (currentTool === 'circle' && circleStart) {
      const dx = pendingEndPoint.x - circleStart.x;
      const dy = pendingEndPoint.y - circleStart.y;
      const radius = Math.sqrt(dx * dx + dy * dy);

      const distFromCenter = Math.sqrt(
        Math.pow(x - circleStart.x, 2) + Math.pow(y - circleStart.y, 2)
      );
      return distFromCenter <= radius;
    }

    if ((currentTool === 'rectangle' || currentTool === 'clearArea') && rectangleStart) {
      const minX = Math.min(rectangleStart.x, pendingEndPoint.x);
      const maxX = Math.max(rectangleStart.x, pendingEndPoint.x);
      const minY = Math.min(rectangleStart.y, pendingEndPoint.y);
      const maxY = Math.max(rectangleStart.y, pendingEndPoint.y);

      return x >= minX && x <= maxX && y >= minY && y <= maxY;
    }

    if (currentTool === 'edgeLine' && edgeLineStart) {
      const minX = Math.min(edgeLineStart.x, pendingEndPoint.x) - 1;
      const maxX = Math.max(edgeLineStart.x, pendingEndPoint.x) + 1;
      const minY = Math.min(edgeLineStart.y, pendingEndPoint.y) - 1;
      const maxY = Math.max(edgeLineStart.y, pendingEndPoint.y) + 1;

      return x >= minX && x <= maxX && y >= minY && y <= maxY;
    }

    return false;
  }, [currentTool, circleStart, rectangleStart, edgeLineStart, pendingEndPoint]);

  const confirmTouchShape = dc.useCallback((): void => {
    if (!touchConfirmPending || !pendingEndPoint) return;

    if (currentTool === 'circle' && circleStart) {
      fillCircle(pendingEndPoint.x, pendingEndPoint.y, circleStart.x, circleStart.y);
      setCircleStart(null);
    } else if (currentTool === 'rectangle' && rectangleStart) {
      fillRectangle(rectangleStart.x, rectangleStart.y, pendingEndPoint.x, pendingEndPoint.y);
      setRectangleStart(null);
    } else if (currentTool === 'clearArea' && rectangleStart) {
      clearRectangle(rectangleStart.x, rectangleStart.y, pendingEndPoint.x, pendingEndPoint.y);
      setRectangleStart(null);
    } else if (currentTool === 'edgeLine' && edgeLineStart) {
      fillEdgeLine(edgeLineStart.x, edgeLineStart.y, pendingEndPoint.x, pendingEndPoint.y);
      setEdgeLineStart(null);
    }

    setTouchConfirmPending(false);
    setPendingEndPoint(null);
    setShapeHoverPosition(null);
  }, [touchConfirmPending, pendingEndPoint, currentTool, circleStart, rectangleStart, edgeLineStart,
      fillCircle, fillRectangle, clearRectangle, fillEdgeLine]);

  const cancelShapePreview = dc.useCallback((): void => {
    setRectangleStart(null);
    setCircleStart(null);
    setEdgeLineStart(null);
    setShapeHoverPosition(null);
    setTouchConfirmPending(false);
    setPendingEndPoint(null);
  }, []);

  const handleDrawingPointerDown = (
    e: PointerEvent | MouseEvent | TouchEvent,
    gridX: number,
    gridY: number,
    isTouchEvent: boolean = false
  ): boolean => {
    if (!mapData) return false;

    if ((e as MouseEvent).button === 2) return false;

    const isTouch = isTouchEvent || (e as TouchEvent).touches !== undefined || (e as PointerEvent).pointerType === 'touch';
    const touchPreviewEnabled = previewSettings.touchEnabled && isTouch;

    if (currentTool === 'rectangle' || currentTool === 'clearArea' || currentTool === 'circle') {

      if (touchConfirmPending && pendingEndPoint) {
        if (isPointInShapeBounds(gridX, gridY)) {
          confirmTouchShape();
        } else {
          cancelShapePreview();
        }
        return true;
      }

      if (currentTool === 'circle') {
        if (!circleStart) {
          setCircleStart({ x: gridX, y: gridY });
          setShapeHoverPosition(null);
        } else if (touchPreviewEnabled) {
          setPendingEndPoint({ x: gridX, y: gridY });
          setTouchConfirmPending(true);
          setShapeHoverPosition({ x: gridX, y: gridY });
        } else {
          fillCircle(gridX, gridY, circleStart.x, circleStart.y);
          setCircleStart(null);
          setShapeHoverPosition(null);
        }
      } else if (!rectangleStart) {
        setRectangleStart({ x: gridX, y: gridY });
        setShapeHoverPosition(null);
      } else if (touchPreviewEnabled) {
        setPendingEndPoint({ x: gridX, y: gridY });
        setTouchConfirmPending(true);
        setShapeHoverPosition({ x: gridX, y: gridY });
      } else {
        if (currentTool === 'rectangle') {
          fillRectangle(rectangleStart.x, rectangleStart.y, gridX, gridY);
        } else {
          clearRectangle(rectangleStart.x, rectangleStart.y, gridX, gridY);
        }
        setRectangleStart(null);
        setShapeHoverPosition(null);
      }
      return true;
    }

    if (currentTool === 'edgeLine') {
      if (!(geometry instanceof GridGeometry)) return false;

      const { clientX, clientY } = getClientCoords(e);
      const worldCoords = screenToWorld(clientX, clientY);
      if (!worldCoords) return false;

      const gridGeometry = geometry as { cellSize: number };
      const cellSize = gridGeometry.cellSize;
      const nearestX = Math.round(worldCoords.worldX / cellSize);
      const nearestY = Math.round(worldCoords.worldY / cellSize);

      if (touchConfirmPending && pendingEndPoint) {
        if (isPointInShapeBounds(nearestX, nearestY)) {
          confirmTouchShape();
        } else {
          cancelShapePreview();
        }
        return true;
      }

      if (!edgeLineStart) {
        setEdgeLineStart({ x: nearestX, y: nearestY });
        setShapeHoverPosition(null);
      } else if (touchPreviewEnabled) {
        setPendingEndPoint({ x: nearestX, y: nearestY });
        setTouchConfirmPending(true);
        setShapeHoverPosition({ x: nearestX, y: nearestY });
      } else {
        fillEdgeLine(edgeLineStart.x, edgeLineStart.y, nearestX, nearestY);
        setEdgeLineStart(null);
        setShapeHoverPosition(null);
      }
      return true;
    }

    if (currentTool === 'edgeDraw' || currentTool === 'edgeErase') {
      startEdgeDrawing(e);
      return true;
    }

    if (currentTool === 'segmentDraw') {
      if (isTouch) {
        if (geometry instanceof GridGeometry) {
          openSegmentPicker(gridX, gridY);
        }
      } else {
        startSegmentDrawing(e);
      }
      return true;
    }

    if (currentTool === 'freehandDraw') {
      startFreehandDrawing(e);
      return true;
    }

    if (currentTool === 'draw' || currentTool === 'erase') {
      startDrawing(e);
      return true;
    }

    return false;
  };

  const handleDrawingPointerMove = (e: PointerEvent | MouseEvent | TouchEvent, dragStart: DragStartContext | null = null): boolean => {
    if (isDrawing && (currentTool === 'edgeDraw' || currentTool === 'edgeErase')) {
      processEdgeDuringDrag(e);
      return true;
    }

    if (isDrawing && currentTool === 'segmentDraw') {
      processSegmentDuringDrag(e);
      return true;
    }

    if (isFreehandDrawing && currentTool === 'freehandDraw') {
      continueFreehandDrawing(e);
      return true;
    }

    if (isDrawing && (currentTool === 'draw' || currentTool === 'erase')) {
      processCellDuringDrag(e, dragStart);
      return true;
    }
    return false;
  };

  const cancelDrawing = (): void => {
    if (isDrawing) {
      setIsDrawing(false);
      setProcessedCells(new Set());
      setProcessedEdges(new Set());
      setProcessedSegments(new Set());
      strokeInitialStateRef.current = null;
      strokeInitialEdgesRef.current = null;
    }
    if (isFreehandDrawing) {
      cancelFreehandDrawing();
    }
  };

  const resetDrawingState = (): void => {
    setRectangleStart(null);
    setCircleStart(null);
    setEdgeLineStart(null);
    setShapeHoverPosition(null);
    setTouchConfirmPending(false);
    setPendingEndPoint(null);
    cancelDrawing();
  };

  dc.useEffect(() => {
    resetDrawingState();
  }, [currentTool]);

  return {
    isDrawing,
    rectangleStart,
    circleStart,
    edgeLineStart,

    shapeHoverPosition,
    touchConfirmPending,
    pendingEndPoint,

    toggleCell,
    fillRectangle,
    fillCircle,
    clearRectangle,
    processCellDuringDrag,
    startDrawing,
    stopDrawing,

    toggleEdge,
    processEdgeDuringDrag,
    startEdgeDrawing,
    stopEdgeDrawing,
    fillEdgeLine,

    toggleSegment,
    processSegmentDuringDrag,
    startSegmentDrawing,
    stopSegmentDrawing,

    segmentPickerOpen,
    segmentPickerCell,
    segmentPickerExistingCell,
    openSegmentPicker,
    closeSegmentPicker,
    applySegmentSelection,
    savedSegments,
    rememberSegments,

    handleDrawingPointerDown,
    handleDrawingPointerMove,
    cancelDrawing,
    resetDrawingState,

    updateShapeHover,
    updateEdgeLineHover,
    isPointInShapeBounds,
    confirmTouchShape,
    cancelShapePreview,

    segmentHoverInfo,
    updateSegmentHover,
    clearSegmentHover,

    // Freehand drawing
    isFreehandDrawing,
    freehandPreviewPoints,
    startFreehandDrawing,
    continueFreehandDrawing,
    finishFreehandDrawing,
    cancelFreehandDrawing,

    setIsDrawing,
    setProcessedCells,
    setProcessedEdges,
    setProcessedSegments,
    setRectangleStart,
    setCircleStart,
    setEdgeLineStart,
    setShapeHoverPosition,
    setTouchConfirmPending,
    setPendingEndPoint
  };
};

return { useDrawingTools };

```

# ShapePreviewOverlay

```tsx
/**
 * ShapePreviewOverlay.tsx
 *
 * Visual overlay for shape drawing tool previews.
 * Shows the outline of rectangle, circle, or edge line shapes
 * with dimensions displayed in the user's selected units.
 *
 * Used by DrawingLayer to show live preview while hovering (KBM)
 * or static preview for touch confirmation flow.
 */

import type { Point } from '#types/core/geometry.types';
import type { IGeometry } from '#types/core/geometry.types';
import type { EffectiveDistanceSettings } from '#types/hooks/distanceMeasurement.types';

const { GridGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "GridGeometry"));

/** Shape type for preview */
type ShapeType = 'rectangle' | 'circle' | 'clearArea' | 'edgeLine';

/** Map data structure */
interface MapData {
  viewState: {
    zoom: number;
    center: Point;
  };
  northDirection?: number;
}

/** Geometry with optional methods */
interface GeometryWithMethods extends IGeometry {
  cellSize: number;
  getCellCenter?: (x: number, y: number) => { worldX: number; worldY: number };
}

/** Props for ShapePreviewOverlay component */
export interface ShapePreviewOverlayProps {
  /** Shape type to preview */
  shapeType: ShapeType | string | null;
  /** Starting point */
  startPoint: Point | null;
  /** End/hover point */
  endPoint: Point | null;
  /** Geometry instance */
  geometry: IGeometry | null;
  /** Map data */
  mapData: MapData | null;
  /** Reference to canvas element */
  canvasRef: { current: HTMLCanvasElement | null } | null;
  /** Reference to container element */
  containerRef: { current: HTMLElement | null } | null;
  /** Distance settings for formatting */
  distanceSettings?: EffectiveDistanceSettings | null;
  /** If true (touch mode), show as confirmable preview */
  isConfirmable?: boolean;
}

/**
 * Convert cell coordinates to screen coordinates
 */
function cellToScreen(
  cellX: number,
  cellY: number,
  geometry: GeometryWithMethods,
  mapData: MapData,
  canvasWidth: number,
  canvasHeight: number,
  useCenter = true
): Point {
  const { zoom, center } = mapData.viewState;
  const northDirection = mapData.northDirection || 0;

  let worldX: number, worldY: number;
  if (useCenter) {
    if (geometry.getCellCenter) {
      const cellCenter = geometry.getCellCenter(cellX, cellY);
      worldX = cellCenter.worldX;
      worldY = cellCenter.worldY;
    } else {
      worldX = (cellX + 0.5) * geometry.cellSize;
      worldY = (cellY + 0.5) * geometry.cellSize;
    }
  } else {
    worldX = cellX * geometry.cellSize;
    worldY = cellY * geometry.cellSize;
  }

  let offsetX: number, offsetY: number;
  if (geometry instanceof GridGeometry) {
    const scaledCellSize = geometry.getScaledCellSize(zoom);
    offsetX = canvasWidth / 2 - center.x * scaledCellSize;
    offsetY = canvasHeight / 2 - center.y * scaledCellSize;
  } else {
    offsetX = canvasWidth / 2 - center.x * zoom;
    offsetY = canvasHeight / 2 - center.y * zoom;
  }

  let screenX = offsetX + worldX * zoom;
  let screenY = offsetY + worldY * zoom;

  if (northDirection !== 0) {
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;

    screenX -= centerX;
    screenY -= centerY;

    const angleRad = (northDirection * Math.PI) / 180;
    const rotatedX = screenX * Math.cos(angleRad) - screenY * Math.sin(angleRad);
    const rotatedY = screenX * Math.sin(angleRad) + screenY * Math.cos(angleRad);

    screenX = rotatedX + centerX;
    screenY = rotatedY + centerY;
  }

  return { x: screenX, y: screenY };
}

/**
 * Format dimension text for display
 */
function formatRectDimensions(
  widthCells: number,
  heightCells: number,
  distanceSettings: EffectiveDistanceSettings
): string {
  const { distancePerCell, distanceUnit } = distanceSettings;
  const widthUnits = widthCells * distancePerCell;
  const heightUnits = heightCells * distancePerCell;

  const roundedWidth = Number.isInteger(widthUnits) ? widthUnits : Math.round(widthUnits * 10) / 10;
  const roundedHeight = Number.isInteger(heightUnits) ? heightUnits : Math.round(heightUnits * 10) / 10;

  return `${roundedWidth}${roundedHeight} ${distanceUnit}`;
}

/**
 * Format radius for circle display
 */
function formatCircleRadius(radiusCells: number, distanceSettings: EffectiveDistanceSettings): string {
  const { distancePerCell, distanceUnit } = distanceSettings;
  const radiusUnits = radiusCells * distancePerCell;
  const rounded = Number.isInteger(radiusUnits) ? radiusUnits : Math.round(radiusUnits * 10) / 10;
  return `r: ${rounded} ${distanceUnit}`;
}

/**
 * Format edge line length
 */
function formatEdgeLength(lengthCells: number, distanceSettings: EffectiveDistanceSettings): string {
  const { distancePerCell, distanceUnit } = distanceSettings;
  const lengthUnits = lengthCells * distancePerCell;
  const rounded = Number.isInteger(lengthUnits) ? lengthUnits : Math.round(lengthUnits * 10) / 10;
  return `${rounded} ${distanceUnit}`;
}

const ShapePreviewOverlay = ({
  shapeType,
  startPoint,
  endPoint,
  geometry,
  mapData,
  canvasRef,
  containerRef,
  distanceSettings,
  isConfirmable = false
}: ShapePreviewOverlayProps): React.ReactElement | null => {
  const textRef = dc.useRef<SVGTextElement | null>(null);
  const [textWidth, setTextWidth] = dc.useState(80);

  dc.useEffect(() => {
    if (textRef.current) {
      try {
        const bbox = textRef.current.getBBox();
        setTextWidth(Math.max(bbox.width + 20, 60));
      } catch {
        // getBBox can fail if element not rendered yet
      }
    }
  }, [startPoint, endPoint, shapeType]);

  if (!startPoint || !endPoint || !geometry || !mapData || !canvasRef?.current || !containerRef?.current) {
    return null;
  }

  const canvas = canvasRef.current;
  const { width: canvasWidth, height: canvasHeight } = canvas;
  const canvasRect = canvas.getBoundingClientRect();
  const containerRect = containerRef.current.getBoundingClientRect();
  const displayScale = canvasRect.width / canvasWidth;

  const canvasOffsetX = canvasRect.left - containerRect.left;
  const canvasOffsetY = canvasRect.top - containerRect.top;

  const { zoom } = mapData.viewState;
  const scaledCellSize = geometry.getScaledCellSize(zoom) * displayScale;

  const colors: Record<string, string> = {
    rectangle: '#00ff00',
    clearArea: '#ff0000',
    circle: '#00aaff',
    edgeLine: '#ff9500'
  };
  const strokeColor = colors[shapeType || ''] || '#00ff00';

  let overlayContent: React.ReactElement | null = null;
  let dimensionText = '';
  let tooltipPosition = { x: 0, y: 0 };

  const geo = geometry as GeometryWithMethods;

  if (shapeType === 'rectangle' || shapeType === 'clearArea') {
    const startScreen = cellToScreen(startPoint.x, startPoint.y, geo, mapData, canvasWidth, canvasHeight, true);
    const endScreen = cellToScreen(endPoint.x, endPoint.y, geo, mapData, canvasWidth, canvasHeight, true);

    const scaledStart = {
      x: startScreen.x * displayScale + canvasOffsetX,
      y: startScreen.y * displayScale + canvasOffsetY
    };
    const scaledEnd = {
      x: endScreen.x * displayScale + canvasOffsetX,
      y: endScreen.y * displayScale + canvasOffsetY
    };

    const minX = Math.min(startPoint.x, endPoint.x);
    const maxX = Math.max(startPoint.x, endPoint.x);
    const minY = Math.min(startPoint.y, endPoint.y);
    const maxY = Math.max(startPoint.y, endPoint.y);

    const widthCells = maxX - minX + 1;
    const heightCells = maxY - minY + 1;

    const topLeftScreen = cellToScreen(minX, minY, geo, mapData, canvasWidth, canvasHeight, true);
    const rectX = topLeftScreen.x * displayScale + canvasOffsetX - scaledCellSize / 2;
    const rectY = topLeftScreen.y * displayScale + canvasOffsetY - scaledCellSize / 2;
    const rectWidth = widthCells * scaledCellSize;
    const rectHeight = heightCells * scaledCellSize;

    dimensionText = distanceSettings
      ? formatRectDimensions(widthCells, heightCells, distanceSettings)
      : `${widthCells}${heightCells}`;
    tooltipPosition = { x: rectX + rectWidth / 2, y: rectY - 10 };

    overlayContent = (
      <rect
        x={rectX}
        y={rectY}
        width={rectWidth}
        height={rectHeight}
        fill={isConfirmable ? `${strokeColor}22` : 'none'}
        stroke={strokeColor}
        strokeWidth={2}
        strokeDasharray={isConfirmable ? "none" : "8,4"}
        rx={2}
      />
    );

  } else if (shapeType === 'circle') {
    const centerScreen = cellToScreen(startPoint.x, startPoint.y, geo, mapData, canvasWidth, canvasHeight, true);

    const scaledCenter = {
      x: centerScreen.x * displayScale + canvasOffsetX,
      y: centerScreen.y * displayScale + canvasOffsetY
    };

    const dx = endPoint.x - startPoint.x;
    const dy = endPoint.y - startPoint.y;
    const radiusCells = Math.max(Math.abs(dx), Math.abs(dy));
    const radiusScreen = radiusCells * scaledCellSize;

    dimensionText = distanceSettings
      ? formatCircleRadius(radiusCells, distanceSettings)
      : `r: ${Math.round(radiusCells * 10) / 10}`;
    tooltipPosition = { x: scaledCenter.x, y: scaledCenter.y - radiusScreen - 15 };

    overlayContent = (
      <circle
        cx={scaledCenter.x}
        cy={scaledCenter.y}
        r={radiusScreen}
        fill={isConfirmable ? `${strokeColor}22` : 'none'}
        stroke={strokeColor}
        strokeWidth={2}
        strokeDasharray={isConfirmable ? "none" : "8,4"}
      />
    );

  } else if (shapeType === 'edgeLine') {
    const startScreen = cellToScreen(startPoint.x, startPoint.y, geo, mapData, canvasWidth, canvasHeight, false);
    const endScreen = cellToScreen(endPoint.x, endPoint.y, geo, mapData, canvasWidth, canvasHeight, false);

    const scaledStart = {
      x: startScreen.x * displayScale + canvasOffsetX,
      y: startScreen.y * displayScale + canvasOffsetY
    };
    const scaledEnd = {
      x: endScreen.x * displayScale + canvasOffsetX,
      y: endScreen.y * displayScale + canvasOffsetY
    };

    const dx = Math.abs(endPoint.x - startPoint.x);
    const dy = Math.abs(endPoint.y - startPoint.y);
    const lengthCells = dx + dy;

    dimensionText = distanceSettings ? formatEdgeLength(lengthCells, distanceSettings) : `${lengthCells}`;

    tooltipPosition = {
      x: (scaledStart.x + scaledEnd.x) / 2,
      y: (scaledStart.y + scaledEnd.y) / 2 - 25
    };

    overlayContent = (
      <>
        <line
          x1={scaledStart.x}
          y1={scaledStart.y}
          x2={scaledEnd.x}
          y2={scaledEnd.y}
          stroke={strokeColor}
          strokeWidth={3}
          strokeDasharray={isConfirmable ? "none" : "8,4"}
          strokeLinecap="round"
        />
        <circle cx={scaledStart.x} cy={scaledStart.y} r={6} fill={strokeColor} />
        <circle cx={scaledEnd.x} cy={scaledEnd.y} r={5} fill={`${strokeColor}aa`} stroke={strokeColor} strokeWidth={1.5} />
      </>
    );
  }

  if (!overlayContent) return null;

  return (
    <svg
      className="dmt-shape-preview-overlay"
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
        zIndex: 100,
        overflow: 'visible'
      }}
    >
      {overlayContent}

      {dimensionText && (
        <g transform={`translate(${tooltipPosition.x}, ${tooltipPosition.y})`}>
          <rect
            x={-textWidth / 2}
            y={-14}
            width={textWidth}
            height={28}
            rx={4}
            fill="rgba(26, 26, 26, 0.95)"
            stroke={strokeColor}
            strokeWidth={1}
          />
          <text
            ref={textRef}
            x={0}
            y={5}
            textAnchor="middle"
            fill="#ffffff"
            fontSize={13}
            fontFamily="var(--font-interface, -apple-system, BlinkMacSystemFont, sans-serif)"
            fontWeight="500"
          >
            {dimensionText}
          </text>
        </g>
      )}

      {isConfirmable && (
        <g transform={`translate(${tooltipPosition.x}, ${tooltipPosition.y + 40})`}>
          <text
            x={0}
            y={0}
            textAnchor="middle"
            fill="#888888"
            fontSize={11}
            fontFamily="var(--font-interface, -apple-system, BlinkMacSystemFont, sans-serif)"
          >
            Tap inside to confirm
          </text>
        </g>
      )}
    </svg>
  );
};

return { ShapePreviewOverlay };

```

# ModalPortal

```tsx
/**
 * ModalPortal.tsx
 *
 * Reusable portal component for rendering modals to document.body.
 * This renders children normally, then uses DOM manipulation to move the rendered
 * content to a portal container in document.body, fixing mobile viewport issues.
 */

/** Props for ModalPortal component */
export interface ModalPortalProps {
  /** Content to render in the portal */
  children: React.ReactNode;
}

const ModalPortal = ({ children }: ModalPortalProps): React.ReactElement => {
  const wrapperRef = dc.useRef<HTMLDivElement>(null);
  const portalContainerRef = dc.useRef<HTMLDivElement | null>(null);
  const [isInPortal, setIsInPortal] = dc.useState(false);

  dc.useEffect(() => {
    let portal = document.getElementById('dmt-modal-portal') as HTMLDivElement | null;
    if (!portal) {
      portal = document.createElement('div');
      portal.id = 'dmt-modal-portal';
      portal.className = 'dmt-modal-portal';
      document.body.appendChild(portal);
    }
    portalContainerRef.current = portal;

    return () => {
      if (portal && portal.childNodes.length === 0 && portal.parentNode) {
        portal.parentNode.removeChild(portal);
      }
    };
  }, []);

  dc.useEffect(() => {
    if (wrapperRef.current && portalContainerRef.current) {
      portalContainerRef.current.appendChild(wrapperRef.current);
      setIsInPortal(true);
    }

    return () => {
      if (wrapperRef.current && wrapperRef.current.parentNode) {
        wrapperRef.current.parentNode.removeChild(wrapperRef.current);
      }
    };
  }, []);

  // Hidden until moved to prevent visual jump
  return (
    <div
      ref={wrapperRef}
      className="dmt-modal-portal-content"
      style={{ visibility: isInPortal ? 'visible' : 'hidden' }}
    >
      {children}
    </div>
  );
};

return { ModalPortal };

```

# SegmentPickerOverlay

```tsx
/**
 * SegmentPickerOverlay.tsx
 *
 * Mobile-friendly picker for segment painting (partial cell painting).
 * Shows an enlarged view of the 8 triangular segments within a cell,
 * allowing users to tap or drag to toggle individual segments.
 *
 * Used when the segmentDraw tool is active and user taps on a cell
 * on a touch device.
 */

import type { HexColor } from '#types/core/common.types';
import type { Point } from '#types/core/geometry.types';

const { ModalPortal } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ModalPortal"));
const { SEGMENT_NAMES, SEGMENT_VERTICES, SEGMENT_TRIANGLES } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants"));

/** Segment name type (8 triangular sections) */
type SegmentName = 'nw' | 'n' | 'ne' | 'e' | 'se' | 's' | 'sw' | 'w';

/** Existing cell data structure */
interface ExistingCellData {
  segments?: Record<SegmentName, boolean>;
  color?: HexColor;
}

/** Props for SegmentPickerOverlay component */
export interface SegmentPickerOverlayProps {
  /** Whether the picker is visible */
  isOpen: boolean;
  /** Coordinates of the cell being edited */
  cellCoords: Point | null;
  /** Existing cell data (if editing), or null for new cell */
  existingCell: ExistingCellData | null;
  /** Currently selected paint color */
  selectedColor: HexColor;
  /** Currently selected paint opacity (0-1) */
  selectedOpacity?: number;
  /** Called with array of selected segment names and remember state */
  onConfirm: (segments: SegmentName[], remember: boolean) => void;
  /** Called when picker is dismissed */
  onCancel: () => void;
  /** Screen position to anchor the picker near */
  screenPosition?: Point;
  /** Previously saved segment selection */
  savedSegments?: SegmentName[];
  /** Initial state of "remember selection" checkbox */
  initialRememberState?: boolean;
}

/**
 * Calculate triangle path for SVG rendering
 */
function getSegmentPath(segmentName: SegmentName, size: number): string {
  const [v1Name, v2Name, v3Name] = SEGMENT_TRIANGLES[segmentName];

  const getPoint = (vertexName: string): Point => {
    const vertex = SEGMENT_VERTICES[vertexName];
    return {
      x: vertex.xRatio * size,
      y: vertex.yRatio * size
    };
  };

  const v1 = getPoint(v1Name);
  const v2 = getPoint(v2Name);
  const v3 = getPoint(v3Name);

  return `M ${v1.x} ${v1.y} L ${v2.x} ${v2.y} L ${v3.x} ${v3.y} Z`;
}

const SegmentPickerOverlay = ({
  isOpen,
  cellCoords,
  existingCell,
  selectedColor,
  selectedOpacity = 1,
  onConfirm,
  onCancel,
  savedSegments = [],
  initialRememberState = true
}: SegmentPickerOverlayProps): React.ReactElement | null => {
  const [selectedSegments, setSelectedSegments] = dc.useState<Set<SegmentName>>(new Set());
  const [rememberSelection, setRememberSelection] = dc.useState(initialRememberState);
  const selectedSegmentsRef = dc.useRef<Set<SegmentName>>(selectedSegments);
  selectedSegmentsRef.current = selectedSegments;

  const [isDragging, setIsDragging] = dc.useState(false);
  const dragModeRef = dc.useRef<'add' | 'remove' | null>(null);
  const svgRef = dc.useRef<SVGSVGElement | null>(null);

  const PICKER_SIZE = 200;

  dc.useEffect(() => {
    if (isOpen && existingCell) {
      if (existingCell.segments) {
        const filled = (Object.keys(existingCell.segments) as SegmentName[]).filter(
          seg => existingCell.segments![seg]
        );
        setSelectedSegments(new Set(filled));
      } else if (existingCell.color) {
        setSelectedSegments(new Set(SEGMENT_NAMES as SegmentName[]));
      } else {
        setSelectedSegments(new Set());
      }
    } else if (isOpen) {
      if (savedSegments && savedSegments.length > 0) {
        setSelectedSegments(new Set(savedSegments));
      } else {
        setSelectedSegments(new Set());
      }
    }

    if (isOpen) {
      setRememberSelection(initialRememberState);
    }
  }, [isOpen, existingCell, savedSegments, initialRememberState]);

  dc.useEffect(() => {
    if (!isOpen) {
      setIsDragging(false);
      dragModeRef.current = null;
    }
  }, [isOpen]);

  /**
   * Determine which segment a point is in based on angle from center
   */
  const getSegmentAtPoint = (x: number, y: number): SegmentName => {
    const centerX = PICKER_SIZE / 2;
    const centerY = PICKER_SIZE / 2;

    const dx = x - centerX;
    const dy = y - centerY;

    let angle = Math.atan2(-dy, dx) * (180 / Math.PI);
    if (angle < 0) angle += 360;

    if (angle >= 315) return 'e';
    if (angle >= 270) return 'se';
    if (angle >= 225) return 's';
    if (angle >= 180) return 'sw';
    if (angle >= 135) return 'w';
    if (angle >= 90) return 'nw';
    if (angle >= 45) return 'n';
    return 'ne';
  };

  /**
   * Get touch/mouse position relative to the SVG element
   */
  const getRelativePosition = (e: TouchEvent | MouseEvent): Point | null => {
    if (!svgRef.current) return null;

    const rect = svgRef.current.getBoundingClientRect();
    let clientX: number, clientY: number;

    if ('touches' in e && e.touches.length > 0) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else if ('changedTouches' in e && e.changedTouches.length > 0) {
      clientX = e.changedTouches[0].clientX;
      clientY = e.changedTouches[0].clientY;
    } else if ('clientX' in e) {
      clientX = e.clientX;
      clientY = e.clientY;
    } else {
      return null;
    }

    const scaleX = PICKER_SIZE / rect.width;
    const scaleY = PICKER_SIZE / rect.height;

    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY
    };
  };

  /**
   * Handle segment toggle (tap or drag start)
   */
  const handleSegmentInteraction = dc.useCallback((segment: SegmentName | null, isStart = false): void => {
    if (!segment) return;

    if (isStart) {
      const isCurrentlySelected = selectedSegmentsRef.current.has(segment);
      dragModeRef.current = isCurrentlySelected ? 'remove' : 'add';
    }

    setSelectedSegments(prev => {
      const newSet = new Set(prev);
      if (dragModeRef.current === 'add') {
        newSet.add(segment);
      } else {
        newSet.delete(segment);
      }
      return newSet;
    });
  }, []);

  dc.useEffect(() => {
    const svg = svgRef.current;
    if (!svg || !isOpen) return;

    let dragging = false;

    const handleStart = (e: TouchEvent | MouseEvent): void => {
      e.preventDefault();
      e.stopPropagation();

      const pos = getRelativePosition(e);
      if (!pos) return;

      const segment = getSegmentAtPoint(pos.x, pos.y);
      if (segment) {
        dragging = true;
        setIsDragging(true);
        handleSegmentInteraction(segment, true);
      }
    };

    const handleMove = (e: TouchEvent | MouseEvent): void => {
      if (!dragging) return;

      e.preventDefault();
      e.stopPropagation();

      const pos = getRelativePosition(e);
      if (!pos) return;

      const segment = getSegmentAtPoint(pos.x, pos.y);
      if (segment) {
        handleSegmentInteraction(segment, false);
      }
    };

    const handleEnd = (e: TouchEvent | MouseEvent): void => {
      if (dragging) {
        e.preventDefault();
        e.stopPropagation();
      }
      dragging = false;
      setIsDragging(false);
      dragModeRef.current = null;
    };

    svg.addEventListener('touchstart', handleStart as EventListener, { passive: false });
    svg.addEventListener('touchmove', handleMove as EventListener, { passive: false });
    svg.addEventListener('touchend', handleEnd as EventListener, { passive: false });
    svg.addEventListener('touchcancel', handleEnd as EventListener, { passive: false });
    svg.addEventListener('mousedown', handleStart as EventListener);
    svg.addEventListener('mousemove', handleMove as EventListener);
    svg.addEventListener('mouseup', handleEnd as EventListener);
    svg.addEventListener('mouseleave', handleEnd as EventListener);

    return () => {
      svg.removeEventListener('touchstart', handleStart as EventListener);
      svg.removeEventListener('touchmove', handleMove as EventListener);
      svg.removeEventListener('touchend', handleEnd as EventListener);
      svg.removeEventListener('touchcancel', handleEnd as EventListener);
      svg.removeEventListener('mousedown', handleStart as EventListener);
      svg.removeEventListener('mousemove', handleMove as EventListener);
      svg.removeEventListener('mouseup', handleEnd as EventListener);
      svg.removeEventListener('mouseleave', handleEnd as EventListener);
    };
  }, [isOpen, handleSegmentInteraction]);

  if (!isOpen) return null;

  const handleConfirm = (e: Event): void => {
    e.preventDefault();
    e.stopPropagation();
    onConfirm(Array.from(selectedSegments), rememberSelection);
  };

  const handleCancel = (e: Event): void => {
    e.preventDefault();
    e.stopPropagation();
    onCancel();
  };

  const handleOverlayClick = (e: Event): void => {
    if (e.target === e.currentTarget) {
      onCancel();
    }
  };

  const handleSelectAll = (e: Event): void => {
    e.preventDefault();
    e.stopPropagation();
    setSelectedSegments(new Set(SEGMENT_NAMES as SegmentName[]));
  };

  const handleClearAll = (e: Event): void => {
    e.preventDefault();
    e.stopPropagation();
    setSelectedSegments(new Set());
  };

  const segmentAngles: Record<SegmentName, number> = {
    ne: 22.5, n: 67.5, nw: 112.5, w: 157.5, sw: 202.5, s: 247.5, se: 292.5, e: 337.5
  };

  return (
    <ModalPortal>
      <div
        className="dmt-segment-picker-overlay"
        onClick={handleOverlayClick}
        onTouchEnd={handleOverlayClick}
        style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundColor: 'rgba(0, 0, 0, 0.6)',
          zIndex: 1999,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}
      >
        <div
          className="dmt-segment-picker"
          onClick={(e: Event) => e.stopPropagation()}
          onTouchEnd={(e: Event) => e.stopPropagation()}
          style={{
            backgroundColor: '#1a1a1a',
            borderRadius: '12px',
            padding: '16px',
            border: '2px solid #c4a57b',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.5)',
            minWidth: '260px'
          }}
        >
          <div style={{
            color: '#c4a57b',
            fontSize: '14px',
            fontWeight: '600',
            marginBottom: '12px',
            textAlign: 'center',
            textTransform: 'uppercase',
            letterSpacing: '1px'
          }}>
            Select Segments
          </div>

          <div style={{
            color: '#888',
            fontSize: '11px',
            textAlign: 'center',
            marginBottom: '12px'
          }}>
            Cell ({cellCoords?.x}, {cellCoords?.y})
          </div>

          <div style={{
            display: 'flex',
            justifyContent: 'center',
            marginBottom: '16px'
          }}>
            <svg
              ref={svgRef}
              width={PICKER_SIZE}
              height={PICKER_SIZE}
              viewBox={`0 0 ${PICKER_SIZE} ${PICKER_SIZE}`}
              style={{
                backgroundColor: '#2a2a2a',
                borderRadius: '8px',
                cursor: 'pointer',
                touchAction: 'none',
                userSelect: 'none',
                WebkitUserSelect: 'none',
                WebkitTouchCallout: 'none'
              }}
            >
              <line x1={PICKER_SIZE/2} y1="0" x2={PICKER_SIZE/2} y2={PICKER_SIZE} stroke="#444" strokeWidth="1" />
              <line x1="0" y1={PICKER_SIZE/2} x2={PICKER_SIZE} y2={PICKER_SIZE/2} stroke="#444" strokeWidth="1" />
              <line x1="0" y1="0" x2={PICKER_SIZE} y2={PICKER_SIZE} stroke="#444" strokeWidth="1" />
              <line x1={PICKER_SIZE} y1="0" x2="0" y2={PICKER_SIZE} stroke="#444" strokeWidth="1" />

              {(SEGMENT_NAMES as SegmentName[]).map(segmentName => {
                const isSelected = selectedSegments.has(segmentName);
                const path = getSegmentPath(segmentName, PICKER_SIZE);

                return (
                  <path
                    key={segmentName}
                    d={path}
                    fill={isSelected ? selectedColor : 'transparent'}
                    fillOpacity={isSelected ? selectedOpacity : 0}
                    stroke={isSelected ? '#c4a57b' : '#666'}
                    strokeWidth={isSelected ? 2 : 1}
                    style={{ pointerEvents: 'none' }}
                  />
                );
              })}

              {(SEGMENT_NAMES as SegmentName[]).map(segmentName => {
                const angle = segmentAngles[segmentName] * (Math.PI / 180);
                const labelRadius = PICKER_SIZE * 0.35;
                const labelX = PICKER_SIZE/2 + Math.cos(angle) * labelRadius;
                const labelY = PICKER_SIZE/2 - Math.sin(angle) * labelRadius;
                const isSelected = selectedSegments.has(segmentName);

                return (
                  <text
                    key={`label-${segmentName}`}
                    x={labelX}
                    y={labelY}
                    textAnchor="middle"
                    dominantBaseline="middle"
                    fill={isSelected ? '#fff' : '#888'}
                    fontSize="12"
                    fontWeight={isSelected ? '600' : '400'}
                    style={{ pointerEvents: 'none', userSelect: 'none' }}
                  >
                    {segmentName.toUpperCase()}
                  </text>
                );
              })}

              <circle
                cx={PICKER_SIZE/2}
                cy={PICKER_SIZE/2}
                r="4"
                fill="#c4a57b"
                style={{ pointerEvents: 'none' }}
              />
            </svg>
          </div>

          <div style={{
            display: 'flex',
            gap: '8px',
            marginBottom: '16px',
            justifyContent: 'center'
          }}>
            <button
              onClick={handleSelectAll}
              style={{
                padding: '6px 12px',
                backgroundColor: '#333',
                border: '1px solid #555',
                borderRadius: '4px',
                color: '#ccc',
                fontSize: '12px',
                cursor: 'pointer'
              }}
            >
              Select All
            </button>
            <button
              onClick={handleClearAll}
              style={{
                padding: '6px 12px',
                backgroundColor: '#333',
                border: '1px solid #555',
                borderRadius: '4px',
                color: '#ccc',
                fontSize: '12px',
                cursor: 'pointer'
              }}
            >
              Clear All
            </button>
          </div>

          <div style={{
            color: '#888',
            fontSize: '12px',
            textAlign: 'center',
            marginBottom: '12px'
          }}>
            {selectedSegments.size} of 8 segments selected
          </div>

          <label style={{
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            gap: '8px',
            color: '#aaa',
            fontSize: '12px',
            cursor: 'pointer',
            marginBottom: '16px',
            userSelect: 'none',
            WebkitUserSelect: 'none'
          }}>
            <input
              type="checkbox"
              checked={rememberSelection}
              onChange={(e: Event) => setRememberSelection((e.target as HTMLInputElement).checked)}
              style={{
                width: '16px',
                height: '16px',
                cursor: 'pointer',
                accentColor: '#c4a57b'
              }}
            />
            Remember selection for next cell
          </label>

          <div style={{
            display: 'flex',
            gap: '12px',
            justifyContent: 'center'
          }}>
            <button
              onClick={handleCancel}
              style={{
                padding: '10px 24px',
                backgroundColor: '#333',
                border: '1px solid #555',
                borderRadius: '6px',
                color: '#ccc',
                fontSize: '14px',
                cursor: 'pointer',
                minWidth: '80px'
              }}
            >
              Cancel
            </button>
            <button
              onClick={handleConfirm}
              style={{
                padding: '10px 24px',
                backgroundColor: '#c4a57b',
                border: 'none',
                borderRadius: '6px',
                color: '#1a1a1a',
                fontSize: '14px',
                fontWeight: '600',
                cursor: 'pointer',
                minWidth: '80px'
              }}
            >
              Apply
            </button>
          </div>

          <div style={{
            color: '#666',
            fontSize: '11px',
            textAlign: 'center',
            marginTop: '12px'
          }}>
            Tap or drag to toggle segments
          </div>
        </div>
      </div>
    </ModalPortal>
  );
};

return { SegmentPickerOverlay };

```

# SegmentHoverOverlay

```tsx
/**
 * SegmentHoverOverlay.tsx
 *
 * Visual overlay showing which segment will be painted on click.
 * Only shown on desktop (mouse/pointer) when segment paint tool is active.
 */

import type { HexColor } from '#types/core/common.types';
import type { Point } from '#types/core/geometry.types';
import type { IGeometry } from '#types/core/geometry.types';

const { GridGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "GridGeometry"));
const { SEGMENT_VERTICES, SEGMENT_TRIANGLES } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants"));

/** Segment name type */
type SegmentName = 'nw' | 'n' | 'ne' | 'e' | 'se' | 's' | 'sw' | 'w';

/** Map data structure for segment overlay */
interface MapData {
  viewState: {
    zoom: number;
    center: Point;
  };
  northDirection?: number;
}

/** Hover info for segment */
interface SegmentHoverInfo {
  cellX: number;
  cellY: number;
  segment: SegmentName;
}

/** Props for SegmentHoverOverlay component */
export interface SegmentHoverOverlayProps {
  /** Hover information or null */
  hoverInfo: SegmentHoverInfo | null;
  /** Currently selected paint color */
  selectedColor: HexColor;
  /** Geometry instance */
  geometry: IGeometry | null;
  /** Map data */
  mapData: MapData | null;
  /** Reference to canvas element */
  canvasRef: { current: HTMLCanvasElement | null } | null;
  /** Reference to container element */
  containerRef: { current: HTMLElement | null } | null;
}

/** Grid geometry with cellSize property */
interface GridGeometryInstance extends IGeometry {
  cellSize: number;
}

/**
 * Convert cell coordinates to screen coordinates
 */
function cellToScreen(
  cellX: number,
  cellY: number,
  geometry: GridGeometryInstance,
  mapData: MapData,
  canvasWidth: number,
  canvasHeight: number
): Point {
  const { zoom, center } = mapData.viewState;
  const northDirection = mapData.northDirection || 0;

  const worldX = cellX * geometry.cellSize;
  const worldY = cellY * geometry.cellSize;

  const scaledCellSize = geometry.getScaledCellSize(zoom);
  const offsetX = canvasWidth / 2 - center.x * scaledCellSize;
  const offsetY = canvasHeight / 2 - center.y * scaledCellSize;

  let screenX = offsetX + worldX * zoom;
  let screenY = offsetY + worldY * zoom;

  if (northDirection !== 0) {
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;

    screenX -= centerX;
    screenY -= centerY;

    const angleRad = (northDirection * Math.PI) / 180;
    const rotatedX = screenX * Math.cos(angleRad) - screenY * Math.sin(angleRad);
    const rotatedY = screenX * Math.sin(angleRad) + screenY * Math.cos(angleRad);

    screenX = rotatedX + centerX;
    screenY = rotatedY + centerY;
  }

  return { x: screenX, y: screenY };
}

/**
 * Get SVG path for a segment triangle
 */
function getSegmentPath(segmentName: SegmentName, cellSize: number): string {
  const [v1Name, v2Name, v3Name] = SEGMENT_TRIANGLES[segmentName];

  const getPoint = (vertexName: string): Point => {
    const vertex = SEGMENT_VERTICES[vertexName];
    return {
      x: vertex.xRatio * cellSize,
      y: vertex.yRatio * cellSize
    };
  };

  const v1 = getPoint(v1Name);
  const v2 = getPoint(v2Name);
  const v3 = getPoint(v3Name);

  return `M ${v1.x} ${v1.y} L ${v2.x} ${v2.y} L ${v3.x} ${v3.y} Z`;
}

const SegmentHoverOverlay = ({
  hoverInfo,
  selectedColor,
  geometry,
  mapData,
  canvasRef,
  containerRef
}: SegmentHoverOverlayProps): React.ReactElement | null => {
  if (!hoverInfo || !geometry || !mapData || !(geometry instanceof GridGeometry)) {
    return null;
  }

  const { cellX, cellY, segment } = hoverInfo;

  const canvas = canvasRef?.current;
  const container = containerRef?.current;
  if (!canvas || !container) return null;

  const canvasWidth = canvas.width;
  const canvasHeight = canvas.height;

  const canvasRect = canvas.getBoundingClientRect();
  const containerRect = container.getBoundingClientRect();
  const displayScale = canvasRect.width / canvasWidth;

  const canvasOffsetX = canvasRect.left - containerRect.left;
  const canvasOffsetY = canvasRect.top - containerRect.top;

  const cellTopLeft = cellToScreen(
    cellX,
    cellY,
    geometry as GridGeometryInstance,
    mapData,
    canvasWidth,
    canvasHeight
  );

  const scaledTopLeft = {
    x: cellTopLeft.x * displayScale + canvasOffsetX,
    y: cellTopLeft.y * displayScale + canvasOffsetY
  };

  const scaledCellSize = geometry.getScaledCellSize(mapData.viewState.zoom) * displayScale;
  const segmentPath = getSegmentPath(segment, scaledCellSize);

  return (
    <svg
      style={{
        position: 'absolute',
        left: 0,
        top: 0,
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
        overflow: 'visible'
      }}
    >
      <g transform={`translate(${scaledTopLeft.x}, ${scaledTopLeft.y})`}>
        <path
          d={segmentPath}
          fill={selectedColor}
          fillOpacity={0.4}
          stroke={selectedColor}
          strokeWidth={2}
          strokeOpacity={0.8}
        />
      </g>
    </svg>
  );
};

return { SegmentHoverOverlay };

```

# distanceOperations

```ts
/**
 * distanceOperations.ts
 * 
 * Utilities for distance measurement formatting and settings resolution.
 * Used by the distance measurement tool to format display output and
 * resolve effective settings from global defaults and per-map overrides.
 */

// Type-only imports
import type { MapType } from '#types/core/map.types';
import type { 
  DiagonalRule, 
  DistanceDisplayFormat,
  PluginSettings
} from '#types/settings/settings.types';

// Datacore imports
const { DEFAULTS } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants")) as {
  DEFAULTS: {
    distance: {
      perCellGrid: number;
      perCellHex: number;
      unitGrid: string;
      unitHex: string;
      gridDiagonalRule: DiagonalRule;
      displayFormat: DistanceDisplayFormat;
    }
  }
};

// ===========================================
// Type Definitions
// ===========================================

/** Per-map distance settings override */
export interface MapDistanceOverrides {
  distancePerCell?: number;
  distanceUnit?: string;
  gridDiagonalRule?: DiagonalRule;
  displayFormat?: DistanceDisplayFormat;
}

/** Resolved distance settings */
export interface ResolvedDistanceSettings {
  distancePerCell: number;
  distanceUnit: string;
  gridDiagonalRule: DiagonalRule;
  displayFormat: DistanceDisplayFormat;
}

// ===========================================
// Distance Formatting
// ===========================================

/**
 * Format a distance measurement for display
 * @param cellDistance - Distance in cells
 * @param distancePerCell - Real-world units per cell
 * @param unit - Unit string (e.g., 'ft', 'mi', 'm', 'km')
 * @param displayFormat - 'cells' | 'units' | 'both'
 * @returns Formatted distance string
 */
function formatDistance(
  cellDistance: number,
  distancePerCell: number,
  unit: string,
  displayFormat: DistanceDisplayFormat
): string {
  const totalDistance = cellDistance * distancePerCell;
  
  // Round for cleaner display (1 decimal if needed, no trailing zeros)
  const roundedCells = Number.isInteger(cellDistance) 
    ? cellDistance 
    : Math.round(cellDistance * 10) / 10;
  const roundedDistance = Number.isInteger(totalDistance) 
    ? totalDistance 
    : Math.round(totalDistance * 10) / 10;
  
  const cellLabel = roundedCells === 1 ? 'cell' : 'cells';
  const unitDisplay = unit || '';
  
  switch (displayFormat) {
    case 'cells':
      return `${roundedCells} ${cellLabel}`;
    case 'units':
      return `${roundedDistance} ${unitDisplay}`.trim();
    case 'both':
    default:
      if (unitDisplay) {
        return `${roundedCells} ${cellLabel} (${roundedDistance} ${unitDisplay})`;
      }
      return `${roundedCells} ${cellLabel}`;
  }
}

// ===========================================
// Settings Resolution
// ===========================================

/**
 * Get effective distance settings for a map
 * Merges global defaults with per-map overrides
 * @param mapType - 'grid' or 'hex'
 * @param globalSettings - Settings from plugin or fallbacks
 * @param mapOverrides - Per-map distance settings (or null)
 * @returns Resolved distance settings
 */
function getEffectiveDistanceSettings(
  mapType: MapType,
  globalSettings: Partial<PluginSettings> | null | undefined,
  mapOverrides: MapDistanceOverrides | null | undefined
): ResolvedDistanceSettings {
  const isHex = mapType === 'hex';
  
  // Get appropriate defaults based on map type
  const defaultPerCell = isHex 
    ? (globalSettings?.distancePerCellHex ?? DEFAULTS.distance.perCellHex)
    : (globalSettings?.distancePerCellGrid ?? DEFAULTS.distance.perCellGrid);
  const defaultUnit = isHex
    ? (globalSettings?.distanceUnitHex ?? DEFAULTS.distance.unitHex)
    : (globalSettings?.distanceUnitGrid ?? DEFAULTS.distance.unitGrid);
  
  return {
    distancePerCell: mapOverrides?.distancePerCell ?? defaultPerCell,
    distanceUnit: mapOverrides?.distanceUnit ?? defaultUnit,
    gridDiagonalRule: mapOverrides?.gridDiagonalRule ?? globalSettings?.gridDiagonalRule ?? DEFAULTS.distance.gridDiagonalRule,
    displayFormat: mapOverrides?.displayFormat ?? globalSettings?.distanceDisplayFormat ?? DEFAULTS.distance.displayFormat
  };
}

// ===========================================
// Exports
// ===========================================

return { formatDistance, getEffectiveDistanceSettings };
```

# DrawingLayer

```tsx
/**
 * DrawingLayer.tsx
 *
 * Handles drawing tool interactions and preview overlays.
 * Supports live shape preview for KBM (hover) and touch (3-tap confirmation).
 */

import type { ToolId } from '#types/tools/tool.types';
import type { HexColor } from '#types/core/common.types';
import type { OffsetCoords } from '#types/core/geometry.types';
import type { EffectiveDistanceSettings } from '#types/hooks/distanceMeasurement.types';

const { useDrawingTools } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useDrawingTools"));
const { useMapState } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext"));
const { useEventHandlerRegistration } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "EventHandlerContext"));
const { ShapePreviewOverlay } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ShapePreviewOverlay"));
const { SegmentPickerOverlay } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "SegmentPickerOverlay"));
const { SegmentHoverOverlay } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "SegmentHoverOverlay"));
const { getSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsAccessor"));
const { getEffectiveDistanceSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "distanceOperations"));

/** Preview settings for shapes */
interface PreviewSettings {
  kbmEnabled: boolean;
  touchEnabled: boolean;
}

/** Drawing state change callback data */
interface DrawingStateChangeData {
  isDrawing: boolean;
  rectangleStart: OffsetCoords | null;
  circleStart: OffsetCoords | null;
  edgeLineStart: OffsetCoords | null;
  shapeHoverPosition: OffsetCoords | null;
  touchConfirmPending: boolean;
  handlers: {
    handleDrawingPointerDown: (e: PointerEvent) => void;
    handleDrawingPointerMove: (e: PointerEvent) => void;
    stopDrawing: () => void;
    cancelDrawing: () => void;
    cancelShapePreview: () => void;
  };
}

/** Props for DrawingLayer component */
export interface DrawingLayerProps {
  /** Current active tool */
  currentTool: ToolId;
  /** Selected color for drawing */
  selectedColor: HexColor | null;
  /** Selected opacity (0-1) */
  selectedOpacity?: number;
  /** Callback when drawing state changes */
  onDrawingStateChange?: (state: DrawingStateChangeData) => void;
  /** Global plugin settings */
  globalSettings?: Record<string, unknown>;
  /** Per-map distance setting overrides */
  mapDistanceOverrides?: Partial<EffectiveDistanceSettings>;
}

const DrawingLayer = ({
  currentTool,
  selectedColor,
  selectedOpacity = 1,
  onDrawingStateChange,
  globalSettings,
  mapDistanceOverrides
}: DrawingLayerProps): React.ReactElement => {
  const {
    canvasRef,
    containerRef,
    mapData,
    GridGeometry,
    geometry
  } = useMapState();

  const previewSettings = dc.useMemo((): PreviewSettings => {
    const settings = globalSettings || getSettings();
    return {
      kbmEnabled: (settings as Record<string, unknown>).shapePreviewKbm !== false,
      touchEnabled: (settings as Record<string, unknown>).shapePreviewTouch === true
    };
  }, [globalSettings]);

  const distanceSettings = dc.useMemo(() => {
    const mapType = mapData?.mapType || 'grid';
    const settings = globalSettings || getSettings();
    return getEffectiveDistanceSettings(mapType, settings, mapDistanceOverrides);
  }, [mapData?.mapType, globalSettings, mapDistanceOverrides]);

  const {
    isDrawing,
    rectangleStart,
    circleStart,
    edgeLineStart,
    shapeHoverPosition,
    touchConfirmPending,
    pendingEndPoint,
    handleDrawingPointerDown,
    handleDrawingPointerMove,
    stopDrawing,
    stopEdgeDrawing,
    stopSegmentDrawing,
    cancelDrawing,
    updateShapeHover,
    updateEdgeLineHover,
    cancelShapePreview,
    segmentPickerOpen,
    segmentPickerCell,
    segmentPickerExistingCell,
    closeSegmentPicker,
    applySegmentSelection,
    savedSegments,
    rememberSegments,
    segmentHoverInfo,
    updateSegmentHover,
    clearSegmentHover,
    // Freehand drawing
    isFreehandDrawing,
    freehandPreviewPoints,
    finishFreehandDrawing,
    cancelFreehandDrawing
  } = useDrawingTools(currentTool, selectedColor, selectedOpacity, previewSettings);

  const handleStopDrawing = dc.useCallback(() => {
    if (currentTool === 'edgeDraw' || currentTool === 'edgeErase') {
      stopEdgeDrawing();
    } else if (currentTool === 'segmentDraw') {
      stopSegmentDrawing();
    } else if (currentTool === 'freehandDraw') {
      finishFreehandDrawing();
    } else {
      stopDrawing();
    }
  }, [currentTool, stopDrawing, stopEdgeDrawing, stopSegmentDrawing, finishFreehandDrawing]);

  const handleKeyDown = dc.useCallback((e: KeyboardEvent) => {
    if (e.key === 'Escape') {
      if (segmentPickerOpen) {
        closeSegmentPicker();
      } else if (isFreehandDrawing) {
        cancelFreehandDrawing();
      } else if (rectangleStart || circleStart || edgeLineStart || touchConfirmPending) {
        cancelShapePreview();
      }
    }
  }, [rectangleStart, circleStart, edgeLineStart, touchConfirmPending, cancelShapePreview, segmentPickerOpen, closeSegmentPicker, isFreehandDrawing, cancelFreehandDrawing]);

  dc.useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);

  const { registerHandlers, unregisterHandlers } = useEventHandlerRegistration();

  dc.useEffect(() => {
    registerHandlers('drawing', {
      handleDrawingPointerDown,
      handleDrawingPointerMove,
      stopDrawing: handleStopDrawing,
      cancelDrawing,
      isDrawing,
      isFreehandDrawing,
      rectangleStart,
      circleStart,
      edgeLineStart,
      updateShapeHover,
      updateEdgeLineHover,
      shapeHoverPosition,
      touchConfirmPending,
      cancelShapePreview,
      previewEnabled: previewSettings.kbmEnabled,
      updateSegmentHover,
      clearSegmentHover
    });

    return () => unregisterHandlers('drawing');
  }, [registerHandlers, unregisterHandlers, handleDrawingPointerDown, handleDrawingPointerMove,
    handleStopDrawing, cancelDrawing, isDrawing, isFreehandDrawing, rectangleStart, circleStart, edgeLineStart,
    updateShapeHover, updateEdgeLineHover, shapeHoverPosition, touchConfirmPending,
    cancelShapePreview, previewSettings.kbmEnabled, updateSegmentHover, clearSegmentHover]);

  dc.useEffect(() => {
    if (onDrawingStateChange) {
      onDrawingStateChange({
        isDrawing,
        rectangleStart,
        circleStart,
        edgeLineStart,
        shapeHoverPosition,
        touchConfirmPending,
        handlers: {
          handleDrawingPointerDown,
          handleDrawingPointerMove,
          stopDrawing: handleStopDrawing,
          cancelDrawing,
          cancelShapePreview
        }
      });
    }
  }, [isDrawing, rectangleStart, circleStart, edgeLineStart, shapeHoverPosition,
    touchConfirmPending, onDrawingStateChange, handleStopDrawing, cancelShapePreview]);

  const renderStartMarker = (): React.ReactElement | null => {
    if (!canvasRef.current || !containerRef?.current || !geometry) return null;

    const canvas = canvasRef.current;
    const { viewState, northDirection } = mapData;
    const { zoom, center } = viewState;
    const { width, height } = canvas;

    let scaledSize: number;
    let offsetX: number;
    let offsetY: number;

    const isGrid = geometry instanceof GridGeometry;
    if (isGrid) {
      scaledSize = geometry.getScaledCellSize(zoom);
      offsetX = width / 2 - center.x * scaledSize;
      offsetY = height / 2 - center.y * scaledSize;
    } else {
      scaledSize = geometry.hexSize * zoom;
      offsetX = width / 2 - center.x * zoom;
      offsetY = height / 2 - center.y * zoom;
    }

    const containerRect = containerRef.current.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    const canvasOffsetX = canvasRect.left - containerRect.left;
    const canvasOffsetY = canvasRect.top - containerRect.top;
    const displayScale = canvasRect.width / width;

    const gridToCanvasPosition = (gridX: number, gridY: number): { x: number; y: number } => {
      const worldX = (gridX + 0.5) * geometry.cellSize;
      const worldY = (gridY + 0.5) * geometry.cellSize;

      let screenX = offsetX + worldX * zoom;
      let screenY = offsetY + worldY * zoom;

      if (northDirection !== 0) {
        const centerX = width / 2;
        const centerY = height / 2;
        screenX -= centerX;
        screenY -= centerY;
        const angleRad = (northDirection * Math.PI) / 180;
        const rotatedX = screenX * Math.cos(angleRad) - screenY * Math.sin(angleRad);
        const rotatedY = screenX * Math.sin(angleRad) + screenY * Math.cos(angleRad);
        screenX = rotatedX + centerX;
        screenY = rotatedY + centerY;
      }

      screenX *= displayScale;
      screenY *= displayScale;

      const cellHalfSize = (scaledSize * displayScale) / 2;
      return {
        x: canvasOffsetX + screenX - cellHalfSize,
        y: canvasOffsetY + screenY - cellHalfSize
      };
    };

    const intersectionToCanvasPosition = (intX: number, intY: number): { x: number; y: number } => {
      const worldX = intX * geometry.cellSize;
      const worldY = intY * geometry.cellSize;

      let screenX = offsetX + worldX * zoom;
      let screenY = offsetY + worldY * zoom;

      if (northDirection !== 0) {
        const centerX = width / 2;
        const centerY = height / 2;
        screenX -= centerX;
        screenY -= centerY;
        const angleRad = (northDirection * Math.PI) / 180;
        const rotatedX = screenX * Math.cos(angleRad) - screenY * Math.sin(angleRad);
        const rotatedY = screenX * Math.sin(angleRad) + screenY * Math.cos(angleRad);
        screenX = rotatedX + centerX;
        screenY = rotatedY + centerY;
      }

      screenX *= displayScale;
      screenY *= displayScale;

      return {
        x: canvasOffsetX + screenX,
        y: canvasOffsetY + screenY
      };
    };

    const overlays: React.ReactElement[] = [];
    const displayScaledSize = scaledSize * displayScale;

    const showFullPreview = shapeHoverPosition && previewSettings.kbmEnabled;
    const showTouchPreview = touchConfirmPending && pendingEndPoint;

    if (rectangleStart && !showFullPreview && !showTouchPreview) {
      const pos = gridToCanvasPosition(rectangleStart.x, rectangleStart.y);
      const highlightColor = currentTool === 'clearArea' ? '#ff0000' : '#00ff00';

      overlays.push(
        <div
          key="rectangle-start"
          className="dmt-drawing-preview"
          style={{
            position: 'absolute',
            left: `${pos.x}px`,
            top: `${pos.y}px`,
            width: `${displayScaledSize}px`,
            height: `${displayScaledSize}px`,
            border: `2px solid ${highlightColor}`,
            boxSizing: 'border-box',
            pointerEvents: 'none',
            zIndex: 100
          }}
        />
      );
    }

    if (circleStart && !showFullPreview && !showTouchPreview) {
      const pos = gridToCanvasPosition(circleStart.x, circleStart.y);
      const highlightColor = '#00aaff';

      overlays.push(
        <div
          key="circle-start"
          className="dmt-drawing-preview"
          style={{
            position: 'absolute',
            left: `${pos.x}px`,
            top: `${pos.y}px`,
            width: `${displayScaledSize}px`,
            height: `${displayScaledSize}px`,
            border: `2px solid ${highlightColor}`,
            boxSizing: 'border-box',
            pointerEvents: 'none',
            zIndex: 100
          }}
        />
      );
    }

    if (edgeLineStart && !showFullPreview && !showTouchPreview) {
      const pos = intersectionToCanvasPosition(edgeLineStart.x, edgeLineStart.y);
      const highlightColor = '#ff9500';
      const markerSize = Math.max(16, displayScaledSize * 0.4);
      const halfMarker = markerSize / 2;
      const strokeWidth = Math.max(2, markerSize / 8);

      overlays.push(
        <svg
          key="edgeline-start"
          className="dmt-drawing-preview"
          style={{
            position: 'absolute',
            left: `${pos.x - halfMarker}px`,
            top: `${pos.y - halfMarker}px`,
            width: `${markerSize}px`,
            height: `${markerSize}px`,
            pointerEvents: 'none',
            zIndex: 100,
            overflow: 'visible'
          }}
          viewBox={`0 0 ${markerSize} ${markerSize}`}
        >
          <line
            x1={strokeWidth}
            y1={strokeWidth}
            x2={markerSize - strokeWidth}
            y2={markerSize - strokeWidth}
            stroke={highlightColor}
            strokeWidth={strokeWidth}
            strokeLinecap="round"
          />
          <line
            x1={markerSize - strokeWidth}
            y1={strokeWidth}
            x2={strokeWidth}
            y2={markerSize - strokeWidth}
            stroke={highlightColor}
            strokeWidth={strokeWidth}
            strokeLinecap="round"
          />
        </svg>
      );
    }

    return overlays.length > 0 ? <>{overlays}</> : null;
  };

  const renderShapePreview = (): React.ReactElement | null => {
    const endPoint = touchConfirmPending ? pendingEndPoint : shapeHoverPosition;

    const shouldShowPreview = endPoint && (
      (previewSettings.kbmEnabled && shapeHoverPosition && !touchConfirmPending) ||
      (touchConfirmPending && pendingEndPoint)
    );

    if (!shouldShowPreview) return null;

    let shapeType: string | null = null;
    let startPoint: OffsetCoords | null = null;

    if (circleStart) {
      shapeType = 'circle';
      startPoint = circleStart;
    } else if (rectangleStart) {
      shapeType = currentTool === 'clearArea' ? 'clearArea' : 'rectangle';
      startPoint = rectangleStart;
    } else if (edgeLineStart) {
      shapeType = 'edgeLine';
      startPoint = edgeLineStart;
    }

    if (!shapeType || !startPoint) return null;

    return (
      <ShapePreviewOverlay
        shapeType={shapeType}
        startPoint={startPoint}
        endPoint={endPoint}
        geometry={geometry}
        mapData={mapData}
        canvasRef={canvasRef}
        containerRef={containerRef}
        distanceSettings={distanceSettings}
        isConfirmable={touchConfirmPending}
      />
    );
  };

  return (
    <>
      {renderStartMarker()}
      {renderShapePreview()}

      {currentTool === 'segmentDraw' && segmentHoverInfo && (
        <SegmentHoverOverlay
          hoverInfo={segmentHoverInfo}
          selectedColor={selectedColor}
          geometry={geometry}
          mapData={mapData}
          canvasRef={canvasRef}
          containerRef={containerRef}
        />
      )}

      <SegmentPickerOverlay
        isOpen={segmentPickerOpen}
        cellCoords={segmentPickerCell}
        existingCell={segmentPickerExistingCell}
        selectedColor={selectedColor}
        selectedOpacity={selectedOpacity}
        onConfirm={applySegmentSelection}
        onCancel={closeSegmentPicker}
        savedSegments={savedSegments}
        initialRememberState={rememberSegments}
      />
    </>
  );
};

return { DrawingLayer };

```

# useTextLabelInteraction

```ts
/**
 * useTextLabelInteraction.ts
 *
 * Custom hook for managing text label interactions:
 * - Placement of new text labels
 * - Selection and deselection
 * - Dragging to reposition
 * - Rotation (R key and button)
 * - Deletion (Delete/Backspace)
 * - Editing (double-click and edit button)
 * - Modal state management
 * - Button position calculations
 */

// Type-only imports
import type { ToolId } from '#types/tools/tool.types';
import type { TextLabel, TextLabelId } from '#types/objects/note.types';
import type { MapData, MapLayer, TextLabelSettings } from '#types/core/map.types';
import type { HexColor } from '#types/core/common.types';
import type {
  UseTextLabelInteractionResult,
  PendingTextPosition,
  TextButtonPosition,
  TextDragStart,
  TextLabelModalData,
} from '#types/hooks/textLabelInteraction.types';

// Datacore imports
const { applyInverseRotation } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "screenPositionUtils")) as {
  applyInverseRotation: (x: number, y: number, angle: number, centerX: number, centerY: number) => { x: number; y: number };
};

const { getNextRotation } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "rotationOperations")) as {
  getNextRotation: (currentRotation: number) => number
};

// Inline context types for not-yet-migrated contexts
interface SelectedItem {
  type: 'object' | 'text';
  id: string;
  data: TextLabel | Record<string, unknown>;
}

interface WorldCoords {
  worldX: number;
  worldY: number;
}

const { useMapState, useMapOperations } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext")) as {
  useMapState: () => {
    canvasRef: React.RefObject<HTMLCanvasElement>;
    mapData: MapData | null;
    screenToWorld: (clientX: number, clientY: number) => WorldCoords | null;
    getClientCoords: (e: Event) => { clientX: number; clientY: number };
  };
  useMapOperations: () => {
    onTextLabelsChange: (labels: TextLabel[], suppressHistory?: boolean) => void;
    onMapDataUpdate: (updates: { lastTextLabelSettings?: TextLabelSettings }) => void;
    getTextLabelAtPosition: (labels: TextLabel[], x: number, y: number, ctx: CanvasRenderingContext2D) => TextLabel | null;
    addTextLabel: (labels: TextLabel[], content: string, x: number, y: number, options: Partial<TextLabel>) => TextLabel[];
    updateTextLabel: (labels: TextLabel[], id: TextLabelId, updates: Partial<TextLabel>) => TextLabel[];
    removeTextLabel: (labels: TextLabel[], id: TextLabelId) => TextLabel[];
  };
};

const { useMapSelection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSelectionContext")) as {
  useMapSelection: () => {
    selectedItem: SelectedItem | null;
    setSelectedItem: (item: SelectedItem | null) => void;
    isDraggingSelection: boolean;
    setIsDraggingSelection: (dragging: boolean) => void;
    dragStart: TextDragStart | null;
    setDragStart: (start: TextDragStart | null) => void;
  };
};

const { getActiveLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor")) as {
  getActiveLayer: (mapData: MapData) => MapLayer;
};

/**
 * Hook for managing text label interactions
 */
const useTextLabelInteraction = (
  currentTool: ToolId,
  onAddCustomColor: ((color: HexColor) => void) | undefined,
  customColors: HexColor[]
): UseTextLabelInteractionResult => {
  // Get all required state and operations from Context
  const {
    canvasRef,
    mapData,
    screenToWorld,
    getClientCoords
  } = useMapState();

  const {
    onTextLabelsChange,
    onMapDataUpdate,
    getTextLabelAtPosition,
    addTextLabel,
    updateTextLabel,
    removeTextLabel
  } = useMapOperations();

  const {
    selectedItem,
    setSelectedItem,
    isDraggingSelection,
    setIsDraggingSelection,
    dragStart,
    setDragStart
  } = useMapSelection();

  // Text label modal state
  const [showTextModal, setShowTextModal] = dc.useState<boolean>(false);
  const [pendingTextPosition, setPendingTextPosition] = dc.useState<PendingTextPosition | null>(null);
  const [editingTextId, setEditingTextId] = dc.useState<TextLabelId | null>(null);
  const dragInitialStateRef = dc.useRef<TextLabel[] | null>(null);

  /**
   * Handle text label placement - opens modal to create new label
   */
  const handleTextPlacement = dc.useCallback((clientX: number, clientY: number): boolean => {
    if (currentTool !== 'addText' || !canvasRef.current || !mapData) {
      return false;
    }

    // Use screenToWorld helper which handles both grid and hex geometries
    const worldCoords = screenToWorld(clientX, clientY);
    if (!worldCoords) return false;

    setPendingTextPosition({ x: worldCoords.worldX, y: worldCoords.worldY });
    setShowTextModal(true);
    return true;
  }, [currentTool, canvasRef, mapData, screenToWorld]);

  /**
   * Handle text label selection
   */
  const handleTextSelection = dc.useCallback((clientX: number, clientY: number): boolean => {
    if (currentTool !== 'select' || !mapData?.textLabels || !canvasRef.current) {
      return false;
    }

    const worldCoords = screenToWorld(clientX, clientY);
    if (!worldCoords) return false;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return false;

    const textLabel = getTextLabelAtPosition(
      getActiveLayer(mapData).textLabels,
      worldCoords.worldX,
      worldCoords.worldY,
      ctx
    );

    if (textLabel) {
      // Store initial text label state for batched history entry at drag end
      dragInitialStateRef.current = [...(getActiveLayer(mapData).textLabels || [])];
      setSelectedItem({ type: 'text', id: textLabel.id, data: textLabel });
      setIsDraggingSelection(true);
      setDragStart({ x: clientX, y: clientY, worldX: worldCoords.worldX, worldY: worldCoords.worldY });
      return true;
    }

    return false;
  }, [currentTool, mapData, canvasRef, screenToWorld, getTextLabelAtPosition, setSelectedItem, setIsDraggingSelection, setDragStart]);

  /**
   * Handle text label dragging
   */
  const handleTextDragging = dc.useCallback((e: PointerEvent | MouseEvent | TouchEvent): boolean => {
    if (!isDraggingSelection || selectedItem?.type !== 'text' || !dragStart || !mapData) {
      return false;
    }

    e.preventDefault();
    e.stopPropagation();

    const { clientX, clientY } = getClientCoords(e as Event);
    const worldCoords = screenToWorld(clientX, clientY);
    if (!worldCoords) return false;

    // Calculate delta from drag start
    const deltaWorldX = worldCoords.worldX - dragStart.worldX;
    const deltaWorldY = worldCoords.worldY - dragStart.worldY;

    const selectedData = selectedItem.data as TextLabel;

    // Update text label position (suppress history during drag)
    const updatedLabels = updateTextLabel(
      getActiveLayer(mapData).textLabels,
      selectedItem.id,
      {
        position: {
          x: selectedData.position.x + deltaWorldX,
          y: selectedData.position.y + deltaWorldY
        }
      }
    );
    onTextLabelsChange(updatedLabels, true); // Suppress history

    // Update drag start and selected item data for next frame
    setDragStart({ x: clientX, y: clientY, worldX: worldCoords.worldX, worldY: worldCoords.worldY });
    setSelectedItem({
      ...selectedItem,
      data: {
        ...selectedData,
        position: {
          x: selectedData.position.x + deltaWorldX,
          y: selectedData.position.y + deltaWorldY
        }
      }
    });

    return true;
  }, [isDraggingSelection, selectedItem, dragStart, mapData, getClientCoords, screenToWorld, updateTextLabel, onTextLabelsChange, setDragStart, setSelectedItem]);

  /**
   * Handle text label rotation (45 increments)
   */
  const handleTextRotation = dc.useCallback((): void => {
    if (!selectedItem || selectedItem.type !== 'text' || !mapData) {
      return;
    }

    const selectedData = selectedItem.data as TextLabel;
    const currentRotation = selectedData.rotation || 0;
    const nextRotation = getNextRotation(currentRotation);

    const updatedLabels = updateTextLabel(
      getActiveLayer(mapData).textLabels,
      selectedItem.id,
      { rotation: nextRotation }
    );
    onTextLabelsChange(updatedLabels);

    // Update selected item data
    setSelectedItem({
      ...selectedItem,
      data: {
        ...selectedData,
        rotation: nextRotation
      }
    });
  }, [selectedItem, mapData, updateTextLabel, onTextLabelsChange, setSelectedItem]);

  /**
   * Handle text label deletion
   */
  const handleTextDeletion = (): void => {
    if (!selectedItem || selectedItem.type !== 'text' || !mapData) {
      return;
    }

    const updatedLabels = removeTextLabel(
      getActiveLayer(mapData).textLabels,
      selectedItem.id
    );
    onTextLabelsChange(updatedLabels);
    setSelectedItem(null);
  };

  /**
   * Handle keyboard shortcuts for text labels
   */
  const handleTextKeyDown = (e: KeyboardEvent): boolean => {
    if (!selectedItem || selectedItem.type !== 'text') {
      return false;
    }

    // Rotation with R key
    if (e.key === 'r' || e.key === 'R') {
      e.preventDefault();
      handleTextRotation();
      return true;
    }

    // Deletion with Delete or Backspace
    if (e.key === 'Delete' || e.key === 'Backspace') {
      e.preventDefault();
      handleTextDeletion();
      return true;
    }

    return false;
  };

  /**
   * Handle text label modal submission
   */
  const handleTextSubmit = (labelData: TextLabelModalData): void => {
    if (!labelData || !labelData.content || !labelData.content.trim()) {
      return;
    }

    if (editingTextId) {
      // Update existing label
      const newLabels = updateTextLabel(
        getActiveLayer(mapData!).textLabels || [],
        editingTextId,
        {
          content: labelData.content.trim(),
          fontSize: labelData.fontSize,
          fontFace: labelData.fontFace,
          color: labelData.color
        }
      );
      onTextLabelsChange(newLabels);
    } else if (pendingTextPosition && mapData) {
      // Create new label
      const newLabels = addTextLabel(
        getActiveLayer(mapData).textLabels || [],
        labelData.content.trim(),
        pendingTextPosition.x,
        pendingTextPosition.y,
        {
          fontSize: labelData.fontSize,
          fontFace: labelData.fontFace,
          color: labelData.color
        }
      );
      onTextLabelsChange(newLabels);

      // Save text label settings for future new labels (per-map)
      if (onMapDataUpdate) {
        onMapDataUpdate({
          lastTextLabelSettings: {
            fontSize: labelData.fontSize,
            fontFace: labelData.fontFace,
            color: labelData.color
          }
        });
      }
    }

    setShowTextModal(false);
    setPendingTextPosition(null);
    setEditingTextId(null);
  };

  /**
   * Handle text label modal cancellation
   */
  const handleTextCancel = (): void => {
    setShowTextModal(false);
    setPendingTextPosition(null);
    setEditingTextId(null);
  };

  /**
   * Handle rotate button click
   */
  const handleRotateClick = (e: MouseEvent): void => {
    if (selectedItem?.type === 'text') {
      e.preventDefault();
      e.stopPropagation();
      handleTextRotation();
    }
  };

  /**
   * Handle edit button click
   */
  const handleEditClick = (e: MouseEvent): void => {
    if (selectedItem?.type === 'text') {
      e.preventDefault();
      e.stopPropagation();

      // Open editor with current label data
      setEditingTextId(selectedItem.id);
      setShowTextModal(true);
    }
  };

  /**
   * Handle double-click to edit selected text label
   */
  const handleCanvasDoubleClick = (e: MouseEvent): void => {
    // Only handle double-click for text labels in select mode
    if (currentTool !== 'select' || !selectedItem || selectedItem.type !== 'text') {
      return;
    }

    e.preventDefault();
    e.stopPropagation();

    // Open editor with current label data
    setEditingTextId(selectedItem.id);
    setShowTextModal(true);
  };

  /**
   * Calculate rotate button position
   */
  const calculateRotateButtonPosition = (): TextButtonPosition => {
    if (selectedItem?.type !== 'text' || !mapData || !canvasRef.current) {
      return { x: 0, y: 0 };
    }

    const label = getActiveLayer(mapData).textLabels.find(l => l.id === selectedItem.id);
    if (!label) return { x: 0, y: 0 };

    const canvas = canvasRef.current;
    const { gridSize, viewState, northDirection } = mapData;
    const { zoom, center } = viewState;
    const scaledGridSize = gridSize * zoom;

    // Calculate offsets accounting for map rotation
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const offsetX = centerX - center.x * scaledGridSize;
    const offsetY = centerY - center.y * scaledGridSize;

    // Get label position in world space, then convert to screen space
    let screenX = offsetX + label.position.x * zoom;
    let screenY = offsetY + label.position.y * zoom;

    // Apply canvas rotation if present
    if (northDirection !== 0) {
      // Translate to canvas center
      const relX = screenX - centerX;
      const relY = screenY - centerY;

      // Apply rotation
      const angleRad = (northDirection * Math.PI) / 180;
      const rotatedX = relX * Math.cos(angleRad) - relY * Math.sin(angleRad);
      const rotatedY = relX * Math.sin(angleRad) + relY * Math.cos(angleRad);

      // Translate back
      screenX = centerX + rotatedX;
      screenY = centerY + rotatedY;
    }

    // Measure text to get bounding box (same as selection box calculation)
    const ctx = canvas.getContext('2d');
    if (!ctx) return { x: 0, y: 0 };

    const fontSize = label.fontSize * zoom;
    ctx.font = `${fontSize}px sans-serif`;
    const metrics = ctx.measureText(label.content);
    const textWidth = metrics.width;
    const textHeight = fontSize * 1.2; // Same as selection box

    // Calculate rotated bounding box for the label itself
    const labelAngle = ((label.rotation || 0) * Math.PI) / 180;
    const cos = Math.abs(Math.cos(labelAngle));
    const sin = Math.abs(Math.sin(labelAngle));
    const rotatedWidth = textWidth * cos + textHeight * sin;
    const rotatedHeight = textWidth * sin + textHeight * cos;

    // Position button at top-right corner of selection box
    // Selection box has 4px padding on sides and 2px on top/bottom
    const selectionPaddingX = 4;
    const selectionPaddingY = 2;
    const buttonOffset = 4; // Small gap between selection box and button
    const buttonHeight = 32;

    // Return canvas-relative coordinates for absolute positioning
    const buttonX = screenX + (rotatedWidth / 2) + selectionPaddingX + buttonOffset;
    const buttonY = screenY - (rotatedHeight / 2) - selectionPaddingY - buttonOffset - buttonHeight;

    const rect = canvas.getBoundingClientRect();
    const containerRect = canvas.parentElement?.getBoundingClientRect();
    if (!containerRect) return { x: 0, y: 0 };

    // Calculate canvas offset within container (due to flex centering)
    const canvasOffsetX = rect.left - containerRect.left;
    const canvasOffsetY = rect.top - containerRect.top;

    // Scale from canvas internal coordinates to displayed coordinates
    const scaleX = rect.width / canvas.width;
    const scaleY = rect.height / canvas.height;

    return { x: (buttonX * scaleX) + canvasOffsetX, y: (buttonY * scaleY) + canvasOffsetY };
  };

  /**
   * Calculate edit button position (to the left of rotate button)
   */
  const calculateEditButtonPosition = (): TextButtonPosition => {
    const rotatePos = calculateRotateButtonPosition();
    // Position edit button 40px to the left of rotate button (32px button + 8px gap)
    return { x: rotatePos.x - 40, y: rotatePos.y };
  };

  /**
   * Stop text label dragging and finalize history
   */
  const stopTextDragging = (): boolean => {
    if (isDraggingSelection && selectedItem?.type === 'text') {
      setIsDraggingSelection(false);
      setDragStart(null);

      // Add single history entry for the completed drag
      if (dragInitialStateRef.current !== null && mapData) {
        onTextLabelsChange(getActiveLayer(mapData).textLabels, false);
        dragInitialStateRef.current = null;
      }
      return true;
    }
    return false;
  };

  return {
    // State
    showTextModal,
    editingTextId,

    // Handlers
    handleTextPlacement,
    handleTextSelection,
    handleTextDragging,
    stopTextDragging,
    handleTextRotation,
    handleTextDeletion,
    handleTextKeyDown,
    handleTextSubmit,
    handleTextCancel,
    handleRotateClick,
    handleEditClick,
    handleCanvasDoubleClick,

    // Position calculators
    calculateRotateButtonPosition,
    calculateEditButtonPosition
  };
};

return { useTextLabelInteraction };

```

# TextLabelEditor

```jsx
// components/TextLabelEditor.jsx - Comprehensive text label editor with styling options

const { FONT_OPTIONS, DEFAULT_FONT, DEFAULT_FONT_SIZE, DEFAULT_TEXT_COLOR, FONT_SIZE_MIN, FONT_SIZE_MAX, FONT_SIZE_STEP, getFontOption } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "fontOptions"));
const { ColorPicker } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ColorPicker"));
const { COLOR_PALETTE } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "colorOperations"));

const TextLabelEditor = ({ 
  initialValue = '', 
  initialFontSize = DEFAULT_FONT_SIZE,
  initialFontFace = DEFAULT_FONT,
  initialColor = DEFAULT_TEXT_COLOR,
  onSubmit, 
  onCancel, 
  isEditing = false,
  customColors = [],
  onAddCustomColor,
  onDeleteCustomColor
}) => {
  const [text, setText] = dc.useState(initialValue);
  const [fontSize, setFontSize] = dc.useState(initialFontSize);
  const [fontSizeInput, setFontSizeInput] = dc.useState(String(initialFontSize)); // Raw input for typing
  const [fontFace, setFontFace] = dc.useState(initialFontFace);
  const [color, setColor] = dc.useState(initialColor);
  const [isColorPickerOpen, setIsColorPickerOpen] = dc.useState(false);
  const [showPreview, setShowPreview] = dc.useState(false);
  
  const inputRef = dc.useRef(null);
  const colorBtnRef = dc.useRef(null);
  const pendingCustomColorRef = dc.useRef(null);
  
  // Auto-focus input when modal opens
  dc.useEffect(() => {
    if (inputRef.current) {
      inputRef.current.focus();
      // Select all text if editing existing label
      if (initialValue) {
        inputRef.current.select();
      }
    }
  }, []);
  
  // Handle keyboard shortcuts
  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSubmit();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      onCancel();
    }
  };
  
  const handleSubmit = () => {
    const trimmed = text.trim();
    if (trimmed.length > 0 && trimmed.length <= 200) {
      const labelData = {
        content: trimmed,
        fontSize: fontSize,
        fontFace: fontFace,
        color: color
      };
      onSubmit(labelData);
    }
  };
  
  // Prevent clicks inside modal from closing it
  const handleModalClick = (e) => {
    e.stopPropagation();
  };
  
  // Handle font size input change (no clamping during typing)
  const handleFontSizeInputChange = (e) => {
    setFontSizeInput(e.target.value);
  };
  
  // Handle font size blur - clamp and apply
  const handleFontSizeBlur = () => {
    const value = parseInt(fontSizeInput, 10);
    if (!isNaN(value) && value > 0) {
      const clamped = Math.max(FONT_SIZE_MIN, Math.min(FONT_SIZE_MAX, value));
      setFontSize(clamped);
      setFontSizeInput(String(clamped));
    } else {
      // Invalid input - reset to current fontSize
      setFontSizeInput(String(fontSize));
    }
  };
  
  // Handle font face change
  const handleFontFaceChange = (e) => {
    setFontFace(e.target.value);
  };
  
  // Color picker handlers
  const handleColorPickerToggle = (e) => {
    e.stopPropagation();
    setIsColorPickerOpen(!isColorPickerOpen);
  };
  
  const handleColorSelect = (newColor) => {
    setColor(newColor);
  };
  
  const handleColorReset = () => {
    setColor(DEFAULT_TEXT_COLOR);
    setIsColorPickerOpen(false);
  };
  
  const handleCloseColorPicker = () => {
    setIsColorPickerOpen(false);
  };
  
  const handleAddCustomColor = (newColor) => {
    if (onAddCustomColor) {
      // Pass raw color string - parent handles wrapping into color object
      onAddCustomColor(newColor);
    }
  };
  
  const handleDeleteCustomColor = (colorId) => {
    if (onDeleteCustomColor) {
      onDeleteCustomColor(colorId);
    }
  };
  
  // Close color picker when clicking outside
  dc.useEffect(() => {
    if (isColorPickerOpen) {
      const handleClickOutside = (e) => {
        // Check if click is inside the color picker or the color button
        const pickerElement = e.target.closest('.dmt-color-picker');
        const buttonElement = e.target.closest('.dmt-text-editor-color-button');
        
        if (!pickerElement && !buttonElement) {
          // Click is outside - save any pending color and close the picker
          if (pendingCustomColorRef.current) {
            handleAddCustomColor(pendingCustomColorRef.current);
            setColor(pendingCustomColorRef.current);
            pendingCustomColorRef.current = null;
          }
          
          handleCloseColorPicker();
        }
      };
      
      document.addEventListener('mousedown', handleClickOutside);
      document.addEventListener('touchstart', handleClickOutside);
      
      return () => {
        document.removeEventListener('mousedown', handleClickOutside);
        document.removeEventListener('touchstart', handleClickOutside);
      };
    }
  }, [isColorPickerOpen]);
  
  return (
    <div className="dmt-modal-overlay" onClick={onCancel}>
      <div 
        className="dmt-modal-content dmt-text-editor-modal" 
        onClick={handleModalClick}
      >
        <h3 className="dmt-modal-title">
          {isEditing ? 'Edit Text Label' : 'Add Text Label'}
        </h3>
        
        {/* Text input */}
        <div className="dmt-text-editor-section">
          <label className="dmt-text-editor-label">Text</label>
          <input
            ref={inputRef}
            type="text"
            className="dmt-modal-input"
            value={text}
            onChange={(e) => setText(e.target.value)}
            onKeyDown={handleKeyDown}
            maxLength={200}
            placeholder="Enter label text..."
          />
        </div>
        
        {/* Font controls row */}
        <div className="dmt-text-editor-row">
          {/* Font face dropdown */}
          <div className="dmt-text-editor-section dmt-text-editor-section-grow">
            <label className="dmt-text-editor-label">Font</label>
            <select 
              className="dmt-text-editor-select"
              value={fontFace}
              onChange={handleFontFaceChange}
            >
              {FONT_OPTIONS.map(font => (
                <option key={font.id} value={font.id}>
                  {font.name}
                </option>
              ))}
            </select>
          </div>
          
          {/* Font size input */}
          <div className="dmt-text-editor-section dmt-text-editor-section-small">
            <label className="dmt-text-editor-label">Size</label>
            <input
              type="number"
              className="dmt-text-editor-number"
              value={fontSizeInput}
              onChange={handleFontSizeInputChange}
              onBlur={handleFontSizeBlur}
              min={FONT_SIZE_MIN}
              max={FONT_SIZE_MAX}
              step={FONT_SIZE_STEP}
            />
          </div>
        </div>
        
        {/* Color picker section */}
        <div className="dmt-text-editor-section">
          <label className="dmt-text-editor-label">Color</label>
          <div style={{ position: 'relative' }}>
            <button
              ref={colorBtnRef}
              className="dmt-text-editor-color-button"
              onClick={handleColorPickerToggle}
              style={{ backgroundColor: color }}
              title="Select text color"
            >
              <span className="dmt-text-editor-color-label">
                {color.toUpperCase()}
              </span>
            </button>
            
            {isColorPickerOpen && (
              <ColorPicker
                isOpen={isColorPickerOpen}
                selectedColor={color}
                onColorSelect={handleColorSelect}
                onClose={handleCloseColorPicker}
                onReset={handleColorReset}
                customColors={customColors}
                onAddCustomColor={handleAddCustomColor}
                onDeleteCustomColor={handleDeleteCustomColor}
                pendingCustomColorRef={pendingCustomColorRef}
                title="Text Color"
              />
            )}
          </div>
        </div>
        
        {/* Live Preview Toggle & Section */}
        {text.trim().length > 0 && (
          <div className="dmt-text-editor-section">
            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '4px' }}>
              <label className="dmt-text-editor-label">Preview</label>
              <button
                type="button"
                className="dmt-text-editor-preview-toggle"
                onClick={() => setShowPreview(!showPreview)}
                title={showPreview ? 'Hide preview' : 'Show preview'}
              >
                <dc.Icon icon="lucide-eye" />
              </button>
            </div>
            
            {showPreview && (
              <div 
                className="dmt-text-editor-preview"
                style={{
                  fontSize: `${fontSize}px`,
                  fontFamily: getFontOption(fontFace)?.css || 'sans-serif',
                  color: color,
                  textShadow: '-1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000'
                }}
              >
                {text}
              </div>
            )}
          </div>
        )}
        
        {/* Action buttons */}
        <div className="dmt-modal-buttons">
          <button 
            className="dmt-modal-btn dmt-modal-btn-cancel"
            onClick={onCancel}
          >
            Cancel
          </button>
          <button 
            className="dmt-modal-btn dmt-modal-btn-submit"
            onClick={handleSubmit}
            disabled={text.trim().length === 0}
          >
            {isEditing ? 'Update' : 'Add Label'}
          </button>
        </div>
        
        <div className="dmt-modal-hint">
          Press Enter to confirm, Esc to cancel
        </div>
      </div>
    </div>
  );
};

return { TextLabelEditor };
```

# TextLayer

```tsx
/**
 * TextLayer.tsx
 *
 * Handles all text label interactions:
 * - Text label placement
 * - Text label selection and dragging
 * - Text label rotation and editing
 * - Text label UI controls (rotate button, edit button)
 * - Text label modal
 */

import type { ToolId } from '#types/tools/tool.types';
import type { HexColor } from '#types/core/common.types';
import type { CustomColor } from '../ColorPicker.tsx';

const { useTextLabelInteraction } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useTextLabelInteraction"));
const { useMapState, useMapOperations } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext"));
const { useMapSelection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSelectionContext"));
const { TextLabelEditor } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "TextLabelEditor"));
const { useEventHandlerRegistration } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "EventHandlerContext"));
const { SelectionToolbar } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "SelectionToolbar"));
const { getActiveLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor"));
const { copyDeepLinkToClipboard } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "deepLinkHandler"));

/** Text label data structure */
interface TextLabel {
  id: string;
  content: string;
  fontSize?: number;
  fontFace?: string;
  color?: HexColor;
  rotation?: number;
  position: { x: number; y: number };
}

/** Props for TextLayer component */
export interface TextLayerProps {
  /** Current active tool */
  currentTool: ToolId;
  /** Custom colors array */
  customColors?: CustomColor[];
  /** Callback to add custom color */
  onAddCustomColor?: (color: HexColor) => void;
  /** Callback to delete custom color */
  onDeleteCustomColor?: (colorId: string) => void;
}

const TextLayer = ({
  currentTool,
  customColors,
  onAddCustomColor,
  onDeleteCustomColor
}: TextLayerProps): React.ReactElement | null => {
  const { mapData, mapId, notePath, canvasRef, containerRef, geometry } = useMapState();
  const { selectedItem, showCoordinates, layerVisibility, isDraggingSelection } = useMapSelection();

  const {
    showTextModal,
    editingTextId,
    handleTextPlacement,
    handleTextSelection,
    handleTextDragging,
    stopTextDragging,
    handleTextKeyDown,
    handleTextSubmit,
    handleTextCancel,
    handleRotateClick,
    handleEditClick,
    handleCanvasDoubleClick,
    handleTextRotation,
    handleTextDeletion
  } = useTextLabelInteraction(currentTool, onAddCustomColor, customColors);

  const { registerHandlers, unregisterHandlers } = useEventHandlerRegistration();

  const handleCopyLink = dc.useCallback(() => {
    if (!selectedItem || selectedItem.type !== 'text' || !mapData || !mapId || !notePath) return;

    const activeLayer = getActiveLayer(mapData);
    const label = activeLayer.textLabels?.find((l: TextLabel) => l.id === selectedItem.id);
    if (!label) return;

    const zoom = mapData.viewState?.zoom ?? 1.0;
    const layerId = mapData.activeLayerId || activeLayer?.id || 'layer_001';
    const displayText = label.content || 'Text';

    // Text labels use world coordinates, convert to grid
    const gridSize = mapData.gridSize || 32;
    const x = label.position.x / gridSize;
    const y = label.position.y / gridSize;

    copyDeepLinkToClipboard(displayText, notePath, mapId, x, y, zoom, layerId);
  }, [selectedItem, mapData, mapId, notePath]);

  dc.useEffect(() => {
    registerHandlers('text', {
      handleTextPlacement,
      handleTextSelection,
      handleTextDragging,
      stopTextDragging,
      handleCanvasDoubleClick,
      handleEditClick,
      handleTextKeyDown
    });

    return () => unregisterHandlers('text');
  }, [
    registerHandlers, unregisterHandlers,
    handleTextPlacement, handleTextSelection,
    handleTextDragging, stopTextDragging,
    handleCanvasDoubleClick, handleEditClick,
    handleTextKeyDown
  ]);

  if (showCoordinates || !layerVisibility.textLabels) {
    return null;
  }

  return (
    <>
      {selectedItem?.type === 'text' && !isDraggingSelection && (
        <SelectionToolbar
          selectedItem={selectedItem}
          mapData={mapData}
          canvasRef={canvasRef}
          containerRef={containerRef}
          geometry={geometry}
          onEdit={handleEditClick}
          onRotate={handleRotateClick}
          onCopyLink={handleCopyLink}
          onDelete={handleTextDeletion}
          isResizeMode={false}
          showColorPicker={false}
        />
      )}

      {showTextModal && (() => {
        let currentLabel: TextLabel | null = null;
        if (editingTextId && mapData?.textLabels) {
          currentLabel = getActiveLayer(mapData).textLabels.find((l: TextLabel) => l.id === editingTextId) || null;
        }

        const savedSettings = mapData?.lastTextLabelSettings as { fontSize?: number; fontFace?: string; color?: HexColor } | undefined;
        const defaultFontSize = currentLabel?.fontSize || savedSettings?.fontSize || 16;
        const defaultFontFace = currentLabel?.fontFace || savedSettings?.fontFace || 'sans';
        const defaultColor = currentLabel?.color || savedSettings?.color || '#ffffff';

        return (
          <TextLabelEditor
            initialValue={currentLabel?.content || ''}
            initialFontSize={defaultFontSize}
            initialFontFace={defaultFontFace}
            initialColor={defaultColor}
            isEditing={!!editingTextId}
            customColors={customColors || []}
            onAddCustomColor={onAddCustomColor}
            onDeleteCustomColor={onDeleteCustomColor}
            onSubmit={handleTextSubmit}
            onCancel={handleTextCancel}
          />
        );
      })()}
    </>
  );
};

return { TextLayer };

```

# useNotePinInteraction

```ts
/**
 * useNotePinInteraction.ts
 *
 * Custom hook for managing Note Pin interactions:
 * - Placement of Note Pin objects (click  place  modal  confirm/cancel)
 * - Note link management for all objects
 * - Modal state management
 * - Note Pin special behavior (inseparable from note)
 */

// Type-only imports
import type { ToolId } from '#types/tools/tool.types';
import type { ObjectTypeId, MapObject } from '#types/objects/object.types';
import type { MapData, MapLayer } from '#types/core/map.types';
import type {
  UseNotePinInteractionResult,
  JustSavedRef,
} from '#types/hooks/notePinInteraction.types';

// Datacore imports
const { useMapState, useMapOperations } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext")) as {
  useMapState: () => {
    mapData: MapData | null;
  };
  useMapOperations: () => {
    onObjectsChange: (objects: MapObject[]) => void;
    getObjectAtPosition: (objects: MapObject[], x: number, y: number) => MapObject | null;
    addObject: (objects: MapObject[], type: ObjectTypeId, x: number, y: number) => MapObject[];
    updateObject: (objects: MapObject[], id: string, updates: Partial<MapObject>) => MapObject[];
    removeObject: (objects: MapObject[], id: string) => MapObject[];
  };
};

const { useMapSelection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSelectionContext")) as {
  useMapSelection: () => {
    showNoteLinkModal: boolean;
    setShowNoteLinkModal: (show: boolean) => void;
    pendingNotePinId: string | null;
    setPendingNotePinId: (id: string | null) => void;
    editingNoteObjectId: string | null;
    setEditingNoteObjectId: (id: string | null) => void;
  };
};

const { getActiveLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor")) as {
  getActiveLayer: (mapData: MapData) => MapLayer;
};

/**
 * Hook for managing note pin interactions
 */
const useNotePinInteraction = (
  currentTool: ToolId,
  selectedObjectType: ObjectTypeId | null
): UseNotePinInteractionResult => {
  // Get all required state and operations from Context
  const { mapData } = useMapState();

  const {
    onObjectsChange,
    getObjectAtPosition,
    addObject,
    updateObject,
    removeObject
  } = useMapOperations();

  const {
    showNoteLinkModal,
    setShowNoteLinkModal,
    pendingNotePinId,
    setPendingNotePinId,
    editingNoteObjectId,
    setEditingNoteObjectId
  } = useMapSelection();

  // Track if we just saved (to prevent race condition with cancel)
  const justSavedRef = dc.useRef<boolean>(false) as JustSavedRef;

  /**
   * Handle Note Pin placement - places pin and opens modal
   */
  const handleNotePinPlacement = (gridX: number, gridY: number): boolean => {
    if (currentTool !== 'addObject' || selectedObjectType !== 'note_pin') {
      return false;
    }

    if (!mapData) return false;

    // Check if position is occupied
    const existingObj = getObjectAtPosition(getActiveLayer(mapData).objects || [], gridX, gridY);
    if (existingObj) {
      return true; // Handled but blocked
    }

    // Place the Note Pin object (without linkedNote initially)
    const newObjects = addObject(getActiveLayer(mapData).objects || [], 'note_pin', gridX, gridY);

    // Find the newly created pin
    const newPin = newObjects[newObjects.length - 1];

    // Reset save flag for new interaction
    justSavedRef.current = false;

    // Store its ID and open modal
    setPendingNotePinId(newPin.id);
    setShowNoteLinkModal(true);

    // Update map with new pin
    onObjectsChange(newObjects);

    return true;
  };

  /**
   * Handle note link save from modal
   * Special behavior for Note Pins vs regular objects
   */
  const handleNoteLinkSave = (notePath: string | null): void => {
    if (!mapData) return;

    // Mark that we're saving (not canceling)
    justSavedRef.current = true;

    let updatedObjects: MapObject[];

    // Determine which object we're working with
    const objectId = pendingNotePinId || editingNoteObjectId;
    if (!objectId) return;

    const object = getActiveLayer(mapData).objects?.find(obj => obj.id === objectId);
    if (!object) return;

    const isNotePin = object.type === 'note_pin';

    // Handle based on object type and whether note is being added or removed
    if (!notePath || !notePath.trim()) {
      // Removing note link
      if (isNotePin) {
        // Note Pins are inseparable from notes - remove the entire pin
        updatedObjects = removeObject(getActiveLayer(mapData).objects, objectId);
      } else {
        // Regular objects - just clear the linkedNote field
        updatedObjects = updateObject(getActiveLayer(mapData).objects, objectId, { linkedNote: null });
      }
    } else {
      // Adding/updating note link
      updatedObjects = updateObject(getActiveLayer(mapData).objects, objectId, { linkedNote: notePath });
    }

    onObjectsChange(updatedObjects);

    // Close modal and clear state
    setShowNoteLinkModal(false);
    setPendingNotePinId(null);
    setEditingNoteObjectId(null);
  };

  /**
   * Handle note link modal cancellation
   * If canceling a pending Note Pin, remove it entirely
   */
  const handleNoteLinkCancel = (): void => {
    // If we just saved, don't remove the object (modal calls both onSave and onClose)
    if (justSavedRef.current) {
      justSavedRef.current = false; // Reset for next time
      return;
    }

    if (pendingNotePinId && mapData) {
      // Remove the pending Note Pin since user canceled
      const updatedObjects = removeObject(getActiveLayer(mapData).objects, pendingNotePinId);
      onObjectsChange(updatedObjects);
    }

    // Close modal and clear state
    setShowNoteLinkModal(false);
    setPendingNotePinId(null);
    setEditingNoteObjectId(null);
  };

  /**
   * Handle edit note link button click for existing objects
   */
  const handleEditNoteLink = (objectId: string): void => {
    if (!objectId) return;

    // Reset save flag for new interaction
    justSavedRef.current = false;

    setEditingNoteObjectId(objectId);
    setShowNoteLinkModal(true);
  };

  return {
    handleNotePinPlacement,
    handleNoteLinkSave,
    handleNoteLinkCancel,
    handleEditNoteLink
  };
};

return { useNotePinInteraction };

```

# NotePinLayer

```tsx
/**
 * NotePinLayer.tsx
 *
 * Handles note pin placement interactions:
 * - Places note_pin objects on click
 * - Opens note link modal for new pins
 * - Handles save/cancel for pending note pins
 *
 * Note: Editing note links on existing objects (including note_pins)
 * is handled by ObjectLayer via the "link note" button
 */

import type { ToolId } from '#types/tools/tool.types';
import type { ObjectTypeId } from '#types/objects/object.types';

const { useNotePinInteraction } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useNotePinInteraction"));
const { useMapState, useMapOperations } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext"));
const { useMapSelection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSelectionContext"));
const { NoteLinkModal } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "NoteLinkModal"));
const { useEventHandlerRegistration } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "EventHandlerContext"));

/** Props for NotePinLayer component */
export interface NotePinLayerProps {
  /** Current active tool */
  currentTool: ToolId;
  /** Currently selected object type */
  selectedObjectType: ObjectTypeId | null;
}

const NotePinLayer = ({
  currentTool,
  selectedObjectType
}: NotePinLayerProps): React.ReactElement | null => {
  const { mapData } = useMapState();
  const {
    showNoteLinkModal,
    pendingNotePinId,
    showCoordinates
  } = useMapSelection();

  const {
    handleNotePinPlacement,
    handleNoteLinkSave,
    handleNoteLinkCancel,
    handleEditNoteLink
  } = useNotePinInteraction(currentTool, selectedObjectType);

  const { registerHandlers, unregisterHandlers } = useEventHandlerRegistration();

  dc.useEffect(() => {
    registerHandlers('notePin', {
      handleNotePinPlacement
    });

    return () => unregisterHandlers('notePin');
  }, [registerHandlers, unregisterHandlers, handleNotePinPlacement]);

  if (showCoordinates) {
    return null;
  }

  return (
    <>
      {showNoteLinkModal && pendingNotePinId && mapData && (
        <NoteLinkModal
          isOpen={showNoteLinkModal}
          onClose={handleNoteLinkCancel}
          onSave={handleNoteLinkSave}
          currentNotePath={
            mapData.objects?.find((obj: { id: string }) => obj.id === pendingNotePinId)?.linkedNote || null
          }
          objectType="note_pin"
        />
      )}
    </>
  );
};

return { NotePinLayer };

```

# HexCoordinateLayer

```jsx
/**
 * HexCoordinateLayer.jsx
 * Renders coordinate labels inside each visible hex
 * Supports two modes:
 * - Rectangular: A1, B2, etc. (column-row)
 * - Radial: 0, 1-1, 2-5, etc. (ring-position from center)
 * 
 * Uses HTML overlay positioned via viewport transforms (no canvas rendering)
 * Only renders for hex maps when showCoordinates is true (toggled by 'C' key)
 */

const { useMapState } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext"));
const { useMapSelection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSelectionContext"));
const { axialToOffset, offsetToAxial, columnToLabel, rowToLabel } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "offsetCoordinates"));
const { getEffectiveSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsAccessor"));

/**
 * Calculate the ring (distance from origin) for a hex in axial coordinates
 * Ring 0 = center, Ring 1 = 6 adjacent hexes, Ring 2 = 12 hexes, etc.
 * @param {number} q - Axial q coordinate
 * @param {number} r - Axial r coordinate
 * @returns {number} Ring number (0 = center)
 */
function getHexRing(q, r) {
  // Hex distance formula: (|q| + |q + r| + |r|) / 2
  return (Math.abs(q) + Math.abs(q + r) + Math.abs(r)) / 2;
}

/**
 * Check if a world-space point is inside a flat-topped regular hexagon
 * Used for creating flat-topped radial coordinate boundaries
 * A flat-topped hexagon has flat edges at top/bottom and pointed vertices at left/right
 * @param {number} wx - World X coordinate relative to hexagon center
 * @param {number} wy - World Y coordinate relative to hexagon center  
 * @param {number} circumradius - Distance from center to vertex
 * @returns {boolean} True if point is inside the hexagon
 */
function isInsideFlatToppedHexagon(wx, wy, circumradius) {
  const dx = Math.abs(wx);
  const dy = Math.abs(wy);
  const sqrt3 = Math.sqrt(3);
  
  // Flat-topped hexagon constraints:
  // 1. Top/bottom flat edges: |y| <= inradius (R * sqrt(3)/2)
  // 2. Four diagonal edges: |x| + |y|/sqrt(3) <= R
  const inradius = circumradius * sqrt3 / 2;
  return dy <= inradius && dx + dy / sqrt3 <= circumradius;
}

/**
 * Calculate position within a ring (1-indexed, clockwise from north)
 * @param {number} q - Axial q coordinate (relative to center)
 * @param {number} r - Axial r coordinate (relative to center)
 * @param {number} ring - The ring number
 * @returns {number} Position within ring (1 to 6*ring), or 0 for center
 */
function getPositionInRing(q, r, ring) {
  if (ring === 0) return 0;
  
  // The ring is divided into 6 edges, each with 'ring' hexes
  // We traverse clockwise starting from the "north" hex (0, -ring)
  
  // Direction vectors for traversing each edge of the ring clockwise
  // These move along the ring, not toward center
  const directions = [
    { dq: 1, dr: 0 },   // Edge 0: E (moving from N toward NE corner)
    { dq: 0, dr: 1 },   // Edge 1: SE (moving from NE toward SE corner)
    { dq: -1, dr: 1 },  // Edge 2: SW (moving from SE toward S corner)
    { dq: -1, dr: 0 },  // Edge 3: W (moving from S toward SW corner)
    { dq: 0, dr: -1 },  // Edge 4: NW (moving from SW toward NW corner)
    { dq: 1, dr: -1 }   // Edge 5: NE (moving from NW back toward N)
  ];
  
  // Starting hex of the ring (top/north hex): q=0, r=-ring
  let currentQ = 0;
  let currentR = -ring;
  let position = 1;
  
  for (let edge = 0; edge < 6; edge++) {
    for (let step = 0; step < ring; step++) {
      if (currentQ === q && currentR === r) {
        return position;
      }
      currentQ += directions[edge].dq;
      currentR += directions[edge].dr;
      position++;
    }
  }
  
  // Should not reach here for valid ring hexes
  return position;
}

/**
 * Calculate visible hexes with screen positions (in display coordinates)
 * Supports both rectangular and radial display modes
 * @param {Object} geometry - HexGeometry instance
 * @param {Object} mapData - Map data with viewState
 * @param {HTMLCanvasElement} canvas - Canvas element
 * @param {string} displayMode - 'rectangular' or 'radial'
 * @returns {{hexes: Array<{col, row, q, r, displayX, displayY, label}>, scaleX: number, scaleY: number}} Visible hexes with display positions and scale factors
 */
function getVisibleHexes(geometry, mapData, canvas, displayMode = 'rectangular') {
  if (!canvas || !geometry || !mapData) return { hexes: [], scaleX: 1, scaleY: 1 };
  
  const { viewState, northDirection } = mapData;
  const { zoom, center } = viewState;
  
  // Calculate offset from center (hex maps use world pixel coordinates for center)
  const offsetX = canvas.width / 2 - center.x * zoom;
  const offsetY = canvas.height / 2 - center.y * zoom;
  
  // Get canvas display rect for coordinate scaling
  const rect = canvas.getBoundingClientRect();
  const containerRect = canvas.parentElement?.getBoundingClientRect() || rect;
  
  // Calculate canvas offset within container (due to flex centering)
  const canvasOffsetX = rect.left - containerRect.left;
  const canvasOffsetY = rect.top - containerRect.top;
  
  // Scale factors from canvas internal to display coordinates
  const scaleX = rect.width / canvas.width;
  const scaleY = rect.height / canvas.height;
  
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  
  // Helper to convert axial coords to display position
  const getDisplayPosition = (q, r) => {
    const { worldX, worldY } = geometry.hexToWorld(q, r);
    
    let screenX = offsetX + worldX * zoom;
    let screenY = offsetY + worldY * zoom;
    
    // Apply rotation if north direction is set
    if (northDirection !== 0) {
      const relX = screenX - centerX;
      const relY = screenY - centerY;
      
      const angleRad = (northDirection * Math.PI) / 180;
      const rotatedX = relX * Math.cos(angleRad) - relY * Math.sin(angleRad);
      const rotatedY = relX * Math.sin(angleRad) + relY * Math.cos(angleRad);
      
      screenX = centerX + rotatedX;
      screenY = centerY + rotatedY;
    }
    
    // Check if on screen
    const padding = 50;
    if (screenX < -padding || screenX > canvas.width + padding ||
        screenY < -padding || screenY > canvas.height + padding) {
      return null;
    }
    
    // Convert to display coordinates (CSS pixels)
    return {
      displayX: (screenX * scaleX) + canvasOffsetX,
      displayY: (screenY * scaleY) + canvasOffsetY
    };
  };
  
  const visibleHexes = [];
  
  if (displayMode === 'radial') {
    // Radial mode: iterate all hexes in bounds, check flat-topped hexagonal containment
    const hexBounds = mapData.hexBounds || { maxCol: 26, maxRow: 20 };
    
    // Calculate max radius based on smaller dimension (so pattern fits in bounds)
    const maxRadius = Math.floor(Math.min(hexBounds.maxCol, hexBounds.maxRow) / 2);
    
    // Use the center hex for both boundary and labeling (ensures consistency)
    const centerCol = Math.floor((hexBounds.maxCol - 1) / 2);
    const centerRow = Math.floor((hexBounds.maxRow - 1) / 2);
    const { q: centerQ, r: centerR } = offsetToAxial(centerCol, centerRow, geometry.orientation);
    
    // Get center position in world coordinates
    const centerWorld = geometry.hexToWorld(centerQ, centerR);
    
    // Calculate circumradius for flat-topped hexagonal boundary
    // The world-space distance to a ring boundary is ring * sqrt(3) * hexSize
    const sqrt3 = Math.sqrt(3);
    const circumradius = maxRadius * sqrt3 * geometry.hexSize;
    
    // Iterate all hexes in rectangular bounds
    for (let col = 0; col < hexBounds.maxCol; col++) {
      for (let row = 0; row < hexBounds.maxRow; row++) {
        const { q, r } = offsetToAxial(col, row, geometry.orientation);
        
        // Get this hex's world position relative to center
        const hexWorld = geometry.hexToWorld(q, r);
        const relWorldX = hexWorld.worldX - centerWorld.worldX;
        const relWorldY = hexWorld.worldY - centerWorld.worldY;
        
        // Check if inside flat-topped hexagonal boundary
        if (!isInsideFlatToppedHexagon(relWorldX, relWorldY, circumradius)) {
          continue;
        }
        
        // Calculate ring using hex distance from same center
        const dq = q - centerQ;
        const dr = r - centerR;
        const ring = getHexRing(dq, dr);
        
        const pos = getDisplayPosition(q, r);
        if (!pos) continue;
        
        // Calculate position within ring
        let label;
        if (ring === 0) {
          label = "";
        } else {
          const position = getPositionInRing(dq, dr, ring);
          label = `${ring}-${position}`;
        }
        
        visibleHexes.push({ 
          col, row, q, r, 
          displayX: pos.displayX, 
          displayY: pos.displayY,
          label 
        });
      }
    }
  } else {
    // Rectangular mode: iterate by offset coordinates within bounds
    const { minQ, maxQ, minR, maxR } = geometry.getVisibleHexRange(
      offsetX, offsetY, canvas.width, canvas.height, zoom
    );
    
    // Convert axial visible range to offset bounds
    const offsetCorners = [];
    for (let q = minQ; q <= maxQ; q += (maxQ - minQ) || 1) {
      for (let r = minR; r <= maxR; r += (maxR - minR) || 1) {
        offsetCorners.push(axialToOffset(q, r, geometry.orientation));
      }
    }
    
    const minCol = Math.min(...offsetCorners.map(c => c.col));
    const maxCol = Math.max(...offsetCorners.map(c => c.col));
    const minRow = Math.min(...offsetCorners.map(c => c.row));
    const maxRow = Math.max(...offsetCorners.map(c => c.row));
    
    for (let col = minCol; col <= maxCol; col++) {
      for (let row = minRow; row <= maxRow; row++) {
        const { q, r } = offsetToAxial(col, row, geometry.orientation);
        
        // Check if within map bounds (if bounds are set)
        if (!geometry.isWithinBounds(q, r)) continue;
        
        const pos = getDisplayPosition(q, r);
        if (!pos) continue;
        
        const label = columnToLabel(col) + rowToLabel(row);
        
        visibleHexes.push({ 
          col, row, q, r, 
          displayX: pos.displayX, 
          displayY: pos.displayY,
          label 
        });
      }
    }
  }
  
  return { hexes: visibleHexes, scaleX, scaleY };
}

/**
 * HexCoordinateLayer Component
 * Renders coordinate labels over visible hexes
 * Reads display mode settings from mapData.settings
 */
const HexCoordinateLayer = () => {
  // Get shared state from contexts
  const { canvasRef, mapData, geometry } = useMapState();
  const { showCoordinates, layerVisibility } = useMapSelection();
  
  // C key (showCoordinates) overrides layerVisibility - if C is pressed, always show
  // Otherwise, respect the toolbar visibility setting
  const effectiveVisible = showCoordinates || layerVisibility.hexCoordinates;
  
  // Don't render if not effectively visible or not a hex map
  if (!effectiveVisible || !geometry || !mapData || mapData.mapType !== 'hex') {
    return null;
  }
  
  const canvas = canvasRef.current;
  if (!canvas) return null;
  
  // Get coordinate display settings from map settings (with defaults)
  const displayMode = mapData.settings?.coordinateDisplayMode || 'rectangular';
  
  // Get effective color settings (merges global with map-specific overrides)
  const effectiveSettings = getEffectiveSettings(mapData.settings);
  const textColor = effectiveSettings.coordinateTextColor || '#ffffff';
  const shadowColor = effectiveSettings.coordinateTextShadow || '#000000';
  
  // Calculate visible hexes with display positions and labels
  const { hexes: visibleHexes, scaleX } = getVisibleHexes(
    geometry, mapData, canvas, displayMode
  );
  
  // Calculate font size based on hex size and zoom, scaled to display coordinates
  const zoom = mapData.viewState.zoom;
  const hexSize = geometry.hexSize;
  const canvasFontSize = hexSize * zoom * 0.35;
  const fontSize = Math.max(8, Math.min(24, canvasFontSize * scaleX));
  
  // Determine if we should fade labels slightly (at very low zoom)
  const shouldFade = zoom < 0.4;
  const baseOpacity = shouldFade ? 0.7 : 0.85;
  
  // Generate text-shadow CSS for readability
  const textShadow = `
    -1px -1px 0 ${shadowColor},
    1px -1px 0 ${shadowColor},
    -1px 1px 0 ${shadowColor},
    1px 1px 0 ${shadowColor},
    0 0 4px ${shadowColor},
    0 0 8px ${shadowColor}
  `.trim();
  
  return (
    <div className="dmt-coordinate-layer">
      {visibleHexes.map(({ q, r, displayX, displayY, label }) => {
        return (
          <div
            key={`coord-${q}-${r}`}
            className="dmt-hex-coordinate"
            style={{
              position: 'absolute',
              left: `${displayX}px`,
              top: `${displayY}px`,
              transform: 'translate(-50%, -50%)',
              fontSize: `${fontSize}px`,
              opacity: baseOpacity,
              color: textColor,
              textShadow: textShadow
            }}
          >
            {label}
          </div>
        );
      })}
    </div>
  );
};

return { HexCoordinateLayer };
```

# useDistanceMeasurement

```ts
/**
 * useDistanceMeasurement.ts
 *
 * Hook for distance measurement tool state and calculations.
 * Handles origin selection, live distance updates, and formatting.
 * Supports both mouse (live updates) and touch (tap-to-tap) modes.
 */

// Type-only imports
import type { MapType } from '#types/core/map.types';
import type { IGeometry, DistanceOptions } from '#types/core/geometry.types';
import type { ToolId } from '#types/tools/tool.types';
import type { PluginSettings, DiagonalRule, DistanceDisplayFormat } from '#types/settings/settings.types';
import type {
  MeasurementPoint,
  EffectiveDistanceSettings,
  MapDistanceOverrides,
  UseDistanceMeasurementResult,
} from '#types/hooks/distanceMeasurement.types';

// Datacore imports
const { formatDistance, getEffectiveDistanceSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "distanceOperations")) as {
  formatDistance: (distance: number, distancePerCell: number, unit: string, format: DistanceDisplayFormat) => string;
  getEffectiveDistanceSettings: (mapType: MapType, globalSettings: PluginSettings, overrides: MapDistanceOverrides | null) => EffectiveDistanceSettings;
};

/**
 * Hook for managing distance measurement state
 */
const useDistanceMeasurement = (
  currentTool: ToolId,
  geometry: IGeometry | null,
  mapType: MapType,
  globalSettings: PluginSettings,
  mapDistanceOverrides: MapDistanceOverrides | null
): UseDistanceMeasurementResult => {
  const [measureOrigin, setMeasureOrigin] = dc.useState<MeasurementPoint | null>(null);
  const [currentDistance, setCurrentDistance] = dc.useState<number | null>(null);
  const [currentTarget, setCurrentTarget] = dc.useState<MeasurementPoint | null>(null);
  const [isTargetLocked, setIsTargetLocked] = dc.useState<boolean>(false);

  const distanceSettings = dc.useMemo((): EffectiveDistanceSettings => {
    return getEffectiveDistanceSettings(mapType, globalSettings, mapDistanceOverrides);
  }, [mapType, globalSettings, mapDistanceOverrides]);

  dc.useEffect(() => {
    if (currentTool !== 'measure') {
      setMeasureOrigin(null);
      setCurrentDistance(null);
      setCurrentTarget(null);
      setIsTargetLocked(false);
    }
  }, [currentTool]);

  /**
   * Calculate distance between origin and a target point
   */
  const calculateDistance = dc.useCallback(
    (targetX: number, targetY: number): number => {
      if (!measureOrigin || !geometry) return 0;

      return geometry.getCellDistance(
        measureOrigin.x, measureOrigin.y,
        targetX, targetY,
        { diagonalRule: distanceSettings.gridDiagonalRule } as DistanceOptions
      );
    },
    [measureOrigin, geometry, distanceSettings.gridDiagonalRule]
  );

  /**
   * Handle click/tap - behavior depends on current state and input type
   */
  const handleMeasureClick = dc.useCallback(
    (cellX: number, cellY: number, isTouch: boolean = false): void => {
      if (!measureOrigin) {
        setMeasureOrigin({ x: cellX, y: cellY });
        setCurrentTarget({ x: cellX, y: cellY });
        setCurrentDistance(0);
        setIsTargetLocked(false);
      } else if (isTouch && !isTargetLocked) {
        // Touch: second tap sets and locks target
        setCurrentTarget({ x: cellX, y: cellY });
        setCurrentDistance(calculateDistance(cellX, cellY));
        setIsTargetLocked(true);
      } else {
        // Mouse: second click clears
        // Touch: third tap (after target locked) clears
        setMeasureOrigin(null);
        setCurrentDistance(null);
        setCurrentTarget(null);
        setIsTargetLocked(false);
      }
    },
    [measureOrigin, isTargetLocked, calculateDistance]
  );

  /**
   * Handle cursor move - update live distance (mouse only, not when locked)
   */
  const handleMeasureMove = dc.useCallback(
    (cellX: number, cellY: number): void => {
      if (!measureOrigin || isTargetLocked || !geometry) return;

      setCurrentTarget({ x: cellX, y: cellY });
      setCurrentDistance(calculateDistance(cellX, cellY));
    },
    [measureOrigin, isTargetLocked, geometry, calculateDistance]
  );

  /**
   * Get formatted distance string
   */
  const formattedDistance = dc.useMemo((): string | null => {
    if (currentDistance === null) return null;

    return formatDistance(
      currentDistance,
      distanceSettings.distancePerCell,
      distanceSettings.distanceUnit,
      distanceSettings.displayFormat
    );
  }, [currentDistance, distanceSettings]);

  /**
   * Clear measurement manually
   */
  const clearMeasurement = dc.useCallback((): void => {
    setMeasureOrigin(null);
    setCurrentDistance(null);
    setCurrentTarget(null);
    setIsTargetLocked(false);
  }, []);

  return {
    measureOrigin,
    currentTarget,
    currentDistance,
    formattedDistance,
    distanceSettings,
    isTargetLocked,
    handleMeasureClick,
    handleMeasureMove,
    clearMeasurement
  };
};

return { useDistanceMeasurement };

```

# MeasurementOverlay

```jsx
/**
 * MeasurementOverlay.jsx
 * 
 * Visual overlay for distance measurement tool.
 * Draws a dashed line from origin to current cursor position
 * and displays the calculated distance in an auto-sized tooltip
 * anchored near the target cell.
 */

const { GridGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "GridGeometry"));

/**
 * Convert cell coordinates to screen coordinates
 * Uses the same calculation pattern as DrawingLayer and useCanvasRenderer
 * 
 * @param {number} cellX - Cell X coordinate
 * @param {number} cellY - Cell Y coordinate
 * @param {Object} geometry - GridGeometry or HexGeometry instance
 * @param {Object} mapData - Map data containing viewState
 * @param {number} canvasWidth - Canvas width in pixels
 * @param {number} canvasHeight - Canvas height in pixels
 * @returns {{x: number, y: number}} Screen coordinates
 */
function cellToScreen(cellX, cellY, geometry, mapData, canvasWidth, canvasHeight) {
  const { zoom, center } = mapData.viewState;
  const northDirection = mapData.northDirection || 0;
  
  // Get cell center in world coordinates
  let worldX, worldY;
  if (geometry.getCellCenter) {
    const cellCenter = geometry.getCellCenter(cellX, cellY);
    worldX = cellCenter.worldX;
    worldY = cellCenter.worldY;
  } else if (geometry.getHexCenter) {
    const hexCenter = geometry.getHexCenter(cellX, cellY);
    worldX = hexCenter.worldX;
    worldY = hexCenter.worldY;
  } else {
    worldX = cellX;
    worldY = cellY;
  }
  
  // Calculate offset based on geometry type (same as useCanvasRenderer)
  let offsetX, offsetY;
  if (geometry instanceof GridGeometry) {
    const scaledCellSize = geometry.getScaledCellSize(zoom);
    offsetX = canvasWidth / 2 - center.x * scaledCellSize;
    offsetY = canvasHeight / 2 - center.y * scaledCellSize;
  } else {
    // HexGeometry: center is in world pixel coordinates
    offsetX = canvasWidth / 2 - center.x * zoom;
    offsetY = canvasHeight / 2 - center.y * zoom;
  }
  
  // Convert world to screen
  let screenX = offsetX + worldX * zoom;
  let screenY = offsetY + worldY * zoom;
  
  // Apply rotation if needed
  if (northDirection !== 0) {
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;
    
    screenX -= centerX;
    screenY -= centerY;
    
    const angleRad = (northDirection * Math.PI) / 180;
    const rotatedX = screenX * Math.cos(angleRad) - screenY * Math.sin(angleRad);
    const rotatedY = screenX * Math.sin(angleRad) + screenY * Math.cos(angleRad);
    
    screenX = rotatedX + centerX;
    screenY = rotatedY + centerY;
  }
  
  return { x: screenX, y: screenY };
}

const MeasurementOverlay = ({
  measureOrigin,
  currentTarget,
  formattedDistance,
  isTargetLocked = false,
  geometry,
  mapData,
  canvasRef
}) => {
  const textRef = dc.useRef(null);
  const [textWidth, setTextWidth] = dc.useState(80);
  
  // Measure text width for auto-sizing tooltip
  dc.useEffect(() => {
    if (textRef.current && formattedDistance) {
      const bbox = textRef.current.getBBox();
      setTextWidth(Math.max(bbox.width + 20, 60));
    }
  }, [formattedDistance]);
  
  if (!measureOrigin || !currentTarget || !geometry || !mapData || !canvasRef?.current) {
    return null;
  }
  
  // Get canvas dimensions (same approach as DrawingLayer)
  const canvas = canvasRef.current;
  const { width: canvasWidth, height: canvasHeight } = canvas;
  const canvasRect = canvas.getBoundingClientRect();
  const displayScale = canvasRect.width / canvasWidth;
  
  // Find the flex container (dmt-canvas-container) that the SVG is positioned relative to
  // Canvas may be nested inside wrapper divs, so traverse up to find the actual container
  let flexContainer = canvas.parentElement;
  let traversalCount = 0;
  while (flexContainer?.classList && !flexContainer.classList.contains('dmt-canvas-container')) {
    flexContainer = flexContainer.parentElement;
    traversalCount++;
    if (traversalCount > 10) {
      console.warn('[MeasurementOverlay] Could not find dmt-canvas-container after 10 levels');
      break;
    }
  }
  const containerRect = flexContainer?.getBoundingClientRect();
  const canvasOffsetX = containerRect ? canvasRect.left - containerRect.left : 0;
  const canvasOffsetY = containerRect ? canvasRect.top - containerRect.top : 0;

  // Calculate screen coordinates for origin and target
  const originScreen = cellToScreen(
    measureOrigin.x, measureOrigin.y,
    geometry, mapData, canvasWidth, canvasHeight
  );
  const targetScreen = cellToScreen(
    currentTarget.x, currentTarget.y,
    geometry, mapData, canvasWidth, canvasHeight
  );
  
  // Apply display scale and canvas offset (canvas may be offset within container due to sidebar)
  const scaledOrigin = {
    x: originScreen.x * displayScale + canvasOffsetX,
    y: originScreen.y * displayScale + canvasOffsetY
  };
  const scaledTarget = {
    x: targetScreen.x * displayScale + canvasOffsetX,
    y: targetScreen.y * displayScale + canvasOffsetY
  };

  const tooltipX = scaledTarget.x + 15;
  const tooltipY = scaledTarget.y - 30;
  
  return (
    <svg 
      className="dmt-measurement-overlay"
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
        zIndex: 100,
        overflow: 'visible'
      }}
    >
      {/* Measurement line - solid when locked, dashed when live */}
      <line
        x1={scaledOrigin.x}
        y1={scaledOrigin.y}
        x2={scaledTarget.x}
        y2={scaledTarget.y}
        stroke="#c4a57b"
        strokeWidth={2}
        strokeDasharray={isTargetLocked ? "none" : "8,4"}
        strokeLinecap="round"
      />
      
      {/* Origin marker */}
      <circle
        cx={scaledOrigin.x}
        cy={scaledOrigin.y}
        r={8}
        fill="rgba(196, 165, 123, 0.8)"
        stroke="#c4a57b"
        strokeWidth={2}
      />
      
      {/* Target marker - larger and more opaque when locked */}
      <circle
        cx={scaledTarget.x}
        cy={scaledTarget.y}
        r={isTargetLocked ? 6 : 5}
        fill={isTargetLocked ? "rgba(196, 165, 123, 0.9)" : "rgba(196, 165, 123, 0.6)"}
        stroke="#c4a57b"
        strokeWidth={isTargetLocked ? 2 : 1.5}
      />
      
      {/* Distance tooltip */}
      {formattedDistance && (
        <g transform={`translate(${tooltipX}, ${tooltipY})`}>
          <rect
            x={0}
            y={-14}
            width={textWidth}
            height={28}
            rx={4}
            fill="rgba(26, 26, 26, 0.95)"
            stroke="#c4a57b"
            strokeWidth={1}
          />
          <text
            ref={textRef}
            x={textWidth / 2}
            y={5}
            textAnchor="middle"
            fill="#ffffff"
            fontSize={13}
            fontFamily="var(--font-interface, -apple-system, BlinkMacSystemFont, sans-serif)"
            fontWeight="500"
          >
            {formattedDistance}
          </text>
        </g>
      )}
    </svg>
  );
};

return { MeasurementOverlay };
```

# MeasurementLayer

```tsx
/**
 * MeasurementLayer.tsx
 *
 * Layer component for distance measurement tool.
 * Combines the measurement hook, overlay rendering, and event handler registration.
 */

import type { ToolId } from '#types/tools/tool.types';
import type { EffectiveDistanceSettings } from '#types/hooks/distanceMeasurement.types';

const { useDistanceMeasurement } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useDistanceMeasurement"));
const { MeasurementOverlay } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MeasurementOverlay"));
const { useMapState } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext"));
const { useEventHandlerRegistration } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "EventHandlerContext"));

/** Props for MeasurementLayer component */
export interface MeasurementLayerProps {
  /** Current active tool */
  currentTool: ToolId;
  /** Global plugin settings */
  globalSettings?: Record<string, unknown>;
  /** Per-map distance setting overrides */
  mapDistanceOverrides?: Partial<EffectiveDistanceSettings>;
}

const MeasurementLayer = ({
  currentTool,
  globalSettings,
  mapDistanceOverrides
}: MeasurementLayerProps): React.ReactElement | null => {
  const {
    mapData,
    geometry,
    canvasRef
  } = useMapState();

  const mapType = mapData?.mapType || 'grid';

  const {
    measureOrigin,
    currentTarget,
    formattedDistance,
    isTargetLocked,
    handleMeasureClick,
    handleMeasureMove,
    clearMeasurement
  } = useDistanceMeasurement(
    currentTool,
    geometry,
    mapType,
    globalSettings,
    mapDistanceOverrides
  );

  const { registerHandlers, unregisterHandlers } = useEventHandlerRegistration();

  dc.useEffect(() => {
    registerHandlers('measure', {
      handleMeasureClick,
      handleMeasureMove,
      clearMeasurement,
      measureOrigin
    });
    return () => unregisterHandlers('measure');
  }, [registerHandlers, unregisterHandlers, handleMeasureClick, handleMeasureMove, clearMeasurement, measureOrigin]);

  if (currentTool !== 'measure' || !measureOrigin) {
    return null;
  }

  return (
    <MeasurementOverlay
      measureOrigin={measureOrigin}
      currentTarget={currentTarget}
      formattedDistance={formattedDistance}
      isTargetLocked={isTargetLocked}
      geometry={geometry}
      mapData={mapData}
      canvasRef={canvasRef}
    />
  );
};

return { MeasurementLayer };

```

# diagonalFillOperations

```ts
/**
 * diagonalFillOperations.ts
 * 
 * Pure functions for diagonal fill tool operations.
 * Handles corner detection, concave corner validation, and path calculation
 * for filling gaps along staircase diagonals.
 * 
 * COORDINATE SYSTEM:
 * - Cell coordinates: Integer (x, y) grid positions
 * - Local coordinates: 0-1 within cell, (0,0) = top-left, (1,1) = bottom-right
 * - Corners: TL (top-left), TR (top-right), BR (bottom-right), BL (bottom-left)
 */

// Type-only imports
import type { Point } from '#types/core/geometry.types';
import type { Cell, CellMap, SegmentGridCell, SegmentName } from '#types/core/cell.types';
import type { IGeometry } from '#types/core/geometry.types';
import type { 
  CornerName, 
  NeighborOffset,
  DiagonalDirection 
} from './dmtConstants';

// Datacore imports
const {
  CORNER_SEGMENT_FILL,
  CORNER_NEIGHBOR_CHECKS,
  CORNER_DIAGONAL_DIRECTION
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants")) as {
  CORNER_SEGMENT_FILL: Record<CornerName, SegmentName[]>;
  CORNER_NEIGHBOR_CHECKS: Record<CornerName, NeighborOffset[]>;
  CORNER_DIAGONAL_DIRECTION: Record<CornerName, DiagonalDirection>;
};

const {
  buildCellMap,
  isSimpleCell,
  hasSegments
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "cellAccessor")) as {
  buildCellMap: (cells: Cell[], geometry: IGeometry) => CellMap;
  isSimpleCell: (cell: Cell) => boolean;
  hasSegments: (cell: Cell) => cell is SegmentGridCell;
};

// ===========================================
// Type Definitions
// ===========================================

/** Local position within a cell (0-1 range) */
export interface LocalPosition {
  localX: number;
  localY: number;
}

/** Valid corner result with coordinates */
export interface ValidCornerResult {
  x: number;
  y: number;
  corner: CornerName;
}

/** Color inheritance result */
export interface InheritedColor {
  color: string;
  opacity: number;
}

/** Diagonal path validation result */
export interface DiagonalPathValidation {
  valid: boolean;
  endX: number;
  endY: number;
  cellCount: number;
}

/** Start point for diagonal fill */
export interface DiagonalStartPoint {
  x: number;
  y: number;
  corner: CornerName;
}

// ===========================================
// Corner Detection
// ===========================================

/**
 * Determine which corner of a cell is nearest to a local position
 */
function getNearestCorner(localX: number, localY: number): CornerName {
  const isLeft = localX < 0.5;
  const isTop = localY < 0.5;
  
  if (isTop && isLeft) return 'TL';
  if (isTop && !isLeft) return 'TR';
  if (!isTop && !isLeft) return 'BR';
  return 'BL';
}

/**
 * Calculate local position within a cell from screen/world coordinates
 */
function getLocalPosition(
  worldX: number,
  worldY: number,
  cellX: number,
  cellY: number,
  cellSize: number
): LocalPosition {
  const cellWorldX = cellX * cellSize;
  const cellWorldY = cellY * cellSize;
  
  return {
    localX: Math.max(0, Math.min(1, (worldX - cellWorldX) / cellSize)),
    localY: Math.max(0, Math.min(1, (worldY - cellWorldY) / cellSize))
  };
}

// ===========================================
// Cell State Helpers
// ===========================================

/**
 * Check if a cell is painted (has color data).
 * Works with both simple cells and segment cells.
 */
function cellIsPainted(cellMap: CellMap, x: number, y: number): boolean {
  const key = `${x},${y}`;
  const cell = cellMap.get(key);
  if (!cell) return false;
  
  // Simple cell or segment cell with any segments = painted
  return isSimpleCell(cell) || hasSegments(cell);
}

/**
 * Check if a cell is empty (no paint data)
 */
function cellIsEmpty(cellMap: CellMap, x: number, y: number): boolean {
  return !cellIsPainted(cellMap, x, y);
}

/**
 * Get cell data if it exists
 */
function getCell(cellMap: CellMap, x: number, y: number): Cell | null {
  const key = `${x},${y}`;
  return cellMap.get(key) || null;
}

// ===========================================
// Concave Corner Validation
// ===========================================

/**
 * Check if a cell position is a valid concave corner for diagonal fill.
 * 
 * A valid concave corner is:
 * 1. An empty cell (no paint)
 * 2. With painted cells at both neighbor positions for the specified corner
 */
function isValidConcaveCorner(
  cellMap: CellMap,
  x: number,
  y: number,
  corner: CornerName
): boolean {
  // Cell must be empty
  if (cellIsPainted(cellMap, x, y)) {
    return false;
  }
  
  // Both neighbors for this corner must be painted
  const neighbors = CORNER_NEIGHBOR_CHECKS[corner];
  if (!neighbors) {
    return false;
  }
  
  return neighbors.every(({ dx, dy }) => 
    cellIsPainted(cellMap, x + dx, y + dy)
  );
}

/**
 * Find the valid concave corner for a cell, if any exists.
 * Checks all four corners and returns the first valid one.
 */
function findValidCornerForCell(
  cellMap: CellMap,
  x: number,
  y: number,
  preferredCorner: CornerName | null = null
): CornerName | null {
  const corners: CornerName[] = ['TL', 'TR', 'BR', 'BL'];
  
  // Check preferred corner first if provided
  if (preferredCorner && isValidConcaveCorner(cellMap, x, y, preferredCorner)) {
    return preferredCorner;
  }
  
  // Check all corners
  for (const corner of corners) {
    if (corner !== preferredCorner && isValidConcaveCorner(cellMap, x, y, corner)) {
      return corner;
    }
  }
  
  return null;
}

/**
 * Find the nearest valid concave corner to a given position.
 * Used for "generous snapping" on touch devices.
 */
function findNearestValidCorner(
  cellMap: CellMap,
  x: number,
  y: number,
  preferredCorner: CornerName,
  searchRadius: number = 2
): ValidCornerResult | null {
  // First check if current cell is valid
  if (isValidConcaveCorner(cellMap, x, y, preferredCorner)) {
    return { x, y, corner: preferredCorner };
  }
  
  // Search nearby cells in expanding rings
  for (let radius = 1; radius <= searchRadius; radius++) {
    let nearestDist = Infinity;
    let nearest: ValidCornerResult | null = null;
    
    for (let dy = -radius; dy <= radius; dy++) {
      for (let dx = -radius; dx <= radius; dx++) {
        // Only check cells at this ring's distance
        if (Math.abs(dx) !== radius && Math.abs(dy) !== radius) continue;
        
        const checkX = x + dx;
        const checkY = y + dy;
        
        if (isValidConcaveCorner(cellMap, checkX, checkY, preferredCorner)) {
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < nearestDist) {
            nearestDist = dist;
            nearest = { x: checkX, y: checkY, corner: preferredCorner };
          }
        }
      }
    }
    
    if (nearest) return nearest;
  }
  
  return null;
}

// ===========================================
// Diagonal Path Calculation
// ===========================================

/**
 * Check if two points form a valid 45 diagonal
 */
function isValid45Diagonal(
  startX: number,
  startY: number,
  endX: number,
  endY: number
): boolean {
  const dx = Math.abs(endX - startX);
  const dy = Math.abs(endY - startY);
  
  // Must have equal horizontal and vertical distance (45)
  // And must actually move (not same point)
  return dx === dy && dx > 0;
}

/**
 * Get the diagonal direction for a line from start to end
 */
function getDiagonalDirection(
  startX: number,
  startY: number,
  endX: number,
  endY: number
): DiagonalDirection | null {
  if (!isValid45Diagonal(startX, startY, endX, endY)) {
    return null;
  }
  
  const dx = endX - startX;
  const dy = endY - startY;
  
  // Same sign = descending right (TL-BR), opposite sign = descending left (TR-BL)
  if ((dx > 0 && dy > 0) || (dx < 0 && dy < 0)) {
    return 'TL-BR';
  }
  return 'TR-BL';
}

/**
 * Check if a corner type matches a diagonal direction
 */
function cornerMatchesDiagonal(corner: CornerName, diagonalDir: DiagonalDirection): boolean {
  return CORNER_DIAGONAL_DIRECTION[corner] === diagonalDir;
}

/**
 * Get all cells along a 45 diagonal path
 */
function getCellsAlongDiagonal(
  startX: number,
  startY: number,
  endX: number,
  endY: number
): Point[] {
  const cells: Point[] = [];
  
  if (!isValid45Diagonal(startX, startY, endX, endY)) {
    // Not a valid diagonal, return just start if start equals end
    if (startX === endX && startY === endY) {
      return [{ x: startX, y: startY }];
    }
    return cells;
  }
  
  const dx = endX > startX ? 1 : -1;
  const dy = endY > startY ? 1 : -1;
  const steps = Math.abs(endX - startX);
  
  for (let i = 0; i <= steps; i++) {
    cells.push({
      x: startX + i * dx,
      y: startY + i * dy
    });
  }
  
  return cells;
}

/**
 * Get all valid concave corners along a diagonal path.
 * Filters to only include cells that are valid for filling.
 */
function getValidCornersAlongDiagonal(
  cellMap: CellMap,
  startX: number,
  startY: number,
  endX: number,
  endY: number,
  corner: CornerName
): ValidCornerResult[] {
  const cells = getCellsAlongDiagonal(startX, startY, endX, endY);
  
  return cells
    .filter(cell => isValidConcaveCorner(cellMap, cell.x, cell.y, corner))
    .map(cell => ({ x: cell.x, y: cell.y, corner }));
}

// ===========================================
// Color Inheritance
// ===========================================

/**
 * Get the color to use for diagonal fill by sampling neighbor cells.
 * Prefers neighbor with the matching corner's source direction.
 */
function getInheritedColor(
  cellMap: CellMap,
  x: number,
  y: number,
  corner: CornerName
): InheritedColor | null {
  const neighbors = CORNER_NEIGHBOR_CHECKS[corner];
  if (!neighbors) return null;
  
  // Try each neighbor
  for (const { dx, dy } of neighbors) {
    const cell = getCell(cellMap, x + dx, y + dy);
    if (cell && 'color' in cell) {
      return {
        color: cell.color,
        opacity: cell.opacity ?? 1
      };
    }
  }
  
  return null;
}

// ===========================================
// Segment Fill Helpers
// ===========================================

/**
 * Get the segments to fill for a given corner
 */
function getSegmentsForCorner(corner: CornerName): SegmentName[] {
  return CORNER_SEGMENT_FILL[corner] || [];
}

// ===========================================
// Preview Path Validation
// ===========================================

/**
 * Validate and calculate preview data for diagonal fill.
 * Used during hover to determine if a valid path exists.
 */
function validateDiagonalPath(
  cellMap: CellMap,
  start: DiagonalStartPoint | null,
  targetX: number,
  targetY: number
): DiagonalPathValidation | null {
  if (!start) return null;
  
  const dx = targetX - start.x;
  const dy = targetY - start.y;
  
  // Same cell - return start as the only cell
  if (dx === 0 && dy === 0) {
    if (isValidConcaveCorner(cellMap, start.x, start.y, start.corner)) {
      return { valid: true, endX: start.x, endY: start.y, cellCount: 1 };
    }
    return null;
  }
  
  // Determine which diagonal type this corner requires
  const expectedDiagonalType = CORNER_DIAGONAL_DIRECTION[start.corner];
  
  // Project target onto the correct diagonal line for this corner type
  let snappedX: number, snappedY: number;
  
  if (expectedDiagonalType === 'TL-BR') {
    // Project onto line y - x = start.y - start.x
    const t = (dy - dx) / 2;
    snappedX = Math.round(targetX + t);
    snappedY = Math.round(targetY - t);
  } else {
    // TR-BL: Project onto line y + x = start.y + start.x
    const t = (dx + dy) / 2;
    snappedX = Math.round(targetX - t);
    snappedY = Math.round(targetY - t);
  }
  
  // If snapped back to start or behind, return start only
  if (snappedX === start.x && snappedY === start.y) {
    if (isValidConcaveCorner(cellMap, start.x, start.y, start.corner)) {
      return { valid: true, endX: start.x, endY: start.y, cellCount: 1 };
    }
    return null;
  }
  
  // Verify the direction is valid for this corner
  const actualDir = getDiagonalDirection(start.x, start.y, snappedX, snappedY);
  if (!actualDir || !cornerMatchesDiagonal(start.corner, actualDir)) {
    if (isValidConcaveCorner(cellMap, start.x, start.y, start.corner)) {
      return { valid: true, endX: start.x, endY: start.y, cellCount: 1 };
    }
    return null;
  }
  
  // Get valid corners along the path
  const validCorners = getValidCornersAlongDiagonal(
    cellMap, start.x, start.y, snappedX, snappedY, start.corner
  );
  
  if (validCorners.length === 0) {
    return null;
  }
  
  // Find the furthest valid corner along the path
  const lastValid = validCorners[validCorners.length - 1];
  
  return {
    valid: true,
    endX: lastValid.x,
    endY: lastValid.y,
    cellCount: validCorners.length
  };
}

// ===========================================
// Exports
// ===========================================

return {
  // Corner detection
  getNearestCorner,
  getLocalPosition,
  
  // Cell state helpers
  cellIsPainted,
  cellIsEmpty,
  getCell,
  
  // Concave corner validation
  isValidConcaveCorner,
  findValidCornerForCell,
  findNearestValidCorner,
  
  // Diagonal path calculation
  isValid45Diagonal,
  getDiagonalDirection,
  cornerMatchesDiagonal,
  getCellsAlongDiagonal,
  getValidCornersAlongDiagonal,
  
  // Color inheritance
  getInheritedColor,
  
  // Segment helpers
  getSegmentsForCorner,
  
  // Preview validation
  validateDiagonalPath
};
```

# useDiagonalFill

```ts
/**
 * useDiagonalFill.ts
 *
 * Hook for managing diagonal fill tool state and operations.
 * Handles corner detection, path preview, and segment fill execution.
 *
 * Interaction Model:
 * - Desktop: Click start corner  hover preview  click end corner  fill
 * - Touch: Tap start  tap end  tap confirm/cancel
 *
 * The tool fills "concave corners" along a staircase diagonal by painting
 * 4 segments (half-cell) in each gap, creating smooth diagonal edges.
 */

// Type-only imports
import type { ToolId } from '#types/tools/tool.types';
import type { Point, ScreenCoords, IGeometry } from '#types/core/geometry.types';
import type { MapData, MapLayer } from '#types/core/map.types';
import type { Cell, CellMap, SegmentName } from '#types/core/cell.types';
import type {
  CornerName,
  DiagonalFillStart,
  DiagonalFillEnd,
  DiagonalFillPreview,
  ScreenPosition,
  DiagonalFillViewState,
  UseDiagonalFillResult,
} from '#types/hooks/diagonalFill.types';

// Datacore imports
// Context types
interface MapStateValue {
  geometry: (IGeometry & { cellSize: number }) | null;
  mapData: MapData | null;
  screenToWorld: (clientX: number, clientY: number) => { worldX: number; worldY: number } | null;
  screenToGrid: (clientX: number, clientY: number) => Point | null;
  getClientCoords: (e: PointerEvent | MouseEvent | TouchEvent) => { clientX: number; clientY: number };
}

interface MapOperationsValue {
  onCellsChange: (cells: Cell[], skipHistory?: boolean) => void;
}

const { useMapState, useMapOperations } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext")) as {
  useMapState: () => MapStateValue;
  useMapOperations: () => MapOperationsValue;
};

const { getActiveLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor")) as {
  getActiveLayer: (mapData: MapData) => MapLayer;
};

const { buildCellMap, setSegments } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "cellAccessor")) as {
  buildCellMap: (cells: Cell[], geometry: IGeometry) => CellMap;
  setSegments: (cells: Cell[], coords: Point, segments: SegmentName[], color: string, opacity: number, geometry: IGeometry) => Cell[];
};

interface LocalPosition {
  localX: number;
  localY: number;
}

interface ColorInfo {
  color: string;
  opacity: number;
}

interface ValidCorner {
  x: number;
  y: number;
}

interface PathValidation {
  valid: boolean;
  endX: number;
  endY: number;
}

const {
  getNearestCorner,
  getLocalPosition,
  isValidConcaveCorner,
  findValidCornerForCell,
  findNearestValidCorner,
  validateDiagonalPath,
  getValidCornersAlongDiagonal,
  getInheritedColor,
  getSegmentsForCorner
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "diagonalFillOperations")) as {
  getNearestCorner: (localX: number, localY: number) => CornerName;
  getLocalPosition: (worldX: number, worldY: number, cellX: number, cellY: number, cellSize: number) => LocalPosition;
  isValidConcaveCorner: (cellMap: CellMap, x: number, y: number, corner: CornerName) => boolean;
  findValidCornerForCell: (cellMap: CellMap, x: number, y: number, hintCorner: CornerName) => CornerName | null;
  findNearestValidCorner: (cellMap: CellMap, x: number, y: number, corner: CornerName, radius: number) => ValidCorner | null;
  validateDiagonalPath: (cellMap: CellMap, start: DiagonalFillStart, endX: number, endY: number) => PathValidation | null;
  getValidCornersAlongDiagonal: (cellMap: CellMap, startX: number, startY: number, endX: number, endY: number, corner: CornerName) => ValidCorner[];
  getInheritedColor: (cellMap: CellMap, x: number, y: number, corner: CornerName) => ColorInfo | null;
  getSegmentsForCorner: (corner: CornerName) => SegmentName[];
};

/**
 * Hook for diagonal fill tool
 */
const useDiagonalFill = (currentTool: ToolId): UseDiagonalFillResult => {
  const {
    geometry,
    mapData,
    screenToWorld,
    screenToGrid,
    getClientCoords
  } = useMapState();

  const { onCellsChange } = useMapOperations();

  const [fillStart, setFillStart] = dc.useState<DiagonalFillStart | null>(null);
  const [fillEnd, setFillEnd] = dc.useState<DiagonalFillEnd | null>(null);
  const [isEndLocked, setIsEndLocked] = dc.useState<boolean>(false);
  const [previewEnd, setPreviewEnd] = dc.useState<DiagonalFillPreview | null>(null);

  const cellMap = dc.useMemo((): CellMap => {
    if (!mapData || !geometry) return new Map();
    const activeLayer = getActiveLayer(mapData);
    return buildCellMap(activeLayer.cells || [], geometry);
  }, [mapData, geometry]);

  dc.useEffect(() => {
    if (currentTool !== 'diagonalFill') {
      setFillStart(null);
      setFillEnd(null);
      setIsEndLocked(false);
      setPreviewEnd(null);
    }
  }, [currentTool]);

  const resetState = dc.useCallback((): void => {
    setFillStart(null);
    setFillEnd(null);
    setIsEndLocked(false);
    setPreviewEnd(null);
  }, []);

  const executeFillPath = dc.useCallback(
    (start: DiagonalFillStart, end: DiagonalFillEnd): void => {
      if (!start || !end || !geometry || !mapData) return;

      const activeLayer = getActiveLayer(mapData);
      const currentCellMap = buildCellMap(activeLayer.cells || [], geometry);

      const validCorners = getValidCornersAlongDiagonal(
        currentCellMap, start.x, start.y, end.x, end.y, start.corner
      );

      if (validCorners.length === 0) return;

      const colorInfo = getInheritedColor(currentCellMap, start.x, start.y, start.corner);
      if (!colorInfo) return;

      const segments = getSegmentsForCorner(start.corner);
      if (segments.length === 0) return;

      let updatedCells = [...(activeLayer.cells || [])];

      for (const { x, y } of validCorners) {
        updatedCells = setSegments(
          updatedCells,
          { x, y },
          segments,
          colorInfo.color,
          colorInfo.opacity,
          geometry
        );
      }

      onCellsChange(updatedCells, false);
    },
    [geometry, mapData, onCellsChange]
  );

  const handleDiagonalFillClick = dc.useCallback(
    (e: PointerEvent | MouseEvent | TouchEvent, isTouch: boolean = false): boolean => {
      if (currentTool !== 'diagonalFill' || !geometry || !mapData) {
        return false;
      }

      const { clientX, clientY } = getClientCoords(e);
      const worldCoords = screenToWorld(clientX, clientY);
      if (!worldCoords) return false;

      const gridCoords = screenToGrid(clientX, clientY);
      if (!gridCoords) return false;

      const { x, y } = gridCoords;

      const cellSize = geometry.cellSize;
      const { localX, localY } = getLocalPosition(
        worldCoords.worldX, worldCoords.worldY,
        x, y, cellSize
      );

      const corner = getNearestCorner(localX, localY);

      // Touch confirmation mode
      if (isTouch && isEndLocked && fillEnd) {
        const distToEnd = Math.sqrt(
          Math.pow(x - fillEnd.x, 2) + Math.pow(y - fillEnd.y, 2)
        );

        if (distToEnd <= 1.5) {
          executeFill();
          return true;
        } else {
          setFillEnd(null);
          setIsEndLocked(false);
          setPreviewEnd(null);
          return true;
        }
      }

      if (!fillStart) {
        const validCorner = findValidCornerForCell(cellMap, x, y, corner);

        if (!validCorner) {
          return false;
        }

        setFillStart({ x, y, corner: validCorner });
        setPreviewEnd(null);
        return true;
      }

      const validation = validateDiagonalPath(cellMap, fillStart, x, y);

      if (!validation || !validation.valid) {
        if (isTouch) {
          const snapped = findNearestValidCorner(cellMap, x, y, fillStart.corner, 3);
          if (snapped) {
            const revalidation = validateDiagonalPath(cellMap, fillStart, snapped.x, snapped.y);
            if (revalidation && revalidation.valid) {
              if (isTouch) {
                setFillEnd({ x: revalidation.endX, y: revalidation.endY });
                setIsEndLocked(true);
              } else {
                executeFillPath(fillStart, { x: revalidation.endX, y: revalidation.endY });
                resetState();
              }
              return true;
            }
          }
        }
        return false;
      }

      if (isTouch) {
        setFillEnd({ x: validation.endX, y: validation.endY });
        setIsEndLocked(true);
      } else {
        executeFillPath(fillStart, { x: validation.endX, y: validation.endY });
        resetState();
      }

      return true;
    },
    [currentTool, geometry, mapData, cellMap, fillStart, fillEnd, isEndLocked, getClientCoords, screenToWorld, screenToGrid, executeFillPath, resetState]
  );

  const handleDiagonalFillMove = dc.useCallback(
    (e: PointerEvent | MouseEvent): void => {
      if (currentTool !== 'diagonalFill' || !geometry || !fillStart || isEndLocked) {
        return;
      }

      const { clientX, clientY } = getClientCoords(e);
      const gridCoords = screenToGrid(clientX, clientY);

      if (!gridCoords) {
        setPreviewEnd(null);
        return;
      }

      const { x, y } = gridCoords;

      const validation = validateDiagonalPath(cellMap, fillStart, x, y);

      if (validation && validation.valid) {
        setPreviewEnd({ x: validation.endX, y: validation.endY });
      } else {
        setPreviewEnd(null);
      }
    },
    [currentTool, geometry, fillStart, isEndLocked, cellMap, getClientCoords, screenToGrid]
  );

  const executeFill = dc.useCallback((): void => {
    if (!fillStart || !fillEnd) return;
    executeFillPath(fillStart, fillEnd);
    resetState();
  }, [fillStart, fillEnd, executeFillPath, resetState]);

  const cancelFill = dc.useCallback((): void => {
    resetState();
  }, [resetState]);

  const getCornerScreenPosition = dc.useCallback(
    (
      cellX: number,
      cellY: number,
      corner: CornerName,
      viewState: DiagonalFillViewState,
      canvasWidth: number,
      canvasHeight: number
    ): ScreenPosition => {
      if (!geometry) return { x: 0, y: 0 };

      const { zoom, center } = viewState;
      const cellSize = geometry.cellSize;
      const scaledCellSize = cellSize * zoom;

      const offsetX = canvasWidth / 2 - center.x * scaledCellSize;
      const offsetY = canvasHeight / 2 - center.y * scaledCellSize;

      const { screenX, screenY } = geometry.gridToScreen(
        cellX, cellY, offsetX, offsetY, zoom
      );

      const cornerOffsets: Record<CornerName, { x: number; y: number }> = {
        'TL': { x: 0, y: 0 },
        'TR': { x: scaledCellSize, y: 0 },
        'BR': { x: scaledCellSize, y: scaledCellSize },
        'BL': { x: 0, y: scaledCellSize }
      };

      const offset = cornerOffsets[corner] || { x: 0, y: 0 };

      return {
        x: screenX + offset.x,
        y: screenY + offset.y
      };
    },
    [geometry]
  );

  return {
    fillStart,
    fillEnd,
    isEndLocked,
    previewEnd,
    handleDiagonalFillClick,
    handleDiagonalFillMove,
    executeFill,
    cancelFill,
    getCornerScreenPosition,
    resetState
  };
};

return { useDiagonalFill };

```

# DiagonalFillOverlay

```tsx
/**
 * DiagonalFillOverlay.tsx
 *
 * Overlay component for diagonal fill tool.
 * Manages tool state via useDiagonalFill hook, registers event handlers,
 * and renders SVG preview showing where the diagonal fill will be applied.
 *
 * The diagonal fill tool fills "concave corners" along staircase diagonals
 * by painting 4 segments (half-cell) in each gap, creating smooth diagonal edges.
 */

import type { ToolId } from '#types/tools/tool.types';
import type { Point } from '#types/core/geometry.types';
import type { IGeometry } from '#types/core/geometry.types';

const { GridGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "GridGeometry"));
const { useDiagonalFill } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useDiagonalFill"));
const { useMapState } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext"));
const { useEventHandlerRegistration } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "EventHandlerContext"));

/** Corner names for cell corners */
type CornerName = 'TL' | 'TR' | 'BR' | 'BL';

/** Fill start point with corner info */
interface FillStartPoint {
  x: number;
  y: number;
  corner: CornerName;
}

/** Fill end point */
interface FillEndPoint {
  x: number;
  y: number;
}

/** Map data structure */
interface MapData {
  viewState: {
    zoom: number;
    center: Point;
  };
  northDirection?: number;
}

/** Grid geometry with cellSize property */
interface GridGeometryInstance extends IGeometry {
  cellSize: number;
}

/** Props for DiagonalFillOverlay component */
export interface DiagonalFillOverlayProps {
  /** Current active tool */
  currentTool: ToolId;
}

/** Props for CornerIndicator component */
interface CornerIndicatorProps {
  x: number;
  y: number;
  corner: CornerName;
  size?: number;
}

/**
 * Convert cell corner to screen coordinates
 */
function cornerToScreen(
  cellX: number,
  cellY: number,
  corner: CornerName,
  geometry: GridGeometryInstance,
  mapData: MapData,
  canvasWidth: number,
  canvasHeight: number
): Point {
  const { zoom, center } = mapData.viewState;
  const northDirection = mapData.northDirection || 0;
  const cellSize = geometry.cellSize;

  const cornerWorldOffsets: Record<CornerName, Point> = {
    'TL': { x: 0, y: 0 },
    'TR': { x: 1, y: 0 },
    'BR': { x: 1, y: 1 },
    'BL': { x: 0, y: 1 }
  };

  const cornerOffset = cornerWorldOffsets[corner];
  const worldX = (cellX + cornerOffset.x) * cellSize;
  const worldY = (cellY + cornerOffset.y) * cellSize;

  const scaledCellSize = geometry.getScaledCellSize(zoom);
  const offsetX = canvasWidth / 2 - center.x * scaledCellSize;
  const offsetY = canvasHeight / 2 - center.y * scaledCellSize;

  let screenX = offsetX + worldX * zoom;
  let screenY = offsetY + worldY * zoom;

  if (northDirection !== 0) {
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;

    screenX -= centerX;
    screenY -= centerY;

    const angleRad = (northDirection * Math.PI) / 180;
    const rotatedX = screenX * Math.cos(angleRad) - screenY * Math.sin(angleRad);
    const rotatedY = screenX * Math.sin(angleRad) + screenY * Math.cos(angleRad);

    screenX = rotatedX + centerX;
    screenY = rotatedY + centerY;
  }

  return { x: screenX, y: screenY };
}

/**
 * Small triangle indicator showing which corner was clicked
 */
const CornerIndicator = ({ x, y, corner, size = 12 }: CornerIndicatorProps): React.ReactElement | null => {
  const halfSize = size / 2;

  const trianglePoints: Record<CornerName, string> = {
    'TL': `${x},${y} ${x - halfSize},${y - size} ${x - size},${y - halfSize}`,
    'TR': `${x},${y} ${x + halfSize},${y - size} ${x + size},${y - halfSize}`,
    'BR': `${x},${y} ${x + halfSize},${y + size} ${x + size},${y + halfSize}`,
    'BL': `${x},${y} ${x - halfSize},${y + size} ${x - size},${y + halfSize}`
  };

  const points = trianglePoints[corner];
  if (!points) return null;

  return (
    <polygon
      points={points}
      fill="rgba(0, 212, 255, 0.6)"
      stroke="#00d4ff"
      strokeWidth={1}
    />
  );
};

const DiagonalFillOverlay = ({ currentTool }: DiagonalFillOverlayProps): React.ReactElement | null => {
  const {
    mapData,
    geometry,
    canvasRef
  } = useMapState();

  const {
    fillStart,
    fillEnd,
    isEndLocked,
    previewEnd,
    handleDiagonalFillClick,
    handleDiagonalFillMove,
    cancelFill
  } = useDiagonalFill(currentTool);

  const { registerHandlers, unregisterHandlers } = useEventHandlerRegistration();

  dc.useEffect(() => {
    registerHandlers('diagonalFill', {
      handleDiagonalFillClick,
      handleDiagonalFillMove,
      cancelFill,
      fillStart
    });
    return () => unregisterHandlers('diagonalFill');
  }, [registerHandlers, unregisterHandlers, handleDiagonalFillClick, handleDiagonalFillMove, cancelFill, fillStart]);

  if (currentTool !== 'diagonalFill' || !fillStart || !geometry || !mapData || !canvasRef?.current) {
    return null;
  }

  if (!(geometry instanceof GridGeometry)) {
    return null;
  }

  const displayEnd: FillEndPoint | null = fillEnd || previewEnd;

  const canvas = canvasRef.current;
  const { width: canvasWidth, height: canvasHeight } = canvas;
  const canvasRect = canvas.getBoundingClientRect();
  const displayScale = canvasRect.width / canvasWidth;

  let flexContainer: HTMLElement | null = canvas.parentElement;
  while (flexContainer && !flexContainer.classList.contains('dmt-canvas-container')) {
    flexContainer = flexContainer.parentElement;
  }
  const containerRect = flexContainer?.getBoundingClientRect();
  const canvasOffsetX = containerRect ? canvasRect.left - containerRect.left : 0;
  const canvasOffsetY = containerRect ? canvasRect.top - containerRect.top : 0;

  const startScreen = cornerToScreen(
    fillStart.x,
    fillStart.y,
    fillStart.corner,
    geometry as GridGeometryInstance,
    mapData,
    canvasWidth,
    canvasHeight
  );

  const scaledStart = {
    x: startScreen.x * displayScale + canvasOffsetX,
    y: startScreen.y * displayScale + canvasOffsetY
  };

  let scaledEnd: Point | null = null;
  if (displayEnd) {
    const endScreen = cornerToScreen(
      displayEnd.x,
      displayEnd.y,
      fillStart.corner,
      geometry as GridGeometryInstance,
      mapData,
      canvasWidth,
      canvasHeight
    );

    scaledEnd = {
      x: endScreen.x * displayScale + canvasOffsetX,
      y: endScreen.y * displayScale + canvasOffsetY
    };
  }

  return (
    <svg
      className="dmt-diagonal-fill-overlay"
      style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
        zIndex: 100,
        overflow: 'visible'
      }}
    >
      {scaledEnd && (
        <line
          x1={scaledStart.x}
          y1={scaledStart.y}
          x2={scaledEnd.x}
          y2={scaledEnd.y}
          stroke="#00d4ff"
          strokeWidth={2.5}
          strokeDasharray={isEndLocked ? "none" : "8,4"}
          strokeLinecap="round"
        />
      )}

      <circle
        cx={scaledStart.x}
        cy={scaledStart.y}
        r={8}
        fill="rgba(0, 212, 255, 0.8)"
        stroke="#00d4ff"
        strokeWidth={2}
      />

      <CornerIndicator
        x={scaledStart.x}
        y={scaledStart.y}
        corner={fillStart.corner}
        size={12}
      />

      {scaledEnd && (
        <>
          <circle
            cx={scaledEnd.x}
            cy={scaledEnd.y}
            r={isEndLocked ? 7 : 5}
            fill={isEndLocked ? "rgba(0, 212, 255, 0.9)" : "rgba(0, 212, 255, 0.6)"}
            stroke="#00d4ff"
            strokeWidth={isEndLocked ? 2 : 1.5}
          />

          {isEndLocked && (
            <g transform={`translate(${scaledEnd.x + 15}, ${scaledEnd.y - 20})`}>
              <rect
                x={0}
                y={-12}
                width={70}
                height={24}
                rx={4}
                fill="rgba(26, 26, 26, 0.95)"
                stroke="#00d4ff"
                strokeWidth={1}
              />
              <text
                x={35}
                y={4}
                textAnchor="middle"
                fill="#ffffff"
                fontSize={11}
                fontFamily="var(--font-interface, -apple-system, BlinkMacSystemFont, sans-serif)"
                fontWeight="500"
              >
                Tap to fill
              </text>
            </g>
          )}
        </>
      )}
    </svg>
  );
};

return { DiagonalFillOverlay };

```

# multiSelectOperations

```ts
/**
 * multiSelectOperations.ts
 * 
 * Utilities for multi-select functionality:
 * - Finding items within a selection rectangle
 * - Calculating bounds for objects and text labels
 * - Batch update operations
 */

// Type-only imports
import type { Point } from '#types/core/geometry.types';
import type { MapData, MapLayer } from '#types/core/map.types';
import type { MapObject, ObjectSize } from '#types/objects/object.types';
import type { TextLabel, FontFace } from './textLabelOperations';
import type { IGeometry } from '#types/core/geometry.types';
import type { HexOrientation } from '#types/settings/settings.types';

// Datacore imports
const { getActiveLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor")) as {
  getActiveLayer: (mapData: MapData) => MapLayer
};

const { getFontCss } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "fontOptions")) as {
  getFontCss: (fontFace: FontFace) => string
};

const { GridGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "GridGeometry")) as {
  GridGeometry: new () => GridGeometryInstance
};

const { HexGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "HexGeometry")) as {
  HexGeometry: new () => HexGeometryInstance
};

// ===========================================
// Type Definitions
// ===========================================

/** World-coordinate bounding box */
export interface WorldBounds {
  minX: number;
  minY: number;
  maxX: number;
  maxY: number;
}

/** World coordinate point */
export interface WorldPoint {
  worldX: number;
  worldY: number;
}

/** Item types in selection */
export type SelectableItemType = 'object' | 'text';

/** Selected item reference */
export interface SelectedItem {
  type: SelectableItemType;
  id: string;
  data: MapObject | TextLabel;
}

/** Position update for group move */
export interface PositionUpdate {
  id: string;
  position: Point;
}

/** Grid geometry instance interface */
interface GridGeometryInstance extends IGeometry {
  cellSize: number;
}

/** Hex geometry instance interface */
interface HexGeometryInstance extends IGeometry {
  hexSize: number;
  hexToWorld(q: number, r: number): { worldX: number; worldY: number };
}

/** Geometry with bounds check */
interface GeometryWithBounds {
  isWithinBounds?(x: number, y: number): boolean;
}

// ===========================================
// Rectangle Operations
// ===========================================

/**
 * Check if two rectangles overlap
 */
function rectsOverlap(
  minX1: number,
  minY1: number,
  maxX1: number,
  maxY1: number,
  bounds: WorldBounds
): boolean {
  return !(bounds.maxX < minX1 || bounds.minX > maxX1 ||
           bounds.maxY < minY1 || bounds.minY > maxY1);
}

// ===========================================
// Bounds Calculation
// ===========================================

/**
 * Get the world-coordinate bounds of an object.
 * Objects use grid coordinates, so we need to convert based on geometry.
 */
function getObjectWorldBounds(
  obj: MapObject,
  geometry: IGeometry,
  mapData: MapData
): WorldBounds {
  const pos = obj.position;
  const size: ObjectSize = obj.size || { width: 1, height: 1 };
  
  // For grid maps: convert grid cell to world coords
  if (geometry instanceof GridGeometry) {
    const cellSize = (geometry as GridGeometryInstance).cellSize;
    return {
      minX: pos.x * cellSize,
      minY: pos.y * cellSize,
      maxX: (pos.x + size.width) * cellSize,
      maxY: (pos.y + size.height) * cellSize
    };
  }
  
  // For hex maps: get hex center in world coords and create bounds around it
  if (geometry instanceof HexGeometry) {
    const hexGeo = geometry as HexGeometryInstance;
    const center = hexGeo.hexToWorld(pos.x, pos.y);
    const hexSize = hexGeo.hexSize;
    
    // Approximate hex bounds as a rectangle
    const orientation: HexOrientation = (mapData as MapData & { orientation?: HexOrientation }).orientation || 'flat';
    let halfWidth: number, halfHeight: number;
    
    if (orientation === 'flat') {
      halfWidth = hexSize;
      halfHeight = hexSize * Math.sqrt(3) / 2;
    } else {
      halfWidth = hexSize * Math.sqrt(3) / 2;
      halfHeight = hexSize;
    }
    
    return {
      minX: center.worldX - halfWidth,
      minY: center.worldY - halfHeight,
      maxX: center.worldX + halfWidth,
      maxY: center.worldY + halfHeight
    };
  }
  
  // Fallback for unknown geometry
  return {
    minX: pos.x,
    minY: pos.y,
    maxX: pos.x + 1,
    maxY: pos.y + 1
  };
}

/**
 * Get the world-coordinate bounds of a text label.
 * Text labels already use world coordinates.
 */
function getTextLabelWorldBounds(
  label: TextLabel,
  ctx: CanvasRenderingContext2D | null
): WorldBounds {
  const pos = label.position;
  const fontSize = label.fontSize || 16;
  const fontFace = label.fontFace || 'sans';
  const rotation = label.rotation || 0;
  
  // Measure text width
  let textWidth: number, textHeight: number;
  
  if (ctx) {
    const fontFamily = getFontCss(fontFace);
    ctx.font = `${fontSize}px ${fontFamily}`;
    const metrics = ctx.measureText(label.content || '');
    textWidth = metrics.width;
    textHeight = fontSize * 1.2;
  } else {
    // Estimate if no context available
    textWidth = (label.content || '').length * fontSize * 0.6;
    textHeight = fontSize * 1.2;
  }
  
  // Add padding (same as selection box)
  const paddingX = 4;
  const paddingY = 2;
  const boundingWidth = textWidth + paddingX * 2;
  const boundingHeight = textHeight + paddingY * 2;
  
  // For rotated text, calculate the axis-aligned bounding box
  if (rotation !== 0) {
    const angleRad = (rotation * Math.PI) / 180;
    const cos = Math.abs(Math.cos(angleRad));
    const sin = Math.abs(Math.sin(angleRad));
    const rotatedWidth = boundingWidth * cos + boundingHeight * sin;
    const rotatedHeight = boundingWidth * sin + boundingHeight * cos;
    
    return {
      minX: pos.x - rotatedWidth / 2,
      minY: pos.y - rotatedHeight / 2,
      maxX: pos.x + rotatedWidth / 2,
      maxY: pos.y + rotatedHeight / 2
    };
  }
  
  // Non-rotated: simple bounding box centered on position
  return {
    minX: pos.x - boundingWidth / 2,
    minY: pos.y - boundingHeight / 2,
    maxX: pos.x + boundingWidth / 2,
    maxY: pos.y + boundingHeight / 2
  };
}

// ===========================================
// Selection Operations
// ===========================================

/**
 * Find all objects and text labels within a world-coordinate rectangle
 */
function getItemsInWorldRect(
  mapData: MapData,
  corner1: WorldPoint,
  corner2: WorldPoint,
  geometry: IGeometry,
  ctx: CanvasRenderingContext2D | null
): SelectedItem[] {
  const activeLayer = getActiveLayer(mapData);
  const items: SelectedItem[] = [];
  
  // Normalize rectangle bounds
  const minX = Math.min(corner1.worldX, corner2.worldX);
  const maxX = Math.max(corner1.worldX, corner2.worldX);
  const minY = Math.min(corner1.worldY, corner2.worldY);
  const maxY = Math.max(corner1.worldY, corner2.worldY);
  
  // Check objects
  const objects = activeLayer.objects || [];
  for (const obj of objects) {
    const objBounds = getObjectWorldBounds(obj as unknown as MapObject, geometry, mapData);
    if (rectsOverlap(minX, minY, maxX, maxY, objBounds)) {
      items.push({ type: 'object', id: obj.id, data: obj as unknown as MapObject });
    }
  }
  
  // Check text labels
  const textLabels = activeLayer.textLabels || [];
  for (const label of textLabels) {
    const labelBounds = getTextLabelWorldBounds(label as unknown as TextLabel, ctx);
    if (rectsOverlap(minX, minY, maxX, maxY, labelBounds)) {
      items.push({ type: 'text', id: label.id, data: label as unknown as TextLabel });
    }
  }
  
  return items;
}

/**
 * Calculate the combined bounding box for multiple selected items.
 * Used for positioning the multi-select toolbar.
 */
function getSelectionBounds(
  selectedItems: SelectedItem[] | null | undefined,
  geometry: IGeometry,
  mapData: MapData,
  ctx: CanvasRenderingContext2D | null
): WorldBounds | null {
  if (!selectedItems || selectedItems.length === 0) {
    return null;
  }
  
  let minX = Infinity, minY = Infinity;
  let maxX = -Infinity, maxY = -Infinity;
  
  for (const item of selectedItems) {
    let bounds: WorldBounds | undefined;
    
    if (item.type === 'object') {
      bounds = getObjectWorldBounds(item.data as MapObject, geometry, mapData);
    } else if (item.type === 'text') {
      bounds = getTextLabelWorldBounds(item.data as TextLabel, ctx);
    }
    
    if (bounds) {
      minX = Math.min(minX, bounds.minX);
      minY = Math.min(minY, bounds.minY);
      maxX = Math.max(maxX, bounds.maxX);
      maxY = Math.max(maxY, bounds.maxY);
    }
  }
  
  if (minX === Infinity) {
    return null;
  }
  
  return { minX, minY, maxX, maxY };
}

// ===========================================
// Bounds Validation
// ===========================================

/**
 * Check if a position is within map bounds
 */
function isWithinBounds(
  gridX: number,
  gridY: number,
  geometry: IGeometry & GeometryWithBounds | null,
  mapData: MapData
): boolean {
  if (!geometry) return true;
  
  // Use geometry's bounds check if available
  if (geometry.isWithinBounds) {
    return geometry.isWithinBounds(gridX, gridY);
  }
  
  // For grid maps without explicit bounds, assume unbounded
  return true;
}

/**
 * Validate that all positions in a group move are within bounds
 */
function validateGroupMove(
  updates: PositionUpdate[],
  geometry: IGeometry & GeometryWithBounds | null,
  mapData: MapData
): boolean {
  for (const update of updates) {
    if (update.position) {
      if (!isWithinBounds(update.position.x, update.position.y, geometry, mapData)) {
        return false;
      }
    }
  }
  return true;
}

// ===========================================
// Exports
// ===========================================

return {
  rectsOverlap,
  getObjectWorldBounds,
  getTextLabelWorldBounds,
  getItemsInWorldRect,
  getSelectionBounds,
  isWithinBounds,
  validateGroupMove
};
```

# useAreaSelect

```ts
/**
 * useAreaSelect.ts
 *
 * Custom hook for managing area selection tool:
 * - Two-click rectangle selection (matching other area tools)
 * - First click places start corner marker
 * - Second click completes selection of all items in rectangle
 */

// Type-only imports
import type { ToolId } from '#types/tools/tool.types';
import type { Point, WorldCoords, IGeometry } from '#types/core/geometry.types';
import type { MapData } from '#types/core/map.types';
import type {
  AreaSelectStart,
  SelectableItem,
  UseAreaSelectResult,
} from '#types/hooks/areaSelect.types';

// Datacore imports
// Context types - using inline types until contexts are fully typed
interface MapStateValue {
  canvasRef: { current: HTMLCanvasElement | null };
  mapData: MapData | null;
  geometry: IGeometry | null;
  screenToWorld: (clientX: number, clientY: number) => WorldCoords | null;
  screenToGrid: (clientX: number, clientY: number) => Point | null;
  getClientCoords: (e: PointerEvent | MouseEvent | TouchEvent) => { clientX: number; clientY: number };
}

interface MapSelectionValue {
  areaSelectStart: AreaSelectStart | null;
  setAreaSelectStart: (start: AreaSelectStart | null) => void;
  selectMultiple: (items: SelectableItem[]) => void;
  clearSelection: () => void;
}

const { useMapState, useMapOperations } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext")) as {
  useMapState: () => MapStateValue;
  useMapOperations: () => unknown;
};

const { useMapSelection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSelectionContext")) as {
  useMapSelection: () => MapSelectionValue;
};

const { getItemsInWorldRect } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "multiSelectOperations")) as {
  getItemsInWorldRect: (
    mapData: MapData,
    corner1: WorldCoords,
    corner2: WorldCoords,
    geometry: IGeometry,
    ctx: CanvasRenderingContext2D | null
  ) => SelectableItem[];
};

const { getActiveLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor")) as {
  getActiveLayer: (mapData: MapData) => unknown;
};

/**
 * Hook for managing area selection tool
 *
 * @param currentTool - Current active tool
 * @returns Area select handlers and state
 */
const useAreaSelect = (currentTool: ToolId): UseAreaSelectResult => {
  const {
    canvasRef,
    mapData,
    geometry,
    screenToWorld,
    screenToGrid,
    getClientCoords
  } = useMapState();

  const {
    areaSelectStart,
    setAreaSelectStart,
    selectMultiple,
    clearSelection
  } = useMapSelection();

  const isAreaSelectTool = currentTool === 'areaSelect';

  /**
   * Handle click for area select tool
   * First click: Set start corner
   * Second click: Complete selection
   */
  const handleAreaSelectClick = dc.useCallback(
    (e: PointerEvent | MouseEvent | TouchEvent): boolean => {
      if (!isAreaSelectTool || !mapData || !geometry) {
        return false;
      }

      const { clientX, clientY } = getClientCoords(e);
      const worldCoords = screenToWorld(clientX, clientY);
      const gridCoords = screenToGrid(clientX, clientY);

      if (!worldCoords || !gridCoords) {
        return false;
      }

      if (!areaSelectStart) {
        clearSelection();

        setAreaSelectStart({
          worldX: worldCoords.worldX,
          worldY: worldCoords.worldY,
          x: gridCoords.x,
          y: gridCoords.y
        });
        return true;
      }

      const corner1: WorldCoords = {
        worldX: areaSelectStart.worldX,
        worldY: areaSelectStart.worldY
      };
      const corner2: WorldCoords = {
        worldX: worldCoords.worldX,
        worldY: worldCoords.worldY
      };

      // Get canvas context for text measurement
      const ctx = canvasRef.current?.getContext('2d') ?? null;

      const items = getItemsInWorldRect(mapData, corner1, corner2, geometry, ctx);

      if (items.length > 0) {
        selectMultiple(items);
      } else {
        clearSelection();
      }

      setAreaSelectStart(null);

      return true;
    },
    [
      isAreaSelectTool,
      mapData,
      geometry,
      areaSelectStart,
      getClientCoords,
      screenToWorld,
      screenToGrid,
      canvasRef,
      setAreaSelectStart,
      selectMultiple,
      clearSelection
    ]
  );

  /**
   * Cancel area selection (e.g., on tool change or Escape)
   */
  const cancelAreaSelect = dc.useCallback((): void => {
    if (areaSelectStart) {
      setAreaSelectStart(null);
    }
  }, [areaSelectStart, setAreaSelectStart]);

  /**
   * Check if area selection is in progress (first corner placed)
   */
  const isAreaSelecting = !!areaSelectStart;

  return {
    // State
    areaSelectStart,
    isAreaSelecting,

    // Handlers
    handleAreaSelectClick,
    cancelAreaSelect
  };
};

return { useAreaSelect };

```

# AreaSelectLayer

```tsx
/**
 * AreaSelectLayer.tsx
 *
 * Handles area selection tool:
 * - Registers handlers with EventHandlerContext
 * - Renders start marker overlay (similar to rectangle tool)
 * - Coordinates with MapSelectionContext for multi-select
 */

import type { ToolId } from '#types/tools/tool.types';
import type { OffsetCoords } from '#types/core/geometry.types';

const { useAreaSelect } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useAreaSelect"));
const { useMapState } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext"));
const { useMapSelection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSelectionContext"));
const { useEventHandlerRegistration } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "EventHandlerContext"));
const { GridGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "GridGeometry"));

/** Props for AreaSelectLayer component */
export interface AreaSelectLayerProps {
  /** Current active tool */
  currentTool: ToolId;
}

const AreaSelectLayer = ({ currentTool }: AreaSelectLayerProps): React.ReactElement | null => {
  const { canvasRef, containerRef, mapData, geometry } = useMapState();
  const { areaSelectStart, setAreaSelectStart, clearSelection } = useMapSelection();

  const {
    handleAreaSelectClick,
    cancelAreaSelect,
    isAreaSelecting
  } = useAreaSelect(currentTool);

  const { registerHandlers, unregisterHandlers } = useEventHandlerRegistration();

  dc.useEffect(() => {
    registerHandlers('areaSelect', {
      handleAreaSelectClick,
      cancelAreaSelect,
      isAreaSelecting,
      areaSelectStart
    });

    return () => unregisterHandlers('areaSelect');
  }, [registerHandlers, unregisterHandlers, handleAreaSelectClick, cancelAreaSelect, isAreaSelecting, areaSelectStart]);

  dc.useEffect(() => {
    if (currentTool !== 'areaSelect' && areaSelectStart) {
      setAreaSelectStart(null);
    }
    if (currentTool !== 'areaSelect' && currentTool !== 'select') {
      clearSelection();
    }
  }, [currentTool, areaSelectStart, setAreaSelectStart, clearSelection]);

  const renderStartMarker = (): React.ReactElement | null => {
    if (!areaSelectStart || !canvasRef.current || !containerRef?.current || !geometry || !mapData) {
      return null;
    }

    const canvas = canvasRef.current;
    const { viewState, northDirection } = mapData;
    const { zoom, center } = viewState;
    const { width, height } = canvas;

    let scaledSize: number;
    let offsetX: number;
    let offsetY: number;

    const isGrid = geometry instanceof GridGeometry;
    if (isGrid) {
      scaledSize = geometry.getScaledCellSize(zoom);
      offsetX = width / 2 - center.x * scaledSize;
      offsetY = height / 2 - center.y * scaledSize;
    } else {
      scaledSize = geometry.getScaledHexSize ? geometry.getScaledHexSize(zoom) : zoom * 30;
      offsetX = width / 2 - center.x * zoom;
      offsetY = height / 2 - center.y * zoom;
    }

    const containerRect = containerRef.current.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();

    const canvasOffsetX = canvasRect.left - containerRect.left;
    const canvasOffsetY = canvasRect.top - containerRect.top;

    const displayScale = canvasRect.width / width;

    const gridX = areaSelectStart.x;
    const gridY = areaSelectStart.y;

    let screenX: number;
    let screenY: number;

    if (isGrid) {
      const cellWorldX = (gridX + 0.5) * geometry.cellSize;
      const cellWorldY = (gridY + 0.5) * geometry.cellSize;
      screenX = offsetX + cellWorldX * zoom;
      screenY = offsetY + cellWorldY * zoom;
    } else {
      const hexCenter = geometry.hexToWorld(gridX, gridY);
      screenX = offsetX + hexCenter.worldX * zoom;
      screenY = offsetY + hexCenter.worldY * zoom;
    }

    if (northDirection !== 0) {
      const centerX = width / 2;
      const centerY = height / 2;

      screenX -= centerX;
      screenY -= centerY;

      const angleRad = (northDirection * Math.PI) / 180;
      const rotatedX = screenX * Math.cos(angleRad) - screenY * Math.sin(angleRad);
      const rotatedY = screenX * Math.sin(angleRad) + screenY * Math.cos(angleRad);

      screenX = rotatedX + centerX;
      screenY = rotatedY + centerY;
    }

    screenX *= displayScale;
    screenY *= displayScale;

    const displayScaledSize = scaledSize * displayScale;
    const cellHalfSize = displayScaledSize / 2;

    const markerX = canvasOffsetX + screenX - cellHalfSize;
    const markerY = canvasOffsetY + screenY - cellHalfSize;

    const highlightColor = '#4a9eff';

    return (
      <div
        key="area-select-start"
        className="dmt-area-select-marker"
        style={{
          position: 'absolute',
          left: `${markerX}px`,
          top: `${markerY}px`,
          width: `${displayScaledSize}px`,
          height: `${displayScaledSize}px`,
          border: `2px dashed ${highlightColor}`,
          backgroundColor: 'rgba(74, 158, 255, 0.15)',
          boxSizing: 'border-box',
          pointerEvents: 'none',
          zIndex: 100,
          borderRadius: '2px'
        }}
      />
    );
  };

  return renderStartMarker();
};

return { AreaSelectLayer };

```

# useFogTools

```ts
/**
 * useFogTools.ts
 *
 * Custom hook for managing Fog of War tools (paint, erase, rectangle).
 * Handles all fog-related state and operations including:
 * - Paint tool (add fog) with cell tracking
 * - Erase tool (reveal/remove fog) with cell tracking
 * - Rectangle tool for fog/reveal rectangular areas
 *
 * Follows the same pattern as useDrawingTools for consistency.
 * Uses geometry abstraction for coordinate conversion.
 */

// Type-only imports
import type { MapData, MapLayer, FogOfWar } from '#types/core/map.types';
import type { Point, OffsetCoords, IGeometry } from '#types/core/geometry.types';
import type {
  FogToolId,
  FogRectangleStart,
  FogCellPosition,
  UseFogToolsResult,
  OnFogChangeCallback,
  OnInitializeFogCallback,
} from '#types/hooks/fog.types';

// Datacore imports
// Context types - inline until contexts are fully typed
interface MapStateValue {
  geometry: IGeometry | null;
  mapData: MapData | null;
  screenToGrid: (clientX: number, clientY: number) => Point | null;
}

const { useMapState } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext")) as {
  useMapState: () => MapStateValue;
};

const {
  getActiveLayer,
  initializeFogOfWar,
  fogCell,
  revealCell,
  fogRectangle,
  revealRectangle
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor")) as {
  getActiveLayer: (mapData: MapData) => MapLayer;
  initializeFogOfWar: (mapData: MapData, layerId: string) => MapData;
  fogCell: (layer: MapLayer, col: number, row: number) => MapLayer;
  revealCell: (layer: MapLayer, col: number, row: number) => MapLayer;
  fogRectangle: (layer: MapLayer, startCol: number, startRow: number, endCol: number, endRow: number) => MapLayer;
  revealRectangle: (layer: MapLayer, startCol: number, startRow: number, endCol: number, endRow: number) => MapLayer;
};

/**
 * Hook for managing fog of war tools
 *
 * @param activeTool - Current active fog tool: 'paint', 'erase', 'rectangle', or null
 * @param onFogChange - Callback when fog data changes
 * @param onInitializeFog - Callback to initialize fog structure if needed
 */
const useFogTools = (
  activeTool: FogToolId | null,
  onFogChange: OnFogChangeCallback | undefined,
  onInitializeFog: OnInitializeFogCallback | undefined
): UseFogToolsResult => {
  // Get required state from Context
  const {
    geometry,
    mapData,
    screenToGrid
  } = useMapState();

  // Fog tool state
  const [isDrawing, setIsDrawing] = dc.useState<boolean>(false);
  const [rectangleStart, setRectangleStart] = dc.useState<FogRectangleStart | null>(null);
  const [lastCell, setLastCell] = dc.useState<FogCellPosition | null>(null);
  const [processedCells, setProcessedCells] = dc.useState<Set<string>>(new Set());

  /**
   * Convert screen coordinates to offset coordinates (col, row)
   * Uses geometry abstraction for coordinate conversion
   */
  const screenToOffset = dc.useCallback(
    (clientX: number, clientY: number): OffsetCoords | null => {
      if (!geometry || !mapData) return null;

      // screenToGrid expects raw client coordinates
      const gridResult = screenToGrid(clientX, clientY);
      if (!gridResult) return null;

      // Use geometry's toOffsetCoords for abstracted conversion
      const { x, y } = gridResult;
      return geometry.toOffsetCoords(x, y);
    },
    [geometry, mapData, screenToGrid]
  );

  /**
   * Ensure fog is initialized before making changes
   * Returns the active layer's fog data, initializing if needed
   */
  const ensureFogInitialized = dc.useCallback((): FogOfWar | null => {
    if (!mapData) return null;

    const activeLayer = getActiveLayer(mapData);
    if (activeLayer.fogOfWar) {
      return activeLayer.fogOfWar;
    }

    // Initialize fog and notify parent
    const updatedMapData = initializeFogOfWar(mapData, mapData.activeLayerId);
    if (onInitializeFog) {
      onInitializeFog(updatedMapData);
    }

    return getActiveLayer(updatedMapData).fogOfWar;
  }, [mapData, onInitializeFog]);

  /**
   * Apply fog/reveal to a single cell based on active tool
   */
  const applyToCell = dc.useCallback(
    (col: number, row: number): void => {
      if (!mapData || !onFogChange) return;

      const fogData = ensureFogInitialized();
      if (!fogData) return;

      const activeLayer = getActiveLayer(mapData);
      let updatedLayer: MapLayer | undefined;

      if (activeTool === 'paint') {
        updatedLayer = fogCell(activeLayer, col, row);
      } else if (activeTool === 'erase') {
        updatedLayer = revealCell(activeLayer, col, row);
      } else {
        return;
      }

      if (updatedLayer && updatedLayer.fogOfWar) {
        onFogChange(updatedLayer.fogOfWar);
      }
    },
    [mapData, activeTool, onFogChange, ensureFogInitialized]
  );

  /**
   * Apply fog/reveal to a rectangular area
   * Rectangle tool defaults to reveal (erase) mode
   */
  const applyRectangle = dc.useCallback(
    (startCol: number, startRow: number, endCol: number, endRow: number): void => {
      if (!mapData || !onFogChange) return;

      const fogData = ensureFogInitialized();
      if (!fogData) return;

      const activeLayer = getActiveLayer(mapData);

      // Rectangle tool reveals (erases fog) by default
      const updatedLayer = revealRectangle(activeLayer, startCol, startRow, endCol, endRow);

      if (updatedLayer && updatedLayer.fogOfWar) {
        onFogChange(updatedLayer.fogOfWar);
      }
    },
    [mapData, onFogChange, ensureFogInitialized]
  );

  /**
   * Handle pointer down for fog tools
   */
  const handlePointerDown = dc.useCallback(
    (e: PointerEvent | MouseEvent): void => {
      if (!activeTool || e.button !== 0) return; // Left click only

      const offset = screenToOffset(e.clientX, e.clientY);
      if (!offset) return;

      const { col, row } = offset;

      if (activeTool === 'rectangle') {
        if (!rectangleStart) {
          setRectangleStart({ col, row });
        } else {
          applyRectangle(rectangleStart.col, rectangleStart.row, col, row);
          setRectangleStart(null);
        }
      } else if (activeTool === 'paint' || activeTool === 'erase') {
        setIsDrawing(true);
        setProcessedCells(new Set([`${col},${row}`]));
        setLastCell({ col, row });
        applyToCell(col, row);
      }
    },
    [activeTool, screenToOffset, rectangleStart, applyToCell, applyRectangle]
  );

  /**
   * Handle pointer move for fog tools (paint/erase drag)
   */
  const handlePointerMove = dc.useCallback(
    (e: PointerEvent | MouseEvent): void => {
      if (!activeTool || !isDrawing) return;
      if (activeTool === 'rectangle') return; // Rectangle doesn't use drag

      const offset = screenToOffset(e.clientX, e.clientY);
      if (!offset) return;

      const { col, row } = offset;
      const cellKey = `${col},${row}`;

      // Skip if we've already processed this cell in this stroke
      if (processedCells.has(cellKey)) return;

      // Skip if same cell as last (shouldn't happen with processedCells, but extra safety)
      if (lastCell && lastCell.col === col && lastCell.row === row) return;

      setProcessedCells((prev: Set<string>) => new Set([...prev, cellKey]));
      setLastCell({ col, row });
      applyToCell(col, row);
    },
    [activeTool, isDrawing, screenToOffset, lastCell, processedCells, applyToCell]
  );

  /**
   * Handle pointer up - end drawing stroke
   */
  const handlePointerUp = dc.useCallback((): void => {
    setIsDrawing(false);
    setLastCell(null);
    setProcessedCells(new Set());
  }, []);

  /**
   * Handle key events (Escape to cancel rectangle)
   */
  const handleKeyDown = dc.useCallback(
    (e: KeyboardEvent): void => {
      if (e.key === 'Escape' && rectangleStart) {
        setRectangleStart(null);
      }
    },
    [rectangleStart]
  );

  /**
   * Cancel any in-progress operation
   */
  const cancelFog = dc.useCallback((): void => {
    setIsDrawing(false);
    setRectangleStart(null);
    setLastCell(null);
    setProcessedCells(new Set());
  }, []);

  return {
    isDrawing,
    rectangleStart,
    handlePointerDown,
    handlePointerMove,
    handlePointerUp,
    handleKeyDown,
    cancelFog,
    screenToOffset
  };
};

return { useFogTools };

```

# FogOfWarLayer

```tsx
/**
 * FogOfWarLayer.tsx
 *
 * Interaction layer for Fog of War painting and erasing.
 *
 * This is a thin wrapper component that:
 * - Uses useFogTools hook for all logic
 * - Registers handlers with EventHandlerContext
 * - Renders preview overlay for rectangle start point
 */

import type { FogTool } from '../VisibilityToolbar.tsx';
import type { FogOfWar } from '#types/core/map.types';

const { useFogTools } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useFogTools"));
const { useMapState } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext"));
const { useEventHandlerRegistration } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "EventHandlerContext"));
const { GridGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "GridGeometry"));

/** Props for FogOfWarLayer component */
export interface FogOfWarLayerProps {
  /** Current FoW tool: 'paint', 'erase', 'rectangle', or null */
  activeTool: FogTool;
  /** Callback when fog data changes */
  onFogChange: (updatedFogOfWar: FogOfWar) => void;
  /** Callback to initialize fog if needed */
  onInitializeFog?: () => void;
}

const FogOfWarLayer = ({
  activeTool,
  onFogChange,
  onInitializeFog
}: FogOfWarLayerProps): React.ReactElement | null => {
  const { canvasRef, containerRef, mapData, geometry } = useMapState();
  const { registerHandlers, unregisterHandlers } = useEventHandlerRegistration();

  const {
    isDrawing,
    rectangleStart,
    handlePointerDown,
    handlePointerMove,
    handlePointerUp,
    handleKeyDown,
    cancelFog
  } = useFogTools(activeTool, onFogChange, onInitializeFog);

  dc.useEffect(() => {
    if (!activeTool) {
      unregisterHandlers('fogOfWar');
      return;
    }

    registerHandlers('fogOfWar', {
      handlePointerDown,
      handlePointerMove,
      handlePointerUp,
      handleKeyDown,
      isDrawing,
      rectangleStart
    });

    return () => unregisterHandlers('fogOfWar');
  }, [activeTool, registerHandlers, unregisterHandlers,
    handlePointerDown, handlePointerMove, handlePointerUp, handleKeyDown,
    isDrawing, rectangleStart]);

  const renderPreviewOverlay = (): React.ReactElement | null => {
    if (!activeTool || !rectangleStart || !canvasRef.current || !containerRef?.current || !geometry) {
      return null;
    }

    const canvas = canvasRef.current;
    const { viewState, northDirection } = mapData;
    const { zoom, center } = viewState;
    const { width, height } = canvas;

    let scaledSize: number;
    let offsetX: number;
    let offsetY: number;

    const isGrid = geometry instanceof GridGeometry;
    if (isGrid) {
      scaledSize = geometry.getScaledCellSize(zoom);
      offsetX = width / 2 - center.x * scaledSize;
      offsetY = height / 2 - center.y * scaledSize;
    } else {
      offsetX = width / 2 - center.x * zoom;
      offsetY = height / 2 - center.y * zoom;
      scaledSize = geometry.getScaledCellSize(zoom);
    }

    const containerRect = containerRef.current.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();

    const canvasOffsetX = canvasRect.left - containerRect.left;
    const canvasOffsetY = canvasRect.top - containerRect.top;

    const displayScale = canvasRect.width / width;

    const { col, row } = rectangleStart;

    let screenX: number;
    let screenY: number;

    if (isGrid) {
      const worldX = (col + 0.5) * geometry.cellSize;
      const worldY = (row + 0.5) * geometry.cellSize;
      screenX = offsetX + worldX * zoom;
      screenY = offsetY + worldY * zoom;
    } else {
      if (geometry.offsetToAxial) {
        const axial = geometry.offsetToAxial(col, row);
        const world = geometry.gridToWorld(axial.q, axial.r);
        screenX = offsetX + world.worldX * zoom;
        screenY = offsetY + world.worldY * zoom;
      } else {
        screenX = offsetX + col * scaledSize;
        screenY = offsetY + row * scaledSize;
      }
    }

    if (northDirection !== 0) {
      const centerX = width / 2;
      const centerY = height / 2;

      screenX -= centerX;
      screenY -= centerY;

      const angleRad = (northDirection * Math.PI) / 180;
      const rotatedX = screenX * Math.cos(angleRad) - screenY * Math.sin(angleRad);
      const rotatedY = screenX * Math.sin(angleRad) + screenY * Math.cos(angleRad);

      screenX = rotatedX + centerX;
      screenY = rotatedY + centerY;
    }

    const displayX = canvasOffsetX + screenX * displayScale;
    const displayY = canvasOffsetY + screenY * displayScale;
    const displaySize = scaledSize * displayScale;

    const halfSize = displaySize / 2;

    return (
      <div
        className="dmt-fow-preview"
        style={{
          position: 'absolute',
          left: `${displayX - halfSize}px`,
          top: `${displayY - halfSize}px`,
          width: `${displaySize}px`,
          height: `${displaySize}px`,
          border: '2px dashed #00ff00',
          backgroundColor: 'rgba(0, 255, 0, 0.1)',
          boxSizing: 'border-box',
          pointerEvents: 'none',
          zIndex: 100
        }}
      />
    );
  };

  return renderPreviewOverlay();
};

return { FogOfWarLayer };

```

# dungeonGenerator

```js
/**
 * dungeonGenerator.js
 * 
 * Pure procedural dungeon generation module for Windrose MapDesigner.
 * Implements a four-phase pipeline:
 *   1. Room Generation - scatter rooms with collision detection (monte carlo problem)
 *   2. Connection Graph - determine which rooms connect (via MST algorithm)
 *   3. Corridor Carving - create paths between connected rooms (a nightmare)
 *   4. Cell Generation - convert to Windrose cell format
 * 
 */

// =============================================================================
// PRESETS
// =============================================================================

const DUNGEON_PRESETS = {
  small: {
    // "Tight Lair" - cramped goblin den, linear flow, get in and get out
    gridWidth: 20,
    gridHeight: 20,
    roomCount: { min: 3, max: 5 },
    roomSize: { minWidth: 3, maxWidth: 5, minHeight: 3, maxHeight: 5 },
    padding: 1,
    corridorWidth: 1,
    corridorStyle: 'straight',
    circleChance: 0.15,
    complexRoomChance: 0.1,
    loopChance: 0,
    doorChance: 0.7,
    secretDoorChance: 0.05,
    wideCorridorChance: 0,
    diagonalCorridorChance: 0
  },
  medium: {
    // "Complex" - classic dungeon, multiple paths, exploration, some grand halls
    gridWidth: 40,
    gridHeight: 40,
    roomCount: { min: 8, max: 12 },
    roomSize: { minWidth: 4, maxWidth: 8, minHeight: 4, maxHeight: 8 },
    padding: 2,
    corridorWidth: 1,
    corridorStyle: 'straight',
    circleChance: 0.3,
    complexRoomChance: 0.15,
    loopChance: 0.15,
    doorChance: 0.7,
    secretDoorChance: 0.05,
    wideCorridorChance: 0.25,
    diagonalCorridorChance: 0.5
  },
  large: {
    // "Grand" - fortress/temple scale, grand corridors, many chambers, sprawling
    gridWidth: 60,
    gridHeight: 60,
    roomCount: { min: 10, max: 15 },
    roomSize: { minWidth: 4, maxWidth: 10, minHeight: 4, maxHeight: 10 },
    padding: 3,
    corridorWidth: 1,
    corridorStyle: 'straight',
    circleChance: 0.3,
    complexRoomChance: 0.15,
    loopChance: 0.08,
    doorChance: 0.7,
    secretDoorChance: 0.05,
    wideCorridorChance: 0.5,
    diagonalCorridorChance: 0.5
  }
};

// =============================================================================
// DUNGEON STYLES
// Styles are overlay configurations applied on top of size presets.
// They define the "flavor" of the dungeon independent of its size.
// =============================================================================

const DUNGEON_STYLES = {
  classic: {
    // Default balanced dungeon - no overrides needed
    name: 'Classic',
    description: 'Balanced mix of rooms and corridors',
    overrides: {
      waterChance: 0.15,
      diagonalCorridorChance: 0.5
    }
  },
  cavern: {
    name: 'Cavern',
    description: 'Natural cave system with organic passages',
    overrides: {
      circleChance: 0.6,
      complexRoomChance: 0.05,
      corridorStyle: 'organic',
      doorChance: 0,
      secretDoorChance: 0,
      loopChance: 0.2,
      roomSizeBias: 0.3,
      waterChance: 0.35,
      diagonalCorridorChance: 0.7  // More organic paths
    }
  },
  fortress: {
    name: 'Fortress',
    description: 'Military structure with wide corridors and many doors',
    overrides: {
      circleChance: 0,
      complexRoomChance: 0.25,
      corridorStyle: 'straight',
      doorChance: 0.95,
      secretDoorChance: 0.02,
      wideCorridorChance: 0.7,
      roomSizeBias: -0.2,
      waterChance: 0.05,
      diagonalCorridorChance: 0.2  // Military = more ordered
    }
  },
  crypt: {
    name: 'Crypt',
    description: 'Tight passages with hidden chambers',
    overrides: {
      circleChance: 0.1,
      complexRoomChance: 0.1,
      corridorStyle: 'straight',
      doorChance: 0.5,
      secretDoorChance: 0.2,
      loopChance: 0.02,
      wideCorridorChance: 0,
      roomSizeBias: -0.4,
      waterChance: 0.20,
      diagonalCorridorChance: 0.3
    }
  }
};

const DEFAULT_FLOOR_COLOR = '#c4a57b';
const DEFAULT_WATER_COLOR = '#4a90d9';
const DEFAULT_WATER_OPACITY = 0.6;

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * Generate a random integer with bias toward min or max.
 * @param {number} min - Minimum value
 * @param {number} max - Maximum value  
 * @param {number} bias - Bias from -1 (favor min/compact) to 1 (favor max/spacious), 0 = uniform
 */
function biasedRandomInt(min, max, bias = 0) {
  if (bias === 0) return randomInt(min, max);
  
  // Use power curve to skew distribution
  // bias > 0: skew toward max (spacious)
  // bias < 0: skew toward min (compact)
  const t = Math.random();
  const exponent = bias > 0 ? 1 / (1 + bias * 2) : 1 + Math.abs(bias) * 2;
  const skewed = Math.pow(t, exponent);
  
  return Math.floor(min + skewed * (max - min + 1));
}

function rectanglesOverlap(a, b, padding = 0) {
  return !(
    a.x + a.width + padding <= b.x ||
    b.x + b.width + padding <= a.x ||
    a.y + a.height + padding <= b.y ||
    b.y + b.height + padding <= a.y
  );
}

function getRoomCenter(room) {
  if (room.shape === 'circle') {
    return {
      x: Math.floor(room.x + room.radius),
      y: Math.floor(room.y + room.radius)
    };
  }
  return {
    x: Math.floor(room.x + room.width / 2),
    y: Math.floor(room.y + room.height / 2)
  };
}

function cellKey(x, y) {
  return `${x},${y}`;
}

function isCellInRoom(x, y, room) {
  if (x < room.x || x >= room.x + room.width ||
      y < room.y || y >= room.y + room.height) {
    return false;
  }
  
  if (room.shape === 'circle') {
    const centerX = room.x + room.radius;
    const centerY = room.y + room.radius;
    const dx = x + 0.5 - centerX;
    const dy = y + 0.5 - centerY;
    return dx * dx + dy * dy <= room.radius * room.radius;
  }
  
  if (room.shape === 'composite') {
    // Check if cell is in any of the room's parts
    return room.parts.some(part => 
      x >= part.x && x < part.x + part.width &&
      y >= part.y && y < part.y + part.height
    );
  }
  
  return true;
}

/**
 * Check if cell is in room's RECTANGULAR bounds only.
 * Used for door detection to avoid circular room corner issues.
 */
function isCellInRoomRect(x, y, room) {
  return x >= room.x && x < room.x + room.width &&
         y >= room.y && y < room.y + room.height;
}

function generateObjectId() {
  return 'obj-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
}

// =============================================================================
// COMPOSITE ROOM GENERATION (L and T shapes)
// =============================================================================

/**
 * Generate an L-shaped room from two overlapping rectangles.
 * The L can be in any of 4 orientations.
 * @param {number} x - Base x position
 * @param {number} y - Base y position  
 * @param {Object} roomSize - {minWidth, maxWidth, minHeight, maxHeight}
 * @param {number} bias - Room size bias (-1 to 1)
 * @returns {Object} Room with shape='composite' and parts array
 */
function generateLShapedRoom(x, y, roomSize, bias = 0) {
  // Generate two rectangles that will form the L
  // First rectangle is the "stem", second is the "foot"
  const stemWidth = biasedRandomInt(roomSize.minWidth, roomSize.maxWidth, bias);
  const stemHeight = biasedRandomInt(Math.max(roomSize.minHeight, 4), roomSize.maxHeight + 2, bias);
  
  const footWidth = biasedRandomInt(roomSize.minWidth, roomSize.maxWidth + 2, bias);
  const footHeight = biasedRandomInt(Math.max(2, Math.floor(roomSize.minHeight / 2)), Math.floor(roomSize.maxHeight / 2) + 1, bias);
  
  // Choose orientation (which corner the L bends toward)
  const orientation = randomInt(0, 3);
  
  let parts;
  switch (orientation) {
    case 0: //  shape - foot extends right from bottom of stem
      parts = [
        { x: x, y: y, width: stemWidth, height: stemHeight },
        { x: x + stemWidth - Math.min(2, stemWidth - 1), y: y + stemHeight - footHeight, width: footWidth, height: footHeight }
      ];
      break;
    case 1: //  shape - foot extends left from bottom of stem
      parts = [
        { x: x + footWidth - Math.min(2, footWidth - 1), y: y, width: stemWidth, height: stemHeight },
        { x: x, y: y + stemHeight - footHeight, width: footWidth, height: footHeight }
      ];
      break;
    case 2: //  shape - foot extends left from top of stem  
      parts = [
        { x: x + footWidth - Math.min(2, footWidth - 1), y: y + footHeight - Math.min(2, footHeight - 1), width: stemWidth, height: stemHeight },
        { x: x, y: y, width: footWidth, height: footHeight }
      ];
      break;
    case 3: //  shape - foot extends right from top of stem
    default:
      parts = [
        { x: x, y: y + footHeight - Math.min(2, footHeight - 1), width: stemWidth, height: stemHeight },
        { x: x + stemWidth - Math.min(2, stemWidth - 1), y: y, width: footWidth, height: footHeight }
      ];
      break;
  }
  
  // Calculate bounding box
  const minX = Math.min(...parts.map(p => p.x));
  const minY = Math.min(...parts.map(p => p.y));
  const maxX = Math.max(...parts.map(p => p.x + p.width));
  const maxY = Math.max(...parts.map(p => p.y + p.height));
  
  // Normalize parts to be relative to bounding box origin
  const normalizedParts = parts.map(p => ({
    x: p.x - minX + x,
    y: p.y - minY + y,
    width: p.width,
    height: p.height
  }));
  
  return {
    x: x,
    y: y,
    width: maxX - minX,
    height: maxY - minY,
    shape: 'composite',
    compositeType: 'L',
    parts: normalizedParts
  };
}

/**
 * Generate a T-shaped room from two overlapping rectangles.
 * The T can be in any of 4 orientations.
 * @param {number} x - Base x position
 * @param {number} y - Base y position
 * @param {Object} roomSize - {minWidth, maxWidth, minHeight, maxHeight}
 * @param {number} bias - Room size bias (-1 to 1)
 * @returns {Object} Room with shape='composite' and parts array
 */
function generateTShapedRoom(x, y, roomSize, bias = 0) {
  // T-shape needs a minimum size to look good
  const stemWidth = biasedRandomInt(Math.max(2, roomSize.minWidth - 1), Math.max(3, roomSize.maxWidth - 2), bias);
  const stemHeight = biasedRandomInt(Math.max(roomSize.minHeight, 4), roomSize.maxHeight + 2, bias);
  
  const capWidth = biasedRandomInt(roomSize.minWidth + 2, roomSize.maxWidth + 4, bias);
  const capHeight = biasedRandomInt(2, Math.floor(roomSize.maxHeight / 2) + 1, bias);
  
  // Choose orientation
  const orientation = randomInt(0, 3);
  
  let parts;
  const stemOffset = Math.floor((capWidth - stemWidth) / 2);
  
  switch (orientation) {
    case 0: //  shape - cap on bottom
      parts = [
        { x: x + stemOffset, y: y, width: stemWidth, height: stemHeight },
        { x: x, y: y + stemHeight - Math.min(2, capHeight), width: capWidth, height: capHeight }
      ];
      break;
    case 1: //  shape - cap on top
      parts = [
        { x: x + stemOffset, y: y + capHeight - Math.min(2, capHeight), width: stemWidth, height: stemHeight },
        { x: x, y: y, width: capWidth, height: capHeight }
      ];
      break;
    case 2: //  shape - cap on left (rotated T)
      parts = [
        { x: x + capHeight - Math.min(2, capHeight), y: y + stemOffset, width: stemHeight, height: stemWidth },
        { x: x, y: y, width: capHeight, height: capWidth }
      ];
      break;
    case 3: //  shape - cap on right (rotated T)
    default:
      parts = [
        { x: x, y: y + stemOffset, width: stemHeight, height: stemWidth },
        { x: x + stemHeight - Math.min(2, capHeight), y: y, width: capHeight, height: capWidth }
      ];
      break;
  }
  
  // Calculate bounding box
  const minX = Math.min(...parts.map(p => p.x));
  const minY = Math.min(...parts.map(p => p.y));
  const maxX = Math.max(...parts.map(p => p.x + p.width));
  const maxY = Math.max(...parts.map(p => p.y + p.height));
  
  // Normalize parts to bounding box origin
  const normalizedParts = parts.map(p => ({
    x: p.x - minX + x,
    y: p.y - minY + y,
    width: p.width,
    height: p.height
  }));
  
  return {
    x: x,
    y: y,
    width: maxX - minX,
    height: maxY - minY,
    shape: 'composite',
    compositeType: 'T',
    parts: normalizedParts
  };
}

/**
 * Generate a composite (L or T shaped) room.
 * 70% chance of L-shape, 30% chance of T-shape.
 * @param {number} x - Base x position
 * @param {number} y - Base y position
 * @param {Object} roomSize - {minWidth, maxWidth, minHeight, maxHeight}
 * @param {number} bias - Room size bias
 * @returns {Object} Composite room
 */
function generateCompositeRoom(x, y, roomSize, bias = 0) {
  if (Math.random() < 0.7) {
    return generateLShapedRoom(x, y, roomSize, bias);
  } else {
    return generateTShapedRoom(x, y, roomSize, bias);
  }
}

// =============================================================================
// PHASE 1: ROOM GENERATION
// =============================================================================

function generateRooms(config) {
  const {
    gridWidth,
    gridHeight,
    roomCount,
    roomSize,
    padding,
    circleChance = 0,
    complexRoomChance = 0,
    roomSizeBias = 0
  } = config;
  
  const targetCount = randomInt(roomCount.min, roomCount.max);
  const rooms = [];
  const maxAttempts = targetCount * 50;
  let attempts = 0;
  
  while (rooms.length < targetCount && attempts < maxAttempts) {
    attempts++;
    
    // Determine room type: circle, composite (L/T), or rectangle
    const roll = Math.random();
    const isCircle = roll < circleChance;
    const isComposite = !isCircle && roll < circleChance + complexRoomChance;
    
    let newRoom;
    
    if (isCircle) {
      const minRadius = Math.floor(Math.min(roomSize.minWidth, roomSize.minHeight) / 2);
      const maxRadius = Math.floor(Math.max(roomSize.maxWidth, roomSize.maxHeight) / 2);
      const radius = biasedRandomInt(Math.max(2, minRadius), Math.max(3, maxRadius), roomSizeBias);
      const diameter = radius * 2;
      
      const margin = padding + 1;
      const maxX = gridWidth - diameter - margin;
      const maxY = gridHeight - diameter - margin;
      
      if (maxX < margin || maxY < margin) continue;
      
      const x = randomInt(margin, maxX);
      const y = randomInt(margin, maxY);
      
      newRoom = {
        id: rooms.length,
        x, y,
        width: diameter,
        height: diameter,
        shape: 'circle',
        radius
      };
    } else if (isComposite) {
      // Generate composite room, then check if it fits
      const margin = padding + 1;
      
      // Estimate max bounds for composite (they can be larger than normal rooms)
      const estimatedMaxSize = roomSize.maxWidth + roomSize.maxHeight;
      const maxX = gridWidth - estimatedMaxSize - margin;
      const maxY = gridHeight - estimatedMaxSize - margin;
      
      if (maxX < margin || maxY < margin) continue;
      
      const x = randomInt(margin, maxX);
      const y = randomInt(margin, maxY);
      
      newRoom = generateCompositeRoom(x, y, roomSize, roomSizeBias);
      newRoom.id = rooms.length;
      
      // Verify the room fits within grid bounds
      if (newRoom.x + newRoom.width > gridWidth - margin ||
          newRoom.y + newRoom.height > gridHeight - margin) {
        continue;
      }
    } else {
      const width = biasedRandomInt(roomSize.minWidth, roomSize.maxWidth, roomSizeBias);
      const height = biasedRandomInt(roomSize.minHeight, roomSize.maxHeight, roomSizeBias);
      
      const margin = padding + 1;
      const maxX = gridWidth - width - margin;
      const maxY = gridHeight - height - margin;
      
      if (maxX < margin || maxY < margin) continue;
      
      const x = randomInt(margin, maxX);
      const y = randomInt(margin, maxY);
      
      newRoom = {
        id: rooms.length,
        x, y,
        width,
        height,
        shape: 'rectangle'
      };
    }
    
    const hasOverlap = rooms.some(existing => 
      rectanglesOverlap(newRoom, existing, padding)
    );
    
    if (!hasOverlap) {
      rooms.push(newRoom);
    }
  }
  
  return rooms;
}

// =============================================================================
// PHASE 2: CONNECTION GRAPH (MST)
// =============================================================================

function getRoomDistance(roomA, roomB) {
  const centerA = getRoomCenter(roomA);
  const centerB = getRoomCenter(roomB);
  const dx = centerB.x - centerA.x;
  const dy = centerB.y - centerA.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function buildConnectionGraph(rooms, loopChance = 0) {
  if (rooms.length < 2) return [];
  
  const connections = [];
  const connectedIndices = new Set([0]);
  const unconnectedIndices = new Set(rooms.map((_, i) => i).filter(i => i !== 0));
  
  const allEdges = [];
  for (let i = 0; i < rooms.length; i++) {
    for (let j = i + 1; j < rooms.length; j++) {
      allEdges.push({
        i, j,
        distance: getRoomDistance(rooms[i], rooms[j])
      });
    }
  }
  
  allEdges.sort((a, b) => a.distance - b.distance);
  
  const mstEdges = new Set();
  
  while (unconnectedIndices.size > 0) {
    let bestEdge = null;
    let bestDistance = Infinity;
    
    for (const edge of allEdges) {
      const iConnected = connectedIndices.has(edge.i);
      const jConnected = connectedIndices.has(edge.j);
      
      if (iConnected === jConnected) continue;
      
      if (edge.distance < bestDistance) {
        bestDistance = edge.distance;
        bestEdge = edge;
      }
    }
    
    if (bestEdge) {
      connections.push([rooms[bestEdge.i], rooms[bestEdge.j]]);
      mstEdges.add(bestEdge);
      
      const newConnected = connectedIndices.has(bestEdge.i) ? bestEdge.j : bestEdge.i;
      connectedIndices.add(newConnected);
      unconnectedIndices.delete(newConnected);
    } else {
      break;
    }
  }
  
  if (loopChance > 0) {
    for (const edge of allEdges) {
      if (mstEdges.has(edge)) continue;
      if (Math.random() < loopChance) {
        connections.push([rooms[edge.i], rooms[edge.j]]);
      }
    }
  }
  
  return connections;
}

// =============================================================================
// PHASE 3: CORRIDOR CARVING
// =============================================================================

/**
 * Check if a cell is adjacent to a room (but not inside it).
 * Used to detect if a corridor runs along a room's wall.
 */
function isCellAdjacentToRoom(x, y, room) {
  if (isCellInRoomRect(x, y, room)) return false;
  
  return isCellInRoomRect(x - 1, y, room) ||
         isCellInRoomRect(x + 1, y, room) ||
         isCellInRoomRect(x, y - 1, room) ||
         isCellInRoomRect(x, y + 1, room);
}

/**
 * Try to find an offset path that avoids adjacency issues.
 * Creates a 3-segment "Z-shape" path by offsetting the elbow point.
 */
function tryOffsetPath(centerA, centerB, width, startOffset, endOffset, allRooms, roomA, roomB) {
  const dx = centerB.x - centerA.x;
  const dy = centerB.y - centerA.y;
  const xDir = dx > 0 ? 1 : dx < 0 ? -1 : 0;
  const yDir = dy > 0 ? 1 : dy < 0 ? -1 : 0;
  
  // Try various elbow offsets
  const offsets = [2, -2, 3, -3, 4, -4];
  
  for (const offset of offsets) {
    // Try horizontal-first with offset elbow
    const elbowX = centerB.x + offset;
    const elbowY = centerA.y;
    
    if (isOffsetPathClear(centerA, centerB, elbowX, elbowY, width, startOffset, endOffset, allRooms, roomA, roomB, xDir, yDir)) {
      return carveOffsetPath(centerA, centerB, elbowX, elbowY, width, startOffset, endOffset, xDir, yDir, true);
    }
    
    // Try vertical-first with offset elbow
    const elbowX2 = centerA.x;
    const elbowY2 = centerB.y + offset;
    
    if (isOffsetPathClear(centerA, centerB, elbowX2, elbowY2, width, startOffset, endOffset, allRooms, roomA, roomB, xDir, yDir)) {
      return carveOffsetPath(centerA, centerB, elbowX2, elbowY2, width, startOffset, endOffset, xDir, yDir, false);
    }
  }
  
  return null; // No clear offset found
}

/**
 * Check if an offset path would be clear of adjacency issues.
 */
function isOffsetPathClear(centerA, centerB, elbowX, elbowY, width, startOffset, endOffset, allRooms, roomA, roomB, xDir, yDir) {
  const corridorCells = [];
  
  // Segment 1: centerA to elbow
  const seg1Horizontal = (elbowY === centerA.y);
  if (seg1Horizontal) {
    const dir = elbowX > centerA.x ? 1 : -1;
    for (let x = centerA.x; x !== elbowX + dir; x += dir) {
      for (let w = startOffset; w <= endOffset; w++) {
        corridorCells.push({ x, y: centerA.y + w });
      }
    }
  } else {
    const dir = elbowY > centerA.y ? 1 : -1;
    for (let y = centerA.y; y !== elbowY + dir; y += dir) {
      for (let w = startOffset; w <= endOffset; w++) {
        corridorCells.push({ x: centerA.x + w, y });
      }
    }
  }
  
  // Segment 2: elbow to centerB
  if (seg1Horizontal) {
    // Second segment is vertical
    const dir = centerB.y > elbowY ? 1 : -1;
    for (let y = elbowY; y !== centerB.y + dir; y += dir) {
      for (let w = startOffset; w <= endOffset; w++) {
        corridorCells.push({ x: elbowX + w, y });
      }
    }
  } else {
    // Second segment is horizontal
    const dir = centerB.x > elbowX ? 1 : -1;
    for (let x = elbowX; x !== centerB.x + dir; x += dir) {
      for (let w = startOffset; w <= endOffset; w++) {
        corridorCells.push({ x, y: elbowY + w });
      }
    }
  }
  
  // Check if path runs alongside source or dest room
  if (runsAlongsideRoom(corridorCells, roomA)) return false;
  if (runsAlongsideRoom(corridorCells, roomB)) return false;
  
  // Check adjacency to other rooms
  for (const room of allRooms) {
    if (room.id === roomA.id || room.id === roomB.id) continue;
    
    let adjacentCount = 0;
    for (const cell of corridorCells) {
      if (isCellInRoomRect(cell.x, cell.y, roomA)) continue;
      if (isCellInRoomRect(cell.x, cell.y, roomB)) continue;
      
      if (isCellAdjacentToRoom(cell.x, cell.y, room)) {
        adjacentCount++;
        if (adjacentCount > 1) return false;
      }
    }
  }
  
  return true;
}

/**
 * Carve a path with a specified elbow point.
 */
function carveOffsetPath(centerA, centerB, elbowX, elbowY, width, startOffset, endOffset, xDir, yDir, horizontalFirst) {
  const cells = [];
  const orderedPath = [];
  
  if (horizontalFirst) {
    // Horizontal to elbow
    const hDir = elbowX > centerA.x ? 1 : elbowX < centerA.x ? -1 : 0;
    if (hDir !== 0) {
      for (let x = centerA.x; x !== elbowX + hDir; x += hDir) {
        orderedPath.push({ x, y: centerA.y });
        for (let w = startOffset; w <= endOffset; w++) {
          cells.push({ x, y: centerA.y + w });
        }
      }
    }
    
    // Vertical from elbow to centerB.y
    const vDir = centerB.y > elbowY ? 1 : centerB.y < elbowY ? -1 : 0;
    if (vDir !== 0) {
      for (let y = elbowY; y !== centerB.y + vDir; y += vDir) {
        orderedPath.push({ x: elbowX, y });
        for (let w = startOffset; w <= endOffset; w++) {
          cells.push({ x: elbowX + w, y });
        }
      }
    }
    
    // Horizontal from elbowX to centerB.x (if needed)
    const hDir2 = centerB.x > elbowX ? 1 : centerB.x < elbowX ? -1 : 0;
    if (hDir2 !== 0 && elbowX !== centerB.x) {
      for (let x = elbowX + hDir2; x !== centerB.x + hDir2; x += hDir2) {
        orderedPath.push({ x, y: centerB.y });
        for (let w = startOffset; w <= endOffset; w++) {
          cells.push({ x, y: centerB.y + w });
        }
      }
    }
  } else {
    // Vertical to elbow
    const vDir = elbowY > centerA.y ? 1 : elbowY < centerA.y ? -1 : 0;
    if (vDir !== 0) {
      for (let y = centerA.y; y !== elbowY + vDir; y += vDir) {
        orderedPath.push({ x: centerA.x, y });
        for (let w = startOffset; w <= endOffset; w++) {
          cells.push({ x: centerA.x + w, y });
        }
      }
    }
    
    // Horizontal from elbow to centerB.x
    const hDir = centerB.x > elbowX ? 1 : centerB.x < elbowX ? -1 : 0;
    if (hDir !== 0) {
      for (let x = elbowX; x !== centerB.x + hDir; x += hDir) {
        orderedPath.push({ x, y: elbowY });
        for (let w = startOffset; w <= endOffset; w++) {
          cells.push({ x, y: elbowY + w });
        }
      }
    }
    
    // Vertical from elbowY to centerB.y (if needed)
    const vDir2 = centerB.y > elbowY ? 1 : centerB.y < elbowY ? -1 : 0;
    if (vDir2 !== 0 && elbowY !== centerB.y) {
      for (let y = elbowY + vDir2; y !== centerB.y + vDir2; y += vDir2) {
        orderedPath.push({ x: centerB.x, y });
        for (let w = startOffset; w <= endOffset; w++) {
          cells.push({ x: centerB.x + w, y });
        }
      }
    }
  }
  
  return { cells, orderedPath, width };
}

function carveCorridorBetween(roomA, roomB, width = 1, allRooms = []) {
  const centerA = getRoomCenter(roomA);
  const centerB = getRoomCenter(roomB);
  
  const cells = [];
  const orderedPath = [];
  
  // Calculate width offsets for corridor spreading
  const startOffset = -Math.floor((width - 1) / 2);
  const endOffset = Math.floor(width / 2);
  
  // Determine direction
  const dx = centerB.x - centerA.x;
  const dy = centerB.y - centerA.y;
  const xDir = dx > 0 ? 1 : dx < 0 ? -1 : 0;
  const yDir = dy > 0 ? 1 : dy < 0 ? -1 : 0;
  
  // Check both L-orientations for adjacency issues
  const horizontalFirstBad = wouldRunAdjacentToRoom(
    centerA, centerB, true, allRooms, roomA, roomB, width
  );
  const verticalFirstBad = wouldRunAdjacentToRoom(
    centerA, centerB, false, allRooms, roomA, roomB, width
  );
  
  // If BOTH orientations are bad, try using a 3-segment path with offset elbow
  if (horizontalFirstBad && verticalFirstBad) {
    const offsetResult = tryOffsetPath(centerA, centerB, width, startOffset, endOffset, allRooms, roomA, roomB);
    if (offsetResult) {
      return offsetResult;
    }
  }
  
  // Prefer horizontal-first randomly, but avoid adjacency issues
  let horizontalFirst;
  if (horizontalFirstBad && !verticalFirstBad) {
    horizontalFirst = false;
  } else if (verticalFirstBad && !horizontalFirstBad) {
    horizontalFirst = true;
  } else {
    horizontalFirst = Math.random() < 0.5;
  }
  
  if (horizontalFirst) {
    // Horizontal from A's center.x toward B's center.x, then vertical to B's center
    for (let x = centerA.x; x !== centerB.x + xDir; x += xDir || 1) {
      if (xDir === 0) break;
      orderedPath.push({ x, y: centerA.y });
      for (let w = startOffset; w <= endOffset; w++) {
        cells.push({ x, y: centerA.y + w });
      }
    }
    
    // Vertical segment at B's x
    const yStart = xDir === 0 ? centerA.y : centerA.y + yDir;
    for (let y = yStart; y !== centerB.y + yDir; y += yDir || 1) {
      if (yDir === 0) break;
      orderedPath.push({ x: centerB.x, y });
      for (let w = startOffset; w <= endOffset; w++) {
        cells.push({ x: centerB.x + w, y });
      }
    }
  } else {
    // Vertical from A's center.y toward B's center.y, then horizontal to B's center
    for (let y = centerA.y; y !== centerB.y + yDir; y += yDir || 1) {
      if (yDir === 0) break;
      orderedPath.push({ x: centerA.x, y });
      for (let w = startOffset; w <= endOffset; w++) {
        cells.push({ x: centerA.x + w, y });
      }
    }
    
    // Horizontal segment at B's y
    const xStart = yDir === 0 ? centerA.x : centerA.x + xDir;
    for (let x = xStart; x !== centerB.x + xDir; x += xDir || 1) {
      if (xDir === 0) break;
      orderedPath.push({ x, y: centerB.y });
      for (let w = startOffset; w <= endOffset; w++) {
        cells.push({ x, y: centerB.y + w });
      }
    }
  }
  
  // Ensure we include both endpoints
  if (orderedPath.length === 0 || 
      (orderedPath[orderedPath.length - 1].x !== centerB.x || 
       orderedPath[orderedPath.length - 1].y !== centerB.y)) {
    orderedPath.push({ x: centerB.x, y: centerB.y });
    for (let w = startOffset; w <= endOffset; w++) {
      cells.push({ x: centerB.x + w, y: centerB.y });
      cells.push({ x: centerB.x, y: centerB.y + w });
    }
  }
  
  return { cells, orderedPath, width };
}

/**
 * Check if corridor cells run alongside a room (adjacent but outside) for more than 1 cell.
 * This catches cases like a corridor running along a room's wall before entering it.
 */
function runsAlongsideRoom(corridorCells, room) {
  let adjacentOutsideCount = 0;
  
  for (const cell of corridorCells) {
    // Skip cells that are INSIDE the room (those are fine - it's the entry)
    if (isCellInRoomRect(cell.x, cell.y, room)) continue;
    
    // Check if this cell is adjacent to the room
    if (isCellAdjacentToRoom(cell.x, cell.y, room)) {
      adjacentOutsideCount++;
      if (adjacentOutsideCount > 1) {
        return true;
      }
    }
  }
  
  return false;
}

function wouldRunAdjacentToRoom(centerA, centerB, horizontalFirst, allRooms, roomA, roomB, width = 1) {
  const dx = centerB.x - centerA.x;
  const dy = centerB.y - centerA.y;
  const xDir = dx > 0 ? 1 : dx < 0 ? -1 : 0;
  const yDir = dy > 0 ? 1 : dy < 0 ? -1 : 0;
  
  // Width offsets (must match carveCorridorBetween)
  const startOffset = -Math.floor((width - 1) / 2);
  const endOffset = Math.floor(width / 2);
  
  // Collect ALL corridor cells 
  const corridorCells = [];
  
  if (horizontalFirst) {
    // First segment: horizontal at centerA.y
    if (xDir !== 0) {
      for (let x = centerA.x; x !== centerB.x + xDir; x += xDir) {
        for (let w = startOffset; w <= endOffset; w++) {
          corridorCells.push({ x, y: centerA.y + w });
        }
      }
    }
    // Second segment: vertical at centerB.x (starts at centerA.y + yDir to skip elbow)
    if (yDir !== 0) {
      const yStart = xDir === 0 ? centerA.y : centerA.y + yDir;
      for (let y = yStart; y !== centerB.y + yDir; y += yDir) {
        for (let w = startOffset; w <= endOffset; w++) {
          corridorCells.push({ x: centerB.x + w, y });
        }
      }
    }
  } else {
    // First segment: vertical at centerA.x
    if (yDir !== 0) {
      for (let y = centerA.y; y !== centerB.y + yDir; y += yDir) {
        for (let w = startOffset; w <= endOffset; w++) {
          corridorCells.push({ x: centerA.x + w, y });
        }
      }
    }
    // Second segment: horizontal at centerB.y (starts at centerA.x + xDir to skip elbow)
    if (xDir !== 0) {
      const xStart = yDir === 0 ? centerA.x : centerA.x + xDir;
      for (let x = xStart; x !== centerB.x + xDir; x += xDir) {
        for (let w = startOffset; w <= endOffset; w++) {
          corridorCells.push({ x, y: centerB.y + w });
        }
      }
    }
  }
  
  // Check if path runs alongside source or dest room
  if (runsAlongsideRoom(corridorCells, roomA)) {
    return true;
  }
  if (runsAlongsideRoom(corridorCells, roomB)) {
    return true;
  }
  
  // Check each corridor cell for adjacency to OTHER rooms
  for (const room of allRooms) {
    if (room.id === roomA.id || room.id === roomB.id) continue;
    
    let adjacentCount = 0;
    for (const cell of corridorCells) {
      // Skip cells inside source or dest rooms
      if (isCellInRoomRect(cell.x, cell.y, roomA)) continue;
      if (isCellInRoomRect(cell.x, cell.y, roomB)) continue;
      
      if (isCellAdjacentToRoom(cell.x, cell.y, room)) {
        adjacentCount++;
        if (adjacentCount > 1) {
          return true;
        }
      }
    }
  }
  
  return false;
}

function carveCorridors(connections, corridorWidth = 1, allRooms = [], corridorStyle = 'straight') {
  const allCorridorCells = [];
  const corridorsByConnection = [];
  
  for (const [roomA, roomB] of connections) {
    let result = carveCorridorBetween(roomA, roomB, corridorWidth, allRooms);
    
    // Apply wobble for organic style
    if (corridorStyle === 'organic') {
      result = addCorridorWobble(result, allRooms, roomA, roomB);
    }
    
    allCorridorCells.push(...result.cells);
    corridorsByConnection.push({
      roomA,
      roomB,
      cells: result.cells,
      orderedPath: result.orderedPath,
      width: result.width
    });
  }
  
  return { cells: allCorridorCells, byConnection: corridorsByConnection };
}

// =============================================================================
// ORGANIC CORRIDOR GENERATION (Wobble/Wander)
// =============================================================================

/**
 * Check if a wobble at position (x,y) would cause adjacency issues.
 * @param {number} x - X coordinate
 * @param {number} y - Y coordinate
 * @param {Array} allRooms - All rooms in the dungeon
 * @param {Object} roomA - Source room (allowed to be adjacent)
 * @param {Object} roomB - Dest room (allowed to be adjacent)
 * @param {Set} existingCells - Set of "x,y" keys for existing corridor cells
 * @returns {boolean} True if wobble would cause issues
 */
function wouldWobbleCauseIssues(x, y, allRooms, roomA, roomB, existingCells) {
  // Check adjacency to rooms other than source/dest
  for (const room of allRooms) {
    if (room.id === roomA.id || room.id === roomB.id) continue;
    
    // Don't wobble into another room
    if (isCellInRoomRect(x, y, room)) return true;
    
    // Don't wobble adjacent to another room
    if (isCellAdjacentToRoom(x, y, room)) return true;
  }
  
  return false;
}

/**
 * Determine the direction of a path segment (horizontal, vertical, or turning).
 * @param {Object} prev - Previous point {x, y}
 * @param {Object} curr - Current point {x, y}
 * @param {Object} next - Next point {x, y}
 * @returns {string} 'horizontal', 'vertical', or 'turn'
 */
function getSegmentDirection(prev, curr, next) {
  if (!prev || !next) return 'end';
  
  const fromPrev = { dx: curr.x - prev.x, dy: curr.y - prev.y };
  const toNext = { dx: next.x - curr.x, dy: next.y - curr.y };
  
  // Check if direction changes (it's a turn)
  if ((fromPrev.dx !== 0 && toNext.dy !== 0) || (fromPrev.dy !== 0 && toNext.dx !== 0)) {
    return 'turn';
  }
  
  if (fromPrev.dx !== 0 || toNext.dx !== 0) return 'horizontal';
  if (fromPrev.dy !== 0 || toNext.dy !== 0) return 'vertical';
  
  return 'unknown';
}

/**
 * Find straight runs in the ordered path (sequences of 4+ cells in same direction).
 * @param {Array} orderedPath - Array of {x, y} points
 * @returns {Array} Array of {startIdx, endIdx, direction} for each straight run
 */
function findStraightRuns(orderedPath) {
  const runs = [];
  if (orderedPath.length < 4) return runs;
  
  let runStart = 0;
  let runDirection = null;
  
  for (let i = 1; i < orderedPath.length; i++) {
    const prev = orderedPath[i - 1];
    const curr = orderedPath[i];
    
    const dx = curr.x - prev.x;
    const dy = curr.y - prev.y;
    const direction = dx !== 0 ? 'horizontal' : 'vertical';
    
    if (direction !== runDirection) {
      // End previous run if it was long enough
      if (runDirection && i - runStart >= 4) {
        runs.push({ startIdx: runStart, endIdx: i - 1, direction: runDirection });
      }
      runStart = i - 1;
      runDirection = direction;
    }
  }
  
  // Check final run
  if (runDirection && orderedPath.length - runStart >= 4) {
    runs.push({ startIdx: runStart, endIdx: orderedPath.length - 1, direction: runDirection });
  }
  
  return runs;
}

/**
 * Apply wobble to a straight corridor, making it more organic.
 * @param {Object} corridorResult - Result from carveCorridorBetween
 * @param {Array} allRooms - All rooms for collision checking
 * @param {Object} roomA - Source room
 * @param {Object} roomB - Destination room
 * @returns {Object} Modified corridor result with wobbled path
 */
function addCorridorWobble(corridorResult, allRooms, roomA, roomB) {
  const { orderedPath, width } = corridorResult;
  
  // Don't wobble very short corridors
  if (orderedPath.length < 6) return corridorResult;
  
  // Find straight runs that are candidates for wobble
  const runs = findStraightRuns(orderedPath);
  if (runs.length === 0) return corridorResult;
  
  // Create a mutable copy of the path
  const wobbledPath = orderedPath.map(p => ({ ...p }));
  
  // Build set of existing cells for self-intersection check
  const existingCells = new Set(corridorResult.cells.map(c => `${c.x},${c.y}`));
  
  // Wobble settings
  const wobbleChance = 0.25; // Chance to start a wobble
  const wobblePersist = 0.7; // Chance to continue wobbling in same direction
  
  for (const run of runs) {
    // Don't wobble the first 2 or last 2 cells of a run (keep entries/exits clean)
    const safeStart = run.startIdx + 2;
    const safeEnd = run.endIdx - 2;
    
    if (safeEnd <= safeStart) continue;
    
    let currentWobble = 0; // -1, 0, or 1
    
    for (let i = safeStart; i <= safeEnd; i++) {
      const point = wobbledPath[i];
      
      // Decide whether to change wobble state
      if (currentWobble === 0) {
        // Maybe start wobbling
        if (Math.random() < wobbleChance) {
          currentWobble = Math.random() < 0.5 ? 1 : -1;
        }
      } else {
        // Maybe stop or continue wobbling
        if (Math.random() > wobblePersist) {
          currentWobble = 0;
        }
      }
      
      if (currentWobble !== 0) {
        // Calculate the wobbled position
        let newX = point.x;
        let newY = point.y;
        
        if (run.direction === 'horizontal') {
          newY = point.y + currentWobble;
        } else {
          newX = point.x + currentWobble;
        }
        
        // Check if wobble is safe
        if (!wouldWobbleCauseIssues(newX, newY, allRooms, roomA, roomB, existingCells)) {
          point.x = newX;
          point.y = newY;
        } else {
          // Can't wobble here, reset wobble state
          currentWobble = 0;
        }
      }
    }
  }
  
  // Rebuild cells from wobbled path, filling diagonal gaps
  const newCells = rebuildCellsFromPath(wobbledPath, width, allRooms, roomA, roomB);
  
  return {
    cells: newCells,
    orderedPath: wobbledPath,
    width
  };
}

/**
 * Check if adding a fill cell at (x,y) would cause issues with room adjacency.
 * @returns {boolean} True if fill would cause problems
 */
function wouldFillCauseIssues(x, y, allRooms, roomA, roomB) {
  for (const room of allRooms) {
    if (room.id === roomA.id || room.id === roomB.id) continue;
    
    // Don't fill into another room
    if (isCellInRoomRect(x, y, room)) return true;
    
    // Don't fill adjacent to another room
    if (isCellAdjacentToRoom(x, y, room)) return true;
  }
  return false;
}

/**
 * Rebuild the full cells array from a (possibly wobbled) centerline path.
 * Fills in diagonal gaps to ensure all cells are orthogonally connected.
 * @param {Array} path - Array of {x, y} centerline points
 * @param {number} width - Corridor width
 * @param {Array} allRooms - All rooms for fill safety checking
 * @param {Object} roomA - Source room
 * @param {Object} roomB - Destination room
 * @returns {Array} Array of {x, y} cells
 */
function rebuildCellsFromPath(path, width, allRooms = [], roomA = null, roomB = null) {
  const cellSet = new Set();
  const cells = [];
  
  const startOffset = -Math.floor((width - 1) / 2);
  const endOffset = Math.floor(width / 2);
  
  /**
   * Add a cell and its width expansion to the cell set
   */
  const addCellWithWidth = (x, y, expandDir) => {
    if (expandDir === 'vertical' || expandDir === 'both') {
      for (let w = startOffset; w <= endOffset; w++) {
        const key = `${x},${y + w}`;
        if (!cellSet.has(key)) {
          cellSet.add(key);
          cells.push({ x: x, y: y + w });
        }
      }
    }
    if (expandDir === 'horizontal' || expandDir === 'both') {
      for (let w = startOffset; w <= endOffset; w++) {
        const key = `${x + w},${y}`;
        if (!cellSet.has(key)) {
          cellSet.add(key);
          cells.push({ x: x + w, y: y });
        }
      }
    }
  };
  
  for (let i = 0; i < path.length; i++) {
    const curr = path[i];
    const prev = path[i - 1];
    const next = path[i + 1];
    
    // Check for diagonal step from prev to curr - need to fill the gap
    if (prev) {
      const dx = curr.x - prev.x;
      const dy = curr.y - prev.y;
      
      if (dx !== 0 && dy !== 0) {
        // Diagonal step detected - add fill cell(s) to connect orthogonally
        // Two options: (prev.x, curr.y) or (curr.x, prev.y)
        const fill1 = { x: prev.x, y: curr.y };
        const fill2 = { x: curr.x, y: prev.y };
        
        // Check which fills are safe
        const fill1Safe = !roomA || !wouldFillCauseIssues(fill1.x, fill1.y, allRooms, roomA, roomB);
        const fill2Safe = !roomA || !wouldFillCauseIssues(fill2.x, fill2.y, allRooms, roomA, roomB);
        
        // Add safe fill(s) - prefer adding both for a smoother corner if both are safe
        if (fill1Safe && fill2Safe) {
          // Add both for a nice filled corner
          addCellWithWidth(fill1.x, fill1.y, 'both');
          addCellWithWidth(fill2.x, fill2.y, 'both');
        } else if (fill1Safe) {
          addCellWithWidth(fill1.x, fill1.y, 'both');
        } else if (fill2Safe) {
          addCellWithWidth(fill2.x, fill2.y, 'both');
        }
        // If neither is safe, we skip the fill - corridor may have a gap
        // but this shouldn't happen often since we validate wobbles
      }
    }
    
    // Determine segment direction for width expansion
    let direction = 'both'; // Default: expand in both directions for corners
    
    if (prev && next) {
      const fromPrev = { dx: curr.x - prev.x, dy: curr.y - prev.y };
      const toNext = { dx: next.x - curr.x, dy: next.y - curr.y };
      
      // If moving horizontally, expand vertically
      if (fromPrev.dx !== 0 && toNext.dx !== 0 && fromPrev.dy === 0 && toNext.dy === 0) {
        direction = 'vertical';
      }
      // If moving vertically, expand horizontally
      else if (fromPrev.dy !== 0 && toNext.dy !== 0 && fromPrev.dx === 0 && toNext.dx === 0) {
        direction = 'horizontal';
      }
    } else if (prev) {
      direction = (prev.x !== curr.x) ? 'vertical' : 'horizontal';
    } else if (next) {
      direction = (next.x !== curr.x) ? 'vertical' : 'horizontal';
    }
    
    // Add cells for this path point
    addCellWithWidth(curr.x, curr.y, direction);
  }
  
  return cells;
}

// =============================================================================
// DIAGONAL CORRIDOR GENERATION
// =============================================================================

/**
 * Segment mapping for diagonal directions.
 * Each diagonal direction fills 4 segments (matching CORNER_SEGMENT_FILL pattern).
 */
const DIAGONAL_SEGMENTS = {
  // NE direction (moving right and up) - matches TR corner
  ne: { nw: true, n: true, ne: true, e: true },
  // SE direction (moving right and down) - matches BR corner
  se: { ne: true, e: true, se: true, s: true },
  // SW direction (moving left and down) - matches BL corner
  sw: { se: true, s: true, sw: true, w: true },
  // NW direction (moving left and up) - matches TL corner
  nw: { sw: true, w: true, nw: true, n: true }
};

/**
 * Determine the primary diagonal direction from one point to another.
 * @param {number} dx - X difference (positive = moving right)
 * @param {number} dy - Y difference (positive = moving down)
 * @returns {string|null} Diagonal direction ('ne', 'se', 'sw', 'nw') or null if not diagonal
 */
function getDiagonalDirection(dx, dy) {
  if (dx === 0 || dy === 0) return null;
  if (dx > 0 && dy < 0) return 'ne';  // Right and up
  if (dx > 0 && dy > 0) return 'se';  // Right and down
  if (dx < 0 && dy > 0) return 'sw';  // Left and down
  if (dx < 0 && dy < 0) return 'nw';  // Left and up
  return null;
}

/**
 * Check if rooms are positioned to allow a clean diagonal path.
 * Diagonals work best when rooms are offset both horizontally and vertically.
 * @returns {boolean} True if diagonal corridor is appropriate
 */
function canUseDiagonalCorridor(roomA, roomB, allRooms) {
  const centerA = getRoomCenter(roomA);
  const centerB = getRoomCenter(roomB);

  const dx = Math.abs(centerB.x - centerA.x);
  const dy = Math.abs(centerB.y - centerA.y);

  // Need at least 3 cells of offset in both directions for a visible diagonal
  if (dx < 3 || dy < 3) return false;

  // Check if diagonal path would cross another room
  const diagonalDir = getDiagonalDirection(centerB.x - centerA.x, centerB.y - centerA.y);
  if (!diagonalDir) return false;

  // Sample points along diagonal path
  const steps = Math.min(dx, dy);
  const stepX = (centerB.x - centerA.x) / steps;
  const stepY = (centerB.y - centerA.y) / steps;

  for (let i = 1; i < steps; i++) {
    const testX = Math.round(centerA.x + stepX * i);
    const testY = Math.round(centerA.y + stepY * i);

    for (const room of allRooms) {
      if (room.id === roomA.id || room.id === roomB.id) continue;
      if (isCellInRoomRect(testX, testY, room)) return false;
    }
  }

  return true;
}

/**
 * Create a segment cell for diagonal corridor.
 * @param {number} x - Cell X coordinate
 * @param {number} y - Cell Y coordinate
 * @param {string} diagonalDir - Diagonal direction ('ne', 'se', 'sw', 'nw')
 * @param {string} color - Cell color
 * @returns {Object} Cell with segments property
 */
function createDiagonalSegmentCell(x, y, diagonalDir, color) {
  return {
    x,
    y,
    color,
    segments: { ...DIAGONAL_SEGMENTS[diagonalDir] }
  };
}

/**
 * Carve a diagonal corridor between two rooms.
 * Uses segment cells for 45-degree paths, transitioning to full cells at room boundaries.
 * @param {Object} roomA - Source room
 * @param {Object} roomB - Destination room
 * @param {number} width - Corridor width (1 or 2)
 * @param {Array} allRooms - All rooms for collision checking
 * @param {string} color - Floor color
 * @returns {Object} { cells: Array, orderedPath: Array, width: number, hasDiagonals: boolean }
 */
function carveDiagonalCorridor(roomA, roomB, width, allRooms, color) {
  const centerA = getRoomCenter(roomA);
  const centerB = getRoomCenter(roomB);

  const dx = centerB.x - centerA.x;
  const dy = centerB.y - centerA.y;
  const xDir = dx > 0 ? 1 : -1;
  const yDir = dy > 0 ? 1 : -1;
  const diagonalDir = getDiagonalDirection(dx, dy);

  const cells = [];
  const orderedPath = [];
  const cellSet = new Set();

  const addCell = (cell) => {
    const key = cellKey(cell.x, cell.y);
    if (!cellSet.has(key)) {
      cellSet.add(key);
      cells.push(cell);
    }
  };

  let currentX = centerA.x;
  let currentY = centerA.y;

  // Phase 1: Exit room A with orthogonal cells
  while (isCellInRoomRect(currentX, currentY, roomA) ||
         isCellInRoomRect(currentX + xDir, currentY, roomA)) {
    orderedPath.push({ x: currentX, y: currentY });
    addCell({ x: currentX, y: currentY, color });
    if (width === 2) {
      // Add adjacent cell for width
      if (dy !== 0) addCell({ x: currentX + 1, y: currentY, color });
      else addCell({ x: currentX, y: currentY + 1, color });
    }
    currentX += xDir;
    if (currentX === centerB.x) break;
  }

  // Phase 2: Diagonal corridor with full cells at diagonal positions and segment cells in crooks
  // Crooks fill the triangular gaps between diagonal full cells with wedge-shaped segments
  const diagonalSteps = Math.min(Math.abs(centerB.x - currentX), Math.abs(centerB.y - currentY));

  // Crook segment patterns based on diagonal direction
  // Each direction needs specific segment wedges to create smooth 45 walls
  const CROOK_SEGMENTS = {
    se: { horizontal: 'sw', vertical: 'ne' },
    nw: { horizontal: 'ne', vertical: 'sw' },
    ne: { horizontal: 'nw', vertical: 'se' },
    sw: { horizontal: 'se', vertical: 'nw' }
  };
  const crookPattern = CROOK_SEGMENTS[diagonalDir];

  for (let i = 0; i < diagonalSteps; i++) {
    // Check if we're entering room B - add entry crook and stop diagonal
    if (isCellInRoomRect(currentX, currentY, roomB)) {
      // Add diagonal segment at room entry to smooth the diagonal wall termination
      addCell(createDiagonalSegmentCell(currentX, currentY, diagonalDir, color));
      break;
    }

    orderedPath.push({ x: currentX, y: currentY });

    // Place full cell at diagonal position
    addCell({ x: currentX, y: currentY, color });

    // Place segment cells in the crooks (triangular gaps)
    // Horizontal crook: adjacent in x direction
    addCell(createDiagonalSegmentCell(currentX + xDir, currentY, crookPattern.horizontal, color));
    // Vertical crook: adjacent in y direction
    addCell(createDiagonalSegmentCell(currentX, currentY + yDir, crookPattern.vertical, color));

    if (width === 2) {
      // Width 2: Add parallel diagonal track
      // Full cell on parallel diagonal
      const parallelX = (diagonalDir === 'ne' || diagonalDir === 'se') ? currentX + 1 : currentX - 1;
      const parallelY = (diagonalDir === 'se' || diagonalDir === 'sw') ? currentY + 1 : currentY - 1;
      addCell({ x: parallelX, y: parallelY, color });
    }

    currentX += xDir;
    currentY += yDir;
  }

  // Transition crook: fill the gap where diagonal meets orthogonal
  if (diagonalSteps > 0 && !isCellInRoomRect(currentX, currentY, roomB)) {
    const remainingX = centerB.x - currentX;
    const remainingY = centerB.y - currentY;

    if (remainingX !== 0 && remainingY === 0) {
      // Continuing horizontally only - add vertical crook behind current position
      addCell(createDiagonalSegmentCell(currentX - xDir, currentY, crookPattern.vertical, color));
    } else if (remainingY !== 0 && remainingX === 0) {
      // Continuing vertically only - add horizontal crook behind current position
      addCell(createDiagonalSegmentCell(currentX, currentY - yDir, crookPattern.horizontal, color));
    }
  }

  // Phase 3: Finish with orthogonal to room B center
  while (currentX !== centerB.x || currentY !== centerB.y) {
    orderedPath.push({ x: currentX, y: currentY });
    addCell({ x: currentX, y: currentY, color });
    if (width === 2) {
      if (currentX !== centerB.x) addCell({ x: currentX, y: currentY + 1, color });
      else addCell({ x: currentX + 1, y: currentY, color });
    }

    if (currentX !== centerB.x) currentX += xDir;
    else if (currentY !== centerB.y) currentY += yDir;
    else break;
  }

  // Add final cell
  orderedPath.push({ x: centerB.x, y: centerB.y });
  addCell({ x: centerB.x, y: centerB.y, color });

  return {
    cells,
    orderedPath,
    width,
    hasDiagonals: true
  };
}

/**
 * Carve corridors with diagonal style option.
 * @param {Array} connections - Room connection pairs
 * @param {number} corridorWidth - Base corridor width
 * @param {Array} allRooms - All rooms
 * @param {string} corridorStyle - 'straight', 'organic', or 'diagonal'
 * @param {number} diagonalChance - Probability of using diagonal (0-1)
 * @param {string} color - Floor color
 * @returns {Object} { cells: Array, byConnection: Array }
 */
function carveCorridorsWithDiagonals(connections, corridorWidth, allRooms, corridorStyle, diagonalChance, color) {
  const allCorridorCells = [];
  const corridorsByConnection = [];

  for (const [roomA, roomB] of connections) {
    let result;
    let usedDiagonal = false;

    // Try diagonal if style allows and rooms are suitable
    if (corridorStyle === 'diagonal' || (corridorStyle !== 'organic' && diagonalChance > 0)) {
      const tryDiagonal = corridorStyle === 'diagonal' || Math.random() < diagonalChance;

      if (tryDiagonal && canUseDiagonalCorridor(roomA, roomB, allRooms)) {
        result = carveDiagonalCorridor(roomA, roomB, corridorWidth, allRooms, color);
        usedDiagonal = true;
      }
    }

    // Fall back to standard corridor
    if (!usedDiagonal) {
      result = carveCorridorBetween(roomA, roomB, corridorWidth, allRooms);

      // Apply wobble for organic style
      if (corridorStyle === 'organic') {
        result = addCorridorWobble(result, allRooms, roomA, roomB);
      }
    }

    allCorridorCells.push(...result.cells);
    corridorsByConnection.push({
      roomA,
      roomB,
      cells: result.cells,
      orderedPath: result.orderedPath,
      width: result.width,
      hasDiagonals: usedDiagonal
    });
  }

  return { cells: allCorridorCells, byConnection: corridorsByConnection };
}

// =============================================================================
// PHASE 3.5: DOOR DETECTION
// =============================================================================

/**
 * Find door candidates by walking corridors and detecting room boundary crossings.
 * Uses actual room shape (isCellInRoom) for accurate detection with composite/circular rooms.
 */
function findDoorCandidatesForConnection(roomA, roomB, orderedPath, corridorWidth) {
  const candidates = [];

  if (orderedPath.length < 2) return candidates;

  let prevInA = isCellInRoom(orderedPath[0].x, orderedPath[0].y, roomA);
  let prevInB = isCellInRoom(orderedPath[0].x, orderedPath[0].y, roomB);

  for (let i = 1; i < orderedPath.length; i++) {
    const curr = orderedPath[i];
    const prev = orderedPath[i - 1];

    const currInA = isCellInRoom(curr.x, curr.y, roomA);
    const currInB = isCellInRoom(curr.x, curr.y, roomB);

    // Exiting room A
    if (prevInA && !currInA) {
      const dx = curr.x - prev.x;
      const dy = curr.y - prev.y;
      const type = (dy === 0) ? 'door-vertical' : 'door-horizontal';
      const alignment = getAlignmentFromDelta(-dx, -dy);

      addDoorsForWidth(candidates, curr, type, alignment, roomA.id, corridorWidth, dx, dy);
    }

    // Entering room B
    if (!prevInB && currInB) {
      const dx = curr.x - prev.x;
      const dy = curr.y - prev.y;
      const type = (dy === 0) ? 'door-vertical' : 'door-horizontal';
      const alignment = getAlignmentFromDelta(dx, dy);

      addDoorsForWidth(candidates, prev, type, alignment, roomB.id, corridorWidth, dx, dy);
    }

    prevInA = currInA;
    prevInB = currInB;
  }

  return candidates;
}

function getAlignmentFromDelta(dx, dy) {
  // Always use cardinal directions (no diagonal door rotation)
  // For diagonal movement, pick the dominant axis or default to vertical
  if (dy < 0) return 'north';
  if (dy > 0) return 'south';
  if (dx < 0) return 'west';
  if (dx > 0) return 'east';
  return 'center';
}

function addDoorsForWidth(candidates, baseCell, type, alignment, roomId, width, pathDx, pathDy) {
  const startOffset = -Math.floor((width - 1) / 2);
  const endOffset = Math.floor(width / 2);

  // Spread perpendicular to path direction
  const spreadX = pathDy !== 0; // Vertical path = spread horizontally

  for (let w = startOffset; w <= endOffset; w++) {
    candidates.push({
      x: spreadX ? baseCell.x + w : baseCell.x,
      y: spreadX ? baseCell.y : baseCell.y + w,
      type,
      alignment,
      roomId,
      scale: 1,
      isSecret: false
    });
  }
}

/**
 * Check if a cell is on the perimeter of a room (not an interior cell).
 * A perimeter cell is one where at least one orthogonal neighbor is outside the room.
 */
function isCellOnRoomPerimeter(x, y, room) {
  if (!isCellInRoom(x, y, room)) return false;

  // Check if any orthogonal neighbor is outside the room
  return !isCellInRoom(x - 1, y, room) ||
         !isCellInRoom(x + 1, y, room) ||
         !isCellInRoom(x, y - 1, room) ||
         !isCellInRoom(x, y + 1, room);
}

/**
 * Validate a door position to filter out floating doors.
 * A valid door must be adjacent to its associated room (touching from outside).
 * @param {Object} pos - Door position with x, y, roomId
 * @param {Array<Object>} rooms - All rooms to find the associated room
 * @param {Set<string>} [corridorCellSet] - Set of corridor cell keys for intersection check
 * @param {Set<string>} [segmentCellSet] - Set of diagonal segment cell keys to exclude
 * @returns {boolean} True if door position is valid
 */
function isValidDoorPosition(pos, rooms, corridorCellSet = null, segmentCellSet = null) {
  const room = rooms.find(r => r.id === pos.roomId);
  if (!room) return false;

  // Door should be adjacent to its room (touching from outside)
  const adjacentToRoom = isCellInRoom(pos.x - 1, pos.y, room) ||
                         isCellInRoom(pos.x + 1, pos.y, room) ||
                         isCellInRoom(pos.x, pos.y - 1, room) ||
                         isCellInRoom(pos.x, pos.y + 1, room);
  if (!adjacentToRoom) return false;

  const posKey = `${pos.x},${pos.y}`;

  // Doors should not be placed on diagonal segment cells
  if (segmentCellSet && segmentCellSet.has(posKey)) {
    return false;
  }

  // Door must be in a corridor cell (not floating in void)
  if (corridorCellSet) {
    if (!corridorCellSet.has(posKey)) {
      return false;
    }

    // Must not be at corridor intersection (floating door)
    if (isAtCorridorIntersection(pos, corridorCellSet, rooms)) {
      return false;
    }
  }

  return true;
}

/**
 * Check if a position is at a corridor intersection (4-way cross).
 * Doors at intersections tend to "float" and look wrong.
 * @param {{x: number, y: number}} pos - Position to check
 * @param {Set<string>} corridorCellSet - Set of corridor cell keys ("x,y")
 * @param {Array<Object>} rooms - All rooms to check if position is inside one
 * @returns {boolean} True if position is at a 4-way corridor intersection
 */
function isAtCorridorIntersection(pos, corridorCellSet, rooms) {
  // If position is inside a room, it's not at a corridor intersection
  if (rooms.some(r => isCellInRoom(pos.x, pos.y, r))) return false;

  const hasN = corridorCellSet.has(`${pos.x},${pos.y - 1}`);
  const hasS = corridorCellSet.has(`${pos.x},${pos.y + 1}`);
  const hasE = corridorCellSet.has(`${pos.x + 1},${pos.y}`);
  const hasW = corridorCellSet.has(`${pos.x - 1},${pos.y}`);

  // Intersection = corridor extends in both perpendicular directions
  return (hasN && hasS) && (hasE && hasW);
}

/**
 * Find all valid door candidate positions from corridor connections.
 * @param {Array<Object>} corridorsByConnection - Corridor data with roomA, roomB, orderedPath, width
 * @param {Array<Object>} rooms - All dungeon rooms
 * @param {Set<string>} [corridorCellSet] - Set of corridor cell keys for validation
 * @param {Set<string>} [segmentCellSet] - Set of diagonal segment cell keys to exclude
 * @returns {Array<Object>} Valid door candidate positions
 */
function findDoorCandidates(corridorsByConnection, rooms, corridorCellSet = null, segmentCellSet = null) {
  const allCandidates = [];
  const globalProcessed = new Set();

  for (const { roomA, roomB, orderedPath, width } of corridorsByConnection) {
    const candidates = findDoorCandidatesForConnection(roomA, roomB, orderedPath, width);

    for (const candidate of candidates) {
      const key = `${candidate.x},${candidate.y},${candidate.alignment}`;
      // Validate door position to filter out floating doors
      if (!globalProcessed.has(key) && isValidDoorPosition(candidate, rooms, corridorCellSet, segmentCellSet)) {
        allCandidates.push(candidate);
        globalProcessed.add(key);
      }
    }
  }

  return allCandidates;
}

/**
 * Check if a cell is orthogonally adjacent to a room.
 * @param {number} x - Cell x coordinate
 * @param {number} y - Cell y coordinate
 * @param {Object} room - Room to check adjacency against
 * @returns {boolean} True if cell has at least one orthogonal neighbor inside the room
 */
function isCellAdjacentToRoomForOpening(x, y, room) {
  return isCellInRoom(x - 1, y, room) || isCellInRoom(x + 1, y, room) ||
         isCellInRoom(x, y - 1, room) || isCellInRoom(x, y + 1, room);
}

/**
 * Calculate the width of a room opening at a door position.
 * Scans perpendicular to the door alignment to find contiguous corridor cells adjacent to the room.
 * @param {{x: number, y: number}} doorPos - Starting door position
 * @param {Object} room - Room the door opens into
 * @param {Set<string>} carvedCellSet - Set of all carved cell keys (rooms + corridors)
 * @param {string} alignment - Door alignment ('north', 'south', 'east', 'west')
 * @param {Set<string>} [corridorCellSet] - Optional corridor-only cell set for accuracy
 * @returns {{width: number, cells: Array<{x: number, y: number}>}} Opening width and cells
 */
function calculateRoomOpeningWidth(doorPos, room, carvedCellSet, alignment, corridorCellSet) {
  // Determine scan direction (perpendicular to alignment)
  const scanDir = (alignment === 'north' || alignment === 'south')
    ? { dx: 1, dy: 0 }  // scan horizontally
    : { dx: 0, dy: 1 }; // scan vertically

  const openingCells = [{ x: doorPos.x, y: doorPos.y }];

  // Use corridorCellSet if available for more accurate detection
  const cellSet = corridorCellSet || carvedCellSet;

  for (let i = 1; i < 10; i++) {
    const testX = doorPos.x + scanDir.dx * i;
    const testY = doorPos.y + scanDir.dy * i;
    const key = `${testX},${testY}`;
    // Cell must be in corridor (not room) and adjacent to the room
    if (cellSet.has(key) && !isCellInRoom(testX, testY, room) && isCellAdjacentToRoomForOpening(testX, testY, room)) {
      openingCells.push({ x: testX, y: testY });
    } else break;
  }

  for (let i = 1; i < 10; i++) {
    const testX = doorPos.x - scanDir.dx * i;
    const testY = doorPos.y - scanDir.dy * i;
    const key = `${testX},${testY}`;
    // Cell must be in corridor (not room) and adjacent to the room
    if (cellSet.has(key) && !isCellInRoom(testX, testY, room) && isCellAdjacentToRoomForOpening(testX, testY, room)) {
      openingCells.unshift({ x: testX, y: testY }); // Add to front to maintain order
    } else break;
  }

  return { width: openingCells.length, cells: openingCells };
}

/**
 * Generate wall edges for cells that need to be closed off.
 * Creates edges on the room-facing side of corridor cells.
 * @param {Array<{x: number, y: number}>} cells - Cells to generate edges for
 * @param {string} alignment - Door alignment determining edge placement direction
 * @returns {Array<{x: number, y: number, side: string, color: string}>} Wall edge definitions
 */
function generateWallEdgesForCells(cells, alignment) {
  const edges = [];
  const wallColor = '#333333';

  for (const cell of cells) {
    if (alignment === 'north') {
      // Wall on north side of corridor cell = bottom edge of cell above
      edges.push({ x: cell.x, y: cell.y - 1, side: 'bottom', color: wallColor });
    } else if (alignment === 'south') {
      // Wall on south side of corridor cell = bottom edge of this cell
      edges.push({ x: cell.x, y: cell.y, side: 'bottom', color: wallColor });
    } else if (alignment === 'east') {
      // Wall on east side of corridor cell = right edge of this cell
      edges.push({ x: cell.x, y: cell.y, side: 'right', color: wallColor });
    } else if (alignment === 'west') {
      // Wall on west side of corridor cell = right edge of cell to the left
      edges.push({ x: cell.x - 1, y: cell.y, side: 'right', color: wallColor });
    }
  }

  return edges;
}

/**
 * Generate wall edges for all corridor cells adjacent to rooms.
 * This ensures the entire room perimeter is closed off except where doors are.
 * @param {Array<Object>} rooms - All dungeon rooms
 * @param {Set<string>} corridorCellSet - Set of corridor cell keys ("x,y")
 * @param {Array<{x: number, y: number}>} doorPositions - Door positions to skip
 * @returns {Array<{x: number, y: number, side: string, color: string}>} Deduplicated wall edges
 */
function generateAllRoomBoundaryEdges(rooms, corridorCellSet, doorPositions) {
  const edges = [];
  const wallColor = '#333333';

  const doorSet = new Set(doorPositions.map(d => `${d.x},${d.y}`));

  // For each corridor cell, check if it's adjacent to any room
  for (const cellKey of corridorCellSet) {
    const [x, y] = cellKey.split(',').map(Number);

    // Skip if this cell has a door
    if (doorSet.has(cellKey)) continue;

    // Check each direction for adjacent rooms
    for (const room of rooms) {
      // North neighbor in room = add bottom edge to cell above (which is in room)
      if (isCellInRoom(x, y - 1, room) && !isCellInRoom(x, y, room)) {
        edges.push({ x, y: y - 1, side: 'bottom', color: wallColor });
      }
      // South neighbor in room = add bottom edge to this cell
      if (isCellInRoom(x, y + 1, room) && !isCellInRoom(x, y, room)) {
        edges.push({ x, y, side: 'bottom', color: wallColor });
      }
      // West neighbor in room = add right edge to cell to the left (which is in room)
      if (isCellInRoom(x - 1, y, room) && !isCellInRoom(x, y, room)) {
        edges.push({ x: x - 1, y, side: 'right', color: wallColor });
      }
      // East neighbor in room = add right edge to this cell
      if (isCellInRoom(x + 1, y, room) && !isCellInRoom(x, y, room)) {
        edges.push({ x, y, side: 'right', color: wallColor });
      }
    }
  }

  const edgeSet = new Set();
  const uniqueEdges = [];
  for (const edge of edges) {
    const key = `${edge.x},${edge.y},${edge.side}`;
    if (!edgeSet.has(key)) {
      edgeSet.add(key);
      uniqueEdges.push(edge);
    }
  }

  return uniqueEdges;
}

/**
 * Find rooms that have no adjacent doors.
 * @param {Array<Object>} rooms - All dungeon rooms
 * @param {Array<{x: number, y: number}>} doorPositions - Existing door positions
 * @returns {Array<Object>} Rooms with no adjacent doors
 */
function getIsolatedRooms(rooms, doorPositions) {
  return rooms.filter(room => {
    for (const door of doorPositions) {
      if (isCellAdjacentToRoomForOpening(door.x, door.y, room)) {
        return false;
      }
    }
    return true;
  });
}

/**
 * Find rooms that have no doors and add a secret door by converting one edge.
 * @param {Array<Object>} rooms - All dungeon rooms
 * @param {Array<{x: number, y: number}>} doorPositions - Existing door positions
 * @param {Array<Object>} wallEdges - Wall edges that can be converted to secret doors
 * @param {Set<string>} corridorCellSet - Set of corridor cell keys
 * @param {number} secretDoorQuota - Remaining quota of secret doors to create for isolated rooms
 * @returns {{updatedEdges: Array<Object>, secretDoorObjects: Array<Object>}} Updated edges with secret doors
 */
function addSecretDoorsToIsolatedRooms(rooms, doorPositions, wallEdges, corridorCellSet, secretDoorQuota = Infinity) {
  const isolatedRooms = getIsolatedRooms(rooms, doorPositions);

  if (isolatedRooms.length === 0) {
    return { updatedEdges: wallEdges, secretDoorObjects: [] };
  }

  const existingDoorPositions = new Set(doorPositions.map(d => `${d.x},${d.y}`));

  const secretDoorObjects = [];
  const edgesToRemove = new Set();
  let secretDoorsCreated = 0;

  for (const room of isolatedRooms) {
    const roomEdges = [];

    for (let i = 0; i < wallEdges.length; i++) {
      const edge = wallEdges[i];

      // Check if this edge borders the room
      // For 'bottom' edge at (x, y): the cell above (x, y) or below (x, y+1) should be in room
      // For 'right' edge at (x, y): the cell left (x, y) or right (x+1, y) should be in room
      let bordersRoom = false;
      let corridorCell = null;
      let alignment = null;

      if (edge.side === 'bottom') {
        // Bottom edge: room could be above (y) or below (y+1)
        if (isCellInRoom(edge.x, edge.y, room)) {
          bordersRoom = true;
          corridorCell = { x: edge.x, y: edge.y + 1 };
          alignment = 'south';
        } else if (isCellInRoom(edge.x, edge.y + 1, room)) {
          bordersRoom = true;
          corridorCell = { x: edge.x, y: edge.y };
          alignment = 'north';
        }
      } else if (edge.side === 'right') {
        // Right edge: room could be left (x) or right (x+1)
        if (isCellInRoom(edge.x, edge.y, room)) {
          bordersRoom = true;
          corridorCell = { x: edge.x + 1, y: edge.y };
          alignment = 'east';
        } else if (isCellInRoom(edge.x + 1, edge.y, room)) {
          bordersRoom = true;
          corridorCell = { x: edge.x, y: edge.y };
          alignment = 'west';
        }
      }

      if (bordersRoom && corridorCell) {
        // Verify the corridor cell is actually in the corridor
        const corridorKey = `${corridorCell.x},${corridorCell.y}`;
        // Skip if there's already a door at this position
        if (corridorCellSet.has(corridorKey) && !existingDoorPositions.has(corridorKey)) {
          roomEdges.push({ index: i, edge, corridorCell, alignment });
        }
      }
    }

    // Pick a random edge to create opening (and possibly secret door)
    if (roomEdges.length > 0) {
      const chosen = roomEdges[Math.floor(Math.random() * roomEdges.length)];

      edgesToRemove.add(chosen.index);

      if (secretDoorsCreated < secretDoorQuota) {
        secretDoorObjects.push({
          id: generateObjectId(),
          type: 'secret-door',
          position: { x: chosen.corridorCell.x, y: chosen.corridorCell.y },
          alignment: chosen.alignment,
          scale: 1,
          rotation: 0
        });
        secretDoorsCreated++;
      }
    }
  }

  const updatedEdges = wallEdges.filter((_, i) => !edgesToRemove.has(i));

  return { updatedEdges, secretDoorObjects };
}

/**
 * Group door candidates into contiguous entrance groups and apply door/secret chances.
 */
function groupDoorCandidates(candidates) {
  if (candidates.length === 0) return [];
  
  // Group by roomId and alignment
  const groups = new Map();
  
  for (const door of candidates) {
    const groupKey = `${door.roomId}-${door.alignment}`;
    if (!groups.has(groupKey)) {
      groups.set(groupKey, []);
    }
    groups.get(groupKey).push(door);
  }
  
  // Split non-contiguous doors into separate groups
  const finalGroups = [];
  
  for (const [, doorList] of groups) {
    // Sort by position
    doorList.sort((a, b) => {
      if (a.x !== b.x) return a.x - b.x;
      return a.y - b.y;
    });
    
    let currentGroup = [doorList[0]];
    
    for (let i = 1; i < doorList.length; i++) {
      const prev = doorList[i - 1];
      const curr = doorList[i];
      
      const isAdjacent = (Math.abs(curr.x - prev.x) <= 1 && curr.y === prev.y) ||
                         (Math.abs(curr.y - prev.y) <= 1 && curr.x === prev.x);
      
      if (isAdjacent) {
        currentGroup.push(curr);
      } else {
        finalGroups.push(currentGroup);
        currentGroup = [curr];
      }
    }
    
    finalGroups.push(currentGroup);
  }
  
  return finalGroups;
}

/**
 * Find door positions and generate wall edges for wide openings.
 * @param {Array<Object>} corridorsByConnection - Corridor data with roomA, roomB, orderedPath, width
 * @param {Array<Object>} rooms - All dungeon rooms
 * @param {number} [doorChance=0.7] - Probability of placing a door at each entrance
 * @param {number} [secretDoorChance=0.05] - Probability that a door is secret
 * @param {Set<string>} [carvedCellSet] - Set of all carved cell keys for opening width
 * @param {Set<string>} [corridorCellSet] - Set of corridor cell keys for validation
 * @param {Set<string>} [segmentCellSet] - Set of diagonal segment cell keys to exclude
 * @returns {{doorPositions: Array<Object>, wallEdges: Array<Object>}} Door positions and wall edges
 */
function findDoorPositions(corridorsByConnection, rooms, doorChance = 0.7, secretDoorChance = 0.05, carvedCellSet = null, corridorCellSet = null, segmentCellSet = null) {
  const candidates = findDoorCandidates(corridorsByConnection, rooms, corridorCellSet, segmentCellSet);
  const groups = groupDoorCandidates(candidates);

  const doorPositions = [];
  const wallEdges = [];

  for (const group of groups) {
    // Roll once per entrance group
    if (Math.random() > doorChance) continue;

    // Roll once for secret door for this entrance
    const isSecret = Math.random() < secretDoorChance;

    // If we have carvedCellSet, calculate actual opening width
    if (carvedCellSet && group.length > 0) {
      const firstDoor = group[0];
      const room = rooms.find(r => r.id === firstDoor.roomId);

      if (room) {
        const opening = calculateRoomOpeningWidth(firstDoor, room, carvedCellSet, firstDoor.alignment, corridorCellSet);

        if (opening.width > 2) {
          // Wide opening: place max 2 doors in center, wall edges for the rest
          const centerIdx = Math.floor(opening.cells.length / 2);
          const doorCount = Math.min(2, opening.cells.length);
          const startIdx = centerIdx - Math.floor(doorCount / 2);
          const endIdx = startIdx + doorCount;

          // Add doors for center cells
          for (let i = startIdx; i < endIdx; i++) {
            const cell = opening.cells[i];
            doorPositions.push({
              x: cell.x,
              y: cell.y,
              type: firstDoor.type,
              alignment: firstDoor.alignment,
              roomId: firstDoor.roomId,
              isSecret,
              scale: doorCount >= 2 ? 1.2 : 1
            });
          }

          // Generate wall edges for cells outside door area
          const cellsForWalls = [
            ...opening.cells.slice(0, startIdx),
            ...opening.cells.slice(endIdx)
          ];
          const edges = generateWallEdgesForCells(cellsForWalls, firstDoor.alignment);
          wallEdges.push(...edges);

          continue; // Skip normal group processing
        }
      }
    }

    // Normal processing: mark all doors in group with same secret status
    for (const door of group) {
      doorPositions.push({
        ...door,
        isSecret,
        scale: group.length >= 2 ? 1.2 : 1 // Wider entrances = grander doors
      });
    }
  }

  return { doorPositions, wallEdges };
}

function generateDoorObjects(doorPositions) {
  return doorPositions.map(pos => {
    // Calculate rotation based on alignment
    let rotation = 0;
    // Secret doors on vertical passages need rotation
    if (pos.type === 'door-vertical' && pos.isSecret &&
        (pos.alignment === 'east' || pos.alignment === 'west')) {
      rotation = 90;
    }

    return {
      id: generateObjectId(),
      type: pos.isSecret ? 'secret-door' : pos.type,
      position: { x: pos.x, y: pos.y },
      alignment: pos.alignment,
      scale: pos.scale || 1,
      rotation
    };
  });
}

// =============================================================================
// PHASE 3.6: STAIR GENERATION
// =============================================================================

function getRoomCells(room) {
  const cells = [];
  for (let x = room.x; x < room.x + room.width; x++) {
    for (let y = room.y; y < room.y + room.height; y++) {
      if (isCellInRoom(x, y, room)) {
        cells.push({ x, y });
      }
    }
  }
  return cells;
}

function findEntryExitRooms(rooms) {
  if (rooms.length === 0) return { entry: null, exit: null };
  if (rooms.length === 1) return { entry: rooms[0], exit: rooms[0] };
  
  // Find topmost-leftmost room for entry (stairs down into dungeon)
  // Find bottommost-rightmost room for exit (stairs up out of dungeon)
  let entry = rooms[0];
  let exit = rooms[0];
  
  for (const room of rooms) {
    const roomCenter = getRoomCenter(room);
    const entryCenter = getRoomCenter(entry);
    const exitCenter = getRoomCenter(exit);
    
    // Entry: prefer top-left
    if (roomCenter.y < entryCenter.y || 
        (roomCenter.y === entryCenter.y && roomCenter.x < entryCenter.x)) {
      entry = room;
    }
    
    // Exit: prefer bottom-right
    if (roomCenter.y > exitCenter.y || 
        (roomCenter.y === exitCenter.y && roomCenter.x > exitCenter.x)) {
      exit = room;
    }
  }
  
  return { entry, exit };
}

function generateStairObjects(entryRoom, exitRoom) {
  const objects = [];
  
  if (entryRoom) {
    const entryCells = getRoomCells(entryRoom);
    if (entryCells.length > 0) {
      const cell = entryCells[Math.floor(Math.random() * entryCells.length)];
      objects.push({
        id: generateObjectId(),
        type: 'stairs-down',
        position: { x: cell.x, y: cell.y },
        alignment: 'center',
        scale: 1,
        rotation: 0
      });
    }
  }
  
  if (exitRoom && exitRoom !== entryRoom) {
    const exitCells = getRoomCells(exitRoom);
    if (exitCells.length > 0) {
      const cell = exitCells[Math.floor(Math.random() * exitCells.length)];
      objects.push({
        id: generateObjectId(),
        type: 'stairs-up',
        position: { x: cell.x, y: cell.y },
        alignment: 'center',
        scale: 1,
        rotation: 0
      });
    }
  }
  
  return objects;
}

// =============================================================================
// PHASE 3.7: WATER FEATURE GENERATION
// =============================================================================

/**
 * Select rooms to contain water based on waterChance.
 * Avoids entry/exit rooms.
 * @param {Array} rooms - All rooms
 * @param {number} waterChance - Probability (0-1) for each room to contain water
 * @param {number|null} entryRoomId - Entry room ID to exclude
 * @param {number|null} exitRoomId - Exit room ID to exclude
 * @returns {Array} Array of room IDs selected for water
 */
function selectWaterRooms(rooms, waterChance, entryRoomId, exitRoomId) {
  const waterRoomIds = [];

  for (const room of rooms) {
    // Skip entry/exit rooms
    if (room.id === entryRoomId || room.id === exitRoomId) continue;

    // Roll for water
    if (Math.random() < waterChance) {
      waterRoomIds.push(room.id);
    }
  }

  return waterRoomIds;
}

/**
 * Generate water cells for selected rooms.
 * Water is rendered as cells with a distinct blue color and reduced opacity.
 * @param {Array} rooms - All rooms
 * @param {Array} waterRoomIds - IDs of rooms to fill with water
 * @param {string} waterColor - Color for water cells
 * @param {number} waterOpacity - Opacity for water cells (0-1)
 * @returns {Array} Array of water cell objects {x, y, color, opacity}
 */
function generateWaterCells(rooms, waterRoomIds, waterColor, waterOpacity) {
  const waterCells = [];
  const waterRoomSet = new Set(waterRoomIds);

  for (const room of rooms) {
    if (!waterRoomSet.has(room.id)) continue;

    // Fill entire room with water
    for (let x = room.x; x < room.x + room.width; x++) {
      for (let y = room.y; y < room.y + room.height; y++) {
        if (isCellInRoom(x, y, room)) {
          waterCells.push({ x, y, color: waterColor, opacity: waterOpacity });
        }
      }
    }
  }

  return waterCells;
}

// =============================================================================
// PHASE 4: CELL GENERATION
// =============================================================================

function generateCells(rooms, corridorCells, color = DEFAULT_FLOOR_COLOR) {
  const cellMap = new Map();

  // Add room cells (always full cells)
  for (const room of rooms) {
    for (let x = room.x; x < room.x + room.width; x++) {
      for (let y = room.y; y < room.y + room.height; y++) {
        if (isCellInRoom(x, y, room)) {
          cellMap.set(cellKey(x, y), { x, y, color });
        }
      }
    }
  }

  // Add corridor cells (may include segment cells from diagonals)
  for (const cell of corridorCells) {
    const key = cellKey(cell.x, cell.y);
    const existing = cellMap.get(key);

    if (!existing) {
      // No existing cell - add corridor cell as-is (may be segment or full)
      if (cell.segments) {
        cellMap.set(key, { x: cell.x, y: cell.y, color: cell.color || color, segments: cell.segments });
      } else {
        cellMap.set(key, { x: cell.x, y: cell.y, color: cell.color || color });
      }
    } else if (cell.segments && !existing.segments) {
      // Existing is full cell, corridor has segments - keep full cell (room wins)
      // No change needed
    } else if (!cell.segments && existing.segments) {
      // Corridor is full cell, existing has segments - upgrade to full cell
      cellMap.set(key, { x: cell.x, y: cell.y, color: existing.color });
    }
    // If both have segments or both are full, existing wins (first write wins)
  }

  return Array.from(cellMap.values());
}

// =============================================================================
// MAIN GENERATION FUNCTION
// =============================================================================

function generateDungeon(presetName = 'medium', color = DEFAULT_FLOOR_COLOR, configOverrides = {}) {
  const baseConfig = DUNGEON_PRESETS[presetName] || DUNGEON_PRESETS.medium;
  
  // Apply style overrides if a style is specified
  let styleOverrides = {};
  if (configOverrides.style && DUNGEON_STYLES[configOverrides.style]) {
    styleOverrides = DUNGEON_STYLES[configOverrides.style].overrides;
  }
  
  // Merge: base preset <- style overrides <- user overrides
  // This allows user to tweak a style's defaults
  const config = { ...baseConfig, ...styleOverrides, ...configOverrides };
  
  // Phase 1: Generate rooms
  const rooms = generateRooms(config);
  
  // Phase 2: Build connection graph (MST with optional loops)
  const connections = buildConnectionGraph(rooms, config.loopChance || 0);
  
  // Phase 3: Carve corridors
  const useWideCorridors = Math.random() < (config.wideCorridorChance || 0);
  const corridorWidth = useWideCorridors ? 2 : (config.corridorWidth || 1);
  const corridorStyle = config.corridorStyle || 'straight';
  const diagonalChance = config.diagonalCorridorChance ?? 0;

  // Use diagonal-aware carving if diagonal corridors are enabled
  let corridorResult;
  if (diagonalChance > 0 || corridorStyle === 'diagonal') {
    corridorResult = carveCorridorsWithDiagonals(connections, corridorWidth, rooms, corridorStyle, diagonalChance, color);
  } else {
    corridorResult = carveCorridors(connections, corridorWidth, rooms, corridorStyle);
  }
  const corridorCells = corridorResult.cells;
  const corridorsByConnection = corridorResult.byConnection;

  // Build cell sets for door validation and opening width calculation
  const corridorCellSet = new Set(corridorCells.map(c => `${c.x},${c.y}`));

  // Track segment cells (diagonal corridor cells) - doors shouldn't be placed on these
  const segmentCellSet = new Set(
    corridorCells.filter(c => c.segments).map(c => `${c.x},${c.y}`)
  );

  // Build carved cell set (rooms + corridors) for opening width calculation
  const carvedCellSet = new Set(corridorCellSet);
  for (const room of rooms) {
    for (let x = room.x; x < room.x + room.width; x++) {
      for (let y = room.y; y < room.y + room.height; y++) {
        if (isCellInRoom(x, y, room)) {
          carvedCellSet.add(`${x},${y}`);
        }
      }
    }
  }

  // Phase 3a: Find door positions and wall edges
  const doorResult = findDoorPositions(
    corridorsByConnection,
    rooms,
    config.doorChance ?? 0.7,
    config.secretDoorChance ?? 0,
    carvedCellSet,
    corridorCellSet,
    segmentCellSet
  );
  const doorPositions = doorResult.doorPositions;
  let doorObjects = generateDoorObjects(doorPositions);

  // Generate wall edges for ALL corridor cells adjacent to rooms (except where doors are)
  let wallEdges = generateAllRoomBoundaryEdges(rooms, corridorCellSet, doorPositions);

  // Add secret doors to any rooms that ended up with no doors (emergent generation)
  // Calculate remaining secret door quota based on user's secretDoorChance
  const existingSecretDoorCount = doorObjects.filter(o => o.type === 'secret-door').length;
  const isolatedRoomCount = getIsolatedRooms(rooms, doorPositions).length;
  const totalDoorCount = doorObjects.length + isolatedRoomCount;
  const targetSecretDoorCount = Math.round(totalDoorCount * (config.secretDoorChance ?? 0));
  const remainingSecretQuota = Math.max(0, targetSecretDoorCount - existingSecretDoorCount);

  const isolatedRoomResult = addSecretDoorsToIsolatedRooms(
    rooms, doorPositions, wallEdges, corridorCellSet, remainingSecretQuota
  );
  wallEdges = isolatedRoomResult.updatedEdges;
  if (isolatedRoomResult.secretDoorObjects.length > 0) {
    doorObjects = [...doorObjects, ...isolatedRoomResult.secretDoorObjects];
  }

  // Phase 3b: Generate entry/exit stairs
  const { entry, exit } = findEntryExitRooms(rooms);
  const stairObjects = generateStairObjects(entry, exit);

  // Phase 3c: Generate water features
  const waterChance = config.waterChance ?? 0;
  const waterColor = config.waterColor ?? DEFAULT_WATER_COLOR;
  const waterOpacity = config.waterOpacity ?? DEFAULT_WATER_OPACITY;
  const waterRoomIds = selectWaterRooms(rooms, waterChance, entry?.id, exit?.id);
  const waterCells = generateWaterCells(rooms, waterRoomIds, waterColor, waterOpacity);

  // Combine all objects
  const objects = [...doorObjects, ...stairObjects];

  // Phase 4: Generate cells (floor first, then overlay water)
  const floorCells = generateCells(rooms, corridorCells, color);

  // Merge water cells - water overlays floor cells
  const cellMap = new Map();
  for (const cell of floorCells) {
    cellMap.set(cellKey(cell.x, cell.y), cell);
  }
  for (const cell of waterCells) {
    cellMap.set(cellKey(cell.x, cell.y), cell);
  }
  const cells = Array.from(cellMap.values());

  // Count secret doors for metadata
  const secretDoorCount = doorObjects.filter(o => o.type === 'secret-door').length;

  return {
    cells,
    objects,
    edges: wallEdges,
    metadata: {
      rooms,
      connections: connections.map(([a, b]) => [a.id, b.id]),
      gridWidth: config.gridWidth,
      gridHeight: config.gridHeight,
      roomCount: rooms.length,
      doorCount: doorObjects.length,
      secretDoorCount,
      hasWideCorridors: useWideCorridors,
      hasDiagonalCorridors: corridorsByConnection.some(c => c.hasDiagonals),
      entryRoomId: entry?.id,
      exitRoomId: exit?.id,
      waterRoomIds,
      // Data for objectPlacer (dungeon stocking)
      corridorResult,
      doorPositions,
      style: config.style || 'classic'
    }
  };
}

// =============================================================================
// EXPORTS
// =============================================================================

return {
  generateDungeon,
  DUNGEON_PRESETS,
  DUNGEON_STYLES,
  DEFAULT_FLOOR_COLOR,
  DEFAULT_WATER_COLOR,
  DEFAULT_WATER_OPACITY,
  DIAGONAL_SEGMENTS,

  // Individual phases
  generateRooms,
  buildConnectionGraph,
  carveCorridors,
  carveCorridorsWithDiagonals,
  carveDiagonalCorridor,
  generateCells,
  selectWaterRooms,
  generateWaterCells,

  // Utilities
  getRoomCenter,
  getRoomCells,
  getRoomDistance,
  isCellInRoom,
  isCellInRoomRect,
  isCellAdjacentToRoom,
  carveCorridorBetween,
  canUseDiagonalCorridor,
  getDiagonalDirection,
  findDoorCandidates,
  findDoorPositions,
  generateDoorObjects,
  findEntryExitRooms,
  generateStairObjects,

  // Door/edge utilities (for testing)
  isAtCorridorIntersection,
  isCellAdjacentToRoomForOpening,
  calculateRoomOpeningWidth,
  generateWallEdgesForCells,
  generateAllRoomBoundaryEdges
};
```

# objectPlacer

```js
/**
 * objectPlacer.js
 *
 * Dungeon stocking module for Windrose MapDesigner.
 * Places objects (monsters, traps, treasure, features) in generated dungeons
 * using B/X-style random tables with configurable weights.
 */

// =============================================================================
// TYPE DEFINITIONS (JSDoc)
// =============================================================================

/**
 * @typedef {Object} CellPosition
 * @property {number} x - Grid X coordinate
 * @property {number} y - Grid Y coordinate
 */

/**
 * @typedef {Object} PlacementZones
 * @property {CellPosition[]} center - Center area cells
 * @property {CellPosition[]} corners - Corner cells
 * @property {CellPosition[]} walls - Wall-adjacent cells
 * @property {CellPosition[]} doorAdjacent - Cells near doors (excluded from placement)
 * @property {CellPosition[]} scattered - All valid cells for random placement
 */

/**
 * @typedef {Object} PlacementContext
 * @property {string} [category] - Room category ('monster', 'trap', 'feature', 'empty')
 * @property {boolean} [isTreasure] - Whether this is a treasure object
 * @property {string} [templateName] - Template name if using a room template
 * @property {boolean} [isCorridor] - Whether placed in a corridor
 */

/**
 * @typedef {Object} PlacedObject
 * @property {string} id - Unique object ID
 * @property {string} type - Object type ID
 * @property {CellPosition} position - Grid position
 * @property {{width: number, height: number}} size - Object size in cells
 * @property {string} alignment - Cell alignment
 * @property {number} scale - Render scale
 * @property {number} rotation - Rotation in degrees
 * @property {string} label - Display label
 * @property {string} [customTooltip] - Tooltip text (if applicable)
 */

/**
 * @typedef {Object} RoomDefinition
 * @property {number} id - Room ID
 * @property {number} x - Top-left X
 * @property {number} y - Top-left Y
 * @property {number} width - Room width
 * @property {number} height - Room height
 * @property {string} [shape] - Room shape ('rectangle', 'circle', 'composite')
 */

// =============================================================================
// CONSTANTS
// =============================================================================

const ROOM_CATEGORIES = {
  MONSTER: 'monster',
  EMPTY: 'empty',
  FEATURE: 'feature',
  TRAP: 'trap'
};

/**
 * Default stocking configuration based on B/X D&D.
 * Monster: 33%, Empty: 33%, Feature: 17%, Trap: 17%
 */
const STOCKING_CONFIG = {
  categoryWeights: {
    monster: 0.33,
    empty: 0.33,
    feature: 0.17,
    trap: 0.17
  },
  // Secondary treasure roll by category (B/X style)
  treasureChance: {
    monster: 0.50,  // Monster rooms: 3-in-6 treasure
    trap: 0.33,     // Trap rooms: 2-in-6 treasure (bait)
    empty: 0.17,    // Empty rooms: 1-in-6 hidden treasure
    feature: 0.0    // Feature rooms don't get secondary treasure
  },
  // Room size thresholds (in cells)
  sizeThresholds: {
    small: 6,   // 3-6 cells: 1-2 objects
    medium: 15  // 7-15 cells: 2-4 objects, 16+: 4-6 objects
  },
  // Corridor trap settings
  corridorTrapRatio: 0.6  // 60% of traps go in corridors
};

// =============================================================================
// STYLE-SPECIFIC OBJECT POOLS
// =============================================================================

const STYLE_OBJECT_POOLS = {
  classic: {
    monsters: ['monster', 'guard'],
    treasures: ['chest', 'sack'],
    features: ['table', 'chair', 'statue', 'crate', 'altar'],
    traps: ['trap', 'pit', 'hazard']
  },
  cavern: {
    monsters: ['monster'],
    treasures: ['chest', 'sack'],
    features: ['plant', 'flower', 'fountain', 'statue'],
    traps: ['pit', 'hazard']
  },
  fortress: {
    monsters: ['monster', 'guard', 'guard'],  // Weighted toward guards
    treasures: ['chest', 'crate'],
    features: ['table', 'chair', 'bed', 'anvil', 'statue', 'crate'],
    traps: ['trap', 'pit']
  },
  crypt: {
    monsters: ['monster', 'boss-alt'],  // Undead theme
    treasures: ['chest', 'sack'],
    features: ['coffin', 'altar', 'statue', 'cage'],
    traps: ['trap', 'hazard', 'poison']
  }
};

// =============================================================================
// WATER ROOM PLACEMENT RULES
// =============================================================================

/**
 * Water room object placement configuration.
 * Water rooms have restricted object placement - objects must be on shores/edges.
 */
const WATER_PLACEMENT_RULES = {
  // Objects allowed on island/center (30% chance of center feature)
  centerFeatures: ['fountain', 'statue'],
  // Objects allowed on shore (outer ring of room)
  shoreObjects: ['chest', 'monster', 'sack'],
  // Objects excluded from water rooms entirely
  excluded: ['table', 'chair', 'bed', 'coffin', 'book', 'crate', 'trap', 'pit', 'guard'],
  // Budget reduction factor for water rooms
  budgetDivisor: 12,
  // Chance of placing a center feature (island)
  centerFeatureChance: 0.3,
  // Cavern style allows monsters in deep water (aquatic creatures)
  deepWaterMonsterStyles: ['cavern']
};

// =============================================================================
// ROOM TEMPLATES
// =============================================================================

const ROOM_TEMPLATES = {
  library: {
    name: 'Library',
    objects: [
      { type: 'book', count: { min: 2, max: 4 }, placement: 'walls' },
      { type: 'table', count: { min: 0, max: 1 }, placement: 'center' }
    ],
    minRoomSize: 9
  },
  storage: {
    name: 'Storage',
    objects: [
      { type: 'crate', count: { min: 2, max: 5 }, placement: 'scattered' },
      { type: 'sack', count: { min: 0, max: 2 }, placement: 'corners' }
    ],
    minRoomSize: 6
  },
  shrine: {
    name: 'Shrine',
    objects: [
      { type: 'altar', count: { min: 1, max: 1 }, placement: 'center' },
      { type: 'statue', count: { min: 0, max: 2 }, placement: 'flanking' }
    ],
    minRoomSize: 9
  },
  barracks: {
    name: 'Barracks',
    objects: [
      { type: 'bed', count: { min: 2, max: 4 }, placement: 'walls' },
      { type: 'table', count: { min: 0, max: 1 }, placement: 'center' },
      { type: 'chest', count: { min: 0, max: 1 }, placement: 'corners' }
    ],
    minRoomSize: 12
  },
  treasury: {
    name: 'Treasury',
    objects: [
      { type: 'chest', count: { min: 2, max: 4 }, placement: 'walls' },
      { type: 'sack', count: { min: 0, max: 2 }, placement: 'scattered' }
    ],
    minRoomSize: 6
  },
  guardRoom: {
    name: 'Guard Room',
    objects: [
      { type: 'guard', count: { min: 1, max: 3 }, placement: 'scattered' },
      { type: 'table', count: { min: 0, max: 1 }, placement: 'center' }
    ],
    minRoomSize: 9
  }
};

// =============================================================================
// PLACEMENT PREFERENCES
// =============================================================================

const PLACEMENT_PREFERENCES = {
  // Monsters can be anywhere
  monster: ['scattered', 'center'],
  guard: ['scattered', 'center'],
  boss: ['center'],
  'boss-alt': ['center'],

  // Treasure near walls/corners
  chest: ['corners', 'walls'],
  sack: ['corners', 'walls', 'scattered'],

  // Furniture has specific preferences
  altar: ['center'],
  statue: ['corners', 'walls', 'center'],
  table: ['center'],
  chair: ['center', 'scattered'],
  bed: ['walls', 'corners'],
  coffin: ['walls', 'center'],
  book: ['walls'],
  crate: ['corners', 'walls', 'scattered'],
  cauldron: ['center'],
  fountain: ['center'],
  anvil: ['walls', 'corners'],
  cage: ['walls', 'corners'],

  // Nature
  plant: ['corners', 'scattered'],
  flower: ['scattered'],

  // Hazards
  trap: ['center', 'scattered'],
  pit: ['center'],
  hazard: ['scattered'],
  poison: ['scattered']
};

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function generateObjectId() {
  return 'obj-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
}

function cellKey(x, y) {
  return `${x},${y}`;
}

/**
 * Select a random item from an array.
 */
function selectFromPool(pool) {
  if (!pool || pool.length === 0) return null;
  return pool[Math.floor(Math.random() * pool.length)];
}

/**
 * Roll a weighted category selection.
 * @param {Object} weights - Object with category names as keys and weights as values
 * @returns {string} Selected category name
 */
function rollWeightedCategory(weights) {
  const entries = Object.entries(weights);
  const total = entries.reduce((sum, [, w]) => sum + w, 0);

  if (total === 0) return ROOM_CATEGORIES.EMPTY;

  let roll = Math.random() * total;

  for (const [category, weight] of entries) {
    roll -= weight;
    if (roll <= 0) return category;
  }

  return entries[entries.length - 1][0];
}

/**
 * Normalize weights to sum to 1.0.
 */
function normalizeWeights(weights) {
  const sum = Object.values(weights).reduce((a, b) => a + b, 0);
  if (sum === 0) {
    return {
      monster: 0.25,
      empty: 0.25,
      feature: 0.25,
      trap: 0.25
    };
  }

  const normalized = {};
  for (const [key, val] of Object.entries(weights)) {
    normalized[key] = val / sum;
  }
  return normalized;
}

// =============================================================================
// TOOLTIP GENERATION
// =============================================================================

/**
 * Object type labels for display.
 */
const OBJECT_LABELS = {
  // Monsters
  monster: 'Monster',
  guard: 'Guard',
  boss: 'Boss',
  'boss-alt': 'Boss',

  // Treasures
  chest: 'Chest',
  sack: 'Sack',
  crate: 'Crate',

  // Furniture
  altar: 'Altar',
  statue: 'Statue',
  table: 'Table',
  chair: 'Chair',
  bed: 'Bed',
  coffin: 'Coffin',
  book: 'Bookshelf',
  cauldron: 'Cauldron',
  fountain: 'Fountain',
  anvil: 'Anvil',
  cage: 'Cage',

  // Nature
  plant: 'Plant',
  flower: 'Flowers',

  // Hazards
  trap: 'Trap',
  pit: 'Pit',
  hazard: 'Hazard',
  poison: 'Poison'
};

/**
 * Get display label for an object type.
 * @param {string} objectType - The object type ID
 * @returns {string} Human-readable label
 */
function getObjectLabel(objectType) {
  return OBJECT_LABELS[objectType] || objectType.charAt(0).toUpperCase() + objectType.slice(1);
}

/**
 * Generate contextual tooltip for a placed object.
 * @param {string} objectType - The object type ID
 * @param {Object} context - Placement context
 * @param {string} context.category - Room category (monster, trap, feature, empty)
 * @param {boolean} context.isTreasure - Whether this is a treasure object
 * @param {string} context.templateName - Template name if applicable
 * @param {boolean} context.isCorridor - Whether placed in corridor
 * @returns {string} Tooltip text
 */
function getObjectTooltip(objectType, context = {}) {
  const { category, isTreasure, templateName, isCorridor } = context;

  // Corridor traps
  if (isCorridor) {
    return 'Corridor trap';
  }

  // Treasure objects get special tooltips based on room category
  if (isTreasure) {
    if (category === 'monster') {
      return 'Guarded treasure';
    }
    if (category === 'trap') {
      return 'Trapped treasure (bait)';
    }
    if (category === 'empty') {
      return 'Hidden treasure';
    }
  }

  // Monster category
  if (category === 'monster') {
    if (objectType === 'guard') {
      return 'Guard post';
    }
    return 'Monster lair';
  }

  // Trap category
  if (category === 'trap') {
    return 'Trapped area';
  }

  // Feature category with template
  if (templateName) {
    return `${templateName} furnishing`;
  }

  // Feature category without template
  if (category === 'feature') {
    return 'Room feature';
  }

  // Default
  return null;
}

// =============================================================================
// ROOM ANALYSIS
// =============================================================================

/**
 * Get all cells belonging to a room.
 */
function getRoomCells(room) {
  const cells = [];
  for (let x = room.x; x < room.x + room.width; x++) {
    for (let y = room.y; y < room.y + room.height; y++) {
      if (isCellInRoom(x, y, room)) {
        cells.push({ x, y });
      }
    }
  }
  return cells;
}

/**
 * Check if a cell is inside a room (respects shape).
 */
function isCellInRoom(x, y, room) {
  if (x < room.x || x >= room.x + room.width ||
      y < room.y || y >= room.y + room.height) {
    return false;
  }

  if (room.shape === 'circle') {
    const centerX = room.x + room.radius;
    const centerY = room.y + room.radius;
    const dx = x + 0.5 - centerX;
    const dy = y + 0.5 - centerY;
    return dx * dx + dy * dy <= room.radius * room.radius;
  }

  if (room.shape === 'composite') {
    return room.parts.some(part =>
      x >= part.x && x < part.x + part.width &&
      y >= part.y && y < part.y + part.height
    );
  }

  return true;
}

/**
 * Calculate object budget based on room size and density multiplier.
 */
function getObjectBudget(roomSize, densityMultiplier = 1.0) {
  let base;

  if (roomSize <= STOCKING_CONFIG.sizeThresholds.small) {
    // Small rooms: 1-2 objects
    base = randomInt(1, 2);
  } else if (roomSize <= STOCKING_CONFIG.sizeThresholds.medium) {
    // Medium rooms: 2-4 objects
    base = randomInt(2, 4);
  } else {
    // Large rooms: 4-6 objects
    base = randomInt(4, 6);
  }

  return Math.max(1, Math.round(base * densityMultiplier));
}

// =============================================================================
// PLACEMENT ZONE IDENTIFICATION
// =============================================================================

/**
 * Identify placement zones within a room.
 * @param {Array} roomCells - All cells in the room
 * @param {Object} room - Room object with bounds
 * @param {Array} doorPositions - Door positions to avoid
 * @returns {Object} Zones: center, corners, walls, scattered, doorAdjacent
 */
function identifyPlacementZones(roomCells, room, doorPositions = []) {
  const zones = {
    center: [],
    corners: [],
    walls: [],
    doorAdjacent: [],
    scattered: []
  };

  // Build door position set for quick lookup
  const doorCells = new Set(doorPositions.map(d => cellKey(d.x, d.y)));
  const doorAdjacentCells = new Set();

  // Mark cells adjacent to doors
  for (const door of doorPositions) {
    for (const [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {
      doorAdjacentCells.add(cellKey(door.x + dx, door.y + dy));
    }
  }

  // Calculate room bounds for zone classification
  const minX = room.x;
  const maxX = room.x + room.width - 1;
  const minY = room.y;
  const maxY = room.y + room.height - 1;

  // Classify each cell
  for (const cell of roomCells) {
    const key = cellKey(cell.x, cell.y);

    // Skip door cells and adjacent cells
    if (doorCells.has(key)) {
      zones.doorAdjacent.push(cell);
      continue;
    }
    if (doorAdjacentCells.has(key)) {
      zones.doorAdjacent.push(cell);
      continue;
    }

    const isCorner = isCornerCell(cell, minX, maxX, minY, maxY);
    const isWall = isWallCell(cell, minX, maxX, minY, maxY);
    const isCenter = !isWall;

    if (isCorner) {
      zones.corners.push(cell);
    } else if (isWall) {
      zones.walls.push(cell);
    } else if (isCenter) {
      zones.center.push(cell);
    }

    // All valid cells go in scattered
    zones.scattered.push(cell);
  }

  return zones;
}

/**
 * Check if a cell is in a corner of the room.
 */
function isCornerCell(cell, minX, maxX, minY, maxY) {
  const nearLeft = cell.x <= minX + 1;
  const nearRight = cell.x >= maxX - 1;
  const nearTop = cell.y <= minY + 1;
  const nearBottom = cell.y >= maxY - 1;

  return (nearLeft || nearRight) && (nearTop || nearBottom);
}

/**
 * Check if a cell is along a wall (edge) but not a corner.
 */
function isWallCell(cell, minX, maxX, minY, maxY) {
  return cell.x === minX || cell.x === maxX ||
         cell.y === minY || cell.y === maxY;
}

// =============================================================================
// OBJECT PLACEMENT
// =============================================================================

/**
 * Place a single object at a valid position.
 * @param {PlacementZones} zones - Placement zones
 * @param {string} objectType - Object type ID
 * @param {Set<string>} occupiedCells - Set of occupied cell keys
 * @param {string|null} preferredZone - Preferred zone ('center', 'corners', 'walls', 'scattered')
 * @param {PlacementContext} context - Placement context for tooltip generation
 * @returns {PlacedObject|null} Object definition or null if no valid position
 */
function placeObject(zones, objectType, occupiedCells, preferredZone = null, context = {}) {
  // Determine zone preference order
  const preferences = preferredZone
    ? [preferredZone, 'scattered']
    : (PLACEMENT_PREFERENCES[objectType] || ['scattered']);

  for (const zoneName of preferences) {
    const zone = zones[zoneName];
    if (!zone || zone.length === 0) continue;

    // Find available cells in this zone
    const available = zone.filter(cell => !occupiedCells.has(cellKey(cell.x, cell.y)));
    if (available.length === 0) continue;

    // Select a random cell
    const cell = available[Math.floor(Math.random() * available.length)];
    occupiedCells.add(cellKey(cell.x, cell.y));

    // Generate label and tooltip
    const label = getObjectLabel(objectType);
    const customTooltip = getObjectTooltip(objectType, context);

    const obj = {
      id: generateObjectId(),
      type: objectType,
      position: { x: cell.x, y: cell.y },
      size: { width: 1, height: 1 },
      alignment: 'center',
      scale: 1,
      rotation: 0,
      label
    };

    // Only add customTooltip if we have one
    if (customTooltip) {
      obj.customTooltip = customTooltip;
    }

    return obj;
  }

  return null;
}

/**
 * Place multiple objects from a pool.
 * @param {PlacementZones} zones - Placement zones
 * @param {string[]} pool - Object type pool to select from
 * @param {number} count - Number of objects to place
 * @param {Set<string>} occupiedCells - Set of occupied cell keys
 * @param {string|null} preferredZone - Optional preferred zone
 * @param {PlacementContext} context - Placement context for tooltip generation
 * @returns {PlacedObject[]} Placed objects
 */
function placeObjects(zones, pool, count, occupiedCells, preferredZone = null, context = {}) {
  const placed = [];

  for (let i = 0; i < count; i++) {
    const objectType = selectFromPool(pool);
    if (!objectType) continue;

    const obj = placeObject(zones, objectType, occupiedCells, preferredZone, context);
    if (obj) {
      placed.push(obj);
    }
  }

  return placed;
}

// =============================================================================
// ROOM TEMPLATES
// =============================================================================

/**
 * Select a valid template for the given room size.
 */
function selectValidTemplate(roomSize) {
  const validTemplates = Object.entries(ROOM_TEMPLATES)
    .filter(([, template]) => roomSize >= template.minRoomSize);

  if (validTemplates.length === 0) return null;

  const [, template] = validTemplates[Math.floor(Math.random() * validTemplates.length)];
  return template;
}

/**
 * @typedef {Object} TemplateObjectSpec
 * @property {string} type - Object type ID
 * @property {{min: number, max: number}} count - Count range
 * @property {string} placement - Preferred placement zone
 */

/**
 * @typedef {Object} RoomTemplate
 * @property {string} name - Template display name
 * @property {TemplateObjectSpec[]} objects - Objects to place
 * @property {number} minRoomSize - Minimum room size for this template
 */

/**
 * Apply a room template, placing all its objects.
 * @param {RoomTemplate} template - Room template definition
 * @param {PlacementZones} zones - Placement zones
 * @param {Set<string>} occupiedCells - Set of occupied cell keys
 * @returns {PlacedObject[]} Placed objects
 */
function applyRoomTemplate(template, zones, occupiedCells) {
  const placed = [];
  const context = { category: 'feature', templateName: template.name };

  for (const spec of template.objects) {
    const count = randomInt(spec.count.min, spec.count.max);

    for (let i = 0; i < count; i++) {
      const obj = placeObject(zones, spec.type, occupiedCells, spec.placement, context);
      if (obj) {
        placed.push(obj);
      }
    }
  }

  return placed;
}

// =============================================================================
// CORRIDOR TRAP PLACEMENT
// =============================================================================

/**
 * Find cells that are only in corridors (not in any room).
 */
function findCorridorOnlyCells(corridorCells, rooms) {
  return corridorCells.filter(cell => {
    for (const room of rooms) {
      if (isCellInRoom(cell.x, cell.y, room)) {
        return false;
      }
    }
    return true;
  });
}

/**
 * Select a position for a corridor trap.
 */
function selectCorridorTrapPosition(corridorCells, occupiedCells) {
  const available = corridorCells.filter(cell =>
    !occupiedCells.has(cellKey(cell.x, cell.y))
  );

  if (available.length === 0) return null;

  return available[Math.floor(Math.random() * available.length)];
}

// =============================================================================
// WATER ROOM OBJECT PLACEMENT
// =============================================================================

/**
 * Identify shore cells (outer ring) vs deep water cells (center) in a room.
 * Shore cells are any cells on the edge of the room or within 1 cell of the edge.
 * @param {Array} roomCells - All cells in the room
 * @param {Object} room - Room object with bounds
 * @returns {Object} { shore: CellPosition[], deepWater: CellPosition[] }
 */
function identifyWaterZones(roomCells, room) {
  const shore = [];
  const deepWater = [];

  const minX = room.x;
  const maxX = room.x + room.width - 1;
  const minY = room.y;
  const maxY = room.y + room.height - 1;

  for (const cell of roomCells) {
    // Shore = outer ring (edge or 1 cell from edge)
    const distFromEdge = Math.min(
      cell.x - minX,
      maxX - cell.x,
      cell.y - minY,
      maxY - cell.y
    );

    if (distFromEdge <= 1) {
      shore.push(cell);
    } else {
      deepWater.push(cell);
    }
  }

  return { shore, deepWater };
}

/**
 * Stock a water room with appropriate objects.
 * Water rooms have special placement rules:
 * - Most objects on shore only (outer ring)
 * - 30% chance of center island feature
 * - Reduced object budget
 * - Cavern style allows aquatic monsters in deep water
 *
 * @param {Object} room - Room definition
 * @param {Array} roomCells - All cells in the room
 * @param {Object} roomDoors - Door positions in this room
 * @param {string} style - Dungeon style
 * @param {Set<string>} occupiedCells - Set of occupied cell keys
 * @returns {Object} { objects: PlacedObject[], assignment: { category, isWater: true } }
 */
function stockWaterRoom(room, roomCells, roomDoors, style, occupiedCells) {
  const objects = [];
  const waterZones = identifyWaterZones(roomCells, room);

  // Calculate reduced budget for water rooms
  const budget = Math.max(1, Math.floor(roomCells.length / WATER_PLACEMENT_RULES.budgetDivisor));

  // Build door-adjacent exclusion set
  const doorAdjacentCells = new Set();
  for (const door of roomDoors) {
    doorAdjacentCells.add(cellKey(door.x, door.y));
    for (const [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {
      doorAdjacentCells.add(cellKey(door.x + dx, door.y + dy));
    }
  }

  // Filter shore cells to exclude door-adjacent
  const availableShore = waterZones.shore.filter(
    cell => !doorAdjacentCells.has(cellKey(cell.x, cell.y))
  );

  // 30% chance of center island feature (fountain or statue)
  if (waterZones.deepWater.length > 0 && Math.random() < WATER_PLACEMENT_RULES.centerFeatureChance) {
    const centerCells = waterZones.deepWater.filter(
      cell => !occupiedCells.has(cellKey(cell.x, cell.y))
    );
    if (centerCells.length > 0) {
      const cell = centerCells[Math.floor(Math.random() * centerCells.length)];
      const featureType = selectFromPool(WATER_PLACEMENT_RULES.centerFeatures);
      occupiedCells.add(cellKey(cell.x, cell.y));
      objects.push({
        id: generateObjectId(),
        type: featureType,
        position: { x: cell.x, y: cell.y },
        size: { width: 1, height: 1 },
        alignment: 'center',
        scale: 1,
        rotation: 0,
        label: getObjectLabel(featureType),
        customTooltip: 'Island feature'
      });
    }
  }

  // Cavern style: chance of aquatic monster in deep water
  if (WATER_PLACEMENT_RULES.deepWaterMonsterStyles.includes(style)) {
    if (waterZones.deepWater.length > 0 && Math.random() < 0.3) {
      const deepCells = waterZones.deepWater.filter(
        cell => !occupiedCells.has(cellKey(cell.x, cell.y))
      );
      if (deepCells.length > 0) {
        const cell = deepCells[Math.floor(Math.random() * deepCells.length)];
        occupiedCells.add(cellKey(cell.x, cell.y));
        objects.push({
          id: generateObjectId(),
          type: 'monster',
          position: { x: cell.x, y: cell.y },
          size: { width: 1, height: 1 },
          alignment: 'center',
          scale: 1,
          rotation: 0,
          label: getObjectLabel('monster'),
          customTooltip: 'Aquatic creature'
        });
      }
    }
  }

  // Place remaining objects on shore
  const shorePool = WATER_PLACEMENT_RULES.shoreObjects;
  for (let i = 0; i < budget && availableShore.length > 0; i++) {
    const available = availableShore.filter(
      cell => !occupiedCells.has(cellKey(cell.x, cell.y))
    );
    if (available.length === 0) break;

    const cell = available[Math.floor(Math.random() * available.length)];
    const objectType = selectFromPool(shorePool);
    occupiedCells.add(cellKey(cell.x, cell.y));

    objects.push({
      id: generateObjectId(),
      type: objectType,
      position: { x: cell.x, y: cell.y },
      size: { width: 1, height: 1 },
      alignment: 'center',
      scale: 1,
      rotation: 0,
      label: getObjectLabel(objectType),
      customTooltip: 'Shore placement'
    });
  }

  return {
    objects,
    assignment: { category: 'water', isWater: true, hasSecondaryTreasure: false }
  };
}

// =============================================================================
// MAIN STOCKING FUNCTION
// =============================================================================

/**
 * Stock a dungeon with objects using B/X-style random tables.
 *
 * @param {Array} rooms - Generated rooms
 * @param {Object} corridorResult - Corridor generation result (cells, byConnection)
 * @param {Array} doorPositions - Door positions (to avoid placement)
 * @param {string} style - Dungeon style ('classic', 'cavern', 'fortress', 'crypt')
 * @param {Object} config - Stocking configuration
 * @param {Object} options - Additional options (entryRoomId, exitRoomId, waterRoomIds)
 * @returns {Object} { objects: MapObject[], roomAssignments: {} }
 */
function stockDungeon(rooms, corridorResult, doorPositions, style = 'classic', config = {}, options = {}) {
  const stockedObjects = [];
  const roomAssignments = {};
  const occupiedCells = new Set();

  // Get style-specific object pool
  const objectPool = STYLE_OBJECT_POOLS[style] || STYLE_OBJECT_POOLS.classic;

  // Build water room lookup set
  const waterRoomSet = new Set(options.waterRoomIds || []);

  // Merge config with defaults
  const categoryWeights = normalizeWeights({
    monster: config.monsterWeight ?? STOCKING_CONFIG.categoryWeights.monster,
    empty: config.emptyWeight ?? STOCKING_CONFIG.categoryWeights.empty,
    feature: config.featureWeight ?? STOCKING_CONFIG.categoryWeights.feature,
    trap: config.trapWeight ?? STOCKING_CONFIG.categoryWeights.trap
  });

  const densityMultiplier = config.objectDensity ?? 1.0;
  const useTemplates = config.useTemplates !== false;
  const corridorTrapChance = config.corridorTrapChance ?? 0.1;

  // Mark existing object positions as occupied (doors, stairs)
  for (const door of doorPositions) {
    occupiedCells.add(cellKey(door.x, door.y));
  }

  // Stock each room
  for (const room of rooms) {
    // Skip entry/exit rooms (they have stairs)
    if (room.id === options.entryRoomId || room.id === options.exitRoomId) {
      roomAssignments[room.id] = { category: 'entry_exit', hasSecondaryTreasure: false };
      continue;
    }

    // Get room cells for zone identification
    const roomCells = getRoomCells(room);

    // Filter door positions to just this room
    const roomDoors = doorPositions.filter(d =>
      d.x >= room.x && d.x < room.x + room.width &&
      d.y >= room.y && d.y < room.y + room.height
    );

    // Handle water rooms specially
    if (waterRoomSet.has(room.id)) {
      const waterResult = stockWaterRoom(room, roomCells, roomDoors, style, occupiedCells);
      stockedObjects.push(...waterResult.objects);
      roomAssignments[room.id] = waterResult.assignment;
      continue;
    }

    // Roll room category for non-water rooms
    const category = rollWeightedCategory(categoryWeights);
    roomAssignments[room.id] = { category, hasSecondaryTreasure: false };

    const roomSize = roomCells.length;
    const zones = identifyPlacementZones(roomCells, room, roomDoors);

    // Calculate object budget
    const objectBudget = getObjectBudget(roomSize, densityMultiplier);

    // Place objects based on category
    switch (category) {
      case ROOM_CATEGORIES.MONSTER: {
        // Place monsters (60% of budget)
        const monsterCount = Math.max(1, Math.ceil(objectBudget * 0.6));
        const monsterContext = { category: 'monster' };
        const monsters = placeObjects(zones, objectPool.monsters, monsterCount, occupiedCells, null, monsterContext);
        stockedObjects.push(...monsters);

        // Secondary treasure roll (B/X: 3-in-6 for monster rooms)
        if (Math.random() < STOCKING_CONFIG.treasureChance.monster) {
          roomAssignments[room.id].hasSecondaryTreasure = true;
          const treasureCount = Math.max(1, Math.floor(objectBudget * 0.3));
          const treasureContext = { category: 'monster', isTreasure: true };
          const treasure = placeObjects(zones, objectPool.treasures, treasureCount, occupiedCells, 'corners', treasureContext);
          stockedObjects.push(...treasure);
        }
        break;
      }

      case ROOM_CATEGORIES.TRAP: {
        // Place trap(s)
        const trapCount = randomInt(1, 2);
        const trapContext = { category: 'trap' };
        const traps = placeObjects(zones, objectPool.traps, trapCount, occupiedCells, null, trapContext);
        stockedObjects.push(...traps);

        // Secondary treasure roll (B/X: 2-in-6 for trap rooms - it's bait!)
        if (Math.random() < STOCKING_CONFIG.treasureChance.trap) {
          roomAssignments[room.id].hasSecondaryTreasure = true;
          const treasureContext = { category: 'trap', isTreasure: true };
          const treasure = placeObjects(zones, objectPool.treasures, 1, occupiedCells, 'center', treasureContext);
          stockedObjects.push(...treasure);
        }
        break;
      }

      case ROOM_CATEGORIES.FEATURE: {
        // 50% chance to use a template if room is large enough
        if (useTemplates && Math.random() < 0.5 && roomSize >= 9) {
          const template = selectValidTemplate(roomSize);
          if (template) {
            const templateObjects = applyRoomTemplate(template, zones, occupiedCells);
            stockedObjects.push(...templateObjects);
            roomAssignments[room.id].template = template.name;
            break;
          }
        }

        // Otherwise place random features
        const featureCount = objectBudget;
        const featureContext = { category: 'feature' };
        const features = placeObjects(zones, objectPool.features, featureCount, occupiedCells, null, featureContext);
        stockedObjects.push(...features);
        break;
      }

      case ROOM_CATEGORIES.EMPTY:
      default: {
        // Usually empty, but small chance of hidden treasure (B/X: 1-in-6)
        if (Math.random() < STOCKING_CONFIG.treasureChance.empty) {
          roomAssignments[room.id].hasSecondaryTreasure = true;
          const treasureContext = { category: 'empty', isTreasure: true };
          const treasure = placeObjects(zones, objectPool.treasures, 1, occupiedCells, 'corners', treasureContext);
          stockedObjects.push(...treasure);
        }
        break;
      }
    }
  }

  // Place corridor traps
  if (corridorTrapChance > 0 && corridorResult && corridorResult.cells) {
    const corridorOnlyCells = findCorridorOnlyCells(corridorResult.cells, rooms);

    // Calculate corridor trap count based on corridor length and chance
    const corridorTrapCount = Math.floor(corridorOnlyCells.length * corridorTrapChance / 10);

    for (let i = 0; i < corridorTrapCount; i++) {
      const cell = selectCorridorTrapPosition(corridorOnlyCells, occupiedCells);
      if (cell) {
        occupiedCells.add(cellKey(cell.x, cell.y));
        const trapType = selectFromPool(objectPool.traps);
        stockedObjects.push({
          id: generateObjectId(),
          type: trapType,
          position: { x: cell.x, y: cell.y },
          size: { width: 1, height: 1 },
          alignment: 'center',
          scale: 1,
          rotation: 0,
          label: getObjectLabel(trapType),
          customTooltip: 'Corridor trap'
        });
      }
    }
  }

  return {
    objects: stockedObjects,
    roomAssignments
  };
}

// =============================================================================
// EXPORTS
// =============================================================================

return {
  // Main entry point
  stockDungeon,

  // Constants
  ROOM_CATEGORIES,
  STOCKING_CONFIG,
  STYLE_OBJECT_POOLS,
  ROOM_TEMPLATES,
  PLACEMENT_PREFERENCES,

  // Utilities (exported for testing)
  rollWeightedCategory,
  normalizeWeights,
  getObjectBudget,
  identifyPlacementZones,
  selectValidTemplate,
  applyRoomTemplate,
  placeObject,
  placeObjects,
  findCorridorOnlyCells,

  // Re-exports from dungeonGenerator needed by stockDungeon
  getRoomCells,
  isCellInRoom
};

```

# RerollDungeonButton

```jsx
/**
 * RerollDungeonButton.jsx
 *
 * Button component for re-rolling generated dungeons.
 * Uses MapContext to access mapData and cell operations.
 * Only renders if the map has generationSettings.
 */

const { useMapState, useMapOperations } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext"));
const { generateDungeon } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dungeonGenerator"));
const { stockDungeon } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "objectPlacer"));
const { ModalPortal } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ModalPortal"));

// Structural object types that should be preserved during objects-only reroll
const STRUCTURAL_TYPES = new Set([
  'door-horizontal', 'door-vertical', 'secret-door',
  'stairs-up', 'stairs-down'
]);

const RerollDungeonButton = () => {
  const { mapData } = useMapState();
  const { onCellsChange, onObjectsChange, onEdgesChange } = useMapOperations();

  const [showConfirm, setShowConfirm] = dc.useState(false);

  // Don't render if no generation settings
  if (!mapData?.generationSettings?.preset) {
    return null;
  }

  const settings = mapData.generationSettings;
  const hasStockingMetadata = Boolean(settings.stockingMetadata?.rooms);

  const handleClick = () => {
    setShowConfirm(true);
  };

  const handleRerollAll = () => {
    const result = generateDungeon(settings.preset, undefined, settings.configOverrides || {});
    const stockResult = stockDungeon(
      result.metadata.rooms,
      result.metadata.corridorResult,
      result.metadata.doorPositions,
      result.metadata.style || 'classic',
      {
        objectDensity: settings.configOverrides?.objectDensity ?? 1.0,
        monsterWeight: settings.configOverrides?.monsterWeight,
        emptyWeight: settings.configOverrides?.emptyWeight,
        featureWeight: settings.configOverrides?.featureWeight,
        trapWeight: settings.configOverrides?.trapWeight,
        useTemplates: settings.configOverrides?.useTemplates
      },
      {
        entryRoomId: result.metadata.entryRoomId,
        exitRoomId: result.metadata.exitRoomId,
        waterRoomIds: result.metadata.waterRoomIds
      }
    );
    const allObjects = [...result.objects, ...stockResult.objects];

    // suppressHistory = false so this can be undone
    onCellsChange(result.cells, false);
    onObjectsChange(allObjects, false);
    onEdgesChange(result.edges || [], false);
    setShowConfirm(false);
  };

  const handleRerollObjectsOnly = () => {
    const meta = settings.stockingMetadata;
    if (!meta?.rooms) {
      setShowConfirm(false);
      return;
    }

    // Get current objects and filter to keep only structural ones
    const layer = mapData?.layers?.find(l => l.id === mapData.activeLayerId);
    const currentObjects = layer?.objects || [];
    const structuralObjects = currentObjects.filter(obj => STRUCTURAL_TYPES.has(obj.type));

    const stairPositions = structuralObjects
      .filter(obj => obj.type === 'stairs-up' || obj.type === 'stairs-down')
      .map(obj => ({ x: obj.position.x, y: obj.position.y }));

    const occupiedPositions = [...(meta.doorPositions || []), ...stairPositions];

    // Generate new stocking objects using saved metadata
    const stockResult = stockDungeon(
      meta.rooms,
      meta.corridorResult,
      occupiedPositions,
      meta.style || 'classic',
      {
        objectDensity: settings.configOverrides?.objectDensity ?? 1.0,
        monsterWeight: settings.configOverrides?.monsterWeight,
        emptyWeight: settings.configOverrides?.emptyWeight,
        featureWeight: settings.configOverrides?.featureWeight,
        trapWeight: settings.configOverrides?.trapWeight,
        useTemplates: settings.configOverrides?.useTemplates
      },
      {
        entryRoomId: meta.entryRoomId,
        exitRoomId: meta.exitRoomId,
        waterRoomIds: meta.waterRoomIds
      }
    );

    const allObjects = [...structuralObjects, ...stockResult.objects];
    onObjectsChange(allObjects, false);
    setShowConfirm(false);
  };

  const handleCancel = () => {
    setShowConfirm(false);
  };

  const styleName = settings.configOverrides?.style || 'classic';

  return (
    <>
      <button
        className="dmt-tool-btn dmt-reroll-btn interactive-child"
        onClick={handleClick}
        title={`Re-roll dungeon (${styleName} ${settings.preset})`}
      >
        <dc.Icon icon="lucide-dices" />
      </button>

      {showConfirm && (
        <ModalPortal>
          <div className="dmt-reroll-confirm-overlay" onClick={handleCancel}>
            <div className="dmt-reroll-confirm-dialog" onClick={e => e.stopPropagation()}>
              <h3>Re-roll Dungeon?</h3>
              {hasStockingMetadata ? (
                <>
                  <p>Choose what to regenerate:</p>
                  <p className="dmt-reroll-warning">This action cannot be undone.</p>
                  <div className="dmt-reroll-confirm-buttons dmt-reroll-three-buttons">
                    <button className="dmt-btn dmt-btn-secondary" onClick={handleCancel}>
                      Cancel
                    </button>
                    <button className="dmt-btn dmt-btn-tertiary" onClick={handleRerollObjectsOnly} title="Keep the map layout, only regenerate monsters, features, and traps">
                      Objects Only
                    </button>
                    <button className="dmt-btn dmt-btn-primary" onClick={handleRerollAll}>
                      Entire Dungeon
                    </button>
                  </div>
                </>
              ) : (
                <>
                  <p>This will replace all cells and objects on the current layer with a new randomly generated dungeon.</p>
                  <p className="dmt-reroll-warning">This action cannot be undone.</p>
                  <div className="dmt-reroll-confirm-buttons">
                    <button className="dmt-btn dmt-btn-secondary" onClick={handleCancel}>
                      Cancel
                    </button>
                    <button className="dmt-btn dmt-btn-primary" onClick={handleRerollAll}>
                      Re-roll
                    </button>
                  </div>
                </>
              )}
            </div>
          </div>
        </ModalPortal>
      )}
    </>
  );
};

return { RerollDungeonButton };

```

# usePanZoomCoordinator

```ts
/**
 * usePanZoomCoordinator.ts
 *
 * Coordinator hook that handles pan and zoom interactions:
 * - Mouse wheel zoom
 * - Space + drag pan
 * - Select tool drag pan (on empty space)
 * - Touch pinch-to-zoom
 * - Touch two-finger pan
 * - Middle-click pan
 *
 * Registers pan/zoom handlers with EventHandlerContext for event coordination.
 * This is a coordinator hook, not a visual layer - it manages behavior without rendering.
 */

// Type-only imports
import type { MapData, ViewState } from '#types/core/map.types';
import type { IGeometry, Point } from '#types/core/geometry.types';
import type { UsePanZoomCoordinatorOptions } from '#types/hooks/panZoomCoordinator.types';
import type { UseCanvasInteractionResult } from '#types/hooks/canvasInteraction.types';
import type { PanZoomHandlers } from '#types/hooks/eventCoordinator.types';

// Datacore imports
const { useCanvasInteraction } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useCanvasInteraction")) as {
  useCanvasInteraction: (
    canvasRef: React.RefObject<HTMLCanvasElement>,
    mapData: MapData | null,
    geometry: IGeometry | null,
    onViewStateChange: ((viewState: ViewState) => void) | null,
    isFocused: boolean
  ) => UseCanvasInteractionResult;
};

const { useEventHandlerRegistration } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "EventHandlerContext")) as {
  useEventHandlerRegistration: () => {
    registerHandlers: (layer: string, handlers: Record<string, unknown>) => void;
    unregisterHandlers: (layer: string) => void;
  };
};

const { useMapOperations } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext")) as {
  useMapOperations: () => {
    onMapDataUpdate: ((updates: { viewState?: ViewState }) => void) | null;
  };
};

/**
 * Coordinator hook for pan/zoom interactions
 */
const usePanZoomCoordinator = ({
  canvasRef,
  mapData,
  geometry,
  isFocused
}: UsePanZoomCoordinatorOptions): void => {
  // Get onMapDataUpdate from context to handle viewState changes
  const { onMapDataUpdate } = useMapOperations();

  // Create local callback for viewState changes
  const handleViewStateChange = dc.useCallback((newViewState: ViewState) => {
    if (onMapDataUpdate) {
      onMapDataUpdate({ viewState: newViewState });
    }
  }, [onMapDataUpdate]);

  // Use canvas interaction hook for pan/zoom logic
  const {
    isPanning,
    isTouchPanning,
    panStart,
    touchPanStart,
    spaceKeyPressed,
    initialPinchDistance,
    lastTouchTimeRef,
    getClientCoords,
    getTouchCenter,
    getTouchDistance,
    screenToGrid,
    screenToWorld,
    handleWheel,
    startPan,
    updatePan,
    stopPan,
    startTouchPan,
    updateTouchPan,
    stopTouchPan,
    setIsPanning,
    setIsTouchPanning,
    setPanStart,
    setTouchPanStart,
    setInitialPinchDistance,
    setSpaceKeyPressed
  } = useCanvasInteraction(canvasRef, mapData, geometry, handleViewStateChange, isFocused);

  // Register pan/zoom handlers with EventHandlerContext for event coordination
  const { registerHandlers, unregisterHandlers } = useEventHandlerRegistration();

  // Register pan/zoom handlers and state when they change
  dc.useEffect(() => {
    registerHandlers('panZoom', {
      // Pan handlers
      startPan,
      updatePan,
      stopPan,
      // Touch pan handlers
      startTouchPan,
      updateTouchPan,
      stopTouchPan,
      // Zoom handler
      handleWheel,
      // Helper functions
      getClientCoords,
      getTouchCenter,
      getTouchDistance,
      screenToGrid,
      // State for coordination
      isPanning,
      isTouchPanning,
      panStart,
      touchPanStart,
      spaceKeyPressed,
      lastTouchTimeRef,
      initialPinchDistance,
      // State setters (for coordination layer to manage state)
      setIsPanning,
      setIsTouchPanning,
      setPanStart,
      setTouchPanStart,
      setInitialPinchDistance
    });

    return () => unregisterHandlers('panZoom');
  }, [
    registerHandlers, unregisterHandlers,
    startPan, updatePan, stopPan,
    startTouchPan, updateTouchPan, stopTouchPan,
    handleWheel,
    getClientCoords, getTouchCenter, getTouchDistance, screenToGrid,
    isPanning, isTouchPanning, panStart, touchPanStart, spaceKeyPressed, initialPinchDistance,
    setIsPanning, setIsTouchPanning, setPanStart, setTouchPanStart, setInitialPinchDistance
  ]);

  // Coordinator hooks don't return anything - they just set up behavior
};

// Datacore export
return { usePanZoomCoordinator };

```

# useGroupDrag

```ts
/**
 * useGroupDrag.ts
 *
 * Custom hook for managing group drag operations during multi-select.
 * Handles dragging multiple objects and text labels together as a group.
 *
 * Features:
 * - Stores position offsets for all selected items when drag starts
 * - Applies movement delta to all items during drag
 * - Validates all positions (blocks move if any item would go out of bounds)
 * - Creates single history entry for the entire group move
 */

// Type-only imports
import type { Point, IGeometry } from '#types/core/geometry.types';
import type { MapData, MapLayer } from '#types/core/map.types';
import type { MapObject } from '#types/objects/object.types';
import type { TextLabel } from '#types/core/textLabel.types';
import type {
  SelectedItem,
  DragOffset,
  DragOffsetsMap,
  GroupDragInitialState,
  ObjectDragUpdate,
  TextDragUpdate,
  PositionUpdate,
  UseGroupDragResult,
} from '#types/hooks/groupDrag.types';

// Datacore imports
// Context types
interface MapStateValue {
  geometry: (IGeometry & { isWithinBounds?: (x: number, y: number) => boolean }) | null;
  mapData: MapData | null;
  screenToGrid: (clientX: number, clientY: number) => Point | null;
  screenToWorld: (clientX: number, clientY: number) => { worldX: number; worldY: number } | null;
  getClientCoords: (e: PointerEvent | MouseEvent | TouchEvent) => { clientX: number; clientY: number };
}

interface MapOperationsValue {
  onObjectsChange: (objects: MapObject[], skipHistory?: boolean) => void;
  onTextLabelsChange: (labels: TextLabel[], skipHistory?: boolean) => void;
}

interface DragStart {
  x: number;
  y: number;
  gridX: number;
  gridY: number;
  worldX: number;
  worldY: number;
  isGroupDrag?: boolean;
}

interface MapSelectionValue {
  selectedItems: SelectedItem[];
  hasMultiSelection: boolean;
  isSelected: (type: string, id: string) => boolean;
  updateSelectedItemsData: (updates: PositionUpdate[]) => void;
  isDraggingSelection: boolean;
  setIsDraggingSelection: (value: boolean) => void;
  dragStart: DragStart | null;
  setDragStart: (value: DragStart | null) => void;
  groupDragOffsetsRef: { current: DragOffsetsMap };
  groupDragInitialStateRef: { current: GroupDragInitialState | null };
  isGroupDragging: boolean;
}

const { useMapState, useMapOperations } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext")) as {
  useMapState: () => MapStateValue;
  useMapOperations: () => MapOperationsValue;
};

const { useMapSelection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSelectionContext")) as {
  useMapSelection: () => MapSelectionValue;
};

const { getActiveLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor")) as {
  getActiveLayer: (mapData: MapData) => MapLayer;
};

const { HexGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "HexGeometry")) as {
  HexGeometry: unknown;
};

const { getObjectsInCell, assignSlot } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "hexSlotPositioner")) as {
  getObjectsInCell: unknown;
  assignSlot: unknown;
};

/**
 * Hook for managing group drag operations
 */
const useGroupDrag = (): UseGroupDragResult => {
  const {
    geometry,
    mapData,
    screenToGrid,
    screenToWorld,
    getClientCoords
  } = useMapState();

  const {
    onObjectsChange,
    onTextLabelsChange
  } = useMapOperations();

  const {
    selectedItems,
    hasMultiSelection,
    isSelected,
    updateSelectedItemsData,
    isDraggingSelection,
    setIsDraggingSelection,
    dragStart,
    setDragStart,
    groupDragOffsetsRef,
    groupDragInitialStateRef,
    isGroupDragging
  } = useMapSelection();

  const getClickedSelectedItem = dc.useCallback((
    x: number,
    y: number,
    worldX: number,
    worldY: number
  ): SelectedItem | null => {
    if (!hasMultiSelection || !mapData) {
      return null;
    }

    const activeLayer = getActiveLayer(mapData);

    for (const item of selectedItems) {
      if (item.type === 'object') {
        const obj = activeLayer.objects?.find((o: MapObject) => o.id === item.id);
        if (obj) {
          const size = obj.size || { width: 1, height: 1 };
          if (x >= obj.position.x && x < obj.position.x + size.width &&
              y >= obj.position.y && y < obj.position.y + size.height) {
            return item;
          }
        }
      } else if (item.type === 'text') {
        const label = activeLayer.textLabels?.find((l: TextLabel) => l.id === item.id);
        if (label) {
          const labelWorldX = label.position.x;
          const labelWorldY = label.position.y;
          const hitRadius = (label.fontSize || 16) * 2;
          const dx = worldX - labelWorldX;
          const dy = worldY - labelWorldY;
          if (Math.abs(dx) < hitRadius && Math.abs(dy) < hitRadius) {
            return item;
          }
        }
      }
    }

    return null;
  }, [hasMultiSelection, selectedItems, mapData]);

  const startGroupDrag = dc.useCallback((
    clientX: number,
    clientY: number,
    gridX: number,
    gridY: number
  ): boolean => {
    if (!hasMultiSelection || !mapData) {
      return false;
    }

    const worldCoords = screenToWorld(clientX, clientY);
    if (!worldCoords) return false;

    const activeLayer = getActiveLayer(mapData);

    groupDragInitialStateRef.current = {
      objects: [...(activeLayer.objects || [])],
      textLabels: [...(activeLayer.textLabels || [])]
    };

    const offsets: DragOffsetsMap = new Map();

    for (const item of selectedItems) {
      if (item.type === 'object') {
        const obj = activeLayer.objects?.find((o: MapObject) => o.id === item.id);
        if (obj) {
          offsets.set(item.id, {
            type: 'object',
            gridOffsetX: gridX - obj.position.x,
            gridOffsetY: gridY - obj.position.y,
            worldOffsetX: 0,
            worldOffsetY: 0
          });
        }
      } else if (item.type === 'text') {
        const label = activeLayer.textLabels?.find((l: TextLabel) => l.id === item.id);
        if (label) {
          offsets.set(item.id, {
            type: 'text',
            gridOffsetX: 0,
            gridOffsetY: 0,
            worldOffsetX: worldCoords.worldX - label.position.x,
            worldOffsetY: worldCoords.worldY - label.position.y
          });
        }
      }
    }

    groupDragOffsetsRef.current = offsets;

    setIsDraggingSelection(true);
    setDragStart({
      x: clientX,
      y: clientY,
      gridX,
      gridY,
      worldX: worldCoords.worldX,
      worldY: worldCoords.worldY,
      isGroupDrag: true
    });

    return true;
  }, [hasMultiSelection, selectedItems, mapData, screenToWorld, setIsDraggingSelection, setDragStart]);

  const handleGroupDrag = dc.useCallback((e: PointerEvent | MouseEvent | TouchEvent): boolean => {
    if (!isDraggingSelection || !dragStart?.isGroupDrag || !mapData) {
      return false;
    }

    const { clientX, clientY } = getClientCoords(e);
    const gridCoords = screenToGrid(clientX, clientY);
    const worldCoords = screenToWorld(clientX, clientY);

    if (!gridCoords || !worldCoords) return true;

    const { x, y } = gridCoords;
    const gridX = x;
    const gridY = y;
    const { worldX, worldY } = worldCoords;

    const gridDeltaX = x - dragStart.gridX;
    const gridDeltaY = y - dragStart.gridY;
    const worldDeltaX = worldX - dragStart.worldX;
    const worldDeltaY = worldY - dragStart.worldY;

    if (gridDeltaX === 0 && gridDeltaY === 0 && worldDeltaX === 0 && worldDeltaY === 0) {
      return true;
    }

    const activeLayer = getActiveLayer(mapData);
    const offsets = groupDragOffsetsRef.current;

    const objectUpdates: ObjectDragUpdate[] = [];
    const textUpdates: TextDragUpdate[] = [];

    for (const item of selectedItems) {
      const offset = offsets.get(item.id);
      if (!offset) continue;

      if (item.type === 'object') {
        const obj = activeLayer.objects?.find((o: MapObject) => o.id === item.id);
        if (obj) {
          const newX = gridX - offset.gridOffsetX;
          const newY = gridY - offset.gridOffsetY;
          objectUpdates.push({
            id: item.id,
            oldObj: obj,
            newPosition: { x: newX, y: newY }
          });
        }
      } else if (item.type === 'text') {
        const label = activeLayer.textLabels?.find((l: TextLabel) => l.id === item.id);
        if (label) {
          const newX = worldX - offset.worldOffsetX;
          const newY = worldY - offset.worldOffsetY;
          textUpdates.push({
            id: item.id,
            oldLabel: label,
            newPosition: { x: newX, y: newY }
          });
        }
      }
    }

    if (geometry && geometry.isWithinBounds) {
      for (const update of objectUpdates) {
        if (!geometry.isWithinBounds(update.newPosition.x, update.newPosition.y)) {
          return true;
        }
      }
    }

    const selectedObjectIds = new Set(
      selectedItems.filter(item => item.type === 'object').map(item => item.id)
    );

    const nonSelectedObjects = (activeLayer.objects || []).filter(
      (obj: MapObject) => !selectedObjectIds.has(obj.id)
    );

    for (const update of objectUpdates) {
      const movingSize = update.oldObj.size || { width: 1, height: 1 };
      const movingMinX = update.newPosition.x;
      const movingMinY = update.newPosition.y;
      const movingMaxX = movingMinX + movingSize.width;
      const movingMaxY = movingMinY + movingSize.height;

      for (const staticObj of nonSelectedObjects) {
        const staticSize = staticObj.size || { width: 1, height: 1 };
        const staticMinX = staticObj.position.x;
        const staticMinY = staticObj.position.y;
        const staticMaxX = staticMinX + staticSize.width;
        const staticMaxY = staticMinY + staticSize.height;

        const overlapsX = movingMinX < staticMaxX && movingMaxX > staticMinX;
        const overlapsY = movingMinY < staticMaxY && movingMaxY > staticMinY;

        if (overlapsX && overlapsY) {
          return true;
        }
      }
    }

    if (objectUpdates.length > 0) {
      const updatedObjects = [...activeLayer.objects];

      for (const update of objectUpdates) {
        const idx = updatedObjects.findIndex((o: MapObject) => o.id === update.id);
        if (idx !== -1) {
          updatedObjects[idx] = {
            ...updatedObjects[idx],
            position: update.newPosition
          };
        }
      }

      onObjectsChange(updatedObjects, true);
    }

    if (textUpdates.length > 0) {
      const updatedLabels = [...activeLayer.textLabels];

      for (const update of textUpdates) {
        const idx = updatedLabels.findIndex((l: TextLabel) => l.id === update.id);
        if (idx !== -1) {
          updatedLabels[idx] = {
            ...updatedLabels[idx],
            position: update.newPosition
          };
        }
      }

      onTextLabelsChange(updatedLabels, true);
    }

    setDragStart({
      ...dragStart,
      gridX,
      gridY,
      worldX,
      worldY
    });

    const allUpdates: PositionUpdate[] = [
      ...objectUpdates.map(u => ({ id: u.id, position: u.newPosition })),
      ...textUpdates.map(u => ({ id: u.id, position: u.newPosition }))
    ];
    updateSelectedItemsData(allUpdates);

    return true;
  }, [isDraggingSelection, dragStart, mapData, geometry, selectedItems, getClientCoords,
      screenToGrid, screenToWorld, onObjectsChange, onTextLabelsChange, setDragStart, updateSelectedItemsData]);

  const stopGroupDrag = dc.useCallback((): boolean => {
    if (!isDraggingSelection || !dragStart?.isGroupDrag) {
      return false;
    }

    setIsDraggingSelection(false);
    setDragStart(null);

    if (groupDragInitialStateRef.current !== null) {
      const activeLayer = getActiveLayer(mapData!);

      if (activeLayer.objects) {
        onObjectsChange(activeLayer.objects, false);
      }

      if (activeLayer.textLabels) {
        onTextLabelsChange(activeLayer.textLabels, false);
      }

      groupDragInitialStateRef.current = null;
    }

    groupDragOffsetsRef.current = new Map();

    return true;
  }, [isDraggingSelection, dragStart, mapData, setIsDraggingSelection, setDragStart, onObjectsChange, onTextLabelsChange]);

  return {
    isGroupDragging,
    getClickedSelectedItem,
    startGroupDrag,
    handleGroupDrag,
    stopGroupDrag
  };
};

return { useGroupDrag };

```

# useEventCoordinator

```ts
/**
 * useEventCoordinator.ts
 *
 * Coordinator hook that manages pointer event coordination across all interaction layers.
 * Attaches event listeners to canvas and routes events to registered handlers
 * based on current tool, modifier keys, touch state, and selection state.
 *
 * This is a coordinator hook, not a visual layer - it manages behavior without rendering.
 */

// Type-only imports
import type { Point, IGeometry } from '#types/core/geometry.types';
import type { MapData } from '#types/core/map.types';
import type { ToolId } from '#types/tools/tool.types';
import type {
  UseEventCoordinatorOptions,
  SyntheticPointerEvent,
  PendingToolAction,
  PanStartPosition,
  AreaSelectPending,
  DrawingHandlers,
  ObjectHandlers,
  TextHandlers,
  NotePinHandlers,
  PanZoomHandlers,
  MeasureHandlers,
  AlignmentHandlers,
  FogHandlers,
  AreaSelectHandlers,
  DiagonalFillHandlers,
  HandlerLayerName,
} from '#types/hooks/eventCoordinator.types';
import type { SelectedItem } from '#types/hooks/groupDrag.types';

// Datacore imports
// Context types
interface LayerVisibility {
  objects: boolean;
  textLabels: boolean;
  [key: string]: boolean;
}

interface DragStart {
  x: number;
  y: number;
  gridX: number;
  gridY: number;
  worldX: number;
  worldY: number;
  isGroupDrag?: boolean;
}

interface MapStateValue {
  canvasRef: { current: HTMLCanvasElement | null };
  currentTool: ToolId;
  screenToGrid: (clientX: number, clientY: number) => Point | null;
  screenToWorld: (clientX: number, clientY: number) => { worldX: number; worldY: number } | null;
  getClientCoords: (e: PointerEvent | MouseEvent | TouchEvent) => { clientX: number; clientY: number };
  geometry: (IGeometry & { cellSize: number }) | null;
}

interface MapSelectionValue {
  selectedItem: SelectedItem | null;
  setSelectedItem: (item: SelectedItem | null) => void;
  isDraggingSelection: boolean;
  setIsDraggingSelection: (value: boolean) => void;
  dragStart: DragStart | null;
  setDragStart: (value: DragStart | null) => void;
  layerVisibility: LayerVisibility;
  hasMultiSelection: boolean;
  isSelected: (type: string, id: string) => boolean;
  isGroupDragging: boolean;
  clearSelection: () => void;
}

interface RegisteredHandlersValue {
  getHandlers: (layer: HandlerLayerName) => unknown;
}

interface UseGroupDragResult {
  getClickedSelectedItem: (gridX: number, gridY: number, worldX: number, worldY: number) => SelectedItem | null;
  startGroupDrag: (clientX: number, clientY: number, gridX: number, gridY: number) => boolean;
  handleGroupDrag: (e: PointerEvent | MouseEvent | TouchEvent) => boolean;
  stopGroupDrag: () => boolean;
}

const { useMapState } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext")) as {
  useMapState: () => MapStateValue;
};

const { useMapSelection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSelectionContext")) as {
  useMapSelection: () => MapSelectionValue;
};

const { useRegisteredHandlers } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "EventHandlerContext")) as {
  useRegisteredHandlers: () => RegisteredHandlersValue;
};

const { useGroupDrag } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useGroupDrag")) as {
  useGroupDrag: () => UseGroupDragResult;
};

const useEventCoordinator = ({
  isColorPickerOpen,
  showObjectColorPicker = false,
  isAlignmentMode = false
}: UseEventCoordinatorOptions): void => {
  const { canvasRef, currentTool, screenToGrid, screenToWorld, getClientCoords, geometry } = useMapState();
  const { selectedItem, setSelectedItem, isDraggingSelection, setIsDraggingSelection, dragStart, setDragStart, layerVisibility, hasMultiSelection, isSelected, isGroupDragging, clearSelection } = useMapSelection();
  const { getHandlers } = useRegisteredHandlers();

  const { getClickedSelectedItem, startGroupDrag, handleGroupDrag, stopGroupDrag } = useGroupDrag();

  const [recentMultiTouch, setRecentMultiTouch] = dc.useState<boolean>(false);
  const [pendingToolAction, setPendingToolAction] = dc.useState<PendingToolAction | null>(null);
  const pendingToolTimeoutRef = dc.useRef<ReturnType<typeof setTimeout> | null>(null);

  const panStartPositionRef = dc.useRef<PanStartPosition | null>(null);
  const panMoveThreshold = 5;

  const areaSelectPendingRef = dc.useRef<AreaSelectPending | null>(null);

  const handlePointerDown = dc.useCallback((e: MouseEvent | TouchEvent): void => {
    const drawingHandlers = getHandlers('drawing') as DrawingHandlers | null;
    const objectHandlers = getHandlers('object') as ObjectHandlers | null;
    const textHandlers = getHandlers('text') as TextHandlers | null;
    const notePinHandlers = getHandlers('notePin') as NotePinHandlers | null;
    const panZoomHandlers = getHandlers('panZoom') as PanZoomHandlers | null;
    const measureHandlers = getHandlers('measure') as MeasureHandlers | null;
    const alignmentHandlers = getHandlers('imageAlignment') as AlignmentHandlers | null;
    const fogHandlers = getHandlers('fogOfWar') as FogHandlers | null;
    const diagonalFillHandlers = getHandlers('diagonalFill') as DiagonalFillHandlers | null;

    if (!panZoomHandlers) return;

    const touchEvent = e as TouchEvent;
    if (isAlignmentMode && (!touchEvent.touches || touchEvent.touches.length === 1)) {
      return;
    }

    const {
      getClientCoords: getCoords,
      screenToGrid: toGrid,
      lastTouchTimeRef,
      getTouchCenter,
      getTouchDistance,
      startPan,
      startTouchPan,
      setInitialPinchDistance,
      spaceKeyPressed
    } = panZoomHandlers;

    if (e.type === 'mousedown') {
      const timeSinceTouch = Date.now() - lastTouchTimeRef.current;
      if (timeSinceTouch < 500) {
        return;
      }
    }

    if (e.type === 'touchstart') {
      lastTouchTimeRef.current = Date.now();
    }

    if (isColorPickerOpen || showObjectColorPicker) {
      const target = e.target as HTMLElement;
      const pickerElement = target.closest('.dmt-color-picker');
      const toolBtnElement = target.closest('.dmt-color-tool-btn');
      const objectBtnElement = target.closest('.dmt-object-color-button');

      if (!pickerElement && !toolBtnElement && !objectBtnElement) {
        return;
      }
    }

    if (touchEvent.touches && touchEvent.touches.length === 2) {
      if (isColorPickerOpen || showObjectColorPicker) {
        const touch1Target = document.elementFromPoint(touchEvent.touches[0].clientX, touchEvent.touches[0].clientY);
        const touch2Target = document.elementFromPoint(touchEvent.touches[1].clientX, touchEvent.touches[1].clientY);

        const pickerOrButton1 = touch1Target?.closest('.dmt-color-picker, .dmt-color-tool-btn, .dmt-object-color-button');
        const pickerOrButton2 = touch2Target?.closest('.dmt-color-picker, .dmt-color-tool-btn, .dmt-object-color-button');

        if (pickerOrButton1 || pickerOrButton2) {
          return;
        }
      }

      e.preventDefault();
      e.stopPropagation();

      if (pendingToolTimeoutRef.current) {
        clearTimeout(pendingToolTimeoutRef.current);
        pendingToolTimeoutRef.current = null;
        setPendingToolAction(null);
      }

      setRecentMultiTouch(true);
      const center = getTouchCenter(touchEvent.touches);
      const distance = getTouchDistance(touchEvent.touches);
      if (center && distance) {
        startTouchPan(center);
        setInitialPinchDistance(distance);
      }
      return;
    }

    if (recentMultiTouch || panZoomHandlers.isTouchPanning) {
      return;
    }

    e.preventDefault();
    e.stopPropagation();

    const { clientX, clientY } = getCoords(e);
    const coords = toGrid(clientX, clientY);
    if (!coords) return;

    const gridX = coords.x;
    const gridY = coords.y;

    const eventType = e.type;
    const isTouchEvent = !!touchEvent.touches;
    const targetElement = e.target;

    const syntheticEvent: SyntheticPointerEvent = {
      type: eventType,
      clientX: clientX,
      clientY: clientY,
      button: (e as MouseEvent).button ?? 0,
      preventDefault: () => {},
      stopPropagation: () => {},
      target: targetElement
    };

    const executeToolAction = (): void => {
      if (spaceKeyPressed && !isTouchEvent) {
        panStartPositionRef.current = { x: clientX, y: clientY };
        startPan(clientX, clientY);
        return;
      }

      if (fogHandlers?.handlePointerDown) {
        fogHandlers.handlePointerDown(syntheticEvent);
        return;
      }

      if (currentTool === 'select') {
        if (hasMultiSelection) {
          const worldCoords = screenToWorld(clientX, clientY);
          if (worldCoords) {
            const clickedItem = getClickedSelectedItem(gridX, gridY, worldCoords.worldX, worldCoords.worldY);
            if (clickedItem) {
              startGroupDrag(clientX, clientY, gridX, gridY);
              return;
            }
          }
        }

        if (layerVisibility.objects && objectHandlers?.handleObjectSelection) {
          const objectHandled = objectHandlers.handleObjectSelection(clientX, clientY, gridX, gridY);
          if (objectHandled) return;
        }

        if (layerVisibility.textLabels && textHandlers?.handleTextSelection) {
          const textHandled = textHandlers.handleTextSelection(clientX, clientY);
          if (textHandled) return;
        }

        panStartPositionRef.current = { x: clientX, y: clientY };
        startPan(clientX, clientY);

      } else if (currentTool === 'areaSelect') {
        if (hasMultiSelection) {
          const worldCoords = screenToWorld(clientX, clientY);
          if (worldCoords) {
            const clickedItem = getClickedSelectedItem(gridX, gridY, worldCoords.worldX, worldCoords.worldY);
            if (clickedItem) {
              startGroupDrag(clientX, clientY, gridX, gridY);
              return;
            }
          }
          clearSelection();
          return;
        }

        const areaSelectHandlers = getHandlers('areaSelect') as AreaSelectHandlers | null;
        if (areaSelectHandlers?.areaSelectStart) {
          if (areaSelectHandlers.handleAreaSelectClick) {
            areaSelectHandlers.handleAreaSelectClick(syntheticEvent);
          }
          return;
        }

        if (layerVisibility.objects && objectHandlers?.handleObjectSelection) {
          const objectHandled = objectHandlers.handleObjectSelection(clientX, clientY, gridX, gridY);
          if (objectHandled) return;
        }

        if (layerVisibility.textLabels && textHandlers?.handleTextSelection) {
          const textHandled = textHandlers.handleTextSelection(clientX, clientY);
          if (textHandled) return;
        }

        panStartPositionRef.current = { x: clientX, y: clientY };
        areaSelectPendingRef.current = { clientX, clientY, syntheticEvent };
        startPan(clientX, clientY);

      } else if (currentTool === 'draw' || currentTool === 'erase' ||
                 currentTool === 'rectangle' || currentTool === 'circle' ||
                 currentTool === 'clearArea' ||
                 currentTool === 'edgeDraw' || currentTool === 'edgeErase' ||
                 currentTool === 'edgeLine' || currentTool === 'segmentDraw' ||
                 currentTool === 'freehandDraw') {
        if (hasMultiSelection) clearSelection();

        if (drawingHandlers?.handleDrawingPointerDown) {
          const eventToUse = isTouchEvent ? syntheticEvent : e;
          drawingHandlers.handleDrawingPointerDown(eventToUse, gridX, gridY, isTouchEvent);
        }

      } else if (currentTool === 'addObject') {
        if (hasMultiSelection) clearSelection();

        if (!layerVisibility.objects) return;

        if (notePinHandlers?.handleNotePinPlacement) {
          const notePinHandled = notePinHandlers.handleNotePinPlacement(gridX, gridY);
          if (notePinHandled) return;
        }

        if (objectHandlers?.handleObjectPlacement) {
          objectHandlers.handleObjectPlacement(gridX, gridY, clientX, clientY);
        }

      } else if (currentTool === 'addText') {
        if (hasMultiSelection) clearSelection();

        if (!layerVisibility.textLabels) return;

        if (textHandlers?.handleTextPlacement) {
          textHandlers.handleTextPlacement(clientX, clientY);
        }

      } else if (currentTool === 'measure') {
        if (hasMultiSelection) clearSelection();

        if (measureHandlers?.handleMeasureClick) {
          measureHandlers.handleMeasureClick(gridX, gridY, isTouchEvent);
        }

      } else if (currentTool === 'diagonalFill') {
        if (hasMultiSelection) clearSelection();

        if (diagonalFillHandlers?.handleDiagonalFillClick) {
          diagonalFillHandlers.handleDiagonalFillClick(e, isTouchEvent);
        }
      }
    };

    if (isTouchEvent) {
      setPendingToolAction({ execute: executeToolAction });
      pendingToolTimeoutRef.current = setTimeout(() => {
        executeToolAction();
        setPendingToolAction(null);
        pendingToolTimeoutRef.current = null;
      }, 50);
    } else {
      executeToolAction();
    }
  }, [currentTool, isColorPickerOpen, showObjectColorPicker, recentMultiTouch, selectedItem, hasMultiSelection, clearSelection, screenToWorld, getClickedSelectedItem, startGroupDrag, getHandlers, layerVisibility, isAlignmentMode]);

  const handlePointerMove = dc.useCallback((e: MouseEvent | TouchEvent): void => {
    const drawingHandlers = getHandlers('drawing') as DrawingHandlers | null;
    const objectHandlers = getHandlers('object') as ObjectHandlers | null;
    const textHandlers = getHandlers('text') as TextHandlers | null;
    const panZoomHandlers = getHandlers('panZoom') as PanZoomHandlers | null;
    const measureHandlers = getHandlers('measure') as MeasureHandlers | null;
    const alignmentHandlers = getHandlers('imageAlignment') as AlignmentHandlers | null;
    const fogHandlers = getHandlers('fogOfWar') as FogHandlers | null;
    const diagonalFillHandlers = getHandlers('diagonalFill') as DiagonalFillHandlers | null;

    if (!panZoomHandlers) return;

    const touchEvent = e as TouchEvent;
    if (isAlignmentMode && (!touchEvent.touches || touchEvent.touches.length !== 2)) {
      return;
    }

    const {
      getClientCoords: getCoords,
      isTouchPanning,
      updateTouchPan,
      isPanning,
      updatePan,
      panStart,
      touchPanStart,
      screenToGrid: toGrid
    } = panZoomHandlers;

    const { clientX, clientY } = getCoords(e);

    if (touchEvent.touches && touchEvent.touches.length === 2 && isTouchPanning && touchPanStart) {
      if (pendingToolTimeoutRef.current) {
        clearTimeout(pendingToolTimeoutRef.current);
        pendingToolTimeoutRef.current = null;
        setPendingToolAction(null);
      }
      e.preventDefault();
      e.stopPropagation();
      updateTouchPan(touchEvent.touches);
      return;
    }

    if (isPanning && panStart) {
      e.preventDefault();
      updatePan(clientX, clientY);
      return;
    }

    if (touchEvent.touches && touchEvent.touches.length > 1) {
      if (pendingToolTimeoutRef.current) {
        clearTimeout(pendingToolTimeoutRef.current);
        pendingToolTimeoutRef.current = null;
        setPendingToolAction(null);
      }
    }

    if (layerVisibility.objects && objectHandlers?.isResizing && selectedItem?.type === 'object') {
      if (objectHandlers.handleObjectResizing) {
        objectHandlers.handleObjectResizing(e);
      }
      return;
    }

    if (isDraggingSelection && dragStart?.isGroupDrag) {
      handleGroupDrag(e as PointerEvent);
      return;
    }

    if (isDraggingSelection && selectedItem) {
      if (selectedItem.type === 'object' && layerVisibility.objects && objectHandlers?.handleObjectDragging) {
        objectHandlers.handleObjectDragging(e);
      } else if (selectedItem.type === 'text' && layerVisibility.textLabels && textHandlers?.handleTextDragging) {
        textHandlers.handleTextDragging(e);
      }
      return;
    }

    if (fogHandlers?.handlePointerMove) {
      fogHandlers.handlePointerMove(e);
    }

    if (currentTool === 'draw' || currentTool === 'erase' ||
        currentTool === 'rectangle' || currentTool === 'circle' ||
        currentTool === 'clearArea' ||
        currentTool === 'edgeDraw' || currentTool === 'edgeErase' ||
        currentTool === 'edgeLine' || currentTool === 'segmentDraw' ||
        currentTool === 'freehandDraw') {

      if (drawingHandlers?.handleDrawingPointerMove) {
        drawingHandlers.handleDrawingPointerMove(e);
      }

      const isTouch = touchEvent.touches !== undefined || (e as PointerEvent).pointerType === 'touch';
      if (!isTouch && drawingHandlers?.previewEnabled && drawingHandlers?.updateShapeHover) {

        if (currentTool === 'edgeLine' && drawingHandlers.edgeLineStart && panZoomHandlers.screenToWorld) {
          const worldCoords = panZoomHandlers.screenToWorld(clientX, clientY);
          if (worldCoords && geometry) {
            const cellSize = geometry.cellSize;
            const nearestX = Math.round(worldCoords.worldX / cellSize);
            const nearestY = Math.round(worldCoords.worldY / cellSize);
            if (drawingHandlers.updateEdgeLineHover) {
              drawingHandlers.updateEdgeLineHover(nearestX, nearestY);
            }
          }
        }
        else if ((currentTool === 'rectangle' || currentTool === 'clearArea' || currentTool === 'circle') && toGrid) {
          const hasStart = (currentTool === 'circle' && drawingHandlers.circleStart) ||
                           ((currentTool === 'rectangle' || currentTool === 'clearArea') && drawingHandlers.rectangleStart);
          if (hasStart) {
            const coords = toGrid(clientX, clientY);
            if (coords) {
              const gridX = coords.x;
              const gridY = coords.y;
              drawingHandlers.updateShapeHover(gridX, gridY);
            }
          }
        }
      }

      if (!isTouch && currentTool === 'segmentDraw' && drawingHandlers?.updateSegmentHover) {
        if (screenToWorld && geometry) {
          const worldCoords = screenToWorld(clientX, clientY);
          if (worldCoords) {
            const cellSize = geometry.cellSize;
            const cellX = Math.floor(worldCoords.worldX / cellSize);
            const cellY = Math.floor(worldCoords.worldY / cellSize);
            const localX = (worldCoords.worldX / cellSize) - cellX;
            const localY = (worldCoords.worldY / cellSize) - cellY;
            drawingHandlers.updateSegmentHover(cellX, cellY, localX, localY);
          }
        }
      }

      if (layerVisibility.objects && objectHandlers?.handleHoverUpdate) {
        objectHandlers.handleHoverUpdate(e);
      }
      return;
    }

    if (currentTool === 'measure' && measureHandlers?.handleMeasureMove) {
      if (toGrid) {
        const coords = toGrid(clientX, clientY);
        if (coords) {
          const gridX = coords.x;
          const gridY = coords.y;
          measureHandlers.handleMeasureMove(gridX, gridY);
        }
      }
      return;
    }

    if (currentTool === 'diagonalFill' && diagonalFillHandlers?.handleDiagonalFillMove) {
      diagonalFillHandlers.handleDiagonalFillMove(e as MouseEvent);
      return;
    }

    if (layerVisibility.objects && objectHandlers?.handleHoverUpdate) {
      objectHandlers.handleHoverUpdate(e);
    }
  }, [currentTool, isDraggingSelection, dragStart, selectedItem, isGroupDragging, handleGroupDrag, getHandlers, layerVisibility, isAlignmentMode, geometry, screenToWorld]);

  const handlePointerUp = dc.useCallback((e: MouseEvent | TouchEvent): void => {
    const drawingHandlers = getHandlers('drawing') as DrawingHandlers | null;
    const objectHandlers = getHandlers('object') as ObjectHandlers | null;
    const textHandlers = getHandlers('text') as TextHandlers | null;
    const panZoomHandlers = getHandlers('panZoom') as PanZoomHandlers | null;
    const alignmentHandlers = getHandlers('imageAlignment') as AlignmentHandlers | null;
    const fogHandlers = getHandlers('fogOfWar') as FogHandlers | null;

    if (!panZoomHandlers) return;

    if (isAlignmentMode) {
      return;
    }

    const {
      getClientCoords: getCoords,
      stopPan,
      isPanning
    } = panZoomHandlers;

    if (recentMultiTouch) {
      setTimeout(() => setRecentMultiTouch(false), 300);
    }

    if (isPanning) {
      stopPan();

      if (currentTool === 'select' && panStartPositionRef.current) {
        const { clientX, clientY } = getCoords(e);
        const deltaX = Math.abs(clientX - panStartPositionRef.current.x);
        const deltaY = Math.abs(clientY - panStartPositionRef.current.y);

        if (deltaX < panMoveThreshold && deltaY < panMoveThreshold && selectedItem) {
          if (selectedItem.type === 'object' && objectHandlers?.edgeSnapMode) {
            objectHandlers.setEdgeSnapMode?.(false);
          } else {
            setSelectedItem(null);
          }
        }

        panStartPositionRef.current = null;
      }

      if (currentTool === 'areaSelect' && areaSelectPendingRef.current) {
        const { clientX, clientY } = getCoords(e);
        const deltaX = Math.abs(clientX - areaSelectPendingRef.current.clientX);
        const deltaY = Math.abs(clientY - areaSelectPendingRef.current.clientY);

        if (deltaX < panMoveThreshold && deltaY < panMoveThreshold) {
          const areaSelectHandlers = getHandlers('areaSelect') as AreaSelectHandlers | null;
          if (areaSelectHandlers?.handleAreaSelectClick) {
            areaSelectHandlers.handleAreaSelectClick(areaSelectPendingRef.current.syntheticEvent);
          }
        }

        areaSelectPendingRef.current = null;
        panStartPositionRef.current = null;
      }

      return;
    }

    if (objectHandlers?.isResizing && selectedItem?.type === 'object') {
      if (objectHandlers.stopObjectResizing) {
        objectHandlers.stopObjectResizing();
      }
      return;
    }

    if (isDraggingSelection && dragStart?.isGroupDrag) {
      stopGroupDrag();
      return;
    }

    if (isDraggingSelection) {
      if (selectedItem?.type === 'object' && objectHandlers?.stopObjectDragging) {
        objectHandlers.stopObjectDragging();
      } else if (selectedItem?.type === 'text' && textHandlers?.stopTextDragging) {
        textHandlers.stopTextDragging();
      }
      return;
    }

    if (currentTool === 'draw' || currentTool === 'erase' ||
        currentTool === 'rectangle' || currentTool === 'circle' ||
        currentTool === 'clearArea' ||
        currentTool === 'edgeDraw' || currentTool === 'edgeErase' ||
        currentTool === 'edgeLine' || currentTool === 'segmentDraw' ||
        currentTool === 'freehandDraw') {
      if (drawingHandlers?.stopDrawing) {
        drawingHandlers.stopDrawing(e);
      }
    }

    if (fogHandlers?.handlePointerUp) {
      fogHandlers.handlePointerUp(e);
    }
  }, [currentTool, recentMultiTouch, isDraggingSelection, dragStart, selectedItem, setSelectedItem, isGroupDragging, stopGroupDrag, getHandlers, isAlignmentMode]);

  const handlePointerLeave = dc.useCallback((e: MouseEvent): void => {
    const drawingHandlers = getHandlers('drawing') as DrawingHandlers | null;
    const diagonalFillHandlers = getHandlers('diagonalFill') as DiagonalFillHandlers | null;

    if (pendingToolTimeoutRef.current) {
      clearTimeout(pendingToolTimeoutRef.current);
      pendingToolTimeoutRef.current = null;
      setPendingToolAction(null);
    }

    if (currentTool === 'draw' || currentTool === 'erase' ||
        currentTool === 'rectangle' || currentTool === 'circle' ||
        currentTool === 'clearArea' ||
        currentTool === 'edgeDraw' || currentTool === 'edgeErase' ||
        currentTool === 'edgeLine' || currentTool === 'segmentDraw' ||
        currentTool === 'freehandDraw') {
      if (drawingHandlers?.cancelDrawing) {
        drawingHandlers.cancelDrawing();
      }
    }

    if (currentTool === 'diagonalFill' && diagonalFillHandlers?.cancelFill) {
      diagonalFillHandlers.cancelFill();
    }
  }, [currentTool, getHandlers]);

  const handlePanStart = dc.useCallback((e: MouseEvent): void => {
    const panZoomHandlers = getHandlers('panZoom') as PanZoomHandlers | null;
    if (!panZoomHandlers) return;

    if (e.button === 1) {
      e.preventDefault();
      panZoomHandlers.startPan(e.clientX, e.clientY);
    }
  }, [getHandlers]);

  const handlePanEnd = dc.useCallback((e: MouseEvent): void => {
    const panZoomHandlers = getHandlers('panZoom') as PanZoomHandlers | null;
    if (!panZoomHandlers) return;

    if (panZoomHandlers.isPanning && e.button === 1) {
      e.preventDefault();
      panZoomHandlers.stopPan();
    }
  }, [getHandlers]);

  const handleWheel = dc.useCallback((e: WheelEvent): void => {
    const objectHandlers = getHandlers('object') as ObjectHandlers | null;
    if (objectHandlers?.handleObjectWheel) {
      const handled = objectHandlers.handleObjectWheel(e);
      if (handled) return;
    }

    const panZoomHandlers = getHandlers('panZoom') as PanZoomHandlers | null;
    if (!panZoomHandlers?.handleWheel) return;

    if (panZoomHandlers.isPanning) {
      return;
    }

    panZoomHandlers.handleWheel(e);
  }, [getHandlers]);

  const handleCanvasDoubleClick = dc.useCallback((e: MouseEvent): void => {
    const textHandlers = getHandlers('text') as TextHandlers | null;
    if (!textHandlers?.handleCanvasDoubleClick) return;

    textHandlers.handleCanvasDoubleClick(e);
  }, [getHandlers]);

  const handleContextMenu = dc.useCallback((e: MouseEvent): void => {
    e.preventDefault();
    const drawingHandlers = getHandlers('drawing') as DrawingHandlers | null;
    if (drawingHandlers?.cancelShapePreview) {
      drawingHandlers.cancelShapePreview();
    }
  }, [getHandlers]);

  dc.useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const handleMouseDown = (e: MouseEvent): void => {
      if (e.button === 1) {
        handlePanStart(e);
      } else {
        handlePointerDown(e);
      }
    };

    const handleMouseUp = (e: MouseEvent): void => {
      handlePanEnd(e);
      handlePointerUp(e);
    };

    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('touchstart', handlePointerDown as EventListener);
    canvas.addEventListener('mousemove', handlePointerMove as EventListener);
    canvas.addEventListener('touchmove', handlePointerMove as EventListener);
    canvas.addEventListener('touchend', handlePointerUp as EventListener);
    canvas.addEventListener('mouseleave', handlePointerLeave);
    canvas.addEventListener('wheel', handleWheel);
    canvas.addEventListener('dblclick', handleCanvasDoubleClick);
    canvas.addEventListener('contextmenu', handleContextMenu);

    return () => {
      canvas.removeEventListener('mousedown', handleMouseDown);
      canvas.removeEventListener('mouseup', handleMouseUp);
      canvas.removeEventListener('touchstart', handlePointerDown as EventListener);
      canvas.removeEventListener('mousemove', handlePointerMove as EventListener);
      canvas.removeEventListener('touchmove', handlePointerMove as EventListener);
      canvas.removeEventListener('touchend', handlePointerUp as EventListener);
      canvas.removeEventListener('mouseleave', handlePointerLeave);
      canvas.removeEventListener('wheel', handleWheel);
      canvas.removeEventListener('dblclick', handleCanvasDoubleClick);
      canvas.removeEventListener('contextmenu', handleContextMenu);
    };
  }, [
    canvasRef,
    handlePointerDown,
    handlePointerMove,
    handlePointerUp,
    handlePointerLeave,
    handlePanStart,
    handlePanEnd,
    handleWheel,
    handleCanvasDoubleClick,
    handleContextMenu
  ]);

  dc.useEffect(() => {
    const handleGlobalPointerUp = (e: MouseEvent | TouchEvent): void => {
      const drawingHandlers = getHandlers('drawing') as DrawingHandlers | null;
      const objectHandlers = getHandlers('object') as ObjectHandlers | null;
      const textHandlers = getHandlers('text') as TextHandlers | null;
      const panZoomHandlers = getHandlers('panZoom') as PanZoomHandlers | null;

      if ((drawingHandlers?.isDrawing || drawingHandlers?.isFreehandDrawing) && drawingHandlers?.stopDrawing) {
        drawingHandlers.stopDrawing();
      }

      if (panZoomHandlers?.isPanning && (e as MouseEvent).button === 1) {
        panZoomHandlers.stopPan();
      }

      if (panZoomHandlers?.isTouchPanning) {
        panZoomHandlers.stopTouchPan();
        setTimeout(() => setRecentMultiTouch(false), 100);
      }

      if (objectHandlers?.stopObjectResizing) {
        objectHandlers.stopObjectResizing();
      }

      if (isDraggingSelection && dragStart?.isGroupDrag) {
        stopGroupDrag();
      }

      if (objectHandlers?.stopObjectDragging) {
        objectHandlers.stopObjectDragging();
      }

      if (textHandlers?.stopTextDragging) {
        textHandlers.stopTextDragging();
      }

      if (isDraggingSelection) {
        setIsDraggingSelection(false);
        setDragStart(null);
      }
    };

    const handleGlobalMouseMove = (e: MouseEvent): void => {
      const panZoomHandlers = getHandlers('panZoom') as PanZoomHandlers | null;
      if (panZoomHandlers?.isPanning && panZoomHandlers?.updatePan) {
        panZoomHandlers.updatePan(e.clientX, e.clientY);
      }
    };

    window.addEventListener('mouseup', handleGlobalPointerUp);
    window.addEventListener('touchend', handleGlobalPointerUp as EventListener);
    window.addEventListener('mousemove', handleGlobalMouseMove);

    return () => {
      window.removeEventListener('mouseup', handleGlobalPointerUp);
      window.removeEventListener('touchend', handleGlobalPointerUp as EventListener);
      window.removeEventListener('mousemove', handleGlobalMouseMove);
    };
  }, [isDraggingSelection, dragStart, setIsDraggingSelection, setDragStart, isGroupDragging, stopGroupDrag, getHandlers]);

  dc.useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent): void => {
      const target = e.target as HTMLElement;
      if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
        return;
      }

      const objectHandlers = getHandlers('object') as ObjectHandlers | null;
      const textHandlers = getHandlers('text') as TextHandlers | null;

      if (objectHandlers?.handleObjectKeyDown) {
        const handled = objectHandlers.handleObjectKeyDown(e);
        if (handled) return;
      }

      if (textHandlers?.handleTextKeyDown) {
        const handled = textHandlers.handleTextKeyDown(e);
        if (handled) return;
      }
    };

    window.addEventListener('keydown', handleKeyDown);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [getHandlers]);

  dc.useEffect(() => {
    return () => {
      if (pendingToolTimeoutRef.current) {
        clearTimeout(pendingToolTimeoutRef.current);
      }
    };
  }, []);
};

return { useEventCoordinator };

```

# MapCanvas

```tsx
import type { ComponentChildren } from 'preact';
import type {
  MapData,
  Cell,
  MapObject,
  TextLabel,
  Edge,
  ViewState,
  TextLabelSettings,
  ToolId,
  ObjectTypeId,
  IGeometry,
  Point,
  LayerVisibility,
  SelectedItem,
} from '#types/index';
import type { ResolvedTheme } from '#types/settings/settings.types';

const { useCanvasRenderer, renderCanvas } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useCanvasRenderer"));
const { useCanvasInteraction } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useCanvasInteraction"));
const { GridGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "GridGeometry"));
const { DEFAULTS } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants"));
const { getObjectAtPosition, addObject, removeObject, removeObjectAtPosition, removeObjectsInRectangle, updateObject, isAreaFree, canResizeObject } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "objectOperations"));
const { addTextLabel, getTextLabelAtPosition, removeTextLabel, updateTextLabel } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "textLabelOperations"));
const { HexGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "HexGeometry"));
const { LinkedNoteHoverOverlays } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "LinkedNoteHoverOverlays"));
const { MapStateProvider, MapOperationsProvider } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapContext"));
const { MapSelectionProvider, useMapSelection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSelectionContext"));
const { ObjectLinkingProvider } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ObjectLinkingContext"));
const { ObjectLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ObjectLayer"));
const { DrawingLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "DrawingLayer"));
const { TextLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "TextLayer"));
const { NotePinLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "NotePinLayer"));
const { EventHandlerProvider } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "EventHandlerContext"));
const { HexCoordinateLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "HexCoordinateLayer"));
const { MeasurementLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MeasurementLayer"));
const { DiagonalFillOverlay } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "DiagonalFillOverlay"));
const { AreaSelectLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "AreaSelectLayer"));
const { FogOfWarLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "FogOfWarLayer"));
const { RerollDungeonButton } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "RerollDungeonButton"));
const { getSetting } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsAccessor"));
const { usePanZoomCoordinator } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "usePanZoomCoordinator"));
const { useEventCoordinator } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useEventCoordinator"));

// ===========================================
// Local Type Definitions
// ===========================================

interface CanvasDimensions {
  width: number;
  height: number;
}

interface DrawingLayerState {
  isDrawing: boolean;
  rectangleStart: Point | null;
  circleStart: Point | null;
}

interface PanZoomLayerState {
  isPanning: boolean;
  isTouchPanning: boolean;
  spaceKeyPressed: boolean;
}

interface CoordinatorsProps {
  canvasRef: React.RefObject<HTMLCanvasElement>;
  mapData: MapData | null;
  geometry: IGeometry | null;
  isFocused: boolean;
  isColorPickerOpen: boolean;
  isAlignmentMode: boolean;
}

interface MapCanvasContentProps {
  mapId?: string;
  notePath?: string;
  mapData: MapData | null;
  onCellsChange: (cells: Cell[], skipHistory?: boolean) => void;
  onObjectsChange: (objects: MapObject[]) => void;
  onTextLabelsChange: (labels: TextLabel[]) => void;
  onEdgesChange: (edges: Edge[], skipHistory?: boolean) => void;
  onCurvesChange?: (curves: unknown[], skipHistory?: boolean) => void;
  onViewStateChange: (viewState: ViewState) => void;
  onTextLabelSettingsChange: (settings: TextLabelSettings) => void;
  currentTool: ToolId;
  selectedObjectType: ObjectTypeId | undefined;
  selectedColor: string;
  isColorPickerOpen: boolean;
  customColors: string[];
  onAddCustomColor: (color: string) => void;
  onDeleteCustomColor: (color: string) => void;
  isFocused: boolean;
  isAnimating: boolean;
  theme: ResolvedTheme;
  isAlignmentMode: boolean;
  children: ComponentChildren;
}

interface MapCanvasProps extends MapCanvasContentProps {
  layerVisibility: LayerVisibility;
}

interface MapDataUpdate {
  viewState?: ViewState;
  lastTextLabelSettings?: TextLabelSettings;
}

// ===========================================
// Components
// ===========================================

/**
 * Coordinators - Internal component that calls coordinator hooks
 * This component must be rendered inside the Context provider tree
 * so the hooks have access to MapState, MapSelection, and EventHandler contexts.
 * Returns null (no visual rendering) - only manages behavioral coordination.
 */
const Coordinators = ({ canvasRef, mapData, geometry, isFocused, isColorPickerOpen, isAlignmentMode }: CoordinatorsProps): null => {
  // Coordinator hooks need to be called inside the provider tree
  usePanZoomCoordinator({
    canvasRef,
    mapData,
    geometry,
    isFocused
  });

  useEventCoordinator({
    canvasRef,
    isColorPickerOpen,
    showObjectColorPicker: false,
    isAlignmentMode
  });

  return null; // No UI - coordinators only manage behavior
};

/**
 * MapCanvasContent - Inner component that uses context hooks
 * Contains all the map canvas logic and interacts with shared selection state
 */
const MapCanvasContent = ({ mapId, notePath, mapData, onCellsChange, onObjectsChange, onTextLabelsChange, onEdgesChange, onCurvesChange, onViewStateChange, onTextLabelSettingsChange, currentTool, selectedObjectType, selectedColor, isColorPickerOpen, customColors, onAddCustomColor, onDeleteCustomColor, isFocused, isAnimating, theme, isAlignmentMode, children }: MapCanvasContentProps): React.ReactElement => {
  const canvasRef = dc.useRef<HTMLCanvasElement | null>(null);
  const fogCanvasRef = dc.useRef<HTMLCanvasElement | null>(null);  // Separate canvas for fog blur effect (CSS blur for iOS compat)
  const containerRef = dc.useRef<HTMLDivElement | null>(null);
  const [canvasDimensions, setCanvasDimensions] = dc.useState<CanvasDimensions>({
    width: DEFAULTS.canvasSize.width,
    height: DEFAULTS.canvasSize.height
  });

  // Create onMapDataUpdate wrapper for map-level changes
  // This bridges the old prop-based API with the new context-based approach
  const onMapDataUpdate = dc.useCallback((updates: MapDataUpdate) => {
    if (updates.viewState && onViewStateChange) {
      onViewStateChange(updates.viewState);
    }
    if (updates.lastTextLabelSettings && onTextLabelSettingsChange) {
      onTextLabelSettingsChange(updates.lastTextLabelSettings);
    }
  }, [onViewStateChange, onTextLabelSettingsChange]);

  // Use shared selection from context (same state ObjectLayer uses)
  const {
    selectedItem, setSelectedItem,
    selectedItems,
    isDraggingSelection, setIsDraggingSelection,
    dragStart, setDragStart,
    isResizeMode, setIsResizeMode,
    hoveredObject, setHoveredObject,
    mousePosition, setMousePosition,
    showNoteLinkModal, setShowNoteLinkModal,
    pendingNotePinId, setPendingNotePinId,
    editingNoteObjectId, setEditingNoteObjectId,
    showCoordinates, setShowCoordinates,
    layerVisibility
  } = useMapSelection();

  // Orientation animation state

  // Refs to hold layer state for cursor coordination
  const drawingLayerStateRef = dc.useRef<DrawingLayerState>({ isDrawing: false, rectangleStart: null, circleStart: null });
  const panZoomLayerStateRef = dc.useRef<PanZoomLayerState>({ isPanning: false, isTouchPanning: false, spaceKeyPressed: false });

  // Callbacks for layers to expose their state
  const handleDrawingStateChange = dc.useCallback((drawingState: DrawingLayerState) => {
    drawingLayerStateRef.current = drawingState;
  }, []);

  const handlePanZoomStateChange = dc.useCallback((panZoomState: PanZoomLayerState) => {
    panZoomLayerStateRef.current = panZoomState;
  }, []);

  // Create geometry instance based on map type
  // Return null during loading to prevent errors
  const geometry = dc.useMemo((): IGeometry | null => {
    if (!mapData) return null;

    const mapType = mapData.mapType || DEFAULTS.mapType;

    if (mapType === 'hex') {
      const hexSize = mapData.hexSize || DEFAULTS.hexSize;
      const orientation = mapData.orientation || DEFAULTS.hexOrientation;
      const hexBounds = mapData.hexBounds || null; // null = infinite (backward compat)
      return new HexGeometry(hexSize, orientation, hexBounds);
    } else {
      // Default to grid
      const gridSize = mapData.gridSize || DEFAULTS.gridSize;
      return new GridGeometry(gridSize);
    }
  }, [mapData?.mapType, mapData?.gridSize, mapData?.hexSize, mapData?.orientation, mapData?.hexBounds]);

  // Use canvas interaction ONLY for coordinate utility functions
  const {
    screenToGrid,
    screenToWorld,
    getClientCoords
  } = useCanvasInteraction(canvasRef, mapData, geometry, null, isFocused);

  dc.useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const updateCanvasSize = (): void => {
      const rect = container.getBoundingClientRect();
      setCanvasDimensions({
        width: Math.max(rect.width, DEFAULTS.canvasSize.width),
        height: Math.max(rect.height, DEFAULTS.canvasSize.height)
      });
    };

    // Initial size
    updateCanvasSize();

    // Watch for container size changes
    const resizeObserver = new ResizeObserver(updateCanvasSize);
    resizeObserver.observe(container);

    return () => resizeObserver.disconnect();
  }, []);

  // Force canvas resize when animation completes
  dc.useEffect(() => {
    if (isAnimating) return; // Only run when animation ends

    const container = containerRef.current;
    if (!container) return;

    // Wait one more frame to ensure CSS transition is fully complete
    requestAnimationFrame(() => {
      const rect = container.getBoundingClientRect();
      setCanvasDimensions({
        width: Math.max(rect.width, DEFAULTS.canvasSize.width),
        height: Math.max(rect.height, DEFAULTS.canvasSize.height)
      });
    });
  }, [isAnimating]);

  // Render canvas whenever relevant state changes
  useCanvasRenderer(canvasRef, fogCanvasRef, mapData, geometry, selectedItems, isResizeMode, theme, showCoordinates, layerVisibility);

  // Trigger redraw when canvas dimensions change (from expand/collapse)
  dc.useEffect(() => {
    if (!canvasRef.current || !mapData || !geometry) return;

    const canvas = canvasRef.current;
    const fogCanvas = fogCanvasRef.current;

    // During animation, preserve canvas content
    if (isAnimating) {
      // Save current canvas content
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      const tempCtx = tempCanvas.getContext('2d');
      if (tempCtx) {
        tempCtx.drawImage(canvas, 0, 0);
      }

      // Update canvas size
      canvas.width = canvasDimensions.width;
      canvas.height = canvasDimensions.height;

      // Also update fog canvas size
      if (fogCanvas) {
        fogCanvas.width = canvasDimensions.width;
        fogCanvas.height = canvasDimensions.height;
      }

      // Restore content (will stretch/compress during animation)
      const ctx = canvas.getContext('2d');
      if (ctx) {
        ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
      }
    } else {
      // After animation, do a proper redraw with correct dimensions
      renderCanvas(canvas, fogCanvas, mapData, geometry, selectedItem, isResizeMode, theme, showCoordinates, layerVisibility);
    }
  }, [canvasDimensions.width, canvasDimensions.height, isAnimating, showCoordinates, layerVisibility]);

  // 'C' key handler for coordinate overlay (hex maps only)
  dc.useEffect(() => {
    // Get the coordinate key mode from settings ('hold' or 'toggle')
    const keyMode = getSetting('coordinateKeyMode') || 'hold';

    // Only attach listeners if focused and on a hex map
    if (!isFocused || mapData?.mapType !== 'hex') {
      // Always hide coordinates on non-hex maps
      // In 'hold' mode, also hide when losing focus
      // In 'toggle' mode, keep coordinates visible when mouse leaves (but hide on non-hex maps)
      if (showCoordinates && (mapData?.mapType !== 'hex' || keyMode === 'hold')) {
        setShowCoordinates(false);
      }
      return;
    }

    const handleKeyDown = (e: KeyboardEvent): void => {
      // Only track 'C' key when focused, and only if not typing in an input
      const target = e.target as HTMLElement;
      if (e.key.toLowerCase() === 'c' && !e.shiftKey && !e.ctrlKey && !e.metaKey &&
          target.tagName !== 'INPUT' && target.tagName !== 'TEXTAREA') {
        // Ignore key repeat events in toggle mode
        if (e.repeat && keyMode === 'toggle') return;

        e.preventDefault();

        if (keyMode === 'toggle') {
          // Toggle mode: flip the state
          setShowCoordinates(!showCoordinates);
        } else {
          // Hold mode: show on keydown
          setShowCoordinates(true);
        }
      }
    };

    const handleKeyUp = (e: KeyboardEvent): void => {
      if (e.key.toLowerCase() === 'c') {
        // Only hide on keyup in 'hold' mode
        if (keyMode === 'hold') {
          setShowCoordinates(false);
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, [isFocused, mapData?.mapType, showCoordinates, setShowCoordinates]);

  // Determine cursor class based on current tool and interaction state
  const getCursorClass = (): string => {
    // Get state
    const effectiveDrawingState = drawingLayerStateRef.current;
    const effectivePanZoomState = panZoomLayerStateRef.current;

    // Space key override - show grab cursor
    if (effectivePanZoomState.spaceKeyPressed && !effectivePanZoomState.isPanning) return 'dmt-canvas-space-grab';

    if (effectivePanZoomState.isPanning || effectivePanZoomState.isTouchPanning) return 'dmt-canvas-panning';
    if (isDraggingSelection) return 'dmt-canvas-selecting';
    if (currentTool === 'select') return 'dmt-canvas-select';
    if (currentTool === 'measure') return 'dmt-canvas-measure';
    if (currentTool === 'diagonalFill') return 'dmt-canvas-diagonal-fill';
    if (currentTool === 'addObject') {
      return selectedObjectType ? 'dmt-canvas-add-object' : 'dmt-canvas';
    }
    if (currentTool === 'addText') {
      return 'dmt-canvas-add-text';
    }
    if (currentTool === 'rectangle') {
      return effectiveDrawingState.rectangleStart ? 'dmt-canvas-rectangle-active' : 'dmt-canvas-rectangle';
    }
    if (currentTool === 'circle') {
      return effectiveDrawingState.circleStart ? 'dmt-canvas-circle-active' : 'dmt-canvas-circle';
    }
    if (currentTool === 'clearArea') {
      return effectiveDrawingState.rectangleStart ? 'dmt-canvas-cleararea-active' : 'dmt-canvas-cleararea';
    }
    if (effectiveDrawingState.isDrawing) {
      return currentTool === 'draw' ? 'dmt-canvas-drawing' : 'dmt-canvas-erasing';
    }
    return currentTool === 'erase' ? 'dmt-canvas-erase' : 'dmt-canvas';
  };

  // Build context values for providers
  const mapStateValue = dc.useMemo(() => ({
    canvasRef,
    containerRef,
    mapData,
    mapId,
    notePath,
    geometry,
    currentTool,
    selectedColor,
    selectedObjectType,
    screenToGrid,
    screenToWorld,
    getClientCoords,
    GridGeometry,
    HexGeometry,
    // State change callbacks for layers
    onDrawingStateChange: handleDrawingStateChange,
    onPanZoomStateChange: handlePanZoomStateChange
  }), [canvasRef, containerRef, mapData, mapId, notePath, geometry, currentTool, selectedColor,
    selectedObjectType, screenToGrid, screenToWorld, getClientCoords,
    handleDrawingStateChange, handlePanZoomStateChange]);

  const mapOperationsValue = dc.useMemo(() => ({
    // Object operations
    getObjectAtPosition,
    addObject,
    updateObject,
    removeObject,
    isAreaFree,
    canResizeObject,
    removeObjectAtPosition,
    removeObjectsInRectangle,

    // Text operations
    getTextLabelAtPosition,
    addTextLabel,
    updateTextLabel,
    removeTextLabel,

    // Callbacks
    onCellsChange,
    onObjectsChange,
    onTextLabelsChange,
    onEdgesChange,
    onCurvesChange,
    onMapDataUpdate
  }), [onCellsChange, onObjectsChange, onTextLabelsChange, onEdgesChange, onCurvesChange, onViewStateChange, onTextLabelSettingsChange]);



  return (
    <EventHandlerProvider>
      <MapStateProvider value={mapStateValue}>
        <MapOperationsProvider value={mapOperationsValue}>
          {/* Coordinators - must be inside provider tree to access contexts */}
          <Coordinators
            canvasRef={canvasRef}
            mapData={mapData}
            geometry={geometry}
            isFocused={isFocused}
            isColorPickerOpen={isColorPickerOpen}
            isAlignmentMode={isAlignmentMode}
          />

          <div className="dmt-canvas-container" ref={containerRef}>
            {/* Wrapper for canvas alignment - fog canvas positions relative to this */}
            <div style={{ position: 'relative', display: 'inline-block' }}>
              {/* Main canvas */}
              <canvas
                ref={canvasRef}
                width={canvasDimensions.width}
                height={canvasDimensions.height}
                className={getCursorClass()}
                style={{ touchAction: 'none', display: 'block' }}
              />

              {/* Fog blur overlay canvas */}
              <canvas
                ref={fogCanvasRef}
                width={canvasDimensions.width}
                height={canvasDimensions.height}
                style={{
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  pointerEvents: 'none'
                }}
              />
            </div>

            <LinkedNoteHoverOverlays
              canvasRef={canvasRef}
              mapData={mapData}
              selectedItem={selectedItem}
              geometry={geometry}
              layerVisibility={layerVisibility}
            />

            {/* Render child layers */}
            {children}
          </div>
        </MapOperationsProvider>
      </MapStateProvider>
    </EventHandlerProvider>
  );
};

const MapCanvas = (props: MapCanvasProps): React.ReactElement => {
  const { children, layerVisibility, ...restProps } = props;

  return (
    <MapSelectionProvider layerVisibility={layerVisibility}>
      <ObjectLinkingProvider>
        <MapCanvasContent {...restProps}>
          {children}
        </MapCanvasContent>
      </ObjectLinkingProvider>
    </MapSelectionProvider>
  );
};

// Attach layer components using dot notation
MapCanvas.ObjectLayer = ObjectLayer;
MapCanvas.DrawingLayer = DrawingLayer;
MapCanvas.TextLayer = TextLayer;
MapCanvas.NotePinLayer = NotePinLayer;
MapCanvas.HexCoordinateLayer = HexCoordinateLayer;
MapCanvas.MeasurementLayer = MeasurementLayer;
MapCanvas.DiagonalFillOverlay = DiagonalFillOverlay;
MapCanvas.AreaSelectLayer = AreaSelectLayer;
MapCanvas.FogOfWarLayer = FogOfWarLayer;
MapCanvas.RerollDungeonButton = RerollDungeonButton;

return { MapCanvas };

```

# WindroseCompass

```jsx
// WindroseCompass.jsx - Reusable branded compass rose SVG component

const WindroseCompass = ({ rotation = 0, size, className = '' }) => {
  // Unique filter IDs to avoid document-global collisions
  const instanceIdRef = dc.useRef();
  if (!instanceIdRef.current) {
    instanceIdRef.current = `windrose-${Math.random().toString(36).substr(2, 9)}`;
  }
  const filterId = (name) => `${name}-${instanceIdRef.current}`;
  
  const style = {
    width: size,
    height: size,
    transform: rotation ? `rotate(${rotation}deg)` : undefined,
    transition: rotation ? 'transform 0.3s ease' : undefined
  };
  
  return (
    <svg 
      className={`windrose-compass ${className}`}
      viewBox="0 0 100 100"
      style={style}
    >
      <defs>
        <filter id={filterId('glow')}>
          <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
        <filter id={filterId('whiteGlow')}>
          <feGaussianBlur stdDeviation="1.0" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
        <filter id={filterId('darkGlow')}>
          <feGaussianBlur stdDeviation="2.5" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
        <filter id={filterId('ringGlow')}>
          <feGaussianBlur stdDeviation="1" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
        <filter id={filterId('compassShadow')} x="-50%" y="-50%" width="200%" height="200%">
          <feDropShadow dx="0" dy="3" stdDeviation="4" floodColor="rgba(0, 0, 0, 0.8)"/>
        </filter>
      </defs>
      
      <g filter={`url(#${filterId('compassShadow')})`}>
      
        {/* Background circle */}
        <circle 
          cx="50" 
          cy="50" 
          r="28" 
          fill="rgba(0, 0, 0, 0.7)"
          stroke="rgba(196, 165, 123, 0.4)"
          strokeWidth="2"
          className="windrose-compass-bg"
        />
        
        {/* Outer decorative rings */}
        <circle 
          cx="50" 
          cy="50" 
          r="48" 
          fill="none" 
          stroke="rgba(255, 255, 255, 0.4)" 
          strokeWidth="0.8"
          filter={`url(#${filterId('ringGlow')})`}
        />
        <circle 
          cx="50" 
          cy="50" 
          r="48" 
          fill="none" 
          stroke="rgba(196, 165, 123, 0.3)" 
          strokeWidth="0.5"
        />
        <circle 
          cx="50" 
          cy="50" 
          r="45" 
          fill="none" 
          stroke="rgba(255, 255, 255, 0.4)" 
          strokeWidth="0.8"
          filter={`url(#${filterId('ringGlow')})`}
        />
        <circle 
          cx="50" 
          cy="50" 
          r="45" 
          fill="none" 
          stroke="rgba(196, 165, 123, 0.2)" 
          strokeWidth="0.5"
        />
        
        {/* Cardinal direction lines */}
        {/* North */}
        <line x1="50" y1="2" x2="50" y2="22" stroke="rgba(0, 0, 0, 0.9)" strokeWidth="7" strokeLinecap="round" filter={`url(#${filterId('darkGlow')})`}/>
        <line x1="50" y1="2" x2="50" y2="22" stroke="rgba(255, 255, 255, 0.8)" strokeWidth="6" strokeLinecap="round" filter={`url(#${filterId('whiteGlow')})`}/>
        <line x1="50" y1="2" x2="50" y2="22" stroke="#c4a57b" strokeWidth="2.5" strokeLinecap="round"/>
        <line x1="50" y1="2" x2="50" y2="22" stroke="#c4a57b" strokeWidth="1" strokeLinecap="round" opacity="0.5" filter={`url(#${filterId('glow')})`}/>
        
        {/* South */}
        <line x1="50" y1="78" x2="50" y2="98" stroke="rgba(0, 0, 0, 0.75)" strokeWidth="5" strokeLinecap="round" filter={`url(#${filterId('darkGlow')})`}/>
        <line x1="50" y1="78" x2="50" y2="98" stroke="rgba(255, 255, 255, 0.6)" strokeWidth="4.5" strokeLinecap="round" filter={`url(#${filterId('whiteGlow')})`}/>
        <line x1="50" y1="78" x2="50" y2="98" stroke="rgba(196, 165, 123, 0.55)" strokeWidth="0.9" strokeLinecap="round"/>
        
        {/* East */}
        <line x1="78" y1="50" x2="98" y2="50" stroke="rgba(0, 0, 0, 0.75)" strokeWidth="5" strokeLinecap="round" filter={`url(#${filterId('darkGlow')})`}/>
        <line x1="78" y1="50" x2="98" y2="50" stroke="rgba(255, 255, 255, 0.6)" strokeWidth="4.5" strokeLinecap="round" filter={`url(#${filterId('whiteGlow')})`}/>
        <line x1="78" y1="50" x2="98" y2="50" stroke="rgba(196, 165, 123, 0.55)" strokeWidth="0.9" strokeLinecap="round"/>
        
        {/* West */}
        <line x1="2" y1="50" x2="22" y2="50" stroke="rgba(0, 0, 0, 0.75)" strokeWidth="5" strokeLinecap="round" filter={`url(#${filterId('darkGlow')})`}/>
        <line x1="2" y1="50" x2="22" y2="50" stroke="rgba(255, 255, 255, 0.6)" strokeWidth="4.5" strokeLinecap="round" filter={`url(#${filterId('whiteGlow')})`}/>
        <line x1="2" y1="50" x2="22" y2="50" stroke="rgba(196, 165, 123, 0.55)" strokeWidth="0.9" strokeLinecap="round"/>
        
        {/* Secondary direction lines (NE, SE, SW, NW) */}
        <line x1="71" y1="29" x2="82" y2="18" stroke="rgba(0, 0, 0, 0.5)" strokeWidth="3" strokeLinecap="round" filter={`url(#${filterId('darkGlow')})`}/>
        <line x1="71" y1="29" x2="82" y2="18" stroke="rgba(196, 165, 123, 0.68)" strokeWidth="0.8" strokeLinecap="round"/>
        
        <line x1="71" y1="71" x2="82" y2="82" stroke="rgba(0, 0, 0, 0.5)" strokeWidth="3" strokeLinecap="round" filter={`url(#${filterId('darkGlow')})`}/>
        <line x1="71" y1="71" x2="82" y2="82" stroke="rgba(196, 165, 123, 0.68)" strokeWidth="0.8" strokeLinecap="round"/>
        
        <line x1="29" y1="71" x2="18" y2="82" stroke="rgba(0, 0, 0, 0.5)" strokeWidth="3" strokeLinecap="round" filter={`url(#${filterId('darkGlow')})`}/>
        <line x1="29" y1="71" x2="18" y2="82" stroke="rgba(196, 165, 123, 0.68)" strokeWidth="0.8" strokeLinecap="round"/>
        
        <line x1="29" y1="29" x2="18" y2="18" stroke="rgba(0, 0, 0, 0.5)" strokeWidth="3" strokeLinecap="round" filter={`url(#${filterId('darkGlow')})`}/>
        <line x1="29" y1="29" x2="18" y2="18" stroke="rgba(196, 165, 123, 0.68)" strokeWidth="0.8" strokeLinecap="round"/>
        
        {/* Compass star points */}
        <g className="windrose-compass-star">
          {/* North point (primary, golden) */}
          <path 
            d="M 50 8 L 58 50 L 50 47 L 42 50 Z" 
            fill="rgba(0, 0, 0, 0.6)"
            stroke="rgba(0, 0, 0, 0.7)"
            strokeWidth="3"
            filter={`url(#${filterId('darkGlow')})`}
          />
          <path 
            d="M 50 8 L 58 50 L 50 47 L 42 50 Z" 
            fill="#c4a57b"
            stroke="#8b6842"
            strokeWidth="0.8"
          />
          <path 
            d="M 50 8 L 58 50 L 50 47 L 42 50 Z" 
            fill="none"
            stroke="#c4a57b"
            strokeWidth="1.5"
            opacity="0.4"
            filter={`url(#${filterId('glow')})`}
          />
          
          {/* South point */}
          <path 
            d="M 50 92 L 56 50 L 50 53 L 44 50 Z" 
            fill="rgba(0, 0, 0, 0.5)"
            stroke="rgba(0, 0, 0, 0.6)"
            strokeWidth="2.5"
            filter={`url(#${filterId('darkGlow')})`}
          />
          {/* East point */}
          <path 
            d="M 92 50 L 50 44 L 53 50 L 50 56 Z" 
            fill="rgba(0, 0, 0, 0.5)"
            stroke="rgba(0, 0, 0, 0.6)"
            strokeWidth="2.5"
            filter={`url(#${filterId('darkGlow')})`}
          />
          {/* West point */}
          <path 
            d="M 8 50 L 50 44 L 47 50 L 50 56 Z" 
            fill="rgba(0, 0, 0, 0.5)"
            stroke="rgba(0, 0, 0, 0.6)"
            strokeWidth="2.5"
            filter={`url(#${filterId('darkGlow')})`}
          />
        
          {/* Secondary point fills */}
          <path 
            d="M 50 92 L 56 50 L 50 53 L 44 50 Z" 
            fill="rgba(196, 165, 123, 0.88)"
            stroke="rgba(139, 104, 66, 0.88)"
            strokeWidth="0.5"
          />
          <path 
            d="M 92 50 L 50 44 L 53 50 L 50 56 Z" 
            fill="rgba(196, 165, 123, 0.88)"
            stroke="rgba(139, 104, 66, 0.88)"
            strokeWidth="0.5"
          />
          <path 
            d="M 8 50 L 50 44 L 47 50 L 50 56 Z" 
            fill="rgba(196, 165, 123, 0.88)"
            stroke="rgba(139, 104, 66, 0.88)"
            strokeWidth="0.5"
          />
        </g>
        
        {/* Inner decorative ring */}
        <circle 
          cx="50" 
          cy="50" 
          r="25" 
          fill="none"
          stroke="rgba(196, 165, 123, 0.3)"
          strokeWidth="0.5"
        />
        
        {/* Center "N" letter with layered stroke for depth */}
        <text 
          x="50" 
          y="62" 
          textAnchor="middle" 
          fontSize="36" 
          fontWeight="bold" 
          fill="none"
          stroke="rgba(0, 0, 0, 1)"
          strokeWidth="7.65"
          fontFamily="serif"
          letterSpacing="1"
        >N</text>
        <text 
          x="50" 
          y="62" 
          textAnchor="middle" 
          fontSize="36" 
          fontWeight="bold" 
          fill="none"
          stroke="rgba(0, 0, 0, 1)"
          strokeWidth="6.12"
          fontFamily="serif"
          letterSpacing="1"
        >N</text>
        <text 
          x="50" 
          y="62" 
          textAnchor="middle" 
          fontSize="36" 
          fontWeight="bold" 
          fill="none"
          stroke="rgba(0, 0, 0, 0.9)"
          strokeWidth="4.59"
          fontFamily="serif"
          letterSpacing="1"
        >N</text>
        <text 
          x="50" 
          y="62" 
          textAnchor="middle" 
          fontSize="36" 
          fontWeight="bold" 
          fill="#c4a57b"
          fontFamily="serif"
          letterSpacing="1"
        >N</text>
        
        {/* Red north indicator arrow */}
        <path 
          d="M 50 14 L 44.4 25.2 L 50 21 L 55.6 25.2 Z"
          fill="rgba(0, 0, 0, 0.7)"
          stroke="rgba(0, 0, 0, 0.8)"
          strokeWidth="2.5"
          filter={`url(#${filterId('darkGlow')})`}
        />
        <path 
          d="M 50 14 L 44.4 25.2 L 50 21 L 55.6 25.2 Z"
          fill="#e74c3c"
          stroke="#c0392b"
          strokeWidth="0.8"
        />
        <circle 
          cx="50" 
          cy="14" 
          r="3" 
          fill="#e74c3c"
          opacity="0.4"
          filter={`url(#${filterId('glow')})`}
        />
      </g>
    </svg>
  );
};

return { WindroseCompass };
```

# MapControls

```jsx
const { WindroseCompass } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "WindroseCompass"));

// Timing constants - easy to tune
const COLLAPSE_DELAY_DESKTOP_MS = 800;   // Desktop: time after mouse leaves
const COLLAPSE_DELAY_TOUCH_MS = 3000;    // Touch: longer since no hover cue
const ITEM_STAGGER_MS = 40;              // Delay between each item's animation start
const ITEM_DURATION_MS = 180;            // How long each item takes to animate
const DRAWER_ITEM_COUNT = 4;             // Number of items in the bottom drawer

const MapControls = ({ 
  onZoomIn, 
  onZoomOut, 
  onCompassClick, 
  northDirection, 
  currentZoom, 
  isExpanded, 
  onToggleExpand, 
  onSettingsClick, 
  mapType, 
  showVisibilityToolbar, 
  onToggleVisibilityToolbar,
  showLayerPanel,
  onToggleLayerPanel,
  alwaysShowControls = false
}) => {
    // When alwaysShowControls is true, controls are always visible
    const [controlsRevealed, setControlsRevealed] = dc.useState(alwaysShowControls);
    const collapseTimerRef = dc.useRef(null);
    
    // Update revealed state when alwaysShowControls changes
    dc.useEffect(() => {
      if (alwaysShowControls) {
        setControlsRevealed(true);
        clearCollapseTimer();
      }
    }, [alwaysShowControls]);
    
    // Detect device capabilities separately
    // Touch capability: needs tap-to-reveal and overlay
    // Hover capability: can use hover to reveal
    // iPad with trackpad has BOTH
    const hasTouchCapability = dc.useMemo(() => {
      return window.matchMedia('(pointer: coarse)').matches;
    }, []);
    
    const clearCollapseTimer = () => {
      if (collapseTimerRef.current) {
        clearTimeout(collapseTimerRef.current);
        collapseTimerRef.current = null;
      }
    };
    
    const startCollapseTimer = (forTouch = false) => {
      // Don't collapse if always showing controls
      if (alwaysShowControls) return;
      
      clearCollapseTimer();
      const delay = forTouch ? COLLAPSE_DELAY_TOUCH_MS : COLLAPSE_DELAY_DESKTOP_MS;
      collapseTimerRef.current = setTimeout(() => {
        setControlsRevealed(false);
      }, delay);
    };
    
    // Hover handlers - work on any device with hover capability
    const handleMouseEnter = () => {
      clearCollapseTimer();
      setControlsRevealed(true);
    };
    
    const handleMouseLeave = () => {
      startCollapseTimer(false); // desktop timing
    };
    
    // Compass click - works on all devices
    // If collapsed: reveal (tap-to-reveal for touch, or click-to-reveal)
    // If revealed or always showing: rotate compass
    const handleCompassClick = () => {
      if (alwaysShowControls || controlsRevealed) {
        // Controls already revealed or always showing - rotate compass
        onCompassClick();
        // Reset timer for touch users (only if not always showing)
        if (hasTouchCapability && !alwaysShowControls) {
          startCollapseTimer(true);
        }
      } else {
        // Reveal controls
        clearCollapseTimer();
        setControlsRevealed(true);
        // Start auto-collapse timer for touch interactions
        if (hasTouchCapability) {
          startCollapseTimer(true);
        }
      }
    };
    
    // Touch: tap outside to dismiss (only if not always showing)
    const handleOverlayClick = (e) => {
      if (alwaysShowControls) return;
      
      e.stopPropagation();
      e.preventDefault();
      clearCollapseTimer();
      setControlsRevealed(false);
    };
    
    // Reset collapse timer when interacting with controls (touch)
    const handleControlInteraction = (handler) => (e) => {
      if (hasTouchCapability && controlsRevealed) {
        startCollapseTimer(true);
      }
      handler(e);
    };
    
    // Cleanup timer on unmount
    dc.useEffect(() => {
      return () => clearCollapseTimer();
    }, []);
    
    // Stagger timing for bottom drawer items (indices 0-3)
    const getDrawerItemStyle = (index) => ({
      transitionDelay: controlsRevealed 
        ? `${(index + 1) * ITEM_STAGGER_MS}ms`
        : `${(DRAWER_ITEM_COUNT - index + 1) * ITEM_STAGGER_MS}ms`,
      transitionDuration: `${ITEM_DURATION_MS}ms`
    });
    
    // Expand button animates last on reveal, first on collapse
    const getExpandStyle = () => ({
      transitionDelay: controlsRevealed 
        ? `${(DRAWER_ITEM_COUNT + 1) * ITEM_STAGGER_MS}ms`
        : `0ms`,
      transitionDuration: `${ITEM_DURATION_MS}ms`
    });
    
    // Build compass tooltip based on state and capabilities
    const getCompassTitle = () => {
      if (!controlsRevealed && !alwaysShowControls && hasTouchCapability) {
        return "Tap to show controls";
      }
      if (mapType === 'hex') {
        return `North indicator at ${northDirection} (visual only, ${hasTouchCapability ? 'tap' : 'click'} to rotate)`;
      }
      return `North is at ${northDirection} (${hasTouchCapability ? 'tap' : 'click'} to rotate)`;
    };
    
    return (
      <>
        {/* Invisible overlay to capture taps outside controls (touch capable devices, not when always showing) */}
        {hasTouchCapability && controlsRevealed && !alwaysShowControls && (
          <div 
            className="dmt-controls-overlay"
            onClick={handleOverlayClick}
            onTouchStart={handleOverlayClick}
          />
        )}
        
        <div 
          className="dmt-controls"
          onMouseEnter={handleMouseEnter}
          onMouseLeave={handleMouseLeave}
        >
          {/* Expand/Collapse Button - Above compass, animates last */}
          <button
            className={`dmt-expand-btn dmt-drawer-item dmt-drawer-item-up ${controlsRevealed ? 'dmt-drawer-item-visible' : ''}`}
            style={getExpandStyle()}
            onClick={handleControlInteraction(onToggleExpand)}
            title={isExpanded ? "Collapse to normal width" : "Expand to full width"}
          >
            <dc.Icon icon={isExpanded ? "lucide-minimize" : "lucide-expand"} />
          </button>
          
          {/* Compass Rose - Always visible anchor, slides down on reveal */}
          <div 
            className={`dmt-compass dmt-compass-animated ${controlsRevealed ? 'dmt-compass-revealed' : ''}`}
            onClick={handleCompassClick}
            title={getCompassTitle()}
          >
            <WindroseCompass rotation={northDirection} className="dmt-compass-svg" />
          </div>
          
          {/* Collapsible controls container - Below compass */}
          <div className={`dmt-controls-drawer ${controlsRevealed ? 'dmt-controls-drawer-open' : ''}`}>
            {/* Zoom Controls */}
            <div 
              className={`dmt-zoom-controls dmt-drawer-item ${controlsRevealed ? 'dmt-drawer-item-visible' : ''}`}
              style={getDrawerItemStyle(0)}
            >
              <button
                className="dmt-zoom-btn"
                onClick={handleControlInteraction(onZoomIn)}
                title="Zoom In"
              >
                +
              </button>
              <div className="dmt-zoom-level" title={`Zoom: ${Math.round(currentZoom * 100)}%`}>
                {Math.round(currentZoom * 100)}%
              </div>
              <button 
                className="dmt-zoom-btn"
                onClick={handleControlInteraction(onZoomOut)}
                title="Zoom Out"
              >
                -
              </button>
            </div>
            
            {/* Layer Panel Toggle Button */}
            <button
              className={`dmt-expand-btn dmt-drawer-item ${showLayerPanel ? 'dmt-expand-btn-active' : ''} ${controlsRevealed ? 'dmt-drawer-item-visible' : ''}`}
              style={getDrawerItemStyle(1)}
              onClick={handleControlInteraction(onToggleLayerPanel)}
              title="Toggle layer panel"
            >
              <dc.Icon icon="lucide-layers" />
            </button>
            
            {/* Visibility Toggle Button */}
            <button
              className={`dmt-expand-btn dmt-drawer-item ${showVisibilityToolbar ? 'dmt-expand-btn-active' : ''} ${controlsRevealed ? 'dmt-drawer-item-visible' : ''}`}
              style={getDrawerItemStyle(2)}
              onClick={handleControlInteraction(onToggleVisibilityToolbar)}
              title="Toggle layer visibility"
            >
              <dc.Icon icon="lucide-eye" />
            </button>
            
            {/* Settings Button */}
            <button
              className={`dmt-expand-btn dmt-drawer-item ${controlsRevealed ? 'dmt-drawer-item-visible' : ''}`}
              style={getDrawerItemStyle(3)}
              onClick={handleControlInteraction(onSettingsClick)}
              title="Map Settings"
            >
              <dc.Icon icon="lucide-settings" />
            </button>
          </div>
        </div>
      </>
    );
  };
  
  return { MapControls };
```

# ToolPalette

```tsx
/**
 * ToolPalette.tsx
 *
 * Tool selection palette with sub-tool menus, history controls, and color picker.
 */

import type { JSX } from 'preact';
import type { HexColor } from '#types/core/common.types';
import type { MapType } from '#types/core/map.types';
import type { ToolId } from '#types/tools/tool.types';
import type { CustomColor, ColorOpacityOverrides } from './ColorPicker.tsx';

const { DEFAULT_COLOR } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "colorOperations"));
const { ColorPicker } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ColorPicker"));

/** Sub-tool definition */
interface SubToolDef {
  id: ToolId;
  label: string;
  title: string;
  icon: string;
  gridOnly?: boolean;
}

/** Tool group with sub-tools */
interface ToolGroup {
  id: string;
  subTools: SubToolDef[];
}

/** Simple tool (no sub-menu) */
interface SimpleTool {
  id: ToolId;
  title: string;
  icon: string;
  gridOnly?: boolean;
}

/** Bracket position */
type BracketPosition = 'tl' | 'tr' | 'bl' | 'br';

/** Sub-tool selections state */
interface SubToolSelections {
  select: ToolId;
  draw: ToolId;
  rectangle: ToolId;
}

/** Props for ToolPaletteBracket */
interface ToolPaletteBracketProps {
  position: BracketPosition;
}

/** Props for SubMenuFlyout */
interface SubMenuFlyoutProps {
  subTools: SubToolDef[];
  currentSubTool: ToolId;
  onSelect: (id: ToolId) => void;
  onClose: () => void;
}

/** Props for ToolButtonWithSubMenu */
interface ToolButtonWithSubMenuProps {
  toolGroup: ToolGroup;
  currentTool: ToolId;
  currentSubTool: ToolId;
  isSubMenuOpen: boolean;
  onToolSelect: (id: ToolId) => void;
  onSubToolSelect: (groupId: string, subToolId: ToolId) => void;
  onSubMenuOpen: (groupId: string) => void;
  onSubMenuClose: () => void;
  mapType: MapType;
}

/** Props for ToolPalette */
export interface ToolPaletteProps {
  currentTool: ToolId;
  onToolChange: (tool: ToolId) => void;
  onUndo: () => void;
  onRedo: () => void;
  canUndo: boolean;
  canRedo: boolean;
  selectedColor: HexColor | null;
  onColorChange: (color: HexColor) => void;
  selectedOpacity?: number;
  onOpacityChange?: (opacity: number) => void;
  isColorPickerOpen: boolean;
  onColorPickerOpenChange: (open: boolean) => void;
  customColors: CustomColor[];
  paletteColorOpacityOverrides?: ColorOpacityOverrides;
  onAddCustomColor?: (color: HexColor) => void;
  onDeleteCustomColor?: (colorId: string) => void;
  onUpdateColorOpacity?: (colorId: string, opacity: number) => void;
  mapType: MapType;
  isFocused?: boolean;
}

const ToolPaletteBracket = ({ position }: ToolPaletteBracketProps): React.ReactElement => {
  return (
    <svg
      className={`dmt-tool-palette-bracket dmt-tool-palette-bracket-${position}`}
      viewBox="-5 -5 25 25"
    >
      <defs>
        <filter id={`palette-bracket-glow-${position}`}>
          <feGaussianBlur stdDeviation="1.5" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>
      <path
        d="M 0 15 L 0 0 L 15 0"
        stroke="#c4a57b"
        strokeWidth="1.5"
        fill="none"
        filter={`url(#palette-bracket-glow-${position})`}
      />
      <path
        d="M -2.5 18 L -2.5 -2.5 L 18 -2.5"
        stroke="rgba(255, 255, 255, 0.4)"
        strokeWidth="0.8"
        fill="none"
      />
      <line
        x1="-4" y1="7" x2="0" y2="7"
        stroke="#c4a57b"
        strokeWidth="1.5"
      />
      <line
        x1="7" y1="-4" x2="7" y2="0"
        stroke="#c4a57b"
        strokeWidth="1.5"
      />
    </svg>
  );
};

const SubMenuFlyout = ({ subTools, currentSubTool, onSelect, onClose }: SubMenuFlyoutProps): React.ReactElement => {
  return (
    <div className="dmt-subtool-menu">
      {subTools.map(subTool => (
        <button
          key={subTool.id}
          className={`dmt-subtool-option interactive-child ${currentSubTool === subTool.id ? 'dmt-subtool-option-active' : ''}`}
          onClick={(e) => {
            e.stopPropagation();
            onSelect(subTool.id);
            onClose();
          }}
          title={subTool.title}
        >
          <dc.Icon icon={subTool.icon} />
          <span>{subTool.label}</span>
        </button>
      ))}
    </div>
  );
};

const ToolButtonWithSubMenu = ({
  toolGroup,
  currentTool,
  currentSubTool,
  isSubMenuOpen,
  onToolSelect,
  onSubToolSelect,
  onSubMenuOpen,
  onSubMenuClose,
  mapType
}: ToolButtonWithSubMenuProps): React.ReactElement | null => {
  const longPressTimer = dc.useRef<ReturnType<typeof setTimeout> | null>(null);
  const LONG_PRESS_DURATION = 300;

  const visibleSubTools = toolGroup.subTools.filter(st =>
    mapType !== 'hex' || !st.gridOnly
  );

  if (visibleSubTools.length === 0) return null;

  const currentSubToolDef = visibleSubTools.find(st => st.id === currentSubTool) || visibleSubTools[0];
  const isActive = visibleSubTools.some(st => st.id === currentTool);
  const hasMultipleSubTools = visibleSubTools.length > 1;

  const handlePointerDown = (): void => {
    if (!hasMultipleSubTools) return;

    longPressTimer.current = setTimeout(() => {
      onSubMenuOpen(toolGroup.id);
      longPressTimer.current = null;
    }, LONG_PRESS_DURATION);
  };

  const handlePointerUp = (): void => {
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      longPressTimer.current = null;
      onToolSelect(currentSubToolDef.id);
    } else if (!hasMultipleSubTools) {
      onToolSelect(currentSubToolDef.id);
    }
  };

  const handlePointerLeave = (): void => {
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      longPressTimer.current = null;
    }
  };

  const handleContextMenu = (e: JSX.TargetedMouseEvent<HTMLButtonElement>): void => {
    if (!hasMultipleSubTools) return;

    e.preventDefault();
    e.stopPropagation();
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current);
      longPressTimer.current = null;
    }
    onSubMenuOpen(toolGroup.id);
  };

  const handleSubToolSelect = (subToolId: ToolId): void => {
    onSubToolSelect(toolGroup.id, subToolId);
    onToolSelect(subToolId);
  };

  return (
    <div className="dmt-tool-btn-container" style={{ position: 'relative', display: 'inline-block' }}>
      <button
        className={`dmt-tool-btn interactive-child ${isActive ? 'dmt-tool-btn-active' : ''}`}
        onPointerDown={handlePointerDown}
        onPointerUp={handlePointerUp}
        onPointerLeave={handlePointerLeave}
        onContextMenu={handleContextMenu}
        title={currentSubToolDef?.title}
      >
        <dc.Icon icon={currentSubToolDef?.icon} />
        {hasMultipleSubTools && (
          <span className="dmt-subtool-indicator interactive-child"></span>
        )}
      </button>

      {isSubMenuOpen && hasMultipleSubTools && (
        <SubMenuFlyout
          subTools={visibleSubTools}
          currentSubTool={currentSubTool}
          onSelect={handleSubToolSelect}
          onClose={onSubMenuClose}
        />
      )}
    </div>
  );
};

const ToolPalette = ({
  currentTool,
  onToolChange,
  onUndo,
  onRedo,
  canUndo,
  canRedo,
  selectedColor,
  onColorChange,
  selectedOpacity = 1,
  onOpacityChange,
  isColorPickerOpen,
  onColorPickerOpenChange,
  customColors,
  paletteColorOpacityOverrides = {},
  onAddCustomColor,
  onDeleteCustomColor,
  onUpdateColorOpacity,
  mapType,
  isFocused = false
}: ToolPaletteProps): React.ReactElement => {
  const colorBtnRef = dc.useRef<HTMLButtonElement>(null);
  const pendingCustomColorRef = dc.useRef<HexColor | null>(null);

  const [openSubMenu, setOpenSubMenu] = dc.useState<string | null>(null);
  const [subToolSelections, setSubToolSelections] = dc.useState<SubToolSelections>({
    select: 'select' as ToolId,
    draw: 'draw' as ToolId,
    rectangle: 'rectangle' as ToolId
  });

  dc.useEffect(() => {
    if (!isFocused) return;

    const handleKeyDown = (e: KeyboardEvent): void => {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return;
      if (e.ctrlKey || e.metaKey || e.altKey) return;

      const key = e.key.toLowerCase();

      switch (key) {
        case 'd':
          onToolChange('draw' as ToolId);
          break;
        case 'e':
          onToolChange('erase' as ToolId);
          break;
        case 's':
        case 'v':
          onToolChange(subToolSelections.select || 'select' as ToolId);
          break;
        case 'm':
          onToolChange('measure' as ToolId);
          break;
        default:
          return;
      }

      e.preventDefault();
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [onToolChange, isFocused, subToolSelections]);

  const toolGroups: ToolGroup[] = [
    {
      id: 'select',
      subTools: [
        { id: 'select' as ToolId, label: 'Click Select', title: 'Select/Move (S)', icon: 'lucide-hand' },
        { id: 'areaSelect' as ToolId, label: 'Area Select', title: 'Area Select (click two corners)', icon: 'lucide-box-select' }
      ]
    },
    {
      id: 'draw',
      subTools: [
        { id: 'draw' as ToolId, label: 'Paint Cells', title: 'Draw (fill cells) (D)', icon: 'lucide-paintbrush' },
        { id: 'freehandDraw' as ToolId, label: 'Freehand', title: 'Freehand Draw (curves)', icon: 'lucide-pencil' },
        { id: 'segmentDraw' as ToolId, label: 'Paint Segments', title: 'Paint Segments (partial cells)', icon: 'lucide-triangle', gridOnly: true },
        { id: 'edgeDraw' as ToolId, label: 'Paint Edges', title: 'Paint Edges (grid lines)', icon: 'lucide-pencil-ruler', gridOnly: true }
      ]
    },
    {
      id: 'rectangle',
      subTools: [
        { id: 'rectangle' as ToolId, label: 'Fill Rectangle', title: 'Rectangle (click two corners)', icon: 'lucide-square', gridOnly: true },
        { id: 'edgeLine' as ToolId, label: 'Edge Line', title: 'Edge Line (click two points)', icon: 'lucide-git-commit-horizontal', gridOnly: true },
        { id: 'diagonalFill' as ToolId, label: 'Diagonal Fill', title: 'Fill diagonal gaps (click two corners)', icon: 'lucide-slash', gridOnly: true }
      ]
    }
  ];

  const simpleTools: SimpleTool[] = [
    { id: 'erase' as ToolId, title: 'Erase (remove text/objects/cells/edges) (E)', icon: 'lucide-eraser' },
    { id: 'circle' as ToolId, title: 'Circle (click edge, then center)', icon: 'lucide-circle', gridOnly: true },
    { id: 'clearArea' as ToolId, title: 'Clear Area (click two corners to erase)', icon: 'lucide-square-x', gridOnly: true },
    { id: 'addObject' as ToolId, title: 'Add Object (select from sidebar)', icon: 'lucide-map-pin-plus' },
    { id: 'addText' as ToolId, title: 'Add Text Label', icon: 'lucide-type' },
    { id: 'measure' as ToolId, title: 'Measure Distance (M)', icon: 'lucide-ruler' }
  ];

  const visibleSimpleTools = mapType === 'hex'
    ? simpleTools.filter(tool => !tool.gridOnly)
    : simpleTools;

  const handleSubMenuOpen = (groupId: string): void => {
    setOpenSubMenu(openSubMenu === groupId ? null : groupId);
  };

  const handleSubMenuClose = (): void => {
    setOpenSubMenu(null);
  };

  const handleSubToolSelect = (groupId: string, subToolId: ToolId): void => {
    setSubToolSelections(prev => ({
      ...prev,
      [groupId]: subToolId
    }));
  };

  const toggleColorPicker = (e: JSX.TargetedMouseEvent<HTMLButtonElement>): void => {
    e.stopPropagation();
    onColorPickerOpenChange(!isColorPickerOpen);
  };

  const handleColorSelect = (color: HexColor): void => {
    onColorChange(color);
  };

  const handleColorReset = (): void => {
    onColorChange(DEFAULT_COLOR);
    onColorPickerOpenChange(false);
  };

  const handleCloseColorPicker = (): void => {
    onColorPickerOpenChange(false);
  };

  dc.useEffect(() => {
    if (!openSubMenu) return;

    const handleClickOutside = (e: MouseEvent | TouchEvent): void => {
      const target = e.target as Element;
      const menuElement = target.closest('.dmt-subtool-menu');
      const buttonElement = target.closest('.dmt-tool-btn-container');

      if (!menuElement && !buttonElement) {
        handleSubMenuClose();
      }
    };

    setTimeout(() => {
      document.addEventListener('mousedown', handleClickOutside);
      document.addEventListener('touchstart', handleClickOutside);
    }, 10);

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('touchstart', handleClickOutside);
    };
  }, [openSubMenu]);

  dc.useEffect(() => {
    if (!isColorPickerOpen) return;

    const handleClickOutside = (e: MouseEvent | TouchEvent): void => {
      const target = e.target as Element;
      const pickerElement = target.closest('.dmt-color-picker');
      const buttonElement = target.closest('.dmt-color-tool-btn');

      if (!pickerElement && !buttonElement) {
        if (pendingCustomColorRef.current) {
          const colorValue = pendingCustomColorRef.current;
          onAddCustomColor?.(colorValue);
          onColorChange(colorValue);
          pendingCustomColorRef.current = null;
        }
        handleCloseColorPicker();
      }
    };

    setTimeout(() => {
      document.addEventListener('mousedown', handleClickOutside);
      document.addEventListener('touchstart', handleClickOutside);
    }, 10);

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('touchstart', handleClickOutside);
    };
  }, [isColorPickerOpen]);

  return (
    <div className="dmt-tool-palette">
      <ToolPaletteBracket position="tl" />
      <ToolPaletteBracket position="tr" />
      <ToolPaletteBracket position="bl" />
      <ToolPaletteBracket position="br" />

      <ToolButtonWithSubMenu
        toolGroup={toolGroups[0]}
        currentTool={currentTool}
        currentSubTool={subToolSelections.select}
        isSubMenuOpen={openSubMenu === 'select'}
        onToolSelect={onToolChange}
        onSubToolSelect={handleSubToolSelect}
        onSubMenuOpen={handleSubMenuOpen}
        onSubMenuClose={handleSubMenuClose}
        mapType={mapType}
      />

      <ToolButtonWithSubMenu
        toolGroup={toolGroups[1]}
        currentTool={currentTool}
        currentSubTool={subToolSelections.draw}
        isSubMenuOpen={openSubMenu === 'draw'}
        onToolSelect={onToolChange}
        onSubToolSelect={handleSubToolSelect}
        onSubMenuOpen={handleSubMenuOpen}
        onSubMenuClose={handleSubMenuClose}
        mapType={mapType}
      />

      <div style={{ position: 'relative', display: 'inline-block' }}>
        <button
          ref={colorBtnRef}
          className={`dmt-tool-btn dmt-color-tool-btn interactive-child ${isColorPickerOpen ? 'dmt-tool-btn-active' : ''}`}
          onClick={toggleColorPicker}
          title="Choose color"
          style={{
            borderBottom: `4px solid ${selectedColor || DEFAULT_COLOR}`
          }}
        >
          <dc.Icon icon="lucide-palette" />
        </button>

        <ColorPicker
          isOpen={isColorPickerOpen}
          selectedColor={selectedColor}
          onColorSelect={handleColorSelect}
          onClose={handleCloseColorPicker}
          onReset={handleColorReset}
          customColors={customColors}
          paletteColorOpacityOverrides={paletteColorOpacityOverrides}
          onAddCustomColor={onAddCustomColor}
          onDeleteCustomColor={onDeleteCustomColor}
          onUpdateColorOpacity={onUpdateColorOpacity}
          position={null}
          pendingCustomColorRef={pendingCustomColorRef}
          title="Color"
          opacity={selectedOpacity}
          onOpacityChange={onOpacityChange}
        />
      </div>

      <button
        className={`dmt-tool-btn interactive-child ${currentTool === 'erase' ? 'dmt-tool-btn-active' : ''}`}
        onClick={() => onToolChange('erase' as ToolId)}
        title="Erase (remove text/objects/cells/edges)"
      >
        <dc.Icon icon="lucide-eraser" />
      </button>

      {mapType !== 'hex' && (
        <ToolButtonWithSubMenu
          toolGroup={toolGroups[2]}
          currentTool={currentTool}
          currentSubTool={subToolSelections.rectangle}
          isSubMenuOpen={openSubMenu === 'rectangle'}
          onToolSelect={onToolChange}
          onSubToolSelect={handleSubToolSelect}
          onSubMenuOpen={handleSubMenuOpen}
          onSubMenuClose={handleSubMenuClose}
          mapType={mapType}
        />
      )}

      {visibleSimpleTools.filter(t => t.id !== 'erase').map(tool => (
        <button
          key={tool.id}
          className={`dmt-tool-btn interactive-child ${currentTool === tool.id ? 'dmt-tool-btn-active' : ''}`}
          onClick={() => onToolChange(tool.id)}
          title={tool.title}
        >
          <dc.Icon icon={tool.icon} />
        </button>
      ))}

      <div className="dmt-history-controls">
        <button
          className="dmt-history-btn interactive-child"
          onClick={onUndo}
          disabled={!canUndo}
          title="Undo"
        >
          <dc.Icon icon="lucide-undo" />
        </button>
        <button
          className="dmt-history-btn interactive-child"
          onClick={onRedo}
          disabled={!canRedo}
          title="Redo"
        >
          <dc.Icon icon="lucide-redo" />
        </button>
      </div>
    </div>
  );
};

return { ToolPalette };

```

# ObjectSidebar

```jsx
// Use resolver for dynamic object types (supports overrides and custom objects)
const { getResolvedObjectTypes, getResolvedCategories, hasIconClass } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "objectTypeResolver"));

// Ornamental Arrow SVG - Double Chevron Design
const OrnamentalArrow = ({ direction = "right" }) => {
  const rotation = direction === "left" ? 180 : 0;
  
  return (
    <svg 
      width="16" 
      height="16" 
      viewBox="0 0 16 16"
      style={{ transform: `rotate(${rotation}deg)` }}
    >
      <defs>
        <filter id={`arrow-glow-${direction}`}>
          <feGaussianBlur stdDeviation="1" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>
      {/* First chevron */}
      <polyline 
        points="4,4 8,8 4,12" 
        fill="none" 
        stroke="currentColor" 
        strokeWidth="1.5" 
        strokeLinecap="round" 
        strokeLinejoin="round"
        filter={`url(#arrow-glow-${direction})`}
      />
      {/* Second chevron */}
      <polyline 
        points="8,4 12,8 8,12" 
        fill="none" 
        stroke="currentColor" 
        strokeWidth="1.5" 
        strokeLinecap="round" 
        strokeLinejoin="round"
        filter={`url(#arrow-glow-${direction})`}
      />
    </svg>
  );
};

const ObjectSidebar = ({ selectedObjectType, onObjectTypeSelect, onToolChange, isCollapsed, onCollapseChange }) => {
  // Get resolved object types and categories (includes overrides and custom)
  const allObjectTypes = getResolvedObjectTypes();
  const allCategories = getResolvedCategories();
  
  // Group objects by category (excluding 'notes' category which is handled specially)
  const objectsByCategory = allCategories
    .filter(category => category.id !== 'notes')
    .map(category => ({
      ...category,
      objects: allObjectTypes
        .filter(obj => obj.category === category.id)
        .sort((a, b) => (a.order ?? 0) - (b.order ?? 0))  // Sort by order
    }))
    .filter(category => category.objects.length > 0);  // Only show categories with objects
  
  const handleObjectSelect = (objectId) => {
    onObjectTypeSelect(objectId);
    if (onToolChange) {
      onToolChange('addObject');  // Automatically switch to add object tool
    }
  };
  
  const handleToggleCollapse = () => {
    onCollapseChange(!isCollapsed);
  };
  
  if (isCollapsed) {
    return (
      <div className="dmt-object-sidebar dmt-object-sidebar-collapsed">
        <button
          className="dmt-sidebar-toggle interactive-child"
          onClick={handleToggleCollapse}
          title="Show objects"
        >
          <OrnamentalArrow direction="right" />
        </button>
      </div>
    );
  }
  
  return (
    <div className="dmt-object-sidebar">
      {/* Hidden element to force early emoji font loading */}
      <div className="dmt-font-preloader" aria-hidden="true"></div>
      
      <div className="dmt-sidebar-header">
        Objects
        <button
          className="dmt-sidebar-collapse-btn interactive-child"
          onClick={handleToggleCollapse}
          title="Hide sidebar"
        >
          <OrnamentalArrow direction="left" />
        </button>
      </div>
      
      <div className="dmt-sidebar-content">
        {/* Note Pin special button */}
        <div className="dmt-sidebar-note-section">
          <button
            className={`dmt-note-pin-btn ${selectedObjectType === 'note_pin' ? 'dmt-note-pin-btn-selected' : ''}`}
            onClick={() => handleObjectSelect('note_pin')}
            title="Place Note Pin"
          >
            <dc.Icon icon="lucide-map-pinned" />
            <span>Note Pin</span>
          </button>
        </div>
        
        {/* Existing category loop */}
        {objectsByCategory.map(category => (
          <div key={category.id} className="dmt-sidebar-category">
            <div className="dmt-category-label">{category.label}</div>
            
            {category.objects.map(objType => (
              <button
                key={objType.id}
                className={`dmt-object-item ${selectedObjectType === objType.id ? 'dmt-object-item-selected' : ''}`}
                onClick={() => handleObjectSelect(objType.id)}
                title={objType.label}
              >
                <div className="dmt-object-symbol">
                  {hasIconClass(objType) ? (
                    <span className={`ra ${objType.iconClass}`}></span>
                  ) : (
                    objType.symbol || '?'
                  )}
                </div>
                <div className="dmt-object-label">{objType.label}</div>
              </button>
            ))}
          </div>
        ))}
      </div>
      
      {selectedObjectType && (
        <div className="dmt-sidebar-footer">
          <button
            className="dmt-deselect-btn"
            onClick={() => onObjectTypeSelect(null)}
            title="Deselect object"
          >
            Clear Selection
          </button>
        </div>
      )}
    </div>
  );
};

return { ObjectSidebar };
```

# VisibilityToolbar

```tsx
/**
 * VisibilityToolbar.tsx
 *
 * Compact horizontal toolbar for toggling layer visibility.
 * Overlays below the ToolPalette when eye button is clicked.
 * Extended with Fog of War tools panel.
 */

import type { MapType } from '#types/core/map.types';

/** Fog of War tool identifiers */
export type FogTool = 'paint' | 'erase' | 'rectangle' | null;

/** Fog of War state from active layer */
export interface FogOfWarState {
  initialized: boolean;
  enabled: boolean;
  activeTool: FogTool;
}

/** Layer visibility state */
export interface LayerVisibility {
  objects: boolean;
  textLabels: boolean;
  hexCoordinates?: boolean;
}

/** Layer definition for visibility toggles */
interface LayerDef {
  id: keyof LayerVisibility;
  icon: string;
  tooltip: string;
  hexOnly?: boolean;
}

/** Props for VisibilityToolbar component */
export interface VisibilityToolbarProps {
  /** Whether the toolbar is visible */
  isOpen: boolean;
  /** Current visibility state for each layer */
  layerVisibility: LayerVisibility;
  /** Callback to toggle a layer's visibility */
  onToggleLayer: (layerId: keyof LayerVisibility) => void;
  /** 'grid' or 'hex' - hex coordinates only show for hex maps */
  mapType: MapType;
  /** FoW state from active layer */
  fogOfWarState?: FogOfWarState;
  /** Whether FoW tools panel is expanded */
  showFogTools?: boolean;
  /** Toggle FoW tools panel visibility */
  onFogToolsToggle?: () => void;
  /** Select a FoW tool */
  onFogToolSelect?: (tool: FogTool) => void;
  /** Toggle fog visibility */
  onFogVisibilityToggle?: () => void;
  /** Fill all cells with fog */
  onFogFillAll?: () => void;
  /** Clear all fog */
  onFogClearAll?: () => void;
}

const VisibilityToolbar = ({
  isOpen,
  layerVisibility,
  onToggleLayer,
  mapType,
  fogOfWarState = { initialized: false, enabled: false, activeTool: null },
  showFogTools = false,
  onFogToolsToggle,
  onFogToolSelect,
  onFogVisibilityToggle,
  onFogFillAll,
  onFogClearAll
}: VisibilityToolbarProps): React.ReactElement => {
  const layers: LayerDef[] = [
    {
      id: 'objects',
      icon: 'lucide-boxes',
      tooltip: 'Toggle object visibility'
    },
    {
      id: 'textLabels',
      icon: 'lucide-type',
      tooltip: 'Toggle text label visibility'
    },
    {
      id: 'hexCoordinates',
      icon: 'lucide-key-round',
      tooltip: 'Toggle coordinate visibility (or hold C)',
      hexOnly: true
    }
  ];

  const visibleLayers = layers.filter(layer => !layer.hexOnly || mapType === 'hex');

  return (
    <div className={`dmt-visibility-toolbar ${isOpen ? 'dmt-visibility-toolbar-open' : ''}`}>
      {visibleLayers.map(layer => {
        const isVisible = layerVisibility[layer.id];

        return (
          <button
            key={layer.id}
            className={`dmt-visibility-btn ${!isVisible ? 'dmt-visibility-btn-hidden' : ''}`}
            onClick={() => onToggleLayer(layer.id)}
            title={`${layer.tooltip} (currently ${isVisible ? 'visible' : 'hidden'})`}
          >
            <dc.Icon icon={layer.icon} />
            {!isVisible && (
              <svg
                className="dmt-visibility-strikethrough"
                viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg"
              >
                <line
                  x1="4" y1="4"
                  x2="20" y2="20"
                  stroke="currentColor"
                  strokeWidth="2.5"
                  strokeLinecap="round"
                />
              </svg>
            )}
          </button>
        );
      })}

      <div className="dmt-visibility-separator" />

      <div className="dmt-fow-section">
        <button
          className={`dmt-fow-toggle-btn ${showFogTools ? 'expanded' : ''}`}
          onClick={onFogToolsToggle}
          title="Fog of War tools"
        >
          <dc.Icon icon="lucide-cloud-fog" />
          <span className="dmt-fow-label">Fog</span>
        </button>

        <div className={`dmt-fow-tools-panel ${showFogTools ? 'expanded' : ''}`}>
          <button
            className={`dmt-fow-tool-btn ${!fogOfWarState.enabled ? 'disabled' : ''}`}
            onClick={onFogVisibilityToggle}
            title={fogOfWarState.enabled ? "Hide fog overlay" : "Show fog overlay"}
            disabled={!fogOfWarState.initialized}
          >
            <dc.Icon icon={fogOfWarState.enabled ? "lucide-eye" : "lucide-eye-off"} />
          </button>

          <button
            className={`dmt-fow-tool-btn ${fogOfWarState.activeTool === 'paint' ? 'active' : ''}`}
            onClick={() => onFogToolSelect?.('paint')}
            title="Paint fog onto cells"
          >
            <dc.Icon icon="lucide-paintbrush" />
          </button>

          <button
            className={`dmt-fow-tool-btn ${fogOfWarState.activeTool === 'erase' ? 'active' : ''}`}
            onClick={() => onFogToolSelect?.('erase')}
            title="Erase fog (reveal cells)"
          >
            <dc.Icon icon="lucide-eraser" />
          </button>

          <button
            className={`dmt-fow-tool-btn ${fogOfWarState.activeTool === 'rectangle' ? 'active' : ''}`}
            onClick={() => onFogToolSelect?.('rectangle')}
            title="Rectangle tool - click two corners"
          >
            <dc.Icon icon="lucide-square" />
          </button>

          <button
            className="dmt-fow-tool-btn"
            onClick={onFogFillAll}
            title="Fill all painted cells with fog"
          >
            <dc.Icon icon="lucide-paint-bucket" />
          </button>

          <button
            className="dmt-fow-tool-btn"
            onClick={onFogClearAll}
            title="Clear all fog from layer"
          >
            <dc.Icon icon="lucide-x-square" />
          </button>
        </div>
      </div>
    </div>
  );
};

return { VisibilityToolbar };

```

# settingsPlugin-quickSymbols

```js
return `// settingsPlugin-quickSymbols.js
// Quick symbols palette for object creation in the settings plugin
// Separated to prevent unicode corruption during automated edits

const QUICK_SYMBOLS = [
  '', '', '', '', '', '', '', '',
  '', '', '', '', '', '', '', '',
  '', '', '', '', '', '', '', '',
  '', '', '', '', '', '', '', '',
  '', '', '', '', '', '', '', '',
  '', '', '', '', '', '', '', '',
  '', '', '', '', '', '', '', '',
  '', '', '', '', '', ''
];

return QUICK_SYMBOLS;`;
```

# settingsPluginMain

```js
// settingsPluginMain.js - Template for Windrose MapDesigner Settings Plugin
// Returns the plugin source as a string for templating by SettingsPluginInstaller
// This wrapper allows the file to be dc.require()'d without Datacore trying to execute it as a standard script

return `// settingsPluginMain.js - Windrose MapDesigner Settings Plugin
// This file is generated from a template by SettingsPluginInstaller
// Default values are injected at install time from dmtConstants and objectTypes

/**
 * ============================================================================
 * TABLE OF CONTENTS
 * ============================================================================
 * 
 * Line ~30:    VERSION & IMPORTS
 * Line ~35:    DATA CONSTANTS (BUILT_IN_OBJECTS, CATEGORIES, QUICK_SYMBOLS)
 * Line ~67:    BUILT_IN_COLORS (color palette defaults)
 * Line ~76:    HELPER_NAMESPACES - Injected at assembly time
 * Line ~83:    MODAL_CLASSES - Injected at assembly time
 * Line ~85:    MAIN PLUGIN CLASS (WindroseMDSettingsPlugin)
 * Line ~450:   SETTINGS TAB CLASS (WindroseMDSettingsTab)
 *              - TAB_RENDER_METHODS - Injected at assembly time
 * 
 * ============================================================================
 */

// =============================================================================
// VERSION & IMPORTS
// =============================================================================

const PLUGIN_VERSION = '{{PLUGIN_VERSION}}';

const { Plugin, PluginSettingTab, Setting, Modal, setIcon } = require('obsidian');

// =============================================================================
// DATA CONSTANTS
// Injected from objectTypes.ts at install time - single source of truth
// =============================================================================

const BUILT_IN_OBJECTS = {{BUILT_IN_OBJECTS}};

const BUILT_IN_CATEGORIES = {{BUILT_IN_CATEGORIES}};

const CATEGORY_ORDER = {{CATEGORY_ORDER}};

// RPGAwesome icon data - injected from rpgAwesomeIcons.ts at install time
const RA_ICONS = {{RA_ICONS}};

const RA_CATEGORIES = {{RA_CATEGORIES}};

// Quick symbols palette - injected at install time
const QUICK_SYMBOLS = {{QUICK_SYMBOLS}};

// =============================================================================
// BUILT-IN COLOR PALETTE
// Default colors for drawing and objects
// =============================================================================

const BUILT_IN_COLORS = [
  { id: 'default', color: '#c4a57b', label: 'Default (Tan)' },
  { id: 'stone', color: '#808080', label: 'Stone Gray' },
  { id: 'dark-stone', color: '#505050', label: 'Dark Gray' },
  { id: 'water', color: '#4a9eff', label: 'Water Blue' },
  { id: 'forest', color: '#4ade80', label: 'Forest Green' },
  { id: 'danger', color: '#ef4444', label: 'Danger Red' },
  { id: 'sand', color: '#fbbf24', label: 'Sand Yellow' },
  { id: 'magic', color: '#a855f7', label: 'Magic Purple' },
  { id: 'fire', color: '#fb923c', label: 'Fire Orange' },
  { id: 'ice', color: '#14b8a6', label: 'Ice Teal' }
];


// =============================================================================
// HELPER NAMESPACES
// Injected at assembly time from settingsPlugin-*Helpers.js files
// =============================================================================

{{HELPER_NAMESPACES}}

// =============================================================================
// MODAL CLASSES
// Injected at assembly time from settingsPlugin-*Modal.js files
// =============================================================================

{{MODAL_CLASSES}}

class WindroseMDSettingsPlugin extends Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new WindroseMDSettingsTab(this.app, this));
    
    // Register command to insert a new map
    this.addCommand({
      id: 'insert-new-map',
      name: 'Insert new map',
      editorCallback: (editor, view) => {
        new InsertMapModal(this.app, (mapName, mapType) => {
          const mapId = 'map-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
          
          const codeBlock = [
            '\`\`\`datacorejsx',
            '',
            'const { View: DungeonMapTracker } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md.md"), "DungeonMapTracker"));',
            '',
            \`const mapId = "\${mapId}";\`,
            \`const mapName = "\${mapName}";\`,
            \`const mapType = "\${mapType}";\`,
            '',
            'return <DungeonMapTracker mapId={mapId} mapName={mapName} mapType={mapType} />;',
            '\`\`\`'
          ].join('\\n');
          
          editor.replaceSelection(codeBlock);
        }).open();
      }
    });
    
    // Register Obsidian protocol handler for deep links
    // Format: obsidian://windrose?notePath|mapId,x,y,zoom,layerId
    this.registerObsidianProtocolHandler('windrose', async (params) => {
      // The data comes as URL search params - we need to parse the raw query
      // params.action = 'windrose', and the rest is in the query string
      const rawQuery = Object.keys(params).find(key => key.includes('|'));
      if (!rawQuery) {
        console.error('[Windrose] Invalid deep link format');
        return;
      }

      const pipeIndex = rawQuery.indexOf('|');
      if (pipeIndex === -1) {
        console.error('[Windrose] Missing pipe separator in deep link');
        return;
      }

      const notePath = rawQuery.slice(0, pipeIndex);
      const coordData = rawQuery.slice(pipeIndex + 1);
      const parts = coordData.split(',');

      if (parts.length !== 5) {
        console.error('[Windrose] Invalid coordinate data in deep link');
        return;
      }

      const [mapId, x, y, zoom, layerId] = parts;

      try {
        // Remove .md extension if present for openLinkText
        const linkPath = notePath.replace(/\\.md$/, '');
        await this.app.workspace.openLinkText(linkPath, '', false);

        // Small delay to let the note render before navigating
        setTimeout(() => {
          window.dispatchEvent(new CustomEvent('dmt-navigate-to', {
            detail: {
              mapId,
              x: parseFloat(x),
              y: parseFloat(y),
              zoom: parseFloat(zoom),
              layerId,
              timestamp: Date.now()
            }
          }));
        }, 100);
      } catch (err) {
        console.error('[Windrose] Failed to open note:', err);
        new Notice('Failed to open map note');
      }
    });

    // Register command to generate a random dungeon
    this.addCommand({
      id: 'insert-random-dungeon',
      name: 'Generate random dungeon',
      editorCallback: async (editor, view) => {
        new InsertDungeonModal(this.app, this, async (mapName, cells, objects, edges, options) => {
          const mapId = 'map-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
          await this.saveDungeonToJson(mapId, mapName, cells, objects, edges, options);

          // Debug mode uses source entry point instead of compiled
          const debugFile = this.app.vault.getAbstractFileByPath('WINDROSE-DEBUG.json');
          const codeBlock = debugFile
            ? [
                '\`\`\`datacorejsx',
                'window.__dmtBasePath = "Projects/dungeon-map-tracker";',
                '',
                'const { DungeonMapTracker } = await dc.require(dc.resolvePath("Dungeon" + "MapTracker.tsx"));',
                '',
                \`const mapId = "\${mapId}";\`,
                \`const mapName = "\${mapName}";\`,
                'const mapType = "grid";',
                '',
                'return <DungeonMapTracker mapId={mapId} mapName={mapName} mapType={mapType} />;',
                '\`\`\`'
              ].join('\\n')
            : [
                '\`\`\`datacorejsx',
                '',
                'const { View: DungeonMapTracker } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md.md"), "DungeonMapTracker"));',
                '',
                \`const mapId = "\${mapId}";\`,
                \`const mapName = "\${mapName}";\`,
                'const mapType = "grid";',
                '',
                'return <DungeonMapTracker mapId={mapId} mapName={mapName} mapType={mapType} />;',
                '\`\`\`'
              ].join('\\n');

          editor.replaceSelection(codeBlock);
        }).open();
      }
    });
  }

  onunload() {}

  /**
   * Get the path to the Windrose data file.
   * Priority: 1) WINDROSE-DEBUG.json override, 2) Auto-discover by filename, 3) Default to vault root
   * @returns {Promise<string>} The resolved data file path
   */
  async getDataFilePath() {
    // 1. Check for debug override at vault root
    const debugFile = this.app.vault.getAbstractFileByPath('WINDROSE-DEBUG.json');
    if (debugFile) {
      try {
        const content = await this.app.vault.read(debugFile);
        const config = JSON.parse(content);
        if (config.dataFilePath) {
          console.log('[Windrose DEBUG] Using data file:', config.dataFilePath);
          return config.dataFilePath;
        }
      } catch (e) {
        console.warn('[Windrose] Failed to read WINDROSE-DEBUG.json:', e);
      }
    }
    
    // 2. Auto-discover by filename
    const allFiles = this.app.vault.getFiles();
    const dataFile = allFiles.find(f => f.name === 'windrose-md-data.json');
    if (dataFile) {
      return dataFile.path;
    }
    
    // 3. Default to vault root (file will be created if needed)
    return 'windrose-md-data.json';
  }

  /**
   * Load the dungeon generator module.
   * In debug mode (WINDROSE-DEBUG.json with dungeonGeneratorPath), loads from a .js file directly.
   * Otherwise, extracts from compiled-windrose-md.md.
   * @returns {Promise<Object>} The dungeon generator module exports
   */
  async loadDungeonGenerator() {
    // 1. Check for debug override
    const debugFile = this.app.vault.getAbstractFileByPath('WINDROSE-DEBUG.json');
    if (debugFile) {
      try {
        const debugContent = await this.app.vault.read(debugFile);
        const config = JSON.parse(debugContent);
        if (config.dungeonGeneratorPath) {
          console.log('[Windrose DEBUG] Loading generator from:', config.dungeonGeneratorPath);
          const generatorFile = this.app.vault.getAbstractFileByPath(config.dungeonGeneratorPath);
          if (!generatorFile) {
            throw new Error('Debug dungeonGeneratorPath not found: ' + config.dungeonGeneratorPath);
          }
          const code = await this.app.vault.read(generatorFile);
          const moduleFunc = new Function(code);
          return moduleFunc();
        }
      } catch (e) {
        console.warn('[Windrose] Debug generator load failed, falling back to compiled:', e.message);
      }
    }
    
    // 2. Production: Load from compiled markdown
    const allFiles = this.app.vault.getFiles();
    const compiledFile = allFiles.find(f => f.name === 'compiled-windrose-md.md');
    
    if (!compiledFile) {
      throw new Error(
        'Could not find compiled-windrose-md.md in your vault. ' +
        'Please ensure Windrose MapDesigner is properly installed.'
      );
    }
    
    // Read the file content
    const fileContent = await this.app.vault.read(compiledFile);
    
    // Extract the dungeonGenerator code block
    // Format: # dungeonGenerator\\n\\n\`\`\`js\\n...code...\\n\`\`\`
    const headerPattern = /^# dungeonGenerator\\s*\\n+\`\`\`(?:js|javascript)?\\n([\\s\\S]*?)\\n\`\`\`/m;
    const match = fileContent.match(headerPattern);
    
    if (!match) {
      throw new Error(
        'Could not find dungeonGenerator section in compiled-windrose-md.md. ' +
        'The file may be corrupted or from an incompatible version.'
      );
    }
    
    const code = match[1];
    
    // Execute the code to get exports
    // The module uses "return { ... }" pattern
    try {
      const moduleFunc = new Function(code);
      return moduleFunc();
    } catch (e) {
      throw new Error('Failed to load dungeon generator: ' + e.message);
    }
  }

  /**
   * Load the object placer module for dungeon stocking.
   * In debug mode (WINDROSE-DEBUG.json with objectPlacerPath), loads from a .js file directly.
   * Otherwise, extracts from compiled-windrose-md.md.
   * @returns {Promise<Object>} The object placer module exports
   */
  async loadObjectPlacer() {
    // 1. Check for debug override
    const debugFile = this.app.vault.getAbstractFileByPath('WINDROSE-DEBUG.json');
    if (debugFile) {
      try {
        const debugContent = await this.app.vault.read(debugFile);
        const config = JSON.parse(debugContent);
        if (config.objectPlacerPath) {
          console.log('[Windrose DEBUG] Loading objectPlacer from:', config.objectPlacerPath);
          const placerFile = this.app.vault.getAbstractFileByPath(config.objectPlacerPath);
          if (!placerFile) {
            throw new Error('Debug objectPlacerPath not found: ' + config.objectPlacerPath);
          }
          const code = await this.app.vault.read(placerFile);
          const moduleFunc = new Function(code);
          return moduleFunc();
        }
      } catch (e) {
        console.warn('[Windrose] Debug objectPlacer load failed, falling back to compiled:', e.message);
      }
    }

    // 2. Production: Load from compiled markdown
    const allFiles = this.app.vault.getFiles();
    const compiledFile = allFiles.find(f => f.name === 'compiled-windrose-md.md');

    if (!compiledFile) {
      throw new Error(
        'Could not find compiled-windrose-md.md in your vault. ' +
        'Please ensure Windrose MapDesigner is properly installed.'
      );
    }

    // Read the file content
    const fileContent = await this.app.vault.read(compiledFile);

    // Extract the objectPlacer code block
    const headerPattern = /^# objectPlacer\\s*\\n+\`\`\`(?:js|javascript)?\\n([\\s\\S]*?)\\n\`\`\`/m;
    const match = fileContent.match(headerPattern);

    if (!match) {
      throw new Error(
        'Could not find objectPlacer section in compiled-windrose-md.md. ' +
        'The file may be corrupted or from an incompatible version.'
      );
    }

    const code = match[1];

    // Execute the code to get exports
    try {
      const moduleFunc = new Function(code);
      return moduleFunc();
    } catch (e) {
      throw new Error('Failed to load object placer: ' + e.message);
    }
  }

  /**
   * Build fog of war data for auto-fog feature.
   * Fogs all cells except entry room cells.
   */
  buildFogOfWar(cells, options) {
    const autoFogEnabled = options?.configOverrides?.autoFogEnabled;
    if (!autoFogEnabled) return null;

    const stockingMeta = options?.stockingMetadata;
    if (!stockingMeta?.rooms || !cells?.length) return null;

    // Find entry room
    const entryRoomId = stockingMeta.entryRoomId;
    const entryRoom = stockingMeta.rooms.find(r => r.id === entryRoomId);

    // Build set of entry room cells to exclude from fog
    const entryRoomCells = new Set();
    if (entryRoom) {
      for (let x = entryRoom.x; x < entryRoom.x + entryRoom.width; x++) {
        for (let y = entryRoom.y; y < entryRoom.y + entryRoom.height; y++) {
          // For circular rooms, check if cell is actually in room
          if (entryRoom.shape === 'circle') {
            const centerX = entryRoom.x + entryRoom.radius;
            const centerY = entryRoom.y + entryRoom.radius;
            const dx = x + 0.5 - centerX;
            const dy = y + 0.5 - centerY;
            if (dx * dx + dy * dy <= entryRoom.radius * entryRoom.radius) {
              entryRoomCells.add(\`\${x},\${y}\`);
            }
          } else if (entryRoom.shape === 'composite') {
            // Check if cell is in any of the room's parts
            for (const part of entryRoom.parts) {
              if (x >= part.x && x < part.x + part.width &&
                  y >= part.y && y < part.y + part.height) {
                entryRoomCells.add(\`\${x},\${y}\`);
                break;
              }
            }
          } else {
            entryRoomCells.add(\`\${x},\${y}\`);
          }
        }
      }
    }

    // Fog all cells except entry room
    const foggedCells = cells
      .filter(c => !entryRoomCells.has(\`\${c.x},\${c.y}\`))
      .map(c => ({ col: c.x, row: c.y }));

    return {
      enabled: true,
      foggedCells
    };
  }

  /**
   * Save a generated dungeon directly to the JSON data file
   */
  async saveDungeonToJson(mapId, mapName, cells, objects, edges, options) {
    const SCHEMA_VERSION = 2;
    
    try {
      const dataFilePath = await this.getDataFilePath();
      let allData = { maps: {} };
      
      // Load existing data
      const file = this.app.vault.getAbstractFileByPath(dataFilePath);
      if (file) {
        const content = await this.app.vault.read(file);
        allData = JSON.parse(content);
      }
      
      if (!allData.maps) allData.maps = {};
      
      // Generate layer ID
      const layerId = 'layer-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      
      // Calculate viewport center from generated cells (in grid cell coordinates)
      let centerX = 5, centerY = 5;
      const gridSize = 32;
      if (cells.length > 0) {
        const minX = Math.min(...cells.map(c => c.x));
        const maxX = Math.max(...cells.map(c => c.x));
        const minY = Math.min(...cells.map(c => c.y));
        const maxY = Math.max(...cells.map(c => c.y));
        // Center is in grid cell coordinates, NOT pixels
        centerX = (minX + maxX) / 2;
        centerY = (minY + maxY) / 2;
      }
      
      // Create the map data structure
      const mapData = {
        name: mapName,
        description: "",
        mapType: "grid",
        northDirection: 0,
        customColors: [],
        sidebarCollapsed: false,
        expandedState: false,
        // Store generation settings for re-roll feature
        generationSettings: {
          preset: options.preset,
          configOverrides: options.configOverrides || {},
          distancePerCell: options.distancePerCell || 5,
          distanceUnit: options.distanceUnit || 'ft',
          stockingMetadata: options.stockingMetadata || null
        },
        settings: {
          useGlobalSettings: false,
          overrides: {
            distancePerCellGrid: options.distancePerCell || 5,
            distanceUnitGrid: options.distanceUnit || 'ft'
          }
        },
        uiPreferences: {
          rememberPanZoom: true,
          rememberSidebarState: true,
          rememberExpandedState: false
        },
        lastTextLabelSettings: null,
        schemaVersion: SCHEMA_VERSION,
        activeLayerId: layerId,
        layerPanelVisible: false,
        layers: [{
          id: layerId,
          name: 'Layer 1',
          order: 0,
          visible: true,
          cells: cells,
          edges: edges || [],
          objects: objects || [],
          textLabels: [],
          fogOfWar: this.buildFogOfWar(cells, options)
        }],
        gridSize: gridSize,
        dimensions: { width: 300, height: 300 },
        viewState: {
          zoom: 1.5,
          center: { x: centerX, y: centerY }
        }
      };
      
      // Save to allData
      allData.maps[mapId] = mapData;
      
      // Write back to file
      const jsonString = JSON.stringify(allData, null, 2);
      if (file) {
        await this.app.vault.modify(file, jsonString);
      } else {
        // Create directory if needed
        const dirPath = dataFilePath.substring(0, dataFilePath.lastIndexOf('/'));
        try {
          await this.app.vault.createFolder(dirPath);
        } catch (e) {
          // Folder may already exist
        }
        await this.app.vault.create(dataFilePath, jsonString);
      }
      
    } catch (error) {
      console.error('[Windrose] Failed to save dungeon:', error);
      throw error;
    }
  }

  async loadSettings() {
    try {
      const data = await this.loadData();
      this.settings = Object.assign({
        version: '{{PLUGIN_VERSION}}',
        hexOrientation: '{{DEFAULT_HEX_ORIENTATION}}',
        gridLineColor: '{{DEFAULT_GRID_LINE_COLOR}}',
        gridLineWidth: 1,
        backgroundColor: '{{DEFAULT_BACKGROUND_COLOR}}',
        borderColor: '{{DEFAULT_BORDER_COLOR}}',
        coordinateKeyColor: '{{DEFAULT_COORDINATE_KEY_COLOR}}',
        coordinateTextColor: '{{DEFAULT_COORDINATE_TEXT_COLOR}}',
        coordinateTextShadow: '{{DEFAULT_COORDINATE_TEXT_SHADOW}}',
        coordinateKeyMode: 'hold',
        expandedByDefault: false,
        // Canvas dimensions
        canvasHeight: 600,
        canvasHeightMobile: 400,
        // Distance measurement settings
        distancePerCellGrid: 5,
        distancePerCellHex: 6,
        distanceUnitGrid: 'ft',
        distanceUnitHex: 'mi',
        gridDiagonalRule: 'alternating',
        distanceDisplayFormat: 'both',
        // Object customization - separate for hex and grid maps
        hexObjectOverrides: {},
        customHexObjects: [],
        customHexCategories: [],
        gridObjectOverrides: {},
        customGridObjects: [],
        customGridCategories: [],
        // Color palette customization
        colorPaletteOverrides: {},
        customPaletteColors: [],
        // Fog of War defaults
        fogOfWarBlurEnabled: false,
        fogOfWarBlurFactor: 0.20,
        // Controls visibility
        alwaysShowControls: false
      }, data || {});
    } catch (error) {
      console.warn('[DMT Settings] Error loading settings, using defaults:', error);
      this.settings = {
        version: '{{PLUGIN_VERSION}}',
        hexOrientation: '{{DEFAULT_HEX_ORIENTATION}}',
        gridLineColor: '{{DEFAULT_GRID_LINE_COLOR}}',
        gridLineWidth: 1,
        backgroundColor: '{{DEFAULT_BACKGROUND_COLOR}}',
        borderColor: '{{DEFAULT_BORDER_COLOR}}',
        coordinateKeyColor: '{{DEFAULT_COORDINATE_KEY_COLOR}}',
        coordinateTextColor: '{{DEFAULT_COORDINATE_TEXT_COLOR}}',
        coordinateTextShadow: '{{DEFAULT_COORDINATE_TEXT_SHADOW}}',
        coordinateKeyMode: 'hold',
        expandedByDefault: false,
        // Canvas dimensions
        canvasHeight: 600,
        canvasHeightMobile: 400,
        // Distance measurement settings
        distancePerCellGrid: 5,
        distancePerCellHex: 6,
        distanceUnitGrid: 'ft',
        distanceUnitHex: 'mi',
        gridDiagonalRule: 'alternating',
        distanceDisplayFormat: 'both',
        // Object customization - separate for hex and grid maps
        hexObjectOverrides: {},
        customHexObjects: [],
        customHexCategories: [],
        gridObjectOverrides: {},
        customGridObjects: [],
        customGridCategories: [],
        // Color palette customization
        colorPaletteOverrides: {},
        customPaletteColors: [],
        // Fog of War defaults
        fogOfWarBlurEnabled: false,
        fogOfWarBlurFactor: 0.20,
        // Controls visibility
        alwaysShowControls: false
      };
    }
  }

  async saveSettings() {
    await this.saveData(this.settings);
  }
}

// =============================================================================
// SETTINGS TAB CLASS
// =============================================================================

class WindroseMDSettingsTab extends PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.settingsChanged = false;
    this.objectFilter = '';
    this.selectedMapType = 'grid'; // 'grid' or 'hex' for object editing
  }
  
  // ---------------------------------------------------------------------------
  // Helper: Get object settings for the selected map type
  // Returns a normalized object { objectOverrides, customObjects, customCategories }
  // ---------------------------------------------------------------------------
  
  getObjectSettingsForMapType() {
    const settings = this.plugin.settings;
    if (this.selectedMapType === 'hex') {
      return {
        objectOverrides: settings.hexObjectOverrides || {},
        customObjects: settings.customHexObjects || [],
        customCategories: settings.customHexCategories || []
      };
    } else {
      return {
        objectOverrides: settings.gridObjectOverrides || {},
        customObjects: settings.customGridObjects || [],
        customCategories: settings.customGridCategories || []
      };
    }
  }
  
  // ---------------------------------------------------------------------------
  // Helper: Update object settings for the selected map type
  // ---------------------------------------------------------------------------
  
  updateObjectSettingsForMapType(updates) {
    if (this.selectedMapType === 'hex') {
      if (updates.objectOverrides !== undefined) {
        this.plugin.settings.hexObjectOverrides = updates.objectOverrides;
      }
      if (updates.customObjects !== undefined) {
        this.plugin.settings.customHexObjects = updates.customObjects;
      }
      if (updates.customCategories !== undefined) {
        this.plugin.settings.customHexCategories = updates.customCategories;
      }
    } else {
      if (updates.objectOverrides !== undefined) {
        this.plugin.settings.gridObjectOverrides = updates.objectOverrides;
      }
      if (updates.customObjects !== undefined) {
        this.plugin.settings.customGridObjects = updates.customObjects;
      }
      if (updates.customCategories !== undefined) {
        this.plugin.settings.customGridCategories = updates.customCategories;
      }
    }
  }

  // ---------------------------------------------------------------------------
  // Helper: Create collapsible section with details/summary
  // ---------------------------------------------------------------------------
  
  createCollapsibleSection(containerEl, title, renderFn, options = {}) {
    const details = containerEl.createEl('details', { cls: 'dmt-settings-section' });
    if (options.open) details.setAttribute('open', '');
    
    // Store section reference for search filtering
    if (!this.sections) this.sections = [];
    this.sections.push({ details, title });
    
    const summary = details.createEl('summary');
    summary.createEl('span', { text: title });
    
    const contentEl = details.createEl('div', { cls: 'dmt-settings-section-content' });
    
    // Track settings within this section for search
    const settingItems = [];
    const originalCreateEl = contentEl.createEl.bind(contentEl);
    
    // Render the section content
    renderFn(contentEl);
    
    // Collect all setting-item elements for search filtering
    details.settingItems = Array.from(contentEl.querySelectorAll('.setting-item'));
    
    return details;
  }
  
  // ---------------------------------------------------------------------------
  // Helper: Render search bar
  // ---------------------------------------------------------------------------
  

  // ---------------------------------------------------------------------------
  // Main display method - orchestrates section rendering
  // ---------------------------------------------------------------------------

  display() {
    const { containerEl } = this;
    
    // Preserve which sections are currently open before rebuilding
    const openSections = new Set();
    if (this.sections) {
      this.sections.forEach(({ details, title }) => {
        if (details.hasAttribute('open')) {
          openSections.add(title);
        }
      });
    }
    
    containerEl.empty();
    
    // Reset section tracking for search
    this.sections = [];
    
    this.renderSearchBar(containerEl);
    
    // Render collapsible sections (restore open state if previously open)
    this.createCollapsibleSection(containerEl, 'Hex Map Settings', 
      (el) => this.renderHexSettingsContent(el),
      { open: openSections.has('Hex Map Settings') });
    this.createCollapsibleSection(containerEl, 'Color Settings', 
      (el) => this.renderColorSettingsContent(el),
      { open: openSections.has('Color Settings') });
    this.createCollapsibleSection(containerEl, 'Color Palette', 
      (el) => this.renderColorPaletteContent(el),
      { open: openSections.has('Color Palette') });
    this.createCollapsibleSection(containerEl, 'Fog of War', 
      (el) => this.renderFogOfWarSettingsContent(el),
      { open: openSections.has('Fog of War') });
    this.createCollapsibleSection(containerEl, 'Map Behavior', 
      (el) => this.renderMapBehaviorSettingsContent(el),
      { open: openSections.has('Map Behavior') });
    this.createCollapsibleSection(containerEl, 'Distance Measurement', 
      (el) => this.renderDistanceMeasurementSettingsContent(el),
      { open: openSections.has('Distance Measurement') });
    this.createCollapsibleSection(containerEl, 'Object Types', 
      (el) => this.renderObjectTypesContent(el),
      { open: openSections.has('Object Types') });
  }

  
  hide() {
    // Only dispatch event if settings were actually changed
    if (this.settingsChanged) {
      window.dispatchEvent(new CustomEvent('dmt-settings-changed', {
        detail: { timestamp: Date.now() }
      }));
      this.settingsChanged = false;
    }
    
  }
}

// =============================================================================
// TAB RENDER MIXINS
// Methods injected into WindroseMDSettingsTab prototype at assembly time
// =============================================================================

{{TAB_RENDER_METHODS}}

// Mix in the render methods to WindroseMDSettingsTab
Object.assign(WindroseMDSettingsTab.prototype, TabRenderCoreMethods);
Object.assign(WindroseMDSettingsTab.prototype, TabRenderSettingsMethods);
Object.assign(WindroseMDSettingsTab.prototype, TabRenderColorsMethods);
Object.assign(WindroseMDSettingsTab.prototype, TabRenderObjectsMethods);

module.exports = WindroseMDSettingsPlugin;`;
```

# settingsPlugin-ObjectHelpers

```js
return `// settingsPlugin-ObjectHelpers.js
// Object resolution helpers - transforms raw settings into resolved object/category lists
// This file is concatenated into the settings plugin template by the assembler

/**
 * Object resolution helpers
 * Transform raw settings into resolved object/category lists
 */
const ObjectHelpers = {
  /**
   * Get all resolved object types (built-in + custom, with overrides applied)
   * @param {Object} settings - Plugin settings
   * @returns {Array} Resolved object array with isBuiltIn, isModified flags
   */
  getResolved(settings) {
    const { objectOverrides = {}, customObjects = [] } = settings;
    
    const resolvedBuiltIns = BUILT_IN_OBJECTS
      .filter(obj => !objectOverrides[obj.id]?.hidden)
      .map((obj, index) => {
        const override = objectOverrides[obj.id];
        const defaultOrder = index * 10;
        if (override) {
          const { hidden, ...overrideProps } = override;
          return { 
            ...obj, 
            ...overrideProps, 
            order: override.order ?? defaultOrder, 
            isBuiltIn: true, 
            isModified: true 
          };
        }
        return { ...obj, order: defaultOrder, isBuiltIn: true, isModified: false };
      });
    
    const resolvedCustom = customObjects.map((obj, index) => ({
      ...obj,
      order: obj.order ?? (1000 + index * 10),
      isCustom: true,
      isBuiltIn: false
    }));
    
    return [...resolvedBuiltIns, ...resolvedCustom];
  },
  
  /**
   * Get all resolved categories (built-in + custom, sorted by order)
   * @param {Object} settings - Plugin settings
   * @returns {Array} Sorted category array with isBuiltIn flag
   */
  getCategories(settings) {
    const { customCategories = [] } = settings;
    
    const resolvedBuiltIns = BUILT_IN_CATEGORIES.map(c => ({
      ...c,
      isBuiltIn: true,
      order: CATEGORY_ORDER[c.id] ?? 50
    }));
    
    const resolvedCustom = customCategories.map(c => ({
      ...c,
      isCustom: true,
      isBuiltIn: false,
      order: c.order ?? 100
    }));
    
    return [...resolvedBuiltIns, ...resolvedCustom].sort((a, b) => (a.order ?? 50) - (b.order ?? 50));
  },
  
  /**
   * Get hidden built-in objects
   * @param {Object} settings - Plugin settings
   * @returns {Array} Hidden objects with isBuiltIn, isHidden flags
   */
  getHidden(settings) {
    const { objectOverrides = {} } = settings;
    return BUILT_IN_OBJECTS
      .filter(obj => objectOverrides[obj.id]?.hidden)
      .map(obj => ({ ...obj, isBuiltIn: true, isHidden: true }));
  },
  
  /**
   * Get all categories including notes (for dropdowns)
   * @param {Object} settings - Plugin settings
   * @returns {Array} All categories
   */
  getAllCategories(settings) {
    const { customCategories = [] } = settings;
    const builtIn = BUILT_IN_CATEGORIES.map(c => ({ ...c, isBuiltIn: true }));
    const custom = customCategories.map(c => ({ ...c, isCustom: true }));
    return [...builtIn, ...custom];
  },
  
  /**
   * Get default ID order for a category (for drag/drop comparison)
   * @param {string} categoryId - Category ID
   * @param {Object} settings - Plugin settings
   * @returns {Array} Array of object IDs in default order
   */
  getDefaultIdOrder(categoryId, settings) {
    const { objectOverrides = {} } = settings;
    return BUILT_IN_OBJECTS
      .filter(o => o.category === categoryId && !objectOverrides[o.id]?.hidden)
      .map(o => o.id);
  }
};`;
```

# settingsPlugin-ColorHelpers

```js
return `// settingsPlugin-ColorHelpers.js
// Color palette resolution helpers - transforms raw settings into resolved color list
// This file is concatenated into the settings plugin template by the assembler

/**
 * Color palette resolution helpers
 * Transform raw settings into resolved color list
 */
const ColorHelpers = {
  /**
   * Get all resolved colors (built-in + custom, with overrides applied)
   * @param {Object} settings - Plugin settings
   * @returns {Array} Resolved color array with isBuiltIn, isModified flags
   */
  getResolved(settings) {
    const { colorPaletteOverrides = {}, customPaletteColors = [] } = settings;
    
    const resolvedBuiltIns = BUILT_IN_COLORS
      .filter(c => !colorPaletteOverrides[c.id]?.hidden)
      .map((c, index) => {
        const override = colorPaletteOverrides[c.id];
        if (override) {
          const { hidden, ...overrideProps } = override;
          return { 
            ...c, 
            ...overrideProps, 
            order: override.order ?? index,
            isBuiltIn: true, 
            isModified: true 
          };
        }
        return { ...c, order: index, isBuiltIn: true, isModified: false };
      });
    
    const resolvedCustom = customPaletteColors.map((c, index) => ({
      ...c,
      order: c.order ?? (100 + index),
      isCustom: true,
      isBuiltIn: false
    }));
    
    return [...resolvedBuiltIns, ...resolvedCustom].sort((a, b) => a.order - b.order);
  },
  
  /**
   * Get hidden color IDs
   * @param {Object} settings - Plugin settings
   * @returns {Set} Set of hidden color IDs
   */
  getHidden(settings) {
    const { colorPaletteOverrides = {} } = settings;
    return new Set(
      Object.entries(colorPaletteOverrides)
        .filter(([id, override]) => override.hidden)
        .map(([id]) => id)
    );
  }
};`;
```

# settingsPlugin-DragHelpers

```js
return `// settingsPlugin-DragHelpers.js
// Drag and drop helpers for reordering objects in the settings UI
// This file is concatenated into the settings plugin template by the assembler

/**
 * Drag and drop helpers
 */
const DragHelpers = {
  /**
   * Find element to insert before during drag operation
   * @param {HTMLElement} container - Container element
   * @param {number} y - Mouse Y position
   * @returns {HTMLElement|undefined} Element to insert before
   */
  getAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.dmt-settings-object-row:not(.dmt-dragging)')];
    
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }
};`;
```

# settingsPlugin-IconHelpers

```js
return `// settingsPlugin-IconHelpers.js
// Icon helpers for setting Lucide icons with fallback
// This file is concatenated into the settings plugin template by the assembler

/**
 * Icon helpers
 */
const IconHelpers = {
  /**
   * Set icon on element with fallback
   * @param {HTMLElement} el - Target element
   * @param {string} iconId - Lucide icon ID
   */
  set(el, iconId) {
    if (typeof setIcon !== 'undefined') {
      setIcon(el, iconId);
    } else {
      // Fallback: create a simple text representation
      const icons = {
        'pencil': '',
        'eye': '',
        'eye-off': '',
        'rotate-ccw': '',
        'trash-2': '',
        'grip-vertical': '',
        'x': '',
        'search': ''
      };
      el.textContent = icons[iconId] || '?';
    }
  }
};`;
```

# settingsPlugin-RPGAwesomeHelpers

```js
return `// settingsPlugin-RPGAwesomeHelpers.js
// RPGAwesome icon helpers for the icon picker UI
// This file is concatenated into the settings plugin template by the assembler

/**
 * RPGAwesome icon helpers
 */
const RPGAwesomeHelpers = {
  /**
   * Get icons filtered by category
   * @param {string} categoryId - Category ID or 'all'
   * @returns {Array} Array of { iconClass, char, label, category }
   */
  getByCategory(categoryId) {
    const icons = Object.entries(RA_ICONS).map(([iconClass, data]) => ({
      iconClass,
      ...data
    }));
    
    if (categoryId === 'all') return icons;
    return icons.filter(i => i.category === categoryId);
  },
  
  /**
   * Search icons by label
   * @param {string} query - Search query
   * @returns {Array} Matching icons
   */
  search(query) {
    const q = query.toLowerCase().trim();
    if (!q) return this.getByCategory('all');
    
    return Object.entries(RA_ICONS)
      .filter(([iconClass, data]) => 
        iconClass.toLowerCase().includes(q) || 
        data.label.toLowerCase().includes(q)
      )
      .map(([iconClass, data]) => ({ iconClass, ...data }));
  },
  
  /**
   * Get sorted categories for tab display
   * @returns {Array} Array of { id, label, order }
   */
  getCategories() {
    return [...RA_CATEGORIES].sort((a, b) => a.order - b.order);
  },
  
  /**
   * Validate an icon class exists
   * @param {string} iconClass - Icon class to validate
   * @returns {boolean}
   */
  isValid(iconClass) {
    return iconClass && RA_ICONS.hasOwnProperty(iconClass);
  },
  
  /**
   * Get icon info
   * @param {string} iconClass - Icon class
   * @returns {Object|null} Icon data or null
   */
  getInfo(iconClass) {
    return RA_ICONS[iconClass] || null;
  }
};`;
```

# settingsPlugin-DungeonEssenceVisualizer

```js
return `// settingsPlugin-DungeonEssenceVisualizer.js
// Ambient visualization for the Insert Dungeon modal
// Shows abstract "dungeon being born" animation
// This file is concatenated into the settings plugin template by the assembler

/**
 * DungeonEssenceVisualizer - Vanilla JS Canvas Animation
 * Creates an ambient visualization of dungeon generation
 */
class DungeonEssenceVisualizer {
  constructor(container, options = {}) {
    this.container = container;
    this.height = options.height || 150;
    this.settings = {
      size: 'medium',
      circleChance: 0.3,
      loopChance: 0.15,
      corridorStyle: 'straight',
      ...options.settings
    };
    
    // Create canvas
    this.canvas = document.createElement('canvas');
    this.canvas.style.display = 'block';
    this.canvas.style.width = '100%';
    this.container.appendChild(this.canvas);
    
    // Create stamp overlay container
    this.stampOverlay = document.createElement('div');
    this.stampOverlay.style.cssText = \`
      position: absolute;
      pointer-events: none;
      opacity: 0;
      filter: saturate(0.4);
      transition: opacity 0.3s ease;
    \`;
    this.stampOverlay.innerHTML = this.getWindroseSVG();
    this.container.style.position = 'relative';
    this.container.appendChild(this.stampOverlay);
    
    this.ctx = this.canvas.getContext('2d');
    this.animationId = null;
    this.state = null;
    
    // Sample colors from CSS
    this.sampleColors();
    
    // Setup resize observer
    this.resizeObserver = new ResizeObserver(() => this.handleResize());
    this.resizeObserver.observe(this.container);
    
    // Initial size
    this.handleResize();
  }
  
  sampleColors() {
    const style = getComputedStyle(document.body);
    this.colors = {
      node: style.getPropertyValue('--text-muted').trim() || '#888',
      nodePulse: style.getPropertyValue('--interactive-accent').trim() || '#7c5cbf',
      line: style.getPropertyValue('--text-faint').trim() || '#666',
      lineSolid: style.getPropertyValue('--text-muted').trim() || '#888'
    };
  }
  
  getWindroseSVG() {
    // Simplified WindroseCompass SVG for the stamp
    return \`
      <svg viewBox="0 0 100 100" style="width: 100%; height: 100%;">
        <defs>
          <filter id="dmt-stamp-shadow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="2" stdDeviation="3" flood-color="rgba(0, 0, 0, 0.6)"/>
          </filter>
        </defs>
        <g filter="url(#dmt-stamp-shadow)">
          <circle cx="50" cy="50" r="28" fill="rgba(0, 0, 0, 0.7)" stroke="rgba(196, 165, 123, 0.4)" stroke-width="2"/>
          <circle cx="50" cy="50" r="45" fill="none" stroke="rgba(196, 165, 123, 0.3)" stroke-width="0.8"/>
          
          <!-- Cardinal lines -->
          <line x1="50" y1="2" x2="50" y2="22" stroke="rgba(196, 165, 123, 0.8)" stroke-width="2.5" stroke-linecap="round"/>
          <line x1="50" y1="78" x2="50" y2="98" stroke="rgba(196, 165, 123, 0.5)" stroke-width="1.5" stroke-linecap="round"/>
          <line x1="78" y1="50" x2="98" y2="50" stroke="rgba(196, 165, 123, 0.5)" stroke-width="1.5" stroke-linecap="round"/>
          <line x1="2" y1="50" x2="22" y2="50" stroke="rgba(196, 165, 123, 0.5)" stroke-width="1.5" stroke-linecap="round"/>
          
          <!-- Compass star -->
          <path d="M 50 8 L 58 50 L 50 47 L 42 50 Z" fill="#c4a57b" stroke="#8b6842" stroke-width="0.8"/>
          <path d="M 50 92 L 56 50 L 50 53 L 44 50 Z" fill="rgba(196, 165, 123, 0.7)" stroke="rgba(139, 104, 66, 0.7)" stroke-width="0.5"/>
          <path d="M 92 50 L 50 44 L 53 50 L 50 56 Z" fill="rgba(196, 165, 123, 0.7)" stroke="rgba(139, 104, 66, 0.7)" stroke-width="0.5"/>
          <path d="M 8 50 L 50 44 L 47 50 L 50 56 Z" fill="rgba(196, 165, 123, 0.7)" stroke="rgba(139, 104, 66, 0.7)" stroke-width="0.5"/>
          
          <!-- N letter -->
          <text x="50" y="62" text-anchor="middle" font-size="28" font-weight="bold" fill="#c4a57b" font-family="serif">N</text>
          
          <!-- Red north arrow -->
          <path d="M 50 14 L 45 24 L 50 20 L 55 24 Z" fill="#e74c3c" stroke="#c0392b" stroke-width="0.5"/>
        </g>
      </svg>
    \`;
  }
  
  handleResize() {
    const rect = this.container.getBoundingClientRect();
    const width = Math.floor(rect.width);
    if (width < 10) return;
    
    this.width = width;
    this.canvas.width = width;
    this.canvas.height = this.height;
    
    // Update stamp size
    const stampSize = Math.min(65, Math.max(45, width * 0.12));
    this.stampSize = stampSize;
    this.stampOverlay.style.width = stampSize + 'px';
    this.stampOverlay.style.height = stampSize + 'px';
    
    // Restart animation with new dimensions
    if (this.animationId) {
      this.stop();
      this.start();
    }
  }
  
  /**
   * Update animation settings
   * 
   * Behavior by setting type:
   * - corridorStyle: Updates on-the-fly (affects line drawing)
   * - circleChance: Takes effect on next animation cycle (affects node generation)
   * - loopChance: Takes effect on next animation cycle (affects connection generation)
   * - size: Restarts animation immediately (affects node count significantly)
   */
  updateSettings(newSettings) {
    const sizeChanged = newSettings.size && newSettings.size !== this.settings.size;
    this.settings = { ...this.settings, ...newSettings };
    
    // Size changes warrant an immediate restart since node count changes dramatically
    if (sizeChanged && this.animationId) {
      this.restartAnimation();
    }
  }
  
  /**
   * Restart the animation with current settings
   */
  restartAnimation() {
    if (!this.animationId) return;
    
    this.hideStamp();
    this.initState();
  }
  
  // Apply style overrides (from DUNGEON_STYLES)
  applyStyle(styleName) {
    const styleOverrides = {
      classic: {},
      cavern: { circleChance: 0.6, corridorStyle: 'organic', loopChance: 0.2 },
      fortress: { circleChance: 0, corridorStyle: 'straight', loopChance: 0.08 },
      crypt: { circleChance: 0.1, corridorStyle: 'straight', loopChance: 0.02 }
    };
    
    const overrides = styleOverrides[styleName] || {};
    this.updateSettings(overrides);
  }
  
  start() {
    if (this.animationId) return;
    
    this.initState();
    this.lastTime = performance.now();
    this.animationId = requestAnimationFrame((t) => this.render(t));
  }
  
  stop() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
    this.hideStamp();
  }
  
  destroy() {
    this.stop();
    this.resizeObserver.disconnect();
    this.container.removeChild(this.canvas);
    this.container.removeChild(this.stampOverlay);
  }
  
  // === Animation State ===
  
  initState() {
    const nodeCount = this.settings.size === 'small' ? 5 : 
                      this.settings.size === 'large' ? 12 : 8;
    
    this.state = {
      phase: 'JOURNEY',
      phaseTime: 0,
      journeyStep: 0,
      nodes: [],
      connections: [],
      loopConnections: [],
      circledNode: null,
      fadeOpacity: 1,
      camera: {
        x: 0, y: 0, zoom: 2.2,
        targetX: 0, targetY: 0, targetZoom: 2.2,
        velX: 0, velY: 0, velZoom: 0
      },
      discoveredNodes: new Set()
    };
    
    this.generateNodes(nodeCount);
    this.buildMST();
    this.buildLoops();
    
    // Set initial camera
    if (this.state.nodes.length > 0) {
      const first = this.state.nodes[0];
      this.state.camera.x = this.state.camera.targetX = first.x;
      this.state.camera.y = this.state.camera.targetY = first.y;
    }
  }
  
  generateNodes(count) {
    const nodes = [];
    const padding = 30;
    const bottomPadding = 55; // Extra space at bottom for title overlay
    const minDist = 35;
    const { width, height } = this;
    
    for (let i = 0; i < count; i++) {
      let attempts = 0;
      let placed = false;
      
      while (!placed && attempts < 50) {
        const x = padding + Math.random() * (width - padding * 2);
        const y = padding + Math.random() * (height - padding - bottomPadding);
        
        const tooClose = nodes.some(n => {
          const dx = n.x - x;
          const dy = n.y - y;
          return Math.sqrt(dx * dx + dy * dy) < minDist;
        });
        
        if (!tooClose) {
          const isCircle = Math.random() < this.settings.circleChance;
          nodes.push({
            x, y,
            shape: isCircle ? 'circle' : 'rect',
            size: 5 + Math.random() * 3,
            opacity: 0,
            discovered: i === 0,
            arrivalPulse: 0
          });
          placed = true;
        }
        attempts++;
      }
    }
    
    if (nodes.length > 0) {
      nodes[0].opacity = 1;
      this.state.discoveredNodes.add(0);
      this.state.circledNode = nodes.length - 1;
    }
    
    this.state.nodes = nodes;
  }
  
  buildMST() {
    const nodes = this.state.nodes;
    if (nodes.length < 2) {
      this.state.connections = [];
      return;
    }
    
    const connections = [];
    const connected = new Set([0]);
    const unconnected = new Set(nodes.map((_, i) => i).filter(i => i !== 0));
    
    while (unconnected.size > 0) {
      let bestDist = Infinity;
      let bestEdge = null;
      
      for (const from of connected) {
        for (const to of unconnected) {
          const dx = nodes[to].x - nodes[from].x;
          const dy = nodes[to].y - nodes[from].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < bestDist) {
            bestDist = dist;
            bestEdge = { from, to, distance: dist };
          }
        }
      }
      
      if (bestEdge) {
        connections.push({ ...bestEdge, progress: 0 });
        connected.add(bestEdge.to);
        unconnected.delete(bestEdge.to);
      } else {
        break;
      }
    }
    
    this.state.connections = connections;
  }
  
  buildLoops() {
    const { nodes, connections } = this.state;
    const loops = [];
    const existingPairs = new Set(
      connections.map(c => \`\${Math.min(c.from, c.to)}-\${Math.max(c.from, c.to)}\`)
    );
    
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const key = \`\${i}-\${j}\`;
        if (!existingPairs.has(key) && Math.random() < this.settings.loopChance) {
          loops.push({ from: i, to: j, progress: 0 });
        }
      }
    }
    
    this.state.loopConnections = loops;
  }
  
  // === Easing & Math ===
  
  lerp(a, b, t) { return a + (b - a) * t; }
  
  easeOutCubic(t) { return 1 - Math.pow(1 - t, 3); }
  easeInOutCubic(t) { return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }
  
  easeHandTraced(t) {
    if (t < 0.15) return t * t * 4.44;
    if (t > 0.85) return 1 - Math.pow(1 - t, 2) * 4.44;
    return 0.1 + ((t - 0.15) / 0.7) * 0.8;
  }
  
  smoothDamp(current, target, velocity, smoothTime, dt) {
    const omega = 2 / smoothTime;
    const x = omega * dt;
    const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
    const change = current - target;
    const temp = (velocity + omega * change) * dt;
    const newVel = (velocity - omega * temp) * exp;
    return { value: target + (change + temp) * exp, velocity: newVel };
  }
  
  // === Stamp Control ===
  
  showStamp(screenX, screenY) {
    this.stampOverlay.style.left = screenX + 'px';
    this.stampOverlay.style.top = screenY + 'px';
    this.stampOverlay.style.transform = 'translate(-50%, -50%)';
    this.stampOverlay.style.animation = 'none';
    // Trigger reflow
    this.stampOverlay.offsetHeight;
    this.stampOverlay.style.animation = 'dmt-windrose-stamp 0.35s ease-out forwards';
    this.stampOverlay.style.opacity = '0.75';
  }
  
  hideStamp() {
    this.stampOverlay.style.opacity = '0';
    this.stampOverlay.style.animation = 'none';
  }
  
  // === Rendering ===
  
  render(time) {
    const dt = time - this.lastTime;
    this.lastTime = time;
    const dtSeconds = dt / 1000;
    
    const { state, ctx, width, height } = this;
    state.phaseTime += dt;
    
    // Clear
    ctx.clearRect(0, 0, width, height);
    
    // Smooth camera
    const camSmooth = 0.4;
    let result = this.smoothDamp(state.camera.x, state.camera.targetX, state.camera.velX, camSmooth, dtSeconds);
    state.camera.x = result.value; state.camera.velX = result.velocity;
    
    result = this.smoothDamp(state.camera.y, state.camera.targetY, state.camera.velY, camSmooth, dtSeconds);
    state.camera.y = result.value; state.camera.velY = result.velocity;
    
    result = this.smoothDamp(state.camera.zoom, state.camera.targetZoom, state.camera.velZoom, camSmooth * 1.2, dtSeconds);
    state.camera.zoom = result.value; state.camera.velZoom = result.velocity;
    
    // Apply camera
    ctx.save();
    ctx.translate(width / 2, height / 2);
    ctx.scale(state.camera.zoom, state.camera.zoom);
    ctx.translate(-state.camera.x, -state.camera.y);
    ctx.globalAlpha = state.fadeOpacity;
    
    // Phase logic
    this.updatePhase(dt);
    
    // Draw connections
    state.connections.forEach(conn => {
      if (conn.progress > 0) {
        const from = state.nodes[conn.from];
        const to = state.nodes[conn.to];
        this.drawLine(from, to, conn.progress, false);
      }
    });
    
    // Draw loops
    state.loopConnections.forEach(conn => {
      if (conn.progress > 0) {
        const from = state.nodes[conn.from];
        const to = state.nodes[conn.to];
        this.drawLine(from, to, conn.progress, true);
      }
    });
    
    // Draw nodes
    state.nodes.forEach((node, i) => {
      if (!node.discovered || node.opacity <= 0) return;
      this.drawNode(node);
    });
    
    ctx.restore();
    
    this.animationId = requestAnimationFrame((t) => this.render(t));
  }
  
  updatePhase(dt) {
    const { state, width, height } = this;
    const BASE_JOURNEY_TIME = 350;
    const JOURNEY_VARIANCE = 200;
    const PAUSE_TIME = 180;
    
    switch (state.phase) {
      case 'JOURNEY': {
        const conn = state.connections[state.journeyStep];
        if (!conn) {
          state.phase = 'REVEAL';
          state.phaseTime = 0;
          break;
        }
        
        const variance = Math.sin(state.journeyStep * 7.3 + conn.distance * 0.5) * JOURNEY_VARIANCE;
        const connTime = BASE_JOURNEY_TIME + conn.distance * 2 + variance;
        const totalTime = connTime + PAUSE_TIME;
        
        if (state.phaseTime < connTime) {
          const progress = this.easeHandTraced(state.phaseTime / connTime);
          conn.progress = progress;
          
          const from = state.nodes[conn.from];
          const to = state.nodes[conn.to];
          state.camera.targetX = this.lerp(from.x, to.x, progress);
          state.camera.targetY = this.lerp(from.y, to.y, progress);
          
          const exploreProgress = state.journeyStep / state.connections.length;
          state.camera.targetZoom = this.lerp(2.0, 1.3, exploreProgress);
          
          if (progress > 0.8 && !state.nodes[conn.to].discovered) {
            state.nodes[conn.to].discovered = true;
            state.nodes[conn.to].arrivalPulse = 1;
            state.discoveredNodes.add(conn.to);
          }
        } else {
          conn.progress = 1;
          state.nodes[conn.to].opacity = Math.min(1, state.nodes[conn.to].opacity + 0.15);
          
          if (state.phaseTime >= totalTime) {
            state.journeyStep++;
            state.phaseTime = 0;
          }
        }
        break;
      }
      
      case 'REVEAL': {
        const revealTime = 800;
        const progress = Math.min(1, state.phaseTime / revealTime);
        
        // Calculate graph center
        const nodes = state.nodes;
        const minX = Math.min(...nodes.map(n => n.x));
        const maxX = Math.max(...nodes.map(n => n.x));
        const minY = Math.min(...nodes.map(n => n.y));
        const maxY = Math.max(...nodes.map(n => n.y));
        
        state.camera.targetX = (minX + maxX) / 2;
        state.camera.targetY = (minY + maxY) / 2;
        state.camera.targetZoom = 1.0;
        
        nodes.forEach(n => { if (n.discovered) n.opacity = Math.min(1, n.opacity + 0.1); });
        
        if (progress >= 1) {
          state.phase = 'LOOPING';
          state.phaseTime = 0;
        }
        break;
      }
      
      case 'LOOPING': {
        const loopTime = 600;
        const progress = state.phaseTime / loopTime;
        
        state.loopConnections.forEach((conn, i) => {
          conn.progress = Math.max(0, Math.min(1, (progress - i * 0.15) * 2));
        });
        
        if (progress >= 1 + state.loopConnections.length * 0.1) {
          state.phase = 'STAMPING';
          state.phaseTime = 0;
        }
        break;
      }
      
      case 'STAMPING': {
        if (state.phaseTime < 20 && state.circledNode !== null) {
          const node = state.nodes[state.circledNode];
          if (node) {
            const screenX = (node.x - state.camera.x) * state.camera.zoom + width / 2;
            const screenY = (node.y - state.camera.y) * state.camera.zoom + height / 2;
            this.showStamp(screenX, screenY);
          }
        }
        
        if (state.phaseTime >= 500) {
          state.phase = 'HOLDING';
          state.phaseTime = 0;
        }
        break;
      }
      
      case 'HOLDING': {
        if (state.phaseTime >= 1500) {
          state.phase = 'FADING';
          state.phaseTime = 0;
        }
        break;
      }
      
      case 'FADING': {
        if (state.phaseTime < 20) {
          this.hideStamp();
        }
        
        const fadeTime = 700;
        const progress = state.phaseTime / fadeTime;
        state.fadeOpacity = 1 - this.easeInOutCubic(progress);
        
        if (progress >= 1) {
          state.phase = 'WAITING';
          state.phaseTime = 0;
        }
        break;
      }
      
      case 'WAITING': {
        if (state.phaseTime >= 300) {
          // Reset
          const nodeCount = this.settings.size === 'small' ? 5 : 
                            this.settings.size === 'large' ? 12 : 8;
          
          state.phase = 'JOURNEY';
          state.phaseTime = 0;
          state.journeyStep = 0;
          state.fadeOpacity = 1;
          state.discoveredNodes.clear();
          
          this.generateNodes(nodeCount);
          this.buildMST();
          this.buildLoops();
          
          if (state.nodes.length > 0) {
            const first = state.nodes[0];
            state.camera.x = state.camera.targetX = first.x;
            state.camera.y = state.camera.targetY = first.y;
            state.camera.zoom = state.camera.targetZoom = 2.2;
            state.camera.velX = state.camera.velY = state.camera.velZoom = 0;
          }
        }
        break;
      }
    }
  }
  
  drawLine(from, to, progress, isLoop) {
    if (progress <= 0) return;
    
    const { ctx, colors, settings } = this;
    
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const len = Math.sqrt(dx * dx + dy * dy);
    if (len === 0) return;
    
    const nx = dx / len;
    const ny = dy / len;
    
    // Clip to node edges
    const startPad = from.size + 3;
    const endPad = to.size + 3;
    const x1 = from.x + nx * startPad;
    const y1 = from.y + ny * startPad;
    const x2 = to.x - nx * endPad;
    const y2 = to.y - ny * endPad;
    
    const clippedLen = len - startPad - endPad;
    if (clippedLen <= 0) return;
    
    const wobbleAmount = settings.corridorStyle === 'organic' ? 3 : 0;
    
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    
    const segments = Math.max(5, Math.floor(clippedLen / 8));
    for (let i = 1; i <= segments; i++) {
      const t = i / segments;
      if (t > progress) break;
      
      const px = x1 + (x2 - x1) * t;
      const py = y1 + (y2 - y1) * t;
      
      const wobble = Math.sin(t * Math.PI * 4 + len * 0.1) * wobbleAmount * (0.3 + t * 0.7);
      ctx.lineTo(px - ny * wobble, py + nx * wobble);
    }
    
    ctx.lineWidth = isLoop ? 1.5 : 2.5;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    if (isLoop) {
      ctx.setLineDash([4, 5]);
    } else {
      ctx.setLineDash([]);
    }
    
    const alpha = isLoop ? 0.5 : (0.5 + progress * 0.4);
    ctx.strokeStyle = colors.lineSolid + Math.floor(alpha * 255).toString(16).padStart(2, '0');
    ctx.stroke();
    
    // Pen head
    if (progress < 1 && !isLoop) {
      const headX = x1 + (x2 - x1) * progress;
      const headY = y1 + (y2 - y1) * progress;
      
      ctx.beginPath();
      ctx.arc(headX, headY, 5, 0, Math.PI * 2);
      ctx.fillStyle = colors.nodePulse + '33';
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(headX, headY, 2.5, 0, Math.PI * 2);
      ctx.fillStyle = colors.nodePulse + 'aa';
      ctx.fill();
    }
    
    ctx.setLineDash([]);
  }
  
  drawNode(node) {
    const { ctx, colors, state } = this;
    const nodeAlpha = state.fadeOpacity * node.opacity;
    
    // Arrival pulse
    if (node.arrivalPulse > 0) {
      const pulseRadius = node.size + 10 * node.arrivalPulse;
      ctx.globalAlpha = nodeAlpha * node.arrivalPulse * 0.5;
      ctx.beginPath();
      ctx.arc(node.x, node.y, pulseRadius, 0, Math.PI * 2);
      ctx.strokeStyle = colors.nodePulse;
      ctx.lineWidth = 1.5;
      ctx.stroke();
      node.arrivalPulse = Math.max(0, node.arrivalPulse - 0.025);
    }
    
    // Shadow
    ctx.globalAlpha = nodeAlpha * 0.25;
    const shadowOffset = 2;
    if (node.shape === 'circle') {
      ctx.beginPath();
      ctx.arc(node.x + shadowOffset, node.y + shadowOffset, node.size + 1, 0, Math.PI * 2);
      ctx.fillStyle = colors.node;
      ctx.fill();
    } else {
      ctx.fillStyle = colors.node;
      ctx.fillRect(node.x - node.size + shadowOffset, node.y - node.size + shadowOffset, node.size * 2, node.size * 2);
    }
    
    ctx.globalAlpha = nodeAlpha;
    
    // Node shape
    if (node.shape === 'circle') {
      // Hollow ring
      ctx.beginPath();
      ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2);
      ctx.strokeStyle = colors.node;
      ctx.lineWidth = 2.5;
      ctx.stroke();
      
      // Subtle fill
      ctx.beginPath();
      ctx.arc(node.x, node.y, node.size - 1.5, 0, Math.PI * 2);
      ctx.fillStyle = colors.node + '20';
      ctx.fill();
    } else {
      // Filled square with outline
      const s = node.size;
      ctx.fillStyle = colors.node + '40';
      ctx.fillRect(node.x - s, node.y - s, s * 2, s * 2);
      
      ctx.strokeStyle = colors.node;
      ctx.lineWidth = 2;
      ctx.strokeRect(node.x - s, node.y - s, s * 2, s * 2);
    }
  }
}
`;
```

# settingsPlugin-InsertMapModal

```js
return `// settingsPlugin-InsertMapModal.js
// Modal for inserting a new map block into the editor
// This file is concatenated into the settings plugin template by the assembler

/**
 * Modal for inserting a new map block into the editor
 */
class InsertMapModal extends Modal {
  constructor(app, onInsert) {
    super(app);
    this.onInsert = onInsert;
    this.mapName = '';
    this.mapType = null; // 'grid' or 'hex'
  }
  
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass('dmt-insert-map-modal');
    
    
    contentEl.createEl('h2', { text: 'Insert New Map' });
    
    // Map name input
    new Setting(contentEl)
      .setName('Map name')
      .setDesc('A display name for this map (can be left blank)')
      .addText(text => {
        this.nameInput = text;
        text
          .setPlaceholder('e.g., Goblin Cave Level 1')
          .onChange(value => {
            this.mapName = value;
          });
        // Focus the input after modal opens
        setTimeout(() => text.inputEl.focus(), 10);
      });
    
    // Map type selection
    const typeContainer = contentEl.createDiv({ cls: 'dmt-map-type-selection' });
    typeContainer.createEl('div', { text: 'Map type', cls: 'setting-item-name' });
    typeContainer.createEl('div', { 
      text: 'Choose the grid style for this map', 
      cls: 'setting-item-description' 
    });
    
    const buttonRow = typeContainer.createDiv({ cls: 'dmt-map-type-buttons' });
    
    const gridBtn = buttonRow.createEl('button', { 
      text: 'Grid',
      cls: 'dmt-map-type-btn',
      attr: { type: 'button' }
    });
    
    const hexBtn = buttonRow.createEl('button', { 
      text: 'Hex',
      cls: 'dmt-map-type-btn',
      attr: { type: 'button' }
    });
    
    gridBtn.onclick = () => {
      this.mapType = 'grid';
      gridBtn.addClass('selected');
      hexBtn.removeClass('selected');
    };
    
    hexBtn.onclick = () => {
      this.mapType = 'hex';
      hexBtn.addClass('selected');
      gridBtn.removeClass('selected');
    };
    
    // Buttons
    const buttonContainer = contentEl.createDiv({ cls: 'dmt-modal-buttons' });
    
    const cancelBtn = buttonContainer.createEl('button', { text: 'Cancel' });
    cancelBtn.onclick = () => this.close();
    
    const insertBtn = buttonContainer.createEl('button', { text: 'Insert', cls: 'mod-cta' });
    insertBtn.onclick = () => {
      if (!this.mapType) {
        // Brief visual feedback that type is required
        buttonRow.addClass('dmt-shake');
        setTimeout(() => buttonRow.removeClass('dmt-shake'), 300);
        return;
      }
      this.onInsert(this.mapName, this.mapType);
      this.close();
    };
    
    // Handle Enter key to submit (if type is selected)
    contentEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && this.mapType) {
        e.preventDefault();
        this.onInsert(this.mapName, this.mapType);
        this.close();
      }
    });
  }
  
  onClose() {
    this.contentEl.empty();
  }
}
`;
```

# settingsPlugin-InsertDungeonModal

```js
return `// settingsPlugin-InsertDungeonModal.js
// Modal for generating a random dungeon
// This file is concatenated into the settings plugin template by the assembler

// Style defaults at module scope - avoids recreation on each call
const DUNGEON_STYLE_DEFAULTS = {
  classic: {
    circleChance: 0.3, corridorStyle: 'straight', loopChance: 0.15,
    waterChance: 0.15, doorChance: 0.7, secretDoorChance: 0.05,
    wideCorridorChance: 0.25, roomSizeBias: 0, diagonalCorridorChance: 0.5
  },
  cavern: {
    circleChance: 0.6, corridorStyle: 'organic', loopChance: 0.2,
    waterChance: 0.35, doorChance: 0.3, secretDoorChance: 0.08,
    wideCorridorChance: 0.4, roomSizeBias: 0.3, diagonalCorridorChance: 0.7
  },
  fortress: {
    circleChance: 0, corridorStyle: 'straight', loopChance: 0.08,
    waterChance: 0.05, doorChance: 0.9, secretDoorChance: 0.03,
    wideCorridorChance: 0.5, roomSizeBias: 0.2, diagonalCorridorChance: 0.2
  },
  crypt: {
    circleChance: 0.1, corridorStyle: 'straight', loopChance: 0.02,
    waterChance: 0.1, doorChance: 0.8, secretDoorChance: 0.15,
    wideCorridorChance: 0.1, roomSizeBias: -0.3, diagonalCorridorChance: 0.3
  }
};

/**
 * Stock a generated dungeon with objects using the objectPlacer module.
 * @param {Object} objectPlacer - The loaded objectPlacer module
 * @param {Object} result - The dungeon generation result
 * @param {Object} overrides - Config overrides from the modal
 * @returns {Object} Stock result with objects array
 */
async function stockGeneratedDungeon(plugin, result, overrides) {
  const objectPlacer = await plugin.loadObjectPlacer();
  return objectPlacer.stockDungeon(
    result.metadata.rooms,
    result.metadata.corridorResult,
    result.metadata.doorPositions,
    result.metadata.style || 'classic',
    {
      objectDensity: overrides.objectDensity ?? 1.0,
      monsterWeight: overrides.monsterWeight,
      emptyWeight: overrides.emptyWeight,
      featureWeight: overrides.featureWeight,
      trapWeight: overrides.trapWeight,
      useTemplates: overrides.useTemplates
    },
    {
      entryRoomId: result.metadata.entryRoomId,
      exitRoomId: result.metadata.exitRoomId,
      waterRoomIds: result.metadata.waterRoomIds
    }
  );
}

class InsertDungeonModal extends Modal {
  constructor(app, plugin, onInsert) {
    super(app);
    this.plugin = plugin;
    this.onInsert = onInsert;
    this.mapName = '';
    this.dungeonSize = null; // 'small', 'medium', or 'large'
    this.distancePerCell = 5;
    this.distanceUnit = 'ft';
    this.advancedOpen = false;
    this.dungeonStyle = 'classic'; // Default style
    this.visualizer = null; // DungeonEssenceVisualizer instance
    // Slider references for syncing with style changes
    this.sliderRefs = {};
    this.corridorSelect = null;
    // Config overrides - null means use preset default
    this.configOverrides = {
      circleChance: null,
      loopChance: null,
      doorChance: null,
      secretDoorChance: null,
      wideCorridorChance: null,
      roomSizeBias: null,
      corridorStyle: null,
      diagonalCorridorChance: null,
      style: null,
      // Object placement settings
      objectDensity: null,
      monsterWeight: null,
      emptyWeight: null,
      featureWeight: null,
      trapWeight: null,
      useTemplates: null,
      // Water features
      waterChance: null,
      // Fog of war
      autoFogEnabled: false
    };
  }
  
  getVisualizerSettings() {
    const base = DUNGEON_STYLE_DEFAULTS[this.dungeonStyle] || DUNGEON_STYLE_DEFAULTS.classic;
    
    // Apply any explicit overrides
    const settings = { ...base, size: this.dungeonSize || 'medium' };
    if (this.configOverrides.circleChance !== null) settings.circleChance = this.configOverrides.circleChance;
    if (this.configOverrides.loopChance !== null) settings.loopChance = this.configOverrides.loopChance;
    if (this.configOverrides.corridorStyle !== null) settings.corridorStyle = this.configOverrides.corridorStyle;
    
    return settings;
  }
  
  // Update visualizer with current settings
  updateVisualizer() {
    if (this.visualizer) {
      this.visualizer.updateSettings(this.getVisualizerSettings());
    }
  }

  syncSlidersToStyle() {
    const defaults = DUNGEON_STYLE_DEFAULTS[this.dungeonStyle] || DUNGEON_STYLE_DEFAULTS.classic;

    // Update each slider to the style default
    for (const [key, ref] of Object.entries(this.sliderRefs)) {
      if (defaults[key] !== undefined) {
        ref.slider.value = String(defaults[key]);
        ref.valueDisplay.textContent = ref.formatFn(defaults[key]);
        // Clear override so generator uses style default
        this.configOverrides[key] = null;
      }
    }

    // Update corridor style select
    if (this.corridorSelect && defaults.corridorStyle) {
      this.corridorSelect.value = defaults.corridorStyle;
      this.configOverrides.corridorStyle = null;
    }

    this.updateVisualizer();
  }
  
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass('dmt-insert-dungeon-modal');
    
    // === Header with Visualizer ===
    const headerContainer = contentEl.createDiv({ cls: 'dmt-dungeon-header' });
    
    // Visualizer canvas container
    const visualizerContainer = headerContainer.createDiv({ cls: 'dmt-dungeon-visualizer' });
    
    // Title overlay at bottom of visualizer
    const titleOverlay = headerContainer.createDiv({ cls: 'dmt-dungeon-title-overlay' });
    titleOverlay.createEl('h2', { text: 'Generate Random Dungeon' });
    
    // Initialize visualizer
    this.visualizer = new DungeonEssenceVisualizer(visualizerContainer, {
      height: 180,
      settings: this.getVisualizerSettings()
    });
    this.visualizer.start();
    
    // Map name input
    new Setting(contentEl)
      .setName('Map name')
      .setDesc('A display name for this dungeon map (can be left blank)')
      .addText(text => {
        this.nameInput = text;
        text
          .setPlaceholder('e.g., Goblin Cave Level 1')
          .onChange(value => {
            this.mapName = value;
          });
        // Focus the input after modal opens
        setTimeout(() => text.inputEl.focus(), 10);
      });
    
    // Dungeon style selection
    const styleContainer = contentEl.createDiv({ cls: 'dmt-dungeon-style-selection' });
    styleContainer.createEl('div', { text: 'Style', cls: 'setting-item-name' });
    styleContainer.createEl('div', { 
      text: 'Choose the architectural style of the dungeon', 
      cls: 'setting-item-description' 
    });
    
    const styleRow = styleContainer.createDiv({ cls: 'dmt-dungeon-style-buttons' });
    
    const styleInfo = {
      classic: { label: 'Classic', desc: 'Balanced mix of rooms and corridors' },
      cavern: { label: 'Cavern', desc: 'Natural caves with organic passages' },
      fortress: { label: 'Fortress', desc: 'Military structure, wide corridors' },
      crypt: { label: 'Crypt', desc: 'Tight passages, hidden chambers' }
    };
    
    const styleButtons = {};
    
    for (const [style, info] of Object.entries(styleInfo)) {
      const btn = styleRow.createEl('button', { 
        cls: 'dmt-dungeon-style-btn',
        text: info.label,
        attr: { type: 'button', title: info.desc }
      });
      styleButtons[style] = btn;
      
      btn.onclick = () => {
        this.dungeonStyle = style;
        this.configOverrides.style = style === 'classic' ? null : style;
        Object.values(styleButtons).forEach(b => b.removeClass('selected'));
        btn.addClass('selected');
        this.syncSlidersToStyle();
      };
    }
    
    // Default to classic selected
    styleButtons.classic.addClass('selected');
    
    // Dungeon size selection
    const sizeContainer = contentEl.createDiv({ cls: 'dmt-dungeon-size-selection' });
    sizeContainer.createEl('div', { text: 'Dungeon size', cls: 'setting-item-name' });
    sizeContainer.createEl('div', { 
      text: 'Choose the overall size of the generated dungeon', 
      cls: 'setting-item-description' 
    });
    
    const buttonRow = sizeContainer.createDiv({ cls: 'dmt-dungeon-size-buttons' });
    
    const presetInfo = {
      small: { label: 'Small', desc: '3-5 rooms, tight layout' },
      medium: { label: 'Medium', desc: '8-12 rooms, multiple paths' },
      large: { label: 'Large', desc: '10-15 rooms, grand scale' }
    };
    
    const buttons = {};
    
    for (const [preset, info] of Object.entries(presetInfo)) {
      const btn = buttonRow.createEl('button', { 
        cls: 'dmt-dungeon-size-btn',
        text: info.label,
        attr: { type: 'button', title: info.desc }
      });
      buttons[preset] = btn;
      
      btn.onclick = () => {
        this.dungeonSize = preset;
        Object.values(buttons).forEach(b => b.removeClass('selected'));
        btn.addClass('selected');
        this.updateVisualizer();
      };
    }
    
    // Distance measurement settings
    const distContainer = contentEl.createDiv({ cls: 'dmt-dungeon-size-selection' });
    distContainer.createEl('div', { text: 'Distance measurement', cls: 'setting-item-name' });
    distContainer.createEl('div', { 
      text: 'Set the scale for distance measurement on this map', 
      cls: 'setting-item-description' 
    });
    
    const distRow = distContainer.createDiv({ cls: 'dmt-dungeon-distance-row' });
    
    const distInput = distRow.createEl('input', {
      type: 'number',
      value: String(this.distancePerCell),
      attr: { min: '1', step: '1' }
    });
    distInput.addEventListener('change', (e) => {
      this.distancePerCell = parseInt(e.target.value) || 5;
    });
    
    distRow.createEl('span', { text: 'per cell, unit:' });
    
    const unitInput = distRow.createEl('input', {
      type: 'text',
      value: this.distanceUnit
    });
    unitInput.addEventListener('change', (e) => {
      this.distanceUnit = e.target.value || 'ft';
    });
    
    // Advanced options (collapsed by default)
    const advancedContainer = contentEl.createDiv({ cls: 'dmt-dungeon-advanced' });
    
    const advancedHeader = advancedContainer.createDiv({ cls: 'dmt-dungeon-advanced-header' });
    const chevron = advancedHeader.createSpan({ cls: 'dmt-dungeon-advanced-chevron', text: '' });
    advancedHeader.createSpan({ text: 'Advanced Options' });
    
    const advancedContent = advancedContainer.createDiv({ cls: 'dmt-dungeon-advanced-content' });
    advancedContent.style.display = 'none';
    
    advancedHeader.onclick = () => {
      this.advancedOpen = !this.advancedOpen;
      advancedContent.style.display = this.advancedOpen ? 'block' : 'none';
      chevron.textContent = this.advancedOpen ? '' : '';
    };
    
    // Helper to create a slider row
    const createSlider = (container, label, key, min, max, step, defaultVal, formatFn) => {
      const row = container.createDiv({ cls: 'dmt-dungeon-slider-row' });
      row.createEl('label', { text: label });

      const sliderContainer = row.createDiv({ cls: 'dmt-dungeon-slider-container' });
      const slider = sliderContainer.createEl('input', {
        type: 'range',
        attr: { min: String(min), max: String(max), step: String(step) }
      });
      slider.value = String(defaultVal);

      const valueDisplay = sliderContainer.createSpan({
        cls: 'dmt-dungeon-slider-value',
        text: formatFn(defaultVal)
      });

      slider.addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        valueDisplay.textContent = formatFn(val);
        this.configOverrides[key] = val;
        this.updateVisualizer();
      });

      // Store reference for style sync
      this.sliderRefs[key] = { slider, valueDisplay, formatFn };

      return { slider, valueDisplay };
    };
    
    // Percentage formatter
    const pct = (v) => \`\${Math.round(v * 100)}%\`;
    // Bias formatter  
    const biasLabel = (v) => {
      if (v < -0.3) return 'Compact';
      if (v > 0.3) return 'Spacious';
      return 'Normal';
    };
    
    createSlider(advancedContent, 'Circular Rooms', 'circleChance', 0, 1, 0.05, 0.3, pct);
    createSlider(advancedContent, 'Extra Connections', 'loopChance', 0, 0.5, 0.05, 0.15, pct);
    createSlider(advancedContent, 'Door Frequency', 'doorChance', 0, 1, 0.05, 0.7, pct);
    createSlider(advancedContent, 'Secret Doors', 'secretDoorChance', 0, 1, 0.05, 0.05, pct);
    createSlider(advancedContent, 'Wide Corridors', 'wideCorridorChance', 0, 1, 0.05, 0.25, pct);
    createSlider(advancedContent, 'Room Size Bias', 'roomSizeBias', -1, 1, 0.1, 0, biasLabel);
    
    // Corridor style toggle
    const corridorRow = advancedContent.createDiv({ cls: 'dmt-dungeon-slider-row' });
    corridorRow.createEl('label', { text: 'Corridor Style' });
    const corridorToggleContainer = corridorRow.createDiv({ cls: 'dmt-dungeon-toggle-container' });

    const corridorSelect = corridorToggleContainer.createEl('select', { cls: 'dmt-dungeon-select' });
    corridorSelect.createEl('option', { value: 'straight', text: 'Straight' });
    corridorSelect.createEl('option', { value: 'organic', text: 'Organic' });
    corridorSelect.createEl('option', { value: 'diagonal', text: 'Diagonal' });
    corridorSelect.value = 'straight';
    this.corridorSelect = corridorSelect; // Store reference for style sync

    corridorSelect.addEventListener('change', (e) => {
      this.configOverrides.corridorStyle = e.target.value;
      this.updateVisualizer();
    });

    // Diagonal corridor chance slider
    const diagonalLabel = (v) => v === 0 ? 'None' : \`\${Math.round(v * 100)}%\`;
    createSlider(advancedContent, 'Diagonal Corridors', 'diagonalCorridorChance', 0, 1, 0.1, 0.5, diagonalLabel);

    // Environment section
    advancedContent.createEl('div', { cls: 'dmt-dungeon-section-header', text: 'Environment' });

    const waterLabel = (v) => v === 0 ? 'None' : \`\${Math.round(v * 100)}%\`;
    createSlider(advancedContent, 'Water Features', 'waterChance', 0, 0.5, 0.05, 0.15, waterLabel);

    // Object placement section
    advancedContent.createEl('div', { cls: 'dmt-dungeon-section-header', text: 'Object Placement' });

    const densityLabel = (v) => v < 0.75 ? 'Sparse' : v > 1.25 ? 'Dense' : 'Normal';
    createSlider(advancedContent, 'Object Density', 'objectDensity', 0.5, 2, 0.1, 1.0, densityLabel);

    // Room templates toggle
    const templateRow = advancedContent.createDiv({ cls: 'dmt-dungeon-slider-row' });
    templateRow.createEl('label', { text: 'Room Templates' });
    const templateToggleContainer = templateRow.createDiv({ cls: 'dmt-dungeon-toggle-container' });
    const templateCheckbox = templateToggleContainer.createEl('input', {
      type: 'checkbox',
      attr: { id: 'dmt-template-toggle' }
    });
    templateCheckbox.checked = true; // Default to enabled
    templateToggleContainer.createEl('label', {
      attr: { for: 'dmt-template-toggle' },
      text: 'Enable',
      cls: 'dmt-checkbox-label'
    });
    templateCheckbox.addEventListener('change', (e) => {
      this.configOverrides.useTemplates = e.target.checked;
    });
    // Hint text below checkbox row
    advancedContent.createEl('div', {
      cls: 'dmt-checkbox-hint',
      text: 'Generates themed rooms (library, shrine, barracks) with appropriate objects'
    });

    advancedContent.createEl('div', { cls: 'dmt-dungeon-subsection', text: 'Room Categories' });
    createSlider(advancedContent, 'Monsters', 'monsterWeight', 0, 1, 0.05, 0.33, pct);
    createSlider(advancedContent, 'Empty Rooms', 'emptyWeight', 0, 1, 0.05, 0.33, pct);
    createSlider(advancedContent, 'Features', 'featureWeight', 0, 1, 0.05, 0.17, pct);
    createSlider(advancedContent, 'Traps', 'trapWeight', 0, 1, 0.05, 0.17, pct);

    // Auto-fog section
    advancedContent.createEl('div', { cls: 'dmt-dungeon-section-header', text: 'Solo Play' });

    const fogRow = advancedContent.createDiv({ cls: 'dmt-dungeon-slider-row' });
    fogRow.createEl('label', { text: 'Auto-Fog Dungeon' });
    const fogToggleContainer = fogRow.createDiv({ cls: 'dmt-dungeon-toggle-container' });
    const fogCheckbox = fogToggleContainer.createEl('input', {
      type: 'checkbox',
      attr: { id: 'dmt-fog-toggle' }
    });
    fogCheckbox.checked = false;
    fogToggleContainer.createEl('label', {
      attr: { for: 'dmt-fog-toggle' },
      text: 'Enable',
      cls: 'dmt-checkbox-label'
    });
    fogCheckbox.addEventListener('change', (e) => {
      this.configOverrides.autoFogEnabled = e.target.checked;
    });
    advancedContent.createEl('div', {
      cls: 'dmt-checkbox-hint',
      text: 'Cover dungeon with fog, revealing only the entrance room'
    });

    // Buttons
    const buttonContainer = contentEl.createDiv({ cls: 'dmt-modal-buttons' });
    
    const cancelBtn = buttonContainer.createEl('button', { text: 'Cancel' });
    cancelBtn.onclick = () => this.close();
    
    const generateBtn = buttonContainer.createEl('button', { text: 'Generate', cls: 'mod-cta' });
    generateBtn.onclick = async () => {
      if (!this.dungeonSize) {
        // Brief visual feedback that size is required
        buttonRow.addClass('dmt-shake');
        setTimeout(() => buttonRow.removeClass('dmt-shake'), 300);
        return;
      }

      // Load generator
      try {
        const generator = await this.plugin.loadDungeonGenerator();

        // Build config overrides (only include non-null values)
        const overrides = {};
        for (const [key, val] of Object.entries(this.configOverrides)) {
          if (val !== null) overrides[key] = val;
        }

        const result = generator.generateDungeon(this.dungeonSize, undefined, overrides);
        const stockResult = await stockGeneratedDungeon(this.plugin, result, overrides);
        const allObjects = [...result.objects, ...stockResult.objects];

        await this.onInsert(this.mapName, result.cells, allObjects, result.edges || [], {
          distancePerCell: this.distancePerCell,
          distanceUnit: this.distanceUnit,
          preset: this.dungeonSize,
          configOverrides: overrides,
          roomCount: result.metadata.roomCount,
          doorCount: result.metadata.doorCount,
          stockingMetadata: {
            rooms: result.metadata.rooms,
            corridorResult: result.metadata.corridorResult,
            doorPositions: result.metadata.doorPositions,
            entryRoomId: result.metadata.entryRoomId,
            exitRoomId: result.metadata.exitRoomId,
            waterRoomIds: result.metadata.waterRoomIds,
            style: result.metadata.style
          }
        });
        this.close();
      } catch (err) {
        console.error('[Windrose] Dungeon generation failed:', err);
        alert('Failed to generate dungeon: ' + err.message);
      }
    };

    // Handle Enter key to submit (if size is selected)
    contentEl.addEventListener('keydown', async (e) => {
      if (e.key === 'Enter' && this.dungeonSize) {
        e.preventDefault();
        try {
          const generator = await this.plugin.loadDungeonGenerator();

          // Build config overrides (only include non-null values)
          const overrides = {};
          for (const [key, val] of Object.entries(this.configOverrides)) {
            if (val !== null) overrides[key] = val;
          }

          const result = generator.generateDungeon(this.dungeonSize, undefined, overrides);
          const stockResult = await stockGeneratedDungeon(this.plugin, result, overrides);
          const allObjects = [...result.objects, ...stockResult.objects];

          await this.onInsert(this.mapName, result.cells, allObjects, result.edges || [], {
            distancePerCell: this.distancePerCell,
            distanceUnit: this.distanceUnit,
            preset: this.dungeonSize,
            configOverrides: overrides,
            roomCount: result.metadata.roomCount,
            doorCount: result.metadata.doorCount,
            stockingMetadata: {
              rooms: result.metadata.rooms,
              corridorResult: result.metadata.corridorResult,
              doorPositions: result.metadata.doorPositions,
              entryRoomId: result.metadata.entryRoomId,
              exitRoomId: result.metadata.exitRoomId,
              waterRoomIds: result.metadata.waterRoomIds,
              style: result.metadata.style
            }
          });
          this.close();
        } catch (err) {
          console.error('[Windrose] Dungeon generation failed:', err);
          alert('Failed to generate dungeon: ' + err.message);
        }
      }
    });
  }

  onClose() {
    if (this.visualizer) {
      this.visualizer.destroy();
      this.visualizer = null;
    }
    this.sliderRefs = {};
    this.corridorSelect = null;
    this.contentEl.empty();
  }
}`;
```

# settingsPlugin-ObjectEditModal

```js
return `// settingsPlugin-ObjectEditModal.js
// Modal for editing object properties (symbol, label, category)
// This file is concatenated into the settings plugin template by the assembler

/**
 * Modal for editing object properties (symbol, label, category)
 */
class ObjectEditModal extends Modal {
  constructor(app, plugin, existingObject, onSave, mapType = 'grid') {
    super(app);
    this.plugin = plugin;
    this.existingObject = existingObject;
    this.onSave = onSave;
    this.mapType = mapType;
    
    // Form state
    this.symbol = existingObject?.symbol || '';
    this.iconClass = existingObject?.iconClass || '';
    this.label = existingObject?.label || '';
    this.category = existingObject?.category || 'features';
    
    // UI state - determine initial mode based on existing object
    this.useIcon = !!existingObject?.iconClass;
    this.iconSearchQuery = '';
    this.iconCategory = 'all';
  }
  
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass('dmt-object-edit-modal');
    
    const isEditing = !!this.existingObject;
    
    contentEl.createEl('h2', { text: isEditing ? 'Edit Object' : 'Create Custom Object' });
    
    // Icon type toggle
    const toggleContainer = contentEl.createDiv({ cls: 'dmt-icon-type-toggle' });
    
    const unicodeBtn = toggleContainer.createEl('button', { 
      text: 'Unicode Symbol',
      cls: 'dmt-icon-type-btn' + (this.useIcon ? '' : ' active'),
      attr: { type: 'button' }
    });
    
    const iconBtn = toggleContainer.createEl('button', { 
      text: 'RPGAwesome Icon',
      cls: 'dmt-icon-type-btn' + (this.useIcon ? ' active' : ''),
      attr: { type: 'button' }
    });
    
    // Container for symbol input (shown when useIcon is false)
    this.symbolContainer = contentEl.createDiv({ cls: 'dmt-symbol-container' });
    
    // Container for icon picker (shown when useIcon is true)
    this.iconPickerContainer = contentEl.createDiv({ cls: 'dmt-icon-picker-container' });
    
    // Toggle handlers
    unicodeBtn.onclick = () => {
      if (!this.useIcon) return;
      this.useIcon = false;
      unicodeBtn.addClass('active');
      iconBtn.removeClass('active');
      this.renderSymbolInput();
      this.renderIconPicker();
    };
    
    iconBtn.onclick = () => {
      if (this.useIcon) return;
      this.useIcon = true;
      iconBtn.addClass('active');
      unicodeBtn.removeClass('active');
      this.renderSymbolInput();
      this.renderIconPicker();
    };
    
    // Initial render of symbol/icon sections
    this.renderSymbolInput();
    this.renderIconPicker();
    
    // Label input
    new Setting(contentEl)
      .setName('Label')
      .setDesc('Display name for this object')
      .addText(text => text
        .setValue(this.label)
        .setPlaceholder('e.g., Treasure Chest')
        .onChange(value => {
          this.label = value;
        }));
    
    // Category dropdown
    const allCategories = ObjectHelpers.getAllCategories(this.plugin.settings);
    new Setting(contentEl)
      .setName('Category')
      .setDesc('Group this object belongs to')
      .addDropdown(dropdown => {
        for (const cat of allCategories) {
          dropdown.addOption(cat.id, cat.label);
        }
        dropdown.setValue(this.category);
        dropdown.onChange(value => {
          this.category = value;
        });
      });
    
    // Buttons
    const buttonContainer = contentEl.createDiv({ cls: 'dmt-modal-buttons' });
    
    const cancelBtn = buttonContainer.createEl('button', { text: 'Cancel' });
    cancelBtn.onclick = () => this.close();
    
    const saveBtn = buttonContainer.createEl('button', { text: 'Save', cls: 'mod-cta' });
    saveBtn.onclick = () => this.save();
  }
  
  renderSymbolInput() {
    const container = this.symbolContainer;
    container.empty();
    
    if (this.useIcon) {
      container.style.display = 'none';
      return;
    }
    container.style.display = 'block';
    
    // Symbol input with preview
    const symbolSetting = new Setting(container)
      .setName('Symbol')
      .setDesc('Paste any Unicode character or emoji');
    
    const symbolInput = symbolSetting.controlEl.createEl('input', {
      type: 'text',
      cls: 'dmt-symbol-input',
      value: this.symbol,
      attr: { placeholder: 'Paste symbol...' }
    });
    symbolInput.addEventListener('input', (e) => {
      this.symbol = e.target.value.trim();
      this.updateSymbolPreview();
    });
    
    // Focus the symbol input after a short delay
    setTimeout(() => symbolInput.focus(), 50);
    
    // Symbol preview
    const previewEl = symbolSetting.controlEl.createDiv({ cls: 'dmt-symbol-preview' });
    previewEl.textContent = this.symbol || '?';
    this.symbolPreviewEl = previewEl;
    this.symbolInputEl = symbolInput;
    
    // Quick symbols
    const quickSymbolsContainer = container.createDiv({ cls: 'dmt-quick-symbols' });
    quickSymbolsContainer.createEl('label', { text: 'Quick Symbols', cls: 'dmt-quick-symbols-label' });
    const symbolGrid = quickSymbolsContainer.createDiv({ cls: 'dmt-quick-symbols-grid' });
    
    for (const sym of QUICK_SYMBOLS) {
      const symBtn = symbolGrid.createEl('button', { 
        text: sym, 
        cls: 'dmt-quick-symbol-btn',
        attr: { type: 'button' }
      });
      symBtn.onclick = () => {
        this.symbol = sym;
        symbolInput.value = sym;
        this.updateSymbolPreview();
      };
    }
  }
  
  renderIconPicker() {
    const container = this.iconPickerContainer;
    container.empty();
    
    if (!this.useIcon) {
      container.style.display = 'none';
      return;
    }
    container.style.display = 'block';
    
    const picker = container.createDiv({ cls: 'dmt-icon-picker' });
    
    // Search input
    const searchContainer = picker.createDiv({ cls: 'dmt-icon-picker-search' });
    const searchInput = searchContainer.createEl('input', {
      type: 'text',
      value: this.iconSearchQuery,
      attr: { placeholder: 'Search icons...' }
    });
    searchInput.addEventListener('input', (e) => {
      this.iconSearchQuery = e.target.value;
      this.renderIconGrid();
    });
    
    // Category tabs
    const tabsContainer = picker.createDiv({ cls: 'dmt-icon-picker-tabs' });
    
    // "All" tab
    const allTab = tabsContainer.createEl('button', {
      text: 'All',
      cls: 'dmt-icon-picker-tab' + (this.iconCategory === 'all' ? ' active' : ''),
      attr: { type: 'button' }
    });
    allTab.onclick = () => {
      this.iconCategory = 'all';
      this.renderIconTabs(tabsContainer);
      this.renderIconGrid();
    };
    
    // Category tabs
    const categories = RPGAwesomeHelpers.getCategories();
    for (const cat of categories) {
      const tab = tabsContainer.createEl('button', {
        text: cat.label,
        cls: 'dmt-icon-picker-tab' + (this.iconCategory === cat.id ? ' active' : ''),
        attr: { type: 'button', 'data-category': cat.id }
      });
      tab.onclick = () => {
        this.iconCategory = cat.id;
        this.renderIconTabs(tabsContainer);
        this.renderIconGrid();
      };
    }
    this.tabsContainer = tabsContainer;
    
    // Icon grid
    this.iconGridContainer = picker.createDiv({ cls: 'dmt-icon-picker-grid' });
    this.renderIconGrid();
    
    // Selected icon preview
    this.iconPreviewContainer = picker.createDiv({ cls: 'dmt-icon-preview-row' });
    this.updateIconPreview();
  }
  
  renderIconTabs(container) {
    // Update active state on all tabs
    const tabs = container.querySelectorAll('.dmt-icon-picker-tab');
    tabs.forEach(tab => {
      const catId = tab.getAttribute('data-category') || 'all';
      if (catId === this.iconCategory) {
        tab.addClass('active');
      } else {
        tab.removeClass('active');
      }
    });
  }
  
  renderIconGrid() {
    const container = this.iconGridContainer;
    if (!container) return;
    container.empty();
    
    // Get icons based on search or category
    let icons;
    if (this.iconSearchQuery.trim()) {
      icons = RPGAwesomeHelpers.search(this.iconSearchQuery);
    } else {
      icons = RPGAwesomeHelpers.getByCategory(this.iconCategory);
    }
    
    if (icons.length === 0) {
      container.createDiv({ cls: 'dmt-icon-picker-empty', text: 'No icons found' });
      return;
    }
    
    // Render icon buttons
    for (const icon of icons) {
      const iconBtn = container.createEl('button', {
        cls: 'dmt-icon-picker-icon' + (this.iconClass === icon.iconClass ? ' selected' : ''),
        attr: { 
          type: 'button',
          title: icon.label
        }
      });
      
      // Create the icon span with the character
      const iconSpan = iconBtn.createEl('span', { cls: 'ra' });
      iconSpan.textContent = icon.char;
      
      iconBtn.onclick = () => {
        this.iconClass = icon.iconClass;
        // Update selection state
        container.querySelectorAll('.dmt-icon-picker-icon').forEach(btn => btn.removeClass('selected'));
        iconBtn.addClass('selected');
        this.updateIconPreview();
      };
    }
  }
  
  updateSymbolPreview() {
    if (this.symbolPreviewEl) {
      this.symbolPreviewEl.textContent = this.symbol || '?';
    }
  }
  
  updateIconPreview() {
    const container = this.iconPreviewContainer;
    if (!container) return;
    container.empty();
    
    if (!this.iconClass) {
      container.createDiv({ cls: 'dmt-icon-preview-info', text: 'Select an icon above' });
      return;
    }
    
    const iconInfo = RPGAwesomeHelpers.getInfo(this.iconClass);
    if (!iconInfo) {
      container.createDiv({ cls: 'dmt-icon-preview-info', text: 'Invalid icon selected' });
      return;
    }
    
    // Large preview
    const previewBox = container.createDiv({ cls: 'dmt-icon-preview-large' });
    const iconSpan = previewBox.createEl('span', { cls: 'ra' });
    iconSpan.textContent = iconInfo.char;
    
    // Info
    const infoBox = container.createDiv({ cls: 'dmt-icon-preview-info' });
    infoBox.createDiv({ cls: 'dmt-icon-preview-label', text: iconInfo.label });
    infoBox.createDiv({ cls: 'dmt-icon-preview-class', text: this.iconClass });
  }
  
  save() {
    // Validate based on mode
    if (this.useIcon) {
      if (!this.iconClass || !RPGAwesomeHelpers.isValid(this.iconClass)) {
        alert('Please select a valid icon');
        return;
      }
    } else {
      if (!this.symbol || this.symbol.length === 0 || this.symbol.length > 8) {
        alert('Please enter a valid symbol (1-8 characters)');
        return;
      }
    }
    
    if (!this.label || this.label.trim().length === 0) {
      alert('Please enter a label');
      return;
    }
    
    // Get the correct settings keys for this map type
    const overridesKey = this.mapType === 'hex' ? 'hexObjectOverrides' : 'gridObjectOverrides';
    const customObjectsKey = this.mapType === 'hex' ? 'customHexObjects' : 'customGridObjects';
    
    if (this.existingObject?.isBuiltIn) {
      // Modifying a built-in: save as override
      if (!this.plugin.settings[overridesKey]) {
        this.plugin.settings[overridesKey] = {};
      }
      
      const original = BUILT_IN_OBJECTS.find(o => o.id === this.existingObject.id);
      const override = {};
      
      // Handle symbol/iconClass based on mode
      if (this.useIcon) {
        if (this.iconClass !== original.iconClass) override.iconClass = this.iconClass;
        // Clear symbol override if switching to icon
        if (original.symbol && !this.iconClass) override.symbol = null;
      } else {
        if (this.symbol !== original.symbol) override.symbol = this.symbol;
        // Clear iconClass override if switching to symbol
        if (original.iconClass) override.iconClass = null;
      }
      
      if (this.label !== original.label) override.label = this.label;
      if (this.category !== original.category) override.category = this.category;
      
      // Preserve hidden state if it exists
      if (this.plugin.settings[overridesKey][this.existingObject.id]?.hidden) {
        override.hidden = true;
      }
      
      // Preserve order if it exists
      if (this.plugin.settings[overridesKey][this.existingObject.id]?.order !== undefined) {
        override.order = this.plugin.settings[overridesKey][this.existingObject.id].order;
      }
      
      if (Object.keys(override).length > 0) {
        this.plugin.settings[overridesKey][this.existingObject.id] = override;
      } else {
        delete this.plugin.settings[overridesKey][this.existingObject.id];
      }
    } else if (this.existingObject?.isCustom) {
      // Editing existing custom object
      if (!this.plugin.settings[customObjectsKey]) {
        this.plugin.settings[customObjectsKey] = [];
      }
      const idx = this.plugin.settings[customObjectsKey].findIndex(o => o.id === this.existingObject.id);
      if (idx !== -1) {
        const updated = {
          ...this.plugin.settings[customObjectsKey][idx],
          label: this.label.trim(),
          category: this.category
        };
        
        // Set symbol or iconClass based on mode
        if (this.useIcon) {
          updated.iconClass = this.iconClass;
          delete updated.symbol;
        } else {
          updated.symbol = this.symbol;
          delete updated.iconClass;
        }
        
        this.plugin.settings[customObjectsKey][idx] = updated;
      }
    } else {
      // Creating new custom object
      if (!this.plugin.settings[customObjectsKey]) {
        this.plugin.settings[customObjectsKey] = [];
      }
      
      const newObject = {
        id: 'custom-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
        label: this.label.trim(),
        category: this.category
      };
      
      // Set symbol or iconClass based on mode
      if (this.useIcon) {
        newObject.iconClass = this.iconClass;
      } else {
        newObject.symbol = this.symbol;
      }
      
      this.plugin.settings[customObjectsKey].push(newObject);
    }
    
    this.onSave();
    this.close();
  }
  
  onClose() {
    this.contentEl.empty();
  }
}
`;
```

# settingsPlugin-CategoryEditModal

```js
return `// settingsPlugin-CategoryEditModal.js
// Modal for editing category properties
// This file is concatenated into the settings plugin template by the assembler

/**
 * Modal for editing category properties
 */
class CategoryEditModal extends Modal {
  constructor(app, plugin, existingCategory, onSave, mapType = 'grid') {
    super(app);
    this.plugin = plugin;
    this.existingCategory = existingCategory;
    this.onSave = onSave;
    this.mapType = mapType;
    
    this.label = existingCategory?.label || '';
    this.order = existingCategory?.order ?? 100;
  }
  
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass('dmt-category-edit-modal');
    
    const isEditing = !!this.existingCategory;
    
    contentEl.createEl('h2', { text: isEditing ? 'Edit Category' : 'Create Custom Category' });
    
    let nameInputEl = null;
    new Setting(contentEl)
      .setName('Name')
      .setDesc('Display name for this category')
      .addText(text => {
        nameInputEl = text.inputEl;
        text.setValue(this.label)
          .setPlaceholder('e.g., Alchemy')
          .onChange(value => {
            this.label = value;
          });
      });
    
    // Focus the name input after a short delay
    if (nameInputEl) {
      setTimeout(() => nameInputEl.focus(), 50);
    }
    
    new Setting(contentEl)
      .setName('Sort Order')
      .setDesc('Lower numbers appear first (built-ins use 0-50)')
      .addText(text => text
        .setValue(String(this.order))
        .setPlaceholder('100')
        .onChange(value => {
          const num = parseInt(value, 10);
          if (!isNaN(num)) {
            this.order = num;
          }
        }));
    
    const buttonContainer = contentEl.createDiv({ cls: 'dmt-modal-buttons' });
    
    const cancelBtn = buttonContainer.createEl('button', { text: 'Cancel' });
    cancelBtn.onclick = () => this.close();
    
    const saveBtn = buttonContainer.createEl('button', { text: 'Save', cls: 'mod-cta' });
    saveBtn.onclick = () => this.save();
  }
  
  save() {
    if (!this.label || this.label.trim().length === 0) {
      alert('Please enter a category name');
      return;
    }
    
    // Get the correct settings key for this map type
    const categoriesKey = this.mapType === 'hex' ? 'customHexCategories' : 'customGridCategories';
    
    if (!this.plugin.settings[categoriesKey]) {
      this.plugin.settings[categoriesKey] = [];
    }
    
    if (this.existingCategory) {
      const idx = this.plugin.settings[categoriesKey].findIndex(c => c.id === this.existingCategory.id);
      if (idx !== -1) {
        this.plugin.settings[categoriesKey][idx] = {
          ...this.plugin.settings[categoriesKey][idx],
          label: this.label.trim(),
          order: this.order
        };
      }
    } else {
      const newCategory = {
        id: 'custom-cat-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
        label: this.label.trim(),
        order: this.order
      };
      
      this.plugin.settings[categoriesKey].push(newCategory);
    }
    
    this.onSave();
    this.close();
  }
  
  onClose() {
    this.contentEl.empty();
  }
}
`;
```

# settingsPlugin-ColorEditModal

```js
return `// settingsPlugin-ColorEditModal.js
// Modal for editing color palette entries
// This file is concatenated into the settings plugin template by the assembler

/**
 * Modal for editing color palette entries
 */
class ColorEditModal extends Modal {
  constructor(app, plugin, existingColor, onSave) {
    super(app);
    this.plugin = plugin;
    this.existingColor = existingColor;
    this.onSave = onSave;
    this.isBuiltIn = existingColor?.isBuiltIn || false;
  }
  
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass('dmt-color-edit-modal');
    
    const isEdit = !!this.existingColor;
    const isBuiltIn = this.isBuiltIn;
    
    contentEl.createEl('h2', { 
      text: isEdit 
        ? (isBuiltIn ? \`Edit: \${this.existingColor.label}\` : 'Edit Custom Color')
        : 'Add Custom Color' 
    });
    
    // Get original built-in values if editing a built-in
    const originalBuiltIn = isBuiltIn 
      ? BUILT_IN_COLORS.find(c => c.id === this.existingColor.id)
      : null;
    
    // Initialize form values
    let colorValue = this.existingColor?.color || '#808080';
    let labelValue = this.existingColor?.label || '';
    let opacityValue = this.existingColor?.opacity ?? 1;
    
    // Color picker
    new Setting(contentEl)
      .setName('Color')
      .setDesc('Choose the color value')
      .addColorPicker(picker => picker
        .setValue(colorValue)
        .onChange(value => {
          colorValue = value;
          hexInput.value = value;
        }))
      .addText(text => {
        text.inputEl.addClass('dmt-color-hex-input');
        text.setPlaceholder('#RRGGBB')
          .setValue(colorValue)
          .onChange(value => {
            if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
              colorValue = value;
            }
          });
        // Store reference for color picker sync
        var hexInput = text.inputEl;
      });
    
    // Label input
    new Setting(contentEl)
      .setName('Label')
      .setDesc('Display name for this color')
      .addText(text => text
        .setPlaceholder('e.g., Ocean Blue')
        .setValue(labelValue)
        .onChange(value => {
          labelValue = value;
        }));
    
    // Opacity slider
    const opacitySetting = new Setting(contentEl)
      .setName('Opacity')
      .setDesc('Default opacity when selecting this color');
    
    const opacityContainer = opacitySetting.controlEl.createEl('div', { cls: 'dmt-opacity-control' });
    const opacitySlider = opacityContainer.createEl('input', {
      type: 'range',
      attr: { min: '10', max: '100', value: String(Math.round(opacityValue * 100)) }
    });
    const opacityDisplay = opacityContainer.createEl('span', { 
      text: \`\${Math.round(opacityValue * 100)}%\`,
      cls: 'dmt-opacity-value'
    });
    
    opacitySlider.addEventListener('input', (e) => {
      opacityValue = parseInt(e.target.value, 10) / 100;
      opacityDisplay.textContent = \`\${Math.round(opacityValue * 100)}%\`;
    });
    
    // Show original values for built-ins
    if (isBuiltIn && originalBuiltIn) {
      const origInfo = contentEl.createEl('div', { cls: 'dmt-color-original-info' });
      origInfo.createEl('span', { text: 'Original: ' });
      const origSwatch = origInfo.createEl('span', { 
        cls: 'dmt-color-mini-swatch',
        attr: { style: \`background-color: \${originalBuiltIn.color}\` }
      });
      origInfo.createEl('span', { text: \` \${originalBuiltIn.label} (\${originalBuiltIn.color})\` });
    }
    
    // Action buttons
    const btnContainer = contentEl.createEl('div', { cls: 'dmt-modal-buttons' });
    
    const saveBtn = btnContainer.createEl('button', { 
      text: 'Save', 
      cls: 'mod-cta' 
    });
    saveBtn.addEventListener('click', async () => {
      // Validate
      if (!labelValue.trim()) {
        alert('Please enter a label for this color.');
        return;
      }
      if (!/^#[0-9A-Fa-f]{6}$/.test(colorValue)) {
        alert('Please enter a valid hex color (e.g., #4A9EFF)');
        return;
      }
      
      if (isBuiltIn) {
        // Save as override
        if (!this.plugin.settings.colorPaletteOverrides) {
          this.plugin.settings.colorPaletteOverrides = {};
        }
        const existingOverride = this.plugin.settings.colorPaletteOverrides[this.existingColor.id] || {};
        this.plugin.settings.colorPaletteOverrides[this.existingColor.id] = {
          ...existingOverride,
          color: colorValue,
          label: labelValue,
          opacity: opacityValue
        };
      } else if (isEdit) {
        // Update existing custom color
        const idx = this.plugin.settings.customPaletteColors.findIndex(c => c.id === this.existingColor.id);
        if (idx !== -1) {
          this.plugin.settings.customPaletteColors[idx] = {
            ...this.plugin.settings.customPaletteColors[idx],
            color: colorValue,
            label: labelValue,
            opacity: opacityValue
          };
        }
      } else {
        // Add new custom color
        if (!this.plugin.settings.customPaletteColors) {
          this.plugin.settings.customPaletteColors = [];
        }
        this.plugin.settings.customPaletteColors.push({
          id: 'custom-' + Date.now(),
          color: colorValue,
          label: labelValue,
          opacity: opacityValue
        });
      }
      
      this.onSave();
      this.close();
    });
    
    const cancelBtn = btnContainer.createEl('button', { text: 'Cancel' });
    cancelBtn.addEventListener('click', () => this.close());
  }
  
  onClose() {
    this.contentEl.empty();
  }
}
`;
```

# settingsPlugin-ExportModal

```js
return `// settingsPlugin-ExportModal.js
// Modal for exporting object customizations
// This file is concatenated into the settings plugin template by the assembler

/**
 * Modal for exporting object customizations
 */
class ExportModal extends Modal {
  constructor(app, plugin, mapType = 'grid') {
    super(app);
    this.plugin = plugin;
    this.mapType = mapType;
  }
  
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass('dmt-export-modal');
    
    const mapTypeLabel = this.mapType === 'hex' ? 'Hex' : 'Grid';
    contentEl.createEl('h2', { text: \`Export \${mapTypeLabel} Object Customizations\` });
    
    // Get the correct settings keys for this map type
    const overridesKey = this.mapType === 'hex' ? 'hexObjectOverrides' : 'gridObjectOverrides';
    const customObjectsKey = this.mapType === 'hex' ? 'customHexObjects' : 'customGridObjects';
    const categoriesKey = this.mapType === 'hex' ? 'customHexCategories' : 'customGridCategories';
    
    const objectOverrides = this.plugin.settings[overridesKey] || {};
    const customObjects = this.plugin.settings[customObjectsKey] || [];
    const customCategories = this.plugin.settings[categoriesKey] || [];
    
    const hasOverrides = Object.keys(objectOverrides).length > 0;
    const hasCustom = customObjects.length > 0 || customCategories.length > 0;
    
    // Selection checkboxes
    let exportOverrides = hasOverrides;
    let exportCustom = hasCustom;
    
    // Explain what will be exported
    if (hasOverrides || hasCustom) {
      contentEl.createEl('p', { 
        text: 'Select what to include in the export file:',
        cls: 'setting-item-description'
      });
    }
    
    if (hasOverrides) {
      new Setting(contentEl)
        .setName(\`Built-in modifications (\${Object.keys(objectOverrides).length})\`)
        .setDesc('Changes to symbol, label, or order of built-in objects')
        .addToggle(toggle => toggle
          .setValue(exportOverrides)
          .onChange(v => { exportOverrides = v; }));
    }
    
    if (hasCustom) {
      const customCount = customObjects.length + customCategories.length;
      new Setting(contentEl)
        .setName(\`Custom objects & categories (\${customCount})\`)
        .setDesc(\`\${customObjects.length} object(s), \${customCategories.length} category(ies)\`)
        .addToggle(toggle => toggle
          .setValue(exportCustom)
          .onChange(v => { exportCustom = v; }));
    }
    
    if (!hasOverrides && !hasCustom) {
      contentEl.createEl('p', { 
        text: \`No customizations to export for \${mapTypeLabel} maps. Modify built-in objects or create custom ones first.\`,
        cls: 'dmt-export-empty'
      });
      return;
    }
    
    // Filename input
    const defaultFilename = \`windrose-\${this.mapType}-objects-\${new Date().toISOString().split('T')[0]}.json\`;
    let filename = defaultFilename;
    
    new Setting(contentEl)
      .setName('Filename')
      .setDesc('Will be saved to your vault root')
      .addText(text => text
        .setValue(filename)
        .onChange(v => { filename = v; }));
    
    // Export button
    new Setting(contentEl)
      .addButton(btn => btn
        .setButtonText('Export to Vault')
        .setCta()
        .onClick(async () => {
          const exportData = {
            windroseMD_objectExport: true,
            exportedAt: new Date().toISOString(),
            version: '1.0',
            mapType: this.mapType
          };
          
          if (exportOverrides && hasOverrides) {
            exportData.objectOverrides = objectOverrides;
          }
          if (exportCustom && hasCustom) {
            if (customObjects.length > 0) exportData.customObjects = customObjects;
            if (customCategories.length > 0) exportData.customCategories = customCategories;
          }
          
          // Save to vault
          const json = JSON.stringify(exportData, null, 2);
          const finalFilename = filename.endsWith('.json') ? filename : filename + '.json';
          
          try {
            // Check if file exists
            const existingFile = this.app.vault.getAbstractFileByPath(finalFilename);
            if (existingFile) {
              if (!confirm(\`File "\${finalFilename}" already exists. Overwrite?\`)) {
                return;
              }
              await this.app.vault.modify(existingFile, json);
            } else {
              await this.app.vault.create(finalFilename, json);
            }
            
            alert(\`Exported to: \${finalFilename}\`);
            this.close();
          } catch (err) {
            alert(\`Export failed: \${err.message}\`);
          }
        }));
  }
  
  onClose() {
    this.contentEl.empty();
  }
}
`;
```

# settingsPlugin-ImportModal

```js
return `// settingsPlugin-ImportModal.js
// Modal for importing object customizations
// This file is concatenated into the settings plugin template by the assembler

/**
 * Modal for importing object customizations
 */
class ImportModal extends Modal {
  constructor(app, plugin, onImport, mapType = 'grid') {
    super(app);
    this.plugin = plugin;
    this.onImport = onImport;
    this.mapType = mapType;
    this.importData = null;
  }
  
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass('dmt-import-modal');
    
    const mapTypeLabel = this.mapType === 'hex' ? 'Hex' : 'Grid';
    contentEl.createEl('h2', { text: \`Import \${mapTypeLabel} Object Customizations\` });
    
    contentEl.createEl('p', { 
      text: \`Select a Windrose MD object export file (.json) to import into \${mapTypeLabel} maps.\`,
      cls: 'setting-item-description'
    });
    
    // File picker
    const fileContainer = contentEl.createDiv({ cls: 'dmt-import-file-container' });
    const fileInput = fileContainer.createEl('input', {
      type: 'file',
      attr: { accept: '.json' }
    });
    
    // Preview area (hidden until file selected)
    const previewArea = contentEl.createDiv({ cls: 'dmt-import-preview' });
    previewArea.style.display = 'none';
    
    // Import options (hidden until file validated)
    const optionsArea = contentEl.createDiv({ cls: 'dmt-import-options' });
    optionsArea.style.display = 'none';
    
    let mergeMode = 'merge'; // 'merge' or 'replace'
    
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        
        // Validate it's a Windrose export
        if (!data.windroseMD_objectExport) {
          previewArea.empty();
          previewArea.createEl('p', { 
            text: 'This file is not a valid Windrose MD object export.',
            cls: 'dmt-import-error'
          });
          previewArea.style.display = 'block';
          optionsArea.style.display = 'none';
          this.importData = null;
          return;
        }
        
        this.importData = data;
        
        // Show preview
        previewArea.empty();
        previewArea.createEl('p', { text: 'Valid Windrose MD export file' });
        if (data.exportedAt) {
          previewArea.createEl('p', { 
            text: \`Exported: \${new Date(data.exportedAt).toLocaleString()}\`,
            cls: 'dmt-import-date'
          });
        }
        
        // Show original map type if present
        if (data.mapType) {
          const sourceType = data.mapType === 'hex' ? 'Hex' : 'Grid';
          if (data.mapType !== this.mapType) {
            previewArea.createEl('p', { 
              text: \`Note: This was exported from \${sourceType} maps but will be imported to \${mapTypeLabel} maps.\`,
              cls: 'dmt-import-note'
            });
          }
        }
        
        const overrideCount = data.objectOverrides ? Object.keys(data.objectOverrides).length : 0;
        const customObjCount = data.customObjects?.length || 0;
        const customCatCount = data.customCategories?.length || 0;
        
        if (overrideCount > 0) {
          previewArea.createEl('p', { text: \` \${overrideCount} built-in modification(s)\` });
        }
        if (customObjCount > 0) {
          previewArea.createEl('p', { text: \` \${customObjCount} custom object(s)\` });
        }
        if (customCatCount > 0) {
          previewArea.createEl('p', { text: \` \${customCatCount} custom category(ies)\` });
        }
        
        previewArea.style.display = 'block';
        
        // Show import options
        optionsArea.empty();
        new Setting(optionsArea)
          .setName('Import Mode')
          .setDesc('How to handle existing customizations')
          .addDropdown(dropdown => dropdown
            .addOption('merge', 'Merge (keep existing, add new)')
            .addOption('replace', 'Replace (remove existing first)')
            .setValue(mergeMode)
            .onChange(v => { mergeMode = v; }));
        
        optionsArea.style.display = 'block';
        
      } catch (err) {
        previewArea.empty();
        previewArea.createEl('p', { 
          text: \`Error reading file: \${err.message}\`,
          cls: 'dmt-import-error'
        });
        previewArea.style.display = 'block';
        optionsArea.style.display = 'none';
        this.importData = null;
      }
    });
    
    // Buttons
    const buttonContainer = contentEl.createDiv({ cls: 'dmt-modal-buttons' });
    
    const cancelBtn = buttonContainer.createEl('button', { text: 'Cancel' });
    cancelBtn.onclick = () => this.close();
    
    const importBtn = buttonContainer.createEl('button', { text: 'Import', cls: 'mod-cta' });
    importBtn.onclick = async () => {
      if (!this.importData) {
        alert('Please select a valid export file first.');
        return;
      }
      
      // Get the correct settings keys for this map type
      const overridesKey = this.mapType === 'hex' ? 'hexObjectOverrides' : 'gridObjectOverrides';
      const customObjectsKey = this.mapType === 'hex' ? 'customHexObjects' : 'customGridObjects';
      const categoriesKey = this.mapType === 'hex' ? 'customHexCategories' : 'customGridCategories';
      
      const data = this.importData;
      
      if (mergeMode === 'replace') {
        // Clear existing for this map type
        this.plugin.settings[overridesKey] = {};
        this.plugin.settings[customObjectsKey] = [];
        this.plugin.settings[categoriesKey] = [];
      }
      
      // Import overrides
      if (data.objectOverrides) {
        if (!this.plugin.settings[overridesKey]) {
          this.plugin.settings[overridesKey] = {};
        }
        Object.assign(this.plugin.settings[overridesKey], data.objectOverrides);
      }
      
      // Import custom objects (avoid duplicates by ID)
      if (data.customObjects) {
        if (!this.plugin.settings[customObjectsKey]) {
          this.plugin.settings[customObjectsKey] = [];
        }
        for (const obj of data.customObjects) {
          const existingIdx = this.plugin.settings[customObjectsKey].findIndex(o => o.id === obj.id);
          if (existingIdx !== -1) {
            this.plugin.settings[customObjectsKey][existingIdx] = obj;
          } else {
            this.plugin.settings[customObjectsKey].push(obj);
          }
        }
      }
      
      // Import custom categories (avoid duplicates by ID)
      if (data.customCategories) {
        if (!this.plugin.settings[categoriesKey]) {
          this.plugin.settings[categoriesKey] = [];
        }
        for (const cat of data.customCategories) {
          const existingIdx = this.plugin.settings[categoriesKey].findIndex(c => c.id === cat.id);
          if (existingIdx !== -1) {
            this.plugin.settings[categoriesKey][existingIdx] = cat;
          } else {
            this.plugin.settings[categoriesKey].push(cat);
          }
        }
      }
      
      await this.plugin.saveSettings();
      this.onImport();
      this.close();
    };
  }
  
  onClose() {
    this.contentEl.empty();
  }
}
`;
```

# settingsPlugin-TabRenderCore

```js
return `// settingsPlugin-TabRenderCore.js
// WindroseMDSettingsTab render methods - Core (search bar)
// This file is concatenated into the settings plugin template by the assembler

const TabRenderCoreMethods = {
  renderSearchBar(containerEl) {
    const wrapper = containerEl.createEl('div', { cls: 'dmt-settings-search-wrapper' });
    const searchBox = wrapper.createEl('div', { cls: 'dmt-settings-search-box' });
    
    // Search icon
    const searchIcon = searchBox.createEl('span', { cls: 'search-icon' });
    IconHelpers.set(searchIcon, 'search');
    
    // Input
    const input = searchBox.createEl('input', {
      type: 'text',
      placeholder: 'Search settings...'
    });
    
    // Clear button (hidden initially)
    const clearBtn = searchBox.createEl('button', { cls: 'clear-btn' });
    clearBtn.style.display = 'none';
    IconHelpers.set(clearBtn, 'x');
    
    // No results message (hidden initially)
    this.noResultsEl = containerEl.createEl('div', { 
      cls: 'dmt-settings-no-results',
      text: 'No settings found matching your search.'
    });
    this.noResultsEl.style.display = 'none';
    
    // Search handler
    const handleSearch = (query) => {
      const q = query.toLowerCase().trim();
      clearBtn.style.display = q ? 'block' : 'none';
      
      if (!q) {
        // Clear search - show all, collapse sections
        this.sections?.forEach(({ details }) => {
          details.style.display = '';
          details.settingItems?.forEach(item => {
            item.classList.remove('dmt-setting-hidden');
          });
          details.removeAttribute('open');
        });
        this.noResultsEl.style.display = 'none';
        return;
      }
      
      let anyMatches = false;
      
      this.sections?.forEach(({ details, title }) => {
        let sectionHasMatch = title.toLowerCase().includes(q);
        
        details.settingItems?.forEach(item => {
          const nameEl = item.querySelector('.setting-item-name');
          const descEl = item.querySelector('.setting-item-description');
          const name = nameEl?.textContent?.toLowerCase() || '';
          const desc = descEl?.textContent?.toLowerCase() || '';
          
          const matches = name.includes(q) || desc.includes(q);
          
          if (matches) {
            item.classList.remove('dmt-setting-hidden');
            sectionHasMatch = true;
          } else {
            item.classList.add('dmt-setting-hidden');
          }
        });
        
        if (sectionHasMatch) {
          details.style.display = '';
          details.setAttribute('open', '');
          anyMatches = true;
        } else {
          details.style.display = 'none';
        }
      });
      
      this.noResultsEl.style.display = anyMatches ? 'none' : 'block';
    };
    
    input.addEventListener('input', (e) => handleSearch(e.target.value));
    clearBtn.addEventListener('click', () => {
      input.value = '';
      handleSearch('');
      input.focus();
    });
  }

};`;
```

# settingsPlugin-TabRenderSettings

```js
return `// settingsPlugin-TabRenderSettings.js
// WindroseMDSettingsTab render methods - Settings sections
// This file is concatenated into the settings plugin template by the assembler

const TabRenderSettingsMethods = {
  renderHexSettingsContent(containerEl) {
    // Hex Orientation
    new Setting(containerEl)
      .setName('Hex Grid Orientation')
      .setDesc('Default orientation for hex grids (flat-top or pointy-top)')
      .addDropdown(dropdown => dropdown
        .addOption('flat', 'Flat-Top')
        .addOption('pointy', 'Pointy-Top')
        .setValue(this.plugin.settings.hexOrientation)
        .onChange(async (value) => {
          this.plugin.settings.hexOrientation = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
        }));

    // Coordinate Key Mode
    new Setting(containerEl)
      .setName('Coordinate Overlay Mode')
      .setDesc('How the C key activates coordinate labels: hold to show temporarily, or toggle on/off')
      .addDropdown(dropdown => dropdown
        .addOption('hold', 'Hold to Show')
        .addOption('toggle', 'Toggle On/Off')
        .setValue(this.plugin.settings.coordinateKeyMode || 'hold')
        .onChange(async (value) => {
          this.plugin.settings.coordinateKeyMode = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
        }));

    // Coordinate Text Color
    new Setting(containerEl)
      .setName('Coordinate Text Color')
      .setDesc('Primary color for hex coordinate overlay text (hex format: #RRGGBB)')
      .addColorPicker(color => color
        .setValue(this.plugin.settings.coordinateTextColor)
        .onChange(async (value) => {
          this.plugin.settings.coordinateTextColor = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
        }))
      .addText(text => text
        .setPlaceholder('{{DEFAULT_COORDINATE_TEXT_COLOR}}')
        .setValue(this.plugin.settings.coordinateTextColor)
        .onChange(async (value) => {
          if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
            this.plugin.settings.coordinateTextColor = value;
            this.settingsChanged = true;
            await this.plugin.saveSettings();
          }
        }))
      .addExtraButton(btn => btn
        .setIcon('rotate-ccw')
        .setTooltip('Reset to default')
        .onClick(async () => {
          this.plugin.settings.coordinateTextColor = '{{DEFAULT_COORDINATE_TEXT_COLOR}}';
          this.settingsChanged = true;
          await this.plugin.saveSettings();
          this.display();
        }));

    // Coordinate Text Shadow
    new Setting(containerEl)
      .setName('Coordinate Text Shadow')
      .setDesc('Shadow/outline color for hex coordinate overlay text (hex format: #RRGGBB)')
      .addColorPicker(color => color
        .setValue(this.plugin.settings.coordinateTextShadow)
        .onChange(async (value) => {
          this.plugin.settings.coordinateTextShadow = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
        }))
      .addText(text => text
        .setPlaceholder('{{DEFAULT_COORDINATE_TEXT_SHADOW}}')
        .setValue(this.plugin.settings.coordinateTextShadow)
        .onChange(async (value) => {
          if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
            this.plugin.settings.coordinateTextShadow = value;
            this.settingsChanged = true;
            await this.plugin.saveSettings();
          }
        }))
      .addExtraButton(btn => btn
        .setIcon('rotate-ccw')
        .setTooltip('Reset to default')
        .onClick(async () => {
          this.plugin.settings.coordinateTextShadow = '{{DEFAULT_COORDINATE_TEXT_SHADOW}}';
          this.settingsChanged = true;
          await this.plugin.saveSettings();
          this.display();
        }));
  },
  renderColorSettingsContent(containerEl) {
    containerEl.createEl('p', { 
      text: 'These settings control default colors and behavior for all WindroseMD maps in this vault.',
      cls: 'setting-item-description'
    });
    
    // Grid Line Color
    new Setting(containerEl)
      .setName('Grid Line Color')
      .setDesc('Color for grid lines (hex format: #RRGGBB)')
      .addColorPicker(color => color
        .setValue(this.plugin.settings.gridLineColor)
        .onChange(async (value) => {
          this.plugin.settings.gridLineColor = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
        }))
      .addText(text => text
        .setPlaceholder('{{DEFAULT_GRID_LINE_COLOR}}')
        .setValue(this.plugin.settings.gridLineColor)
        .onChange(async (value) => {
          if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
            this.plugin.settings.gridLineColor = value;
            this.settingsChanged = true;
            await this.plugin.saveSettings();
          }
        }))
      .addExtraButton(btn => btn
        .setIcon('rotate-ccw')
        .setTooltip('Reset to default')
        .onClick(async () => {
          this.plugin.settings.gridLineColor = '{{DEFAULT_GRID_LINE_COLOR}}';
          this.settingsChanged = true;
          await this.plugin.saveSettings();
          this.display();
        }));

    // Grid Line Width (grid maps only)
    new Setting(containerEl)
      .setName('Grid Line Width')
      .setDesc('Thickness of grid lines in pixels (1-5). Applies to grid maps only.')
      .addSlider(slider => slider
        .setLimits(1, 5, 1)
        .setValue(this.plugin.settings.gridLineWidth ?? 1)
        .setDynamicTooltip()
        .onChange(async (value) => {
          this.plugin.settings.gridLineWidth = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
        }))
      .addExtraButton(btn => btn
        .setIcon('rotate-ccw')
        .setTooltip('Reset to default (1px)')
        .onClick(async () => {
          this.plugin.settings.gridLineWidth = 1;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
          this.display();
        }));

    // Background Color
    new Setting(containerEl)
      .setName('Background Color')
      .setDesc('Canvas background color (hex format: #RRGGBB)')
      .addColorPicker(color => color
        .setValue(this.plugin.settings.backgroundColor)
        .onChange(async (value) => {
          this.plugin.settings.backgroundColor = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
        }))
      .addText(text => text
        .setPlaceholder('{{DEFAULT_BACKGROUND_COLOR}}')
        .setValue(this.plugin.settings.backgroundColor)
        .onChange(async (value) => {
          if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
            this.plugin.settings.backgroundColor = value;
            this.settingsChanged = true;
            await this.plugin.saveSettings();
          }
        }))
      .addExtraButton(btn => btn
        .setIcon('rotate-ccw')
        .setTooltip('Reset to default')
        .onClick(async () => {
          this.plugin.settings.backgroundColor = '{{DEFAULT_BACKGROUND_COLOR}}';
          this.settingsChanged = true;
          await this.plugin.saveSettings();
          this.display();
        }));

    // Border Color
    new Setting(containerEl)
      .setName('Border Color')
      .setDesc('Color for painted cell borders (hex format: #RRGGBB)')
      .addColorPicker(color => color
        .setValue(this.plugin.settings.borderColor)
        .onChange(async (value) => {
          this.plugin.settings.borderColor = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
        }))
      .addText(text => text
        .setPlaceholder('{{DEFAULT_BORDER_COLOR}}')
        .setValue(this.plugin.settings.borderColor)
        .onChange(async (value) => {
          if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
            this.plugin.settings.borderColor = value;
            this.settingsChanged = true;
            await this.plugin.saveSettings();
          }
        }))
      .addExtraButton(btn => btn
        .setIcon('rotate-ccw')
        .setTooltip('Reset to default')
        .onClick(async () => {
          this.plugin.settings.borderColor = '{{DEFAULT_BORDER_COLOR}}';
          this.settingsChanged = true;
          await this.plugin.saveSettings();
          this.display();
        }));

    // Coordinate Key Color
    new Setting(containerEl)
      .setName('Coordinate Key Color')
      .setDesc('Background color for coordinate key indicator (hex format: #RRGGBB)')
      .addColorPicker(color => color
        .setValue(this.plugin.settings.coordinateKeyColor)
        .onChange(async (value) => {
          this.plugin.settings.coordinateKeyColor = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
        }))
      .addText(text => text
        .setPlaceholder('{{DEFAULT_COORDINATE_KEY_COLOR}}')
        .setValue(this.plugin.settings.coordinateKeyColor)
        .onChange(async (value) => {
          if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
            this.plugin.settings.coordinateKeyColor = value;
            this.settingsChanged = true;
            await this.plugin.saveSettings();
          }
        }))
      .addExtraButton(btn => btn
        .setIcon('rotate-ccw')
        .setTooltip('Reset to default')
        .onClick(async () => {
          this.plugin.settings.coordinateKeyColor = '{{DEFAULT_COORDINATE_KEY_COLOR}}';
          this.settingsChanged = true;
          await this.plugin.saveSettings();
          this.display();
        }));
  },
  renderFogOfWarSettingsContent(containerEl) {
    containerEl.createEl('p', { 
      text: 'Default fog of war appearance settings for new maps. Individual maps can override these in their settings.',
      cls: 'setting-item-description'
    });
    
    // Soft Edges Toggle
    new Setting(containerEl)
      .setName('Soft Edges')
      .setDesc('Enable a blur effect at fog boundaries for a softer, more atmospheric look')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.fogOfWarBlurEnabled)
        .onChange(async (value) => {
          this.plugin.settings.fogOfWarBlurEnabled = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
          this.display(); // Refresh to show/hide blur intensity slider
        }));
    
    // Blur Intensity Slider (only show when blur is enabled)
    if (this.plugin.settings.fogOfWarBlurEnabled) {
      const blurPercent = Math.round((this.plugin.settings.fogOfWarBlurFactor || 0.20) * 100);
      
      new Setting(containerEl)
        .setName('Blur Intensity')
        .setDesc(\`Size of blur effect as percentage of cell size (currently \${blurPercent}%)\`)
        .addSlider(slider => slider
          .setLimits(5, 50, 1)
          .setValue(blurPercent)
          .setDynamicTooltip()
          .onChange(async (value) => {
            this.plugin.settings.fogOfWarBlurFactor = value / 100;
            this.settingsChanged = true;
            await this.plugin.saveSettings();
          }))
        .addExtraButton(btn => btn
          .setIcon('rotate-ccw')
          .setTooltip('Reset to default (20%)')
          .onClick(async () => {
            this.plugin.settings.fogOfWarBlurFactor = 0.20;
            this.settingsChanged = true;
            await this.plugin.saveSettings();
            this.display();
          }));
    }
  },
  renderMapBehaviorSettingsContent(containerEl) {
    // Expanded by Default
    new Setting(containerEl)
      .setName('Start Maps Expanded')
      .setDesc('When enabled, maps will start in expanded (fullscreen) mode by default')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.expandedByDefault)
        .onChange(async (value) => {
          this.plugin.settings.expandedByDefault = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
        }));

    // Always Show Controls
    new Setting(containerEl)
      .setName('Always Show Controls')
      .setDesc('Keep map controls visible at all times instead of auto-hiding')
      .addToggle(toggle => toggle
        .setValue(this.plugin.settings.alwaysShowControls)
        .onChange(async (value) => {
          this.plugin.settings.alwaysShowControls = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
        }));

    // Canvas Height (Desktop)
    new Setting(containerEl)
      .setName('Canvas Height (Desktop)')
      .setDesc('Default height in pixels for map canvas on desktop devices')
      .addText(text => text
        .setPlaceholder('600')
        .setValue(String(this.plugin.settings.canvasHeight))
        .onChange(async (value) => {
          const num = parseInt(value);
          if (!isNaN(num)) {
            this.plugin.settings.canvasHeight = num;
            this.settingsChanged = true;
            await this.plugin.saveSettings();
          }
        }));

    // Canvas Height (Mobile)
    new Setting(containerEl)
      .setName('Canvas Height (Mobile/Touch)')
      .setDesc('Default height in pixels for map canvas on mobile and touch devices')
      .addText(text => text
        .setPlaceholder('400')
        .setValue(String(this.plugin.settings.canvasHeightMobile))
        .onChange(async (value) => {
          const num = parseInt(value);
          if (!isNaN(num)) {
            this.plugin.settings.canvasHeightMobile = num;
            this.settingsChanged = true;
            await this.plugin.saveSettings();
          }
        }));
  },
  renderDistanceMeasurementSettingsContent(containerEl) {
    // Grid: Distance per cell
    new Setting(containerEl)
      .setName('Grid Map: Distance per Cell')
      .setDesc('Distance each cell represents on grid maps (default: 5 ft for D&D)')
      .addText(text => text
        .setPlaceholder('5')
        .setValue(String(this.plugin.settings.distancePerCellGrid))
        .onChange(async (value) => {
          const num = parseFloat(value);
          if (!isNaN(num) && num > 0) {
            this.plugin.settings.distancePerCellGrid = num;
            this.settingsChanged = true;
            await this.plugin.saveSettings();
          }
        }))
      .addDropdown(dropdown => dropdown
        .addOption('ft', 'feet')
        .addOption('m', 'meters')
        .addOption('mi', 'miles')
        .addOption('km', 'kilometers')
        .addOption('yd', 'yards')
        .setValue(this.plugin.settings.distanceUnitGrid)
        .onChange(async (value) => {
          this.plugin.settings.distanceUnitGrid = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
        }));

    // Hex: Distance per cell
    new Setting(containerEl)
      .setName('Hex Map: Distance per Hex')
      .setDesc('Distance each hex represents on hex maps (default: 6 miles for world maps)')
      .addText(text => text
        .setPlaceholder('6')
        .setValue(String(this.plugin.settings.distancePerCellHex))
        .onChange(async (value) => {
          const num = parseFloat(value);
          if (!isNaN(num) && num > 0) {
            this.plugin.settings.distancePerCellHex = num;
            this.settingsChanged = true;
            await this.plugin.saveSettings();
          }
        }))
      .addDropdown(dropdown => dropdown
        .addOption('mi', 'miles')
        .addOption('km', 'kilometers')
        .addOption('ft', 'feet')
        .addOption('m', 'meters')
        .addOption('yd', 'yards')
        .setValue(this.plugin.settings.distanceUnitHex)
        .onChange(async (value) => {
          this.plugin.settings.distanceUnitHex = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
        }));

    // Grid diagonal rule
    new Setting(containerEl)
      .setName('Grid Diagonal Movement')
      .setDesc('How to calculate diagonal distance on grid maps')
      .addDropdown(dropdown => dropdown
        .addOption('alternating', 'Alternating (5-10-5-10, D&D 5e)')
        .addOption('equal', 'Equal (Chebyshev, all moves = 1)')
        .addOption('euclidean', 'True Distance (Euclidean)')
        .setValue(this.plugin.settings.gridDiagonalRule)
        .onChange(async (value) => {
          this.plugin.settings.gridDiagonalRule = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
        }));

    // Display format
    new Setting(containerEl)
      .setName('Distance Display Format')
      .setDesc('How to display measured distances')
      .addDropdown(dropdown => dropdown
        .addOption('both', 'Cells and Units (e.g., "3 cells (15 ft)")')
        .addOption('cells', 'Cells Only (e.g., "3 cells")')
        .addOption('units', 'Units Only (e.g., "15 ft")')
        .setValue(this.plugin.settings.distanceDisplayFormat)
        .onChange(async (value) => {
          this.plugin.settings.distanceDisplayFormat = value;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
        }));
  }

};`;
```

# settingsPlugin-TabRenderColors

```js
return `// settingsPlugin-TabRenderColors.js
// WindroseMDSettingsTab render methods - Color palette
// This file is concatenated into the settings plugin template by the assembler

const TabRenderColorsMethods = {
  renderColorPaletteContent(containerEl) {
    containerEl.createEl('p', { 
      text: 'Customize the color palette used for drawing cells and objects. Edit built-in colors, add custom colors, or hide colors you don\\'t use.',
      cls: 'setting-item-description'
    });
    
    // Add Custom Color button
    new Setting(containerEl)
      .setName('Add Custom Color')
      .setDesc('Create a new color for your palette')
      .addButton(btn => btn
        .setButtonText('+ Add Color')
        .setCta()
        .onClick(() => {
          new ColorEditModal(this.app, this.plugin, null, async () => {
            this.settingsChanged = true;
            await this.plugin.saveSettings();
            this.display();
          }).open();
        }));
    
    // Reset All Colors button  
    new Setting(containerEl)
      .setName('Reset Palette')
      .setDesc('Restore all built-in colors to defaults and remove custom colors')
      .addButton(btn => btn
        .setButtonText('Reset All')
        .setWarning()
        .onClick(async () => {
          if (confirm('Reset all colors to defaults? This will remove all customizations.')) {
            this.plugin.settings.colorPaletteOverrides = {};
            this.plugin.settings.customPaletteColors = [];
            this.settingsChanged = true;
            await this.plugin.saveSettings();
            this.display();
          }
        }));
    
    // Render color list
    this.renderColorList(containerEl);
  },
  renderColorList(containerEl) {
    const resolvedColors = ColorHelpers.getResolved(this.plugin.settings);
    const hiddenColors = ColorHelpers.getHidden(this.plugin.settings);
    
    // Separate into visible and hidden
    const visibleColors = resolvedColors.filter(c => !hiddenColors.has(c.id));
    const hiddenBuiltIns = BUILT_IN_COLORS.filter(c => hiddenColors.has(c.id));
    
    // Visible colors container
    const visibleContainer = containerEl.createEl('div', { cls: 'dmt-settings-category' });
    const visibleHeader = visibleContainer.createEl('div', { cls: 'dmt-settings-category-header' });
    visibleHeader.createEl('span', { text: \`Active Colors (\${visibleColors.length})\`, cls: 'dmt-settings-category-label' });
    
    const visibleList = visibleContainer.createEl('div', { cls: 'dmt-color-list' });
    
    visibleColors.forEach(color => {
      this.renderColorRow(visibleList, color, false);
    });
    
    if (visibleColors.length === 0) {
      visibleList.createEl('div', { 
        text: 'No colors visible. Use "Show" to restore hidden colors.',
        cls: 'dmt-settings-empty-message'
      });
    }
    
    // Hidden colors (if any)
    if (hiddenBuiltIns.length > 0) {
      const hiddenContainer = containerEl.createEl('div', { cls: 'dmt-settings-category dmt-settings-category-muted' });
      const hiddenHeader = hiddenContainer.createEl('div', { cls: 'dmt-settings-category-header' });
      hiddenHeader.createEl('span', { text: \`Hidden Colors (\${hiddenBuiltIns.length})\`, cls: 'dmt-settings-category-label' });
      
      const hiddenList = hiddenContainer.createEl('div', { cls: 'dmt-color-list' });
      
      hiddenBuiltIns.forEach(color => {
        // Build display version with override if exists
        const override = this.plugin.settings.colorPaletteOverrides?.[color.id];
        const displayColor = override ? { ...color, ...override, isBuiltIn: true, isModified: true } : { ...color, isBuiltIn: true };
        this.renderColorRow(hiddenList, displayColor, true);
      });
    }
  },
  renderColorRow(containerEl, color, isHidden) {
    const row = containerEl.createEl('div', { cls: 'dmt-color-row' });
    
    // Color swatch - apply opacity if set
    const swatchOpacity = color.opacity ?? 1;
    const swatch = row.createEl('div', { 
      cls: 'dmt-color-row-swatch',
      attr: { style: \`background-color: \${color.color}; opacity: \${swatchOpacity}\` }
    });
    
    // Label with modified indicator
    const labelContainer = row.createEl('div', { cls: 'dmt-color-row-label' });
    labelContainer.createEl('span', { text: color.label, cls: 'dmt-color-row-name' });
    
    if (color.isModified) {
      labelContainer.createEl('span', { text: ' (modified)', cls: 'dmt-color-row-modified' });
    }
    if (color.isCustom) {
      labelContainer.createEl('span', { text: ' (custom)', cls: 'dmt-color-row-custom' });
    }
    
    // Hex value + opacity if not 100%
    const hexText = swatchOpacity < 1 
      ? \`\${color.color} @ \${Math.round(swatchOpacity * 100)}%\`
      : color.color;
    row.createEl('code', { text: hexText, cls: 'dmt-color-row-hex' });
    
    // Actions
    const actions = row.createEl('div', { cls: 'dmt-color-row-actions' });
    
    // Edit button
    const editBtn = actions.createEl('button', { cls: 'dmt-btn-icon', attr: { 'aria-label': 'Edit color' } });
    IconHelpers.set(editBtn, 'pencil');
    editBtn.addEventListener('click', () => {
      new ColorEditModal(this.app, this.plugin, color, async () => {
        this.settingsChanged = true;
        await this.plugin.saveSettings();
        this.display();
      }).open();
    });
    
    // Show/Hide button (for built-in colors only)
    if (color.isBuiltIn) {
      const visBtn = actions.createEl('button', { cls: 'dmt-btn-icon', attr: { 'aria-label': isHidden ? 'Show color' : 'Hide color' } });
      IconHelpers.set(visBtn, isHidden ? 'eye' : 'eye-off');
      visBtn.addEventListener('click', async () => {
        if (!this.plugin.settings.colorPaletteOverrides) {
          this.plugin.settings.colorPaletteOverrides = {};
        }
        if (!this.plugin.settings.colorPaletteOverrides[color.id]) {
          this.plugin.settings.colorPaletteOverrides[color.id] = {};
        }
        this.plugin.settings.colorPaletteOverrides[color.id].hidden = !isHidden;
        
        // Clean up empty override
        if (Object.keys(this.plugin.settings.colorPaletteOverrides[color.id]).length === 1 
            && !this.plugin.settings.colorPaletteOverrides[color.id].hidden) {
          delete this.plugin.settings.colorPaletteOverrides[color.id];
        }
        
        this.settingsChanged = true;
        await this.plugin.saveSettings();
        this.display();
      });
      
      // Reset button (if modified)
      if (color.isModified) {
        const resetBtn = actions.createEl('button', { cls: 'dmt-btn-icon', attr: { 'aria-label': 'Reset to default' } });
        IconHelpers.set(resetBtn, 'rotate-ccw');
        resetBtn.addEventListener('click', async () => {
          delete this.plugin.settings.colorPaletteOverrides[color.id];
          this.settingsChanged = true;
          await this.plugin.saveSettings();
          this.display();
        });
      }
    }
    
    // Delete button (for custom colors only)
    if (color.isCustom) {
      const delBtn = actions.createEl('button', { cls: 'dmt-btn-icon dmt-btn-danger', attr: { 'aria-label': 'Delete color' } });
      IconHelpers.set(delBtn, 'trash-2');
      delBtn.addEventListener('click', async () => {
        this.plugin.settings.customPaletteColors = this.plugin.settings.customPaletteColors.filter(c => c.id !== color.id);
        this.settingsChanged = true;
        await this.plugin.saveSettings();
        this.display();
      });
    }
  }

};`;
```

# settingsPlugin-TabRenderObjects

```js
return `// settingsPlugin-TabRenderObjects.js
// WindroseMDSettingsTab render methods - Object types
// This file is concatenated into the settings plugin template by the assembler

const TabRenderObjectsMethods = {
  renderObjectTypesContent(containerEl) {
    containerEl.createEl('p', { 
      text: 'Customize map objects: modify built-in objects, create custom objects, or hide objects you don\\'t use.',
      cls: 'setting-item-description'
    });
    
    // Map Type selector dropdown
    new Setting(containerEl)
      .setName('Map Type')
      .setDesc('Select which map type to configure objects for')
      .addDropdown(dropdown => dropdown
        .addOption('grid', 'Grid Maps')
        .addOption('hex', 'Hex Maps')
        .setValue(this.selectedMapType)
        .onChange((value) => {
          this.selectedMapType = value;
          this.display();
        }));
    
    // Get settings for the selected map type
    const mapTypeSettings = this.getObjectSettingsForMapType();
    
    // Add Custom Object button
    new Setting(containerEl)
      .setName('Add Custom Object')
      .setDesc('Create a new map object with your own symbol')
      .addButton(btn => btn
        .setButtonText('+ Add Object')
        .setCta()
        .onClick(() => {
          new ObjectEditModal(this.app, this.plugin, null, async () => {
            this.settingsChanged = true;
            await this.plugin.saveSettings();
            this.display();
          }, this.selectedMapType).open();
        }));
    
    // Add Custom Category button
    new Setting(containerEl)
      .setName('Add Custom Category')
      .setDesc('Create a new category to organize objects')
      .addButton(btn => btn
        .setButtonText('+ Add Category')
        .onClick(() => {
          new CategoryEditModal(this.app, this.plugin, null, async () => {
            this.settingsChanged = true;
            await this.plugin.saveSettings();
            this.display();
          }, this.selectedMapType).open();
        }));
    
    // Import/Export buttons
    new Setting(containerEl)
      .setName('Import / Export')
      .setDesc('Share object configurations as JSON files')
      .addButton(btn => btn
        .setButtonText('Import')
        .onClick(() => {
          new ImportModal(this.app, this.plugin, async () => {
            this.settingsChanged = true;
            this.display();
          }, this.selectedMapType).open();
        }))
      .addButton(btn => btn
        .setButtonText('Export')
        .onClick(() => {
          new ExportModal(this.app, this.plugin, this.selectedMapType).open();
        }));
    
    // Get resolved data using helpers with map-type-specific settings
    const allCategories = ObjectHelpers.getCategories(mapTypeSettings);
    const allObjects = ObjectHelpers.getResolved(mapTypeSettings);
    const hiddenObjects = ObjectHelpers.getHidden(mapTypeSettings);
    
    // Check if there are any customizations for this map type
    const hasOverrides = Object.keys(mapTypeSettings.objectOverrides || {}).length > 0;
    const hasCustomObjects = (mapTypeSettings.customObjects || []).length > 0;
    const hasCustomCategories = (mapTypeSettings.customCategories || []).length > 0;
    const hasAnyCustomizations = hasOverrides || hasCustomObjects || hasCustomCategories;
    
    // Reset All button (only show if there are customizations)
    if (hasAnyCustomizations) {
      new Setting(containerEl)
        .setName('Reset All Customizations')
        .setDesc(\`Remove all custom objects, categories, and modifications for \${this.selectedMapType} maps\`)
        .addButton(btn => btn
          .setButtonText('Reset All')
          .setWarning()
          .onClick(async () => {
            const counts = [];
            if (hasOverrides) counts.push(\`\${Object.keys(mapTypeSettings.objectOverrides).length} modification(s)\`);
            if (hasCustomObjects) counts.push(\`\${mapTypeSettings.customObjects.length} custom object(s)\`);
            if (hasCustomCategories) counts.push(\`\${mapTypeSettings.customCategories.length} custom category(ies)\`);
            
            if (confirm(\`This will remove \${counts.join(', ')} for \${this.selectedMapType} maps. Maps using custom objects will show "?" placeholders.\\\\n\\\\nContinue?\`)) {
              this.updateObjectSettingsForMapType({
                objectOverrides: {},
                customObjects: [],
                customCategories: []
              });
              this.settingsChanged = true;
              await this.plugin.saveSettings();
              this.display();
            }
          }));
    }
    
    // Search/filter input
    const searchContainer = containerEl.createDiv({ cls: 'dmt-settings-search-container' });
    const searchInput = searchContainer.createEl('input', {
      type: 'text',
      cls: 'dmt-settings-search-input',
      attr: { placeholder: 'Filter objects...' },
      value: this.objectFilter || ''
    });
    searchInput.addEventListener('input', (e) => {
      this.objectFilter = e.target.value.toLowerCase().trim();
      this.renderObjectList(objectListContainer, allCategories, allObjects, hiddenObjects);
    });
    
    if (this.objectFilter) {
      const clearBtn = searchContainer.createEl('button', {
        cls: 'dmt-settings-search-clear',
        attr: { 'aria-label': 'Clear filter', title: 'Clear filter' }
      });
      IconHelpers.set(clearBtn, 'x');
      clearBtn.onclick = () => {
        this.objectFilter = '';
        searchInput.value = '';
        this.renderObjectList(objectListContainer, allCategories, allObjects, hiddenObjects);
      };
    }
    
    // Object list container (for filtered re-renders)
    const objectListContainer = containerEl.createDiv({ cls: 'dmt-settings-object-list-container' });
    this.renderObjectList(objectListContainer, allCategories, allObjects, hiddenObjects);
  },
  renderObjectList(container, allCategories, allObjects, hiddenObjects) {
    container.empty();
    
    const filter = this.objectFilter || '';
    const isDraggable = !filter; // Disable drag when filtering
    
    // Filter objects if search term present
    const filteredObjects = filter
      ? allObjects.filter(obj => 
          obj.label.toLowerCase().includes(filter) || 
          (obj.symbol && obj.symbol.toLowerCase().includes(filter)) ||
          (obj.iconClass && obj.iconClass.toLowerCase().includes(filter)))
      : allObjects;
    
    const filteredHidden = filter
      ? hiddenObjects.filter(obj =>
          obj.label.toLowerCase().includes(filter) ||
          (obj.symbol && obj.symbol.toLowerCase().includes(filter)) ||
          (obj.iconClass && obj.iconClass.toLowerCase().includes(filter)))
      : hiddenObjects;
    
    // Show "no results" message if filter returns nothing
    if (filter && filteredObjects.length === 0 && filteredHidden.length === 0) {
      container.createDiv({ 
        cls: 'dmt-settings-no-results',
        text: \`No objects matching "\${filter}"\`
      });
      return;
    }
    
    // Render each category (skip 'notes' - note_pin is handled specially in the map UI)
    for (const category of allCategories) {
      if (category.id === 'notes') continue;
      
      let categoryObjects = filteredObjects.filter(obj => obj.category === category.id);
      if (categoryObjects.length === 0 && category.isBuiltIn) continue;
      if (categoryObjects.length === 0 && filter) continue;
      
      // Sort by order
      categoryObjects = categoryObjects.slice().sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
      
      const categoryContainer = container.createDiv({ cls: 'dmt-settings-category' });
      
      // Category header with object count
      const categoryHeader = categoryContainer.createDiv({ cls: 'dmt-settings-category-header' });
      const labelText = category.label + (categoryObjects.length > 0 ? \` (\${categoryObjects.length})\` : '');
      categoryHeader.createSpan({ text: labelText, cls: 'dmt-settings-category-label' });
      
      // Edit/Delete for custom categories
      if (category.isCustom) {
        const categoryActions = categoryHeader.createDiv({ cls: 'dmt-settings-category-actions' });
        
        const editBtn = categoryActions.createEl('button', { cls: 'dmt-settings-icon-btn', attr: { 'aria-label': 'Edit category', title: 'Edit category' } });
        IconHelpers.set(editBtn, 'pencil');
        editBtn.onclick = () => {
          new CategoryEditModal(this.app, this.plugin, category, async () => {
            this.settingsChanged = true;
            await this.plugin.saveSettings();
            this.display();
          }).open();
        };
        
        // Get unfiltered count for delete validation
        const allCategoryObjects = allObjects.filter(obj => obj.category === category.id);
        const deleteBtn = categoryActions.createEl('button', { cls: 'dmt-settings-icon-btn dmt-settings-icon-btn-danger', attr: { 'aria-label': 'Delete category', title: 'Delete category' } });
        IconHelpers.set(deleteBtn, 'trash-2');
        deleteBtn.onclick = async () => {
          if (allCategoryObjects.length > 0) {
            alert(\`Cannot delete "\${category.label}" - it contains \${allCategoryObjects.length} object(s). Move or delete them first.\`);
            return;
          }
          if (confirm(\`Delete category "\${category.label}"?\`)) {
            const categoriesKey = this.selectedMapType === 'hex' ? 'customHexCategories' : 'customGridCategories';
            if (this.plugin.settings[categoriesKey]) {
              this.plugin.settings[categoriesKey] = this.plugin.settings[categoriesKey].filter(c => c.id !== category.id);
            }
            this.settingsChanged = true;
            await this.plugin.saveSettings();
            this.display();
          }
        };
      }
      
      // Object list with drag/drop support
      const objectList = categoryContainer.createDiv({ cls: 'dmt-settings-object-list' });
      objectList.dataset.categoryId = category.id;
      
      // Only enable drag/drop when not filtering
      if (!filter) {
        this.setupDragDropForList(objectList, category);
      }
      
      for (const obj of categoryObjects) {
        this.renderObjectRow(objectList, obj, false, !filter);
      }
    }
    
    // Hidden objects section
    if (filteredHidden.length > 0) {
      const hiddenContainer = container.createDiv({ cls: 'dmt-settings-hidden-section' });
      
      const hiddenHeader = new Setting(hiddenContainer)
        .setName(\`Hidden Objects (\${filteredHidden.length})\`)
        .setDesc('Built-in objects you\\'ve hidden from the palette');
      
      const hiddenList = hiddenContainer.createDiv({ cls: 'dmt-settings-object-list dmt-settings-hidden-list' });
      hiddenList.style.display = 'none';
      
      hiddenHeader.addButton(btn => btn
        .setButtonText('Show')
        .onClick(() => {
          const isVisible = hiddenList.style.display !== 'none';
          hiddenList.style.display = isVisible ? 'none' : 'block';
          btn.setButtonText(isVisible ? 'Show' : 'Hide');
        }));
      
      for (const obj of filteredHidden) {
        this.renderObjectRow(hiddenList, obj, true);
      }
    }
  },

  // ---------------------------------------------------------------------------
  // Drag/drop setup for object lists
  // ---------------------------------------------------------------------------
  
  setupDragDropForList(objectList, category) {
    objectList.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      
      const dragging = objectList.querySelector('.dmt-dragging');
      if (!dragging) return;
      
      const afterElement = DragHelpers.getAfterElement(objectList, e.clientY);
      if (afterElement == null) {
        objectList.appendChild(dragging);
      } else {
        objectList.insertBefore(dragging, afterElement);
      }
    });
    
    objectList.addEventListener('dragenter', (e) => {
      e.preventDefault();
    });
    
    objectList.addEventListener('drop', async (e) => {
      e.preventDefault();
      
      // Get the correct settings keys for the selected map type
      const overridesKey = this.selectedMapType === 'hex' ? 'hexObjectOverrides' : 'gridObjectOverrides';
      const customObjectsKey = this.selectedMapType === 'hex' ? 'customHexObjects' : 'customGridObjects';
      
      // Get new order from DOM positions
      const rows = [...objectList.querySelectorAll('.dmt-settings-object-row')];
      
      // Get default ID order for this category
      const defaultIdOrder = ObjectHelpers.getDefaultIdOrder(category.id, this.getObjectSettingsForMapType());
      
      // Apply new orders to settings
      rows.forEach((row, actualPosition) => {
        const id = row.dataset.objectId;
        const isBuiltIn = row.dataset.isBuiltIn === 'true';
        const newOrder = actualPosition * 10;
        
        if (isBuiltIn) {
          const defaultPosition = defaultIdOrder.indexOf(id);
          
          if (actualPosition === defaultPosition) {
            // In default position - remove order override if present
            if (this.plugin.settings[overridesKey]?.[id]) {
              delete this.plugin.settings[overridesKey][id].order;
              if (Object.keys(this.plugin.settings[overridesKey][id]).length === 0) {
                delete this.plugin.settings[overridesKey][id];
              }
            }
          } else {
            // Not in default position - save order override
            if (!this.plugin.settings[overridesKey]) {
              this.plugin.settings[overridesKey] = {};
            }
            if (!this.plugin.settings[overridesKey][id]) {
              this.plugin.settings[overridesKey][id] = {};
            }
            this.plugin.settings[overridesKey][id].order = newOrder;
          }
          
          // Update modified indicator in DOM immediately
          const labelEl = row.querySelector('.dmt-settings-object-label');
          if (labelEl) {
            const override = this.plugin.settings[overridesKey]?.[id];
            const hasAnyOverride = override && Object.keys(override).length > 0;
            labelEl.classList.toggle('dmt-settings-modified', !!hasAnyOverride);
          }
        } else {
          // Custom objects - always save order
          const customObjects = this.plugin.settings[customObjectsKey] || [];
          const customObj = customObjects.find(o => o.id === id);
          if (customObj) {
            customObj.order = newOrder;
          }
        }
      });
      
      this.settingsChanged = true;
      await this.plugin.saveSettings();
    });
  },
  renderObjectRow(container, obj, isHiddenSection = false, canDrag = false) {
    const row = container.createDiv({ cls: 'dmt-settings-object-row' });
    
    // Get the correct settings keys for the selected map type
    const overridesKey = this.selectedMapType === 'hex' ? 'hexObjectOverrides' : 'gridObjectOverrides';
    const customObjectsKey = this.selectedMapType === 'hex' ? 'customHexObjects' : 'customGridObjects';
    
    // Data attributes for drag/drop
    row.dataset.objectId = obj.id;
    row.dataset.isBuiltIn = String(!!obj.isBuiltIn);
    row.dataset.originalOrder = String(obj.order ?? 0);
    
    // Drag handle (only if draggable and not in hidden section)
    if (canDrag && !isHiddenSection) {
      row.setAttribute('draggable', 'true');
      row.classList.add('dmt-draggable');
      
      const dragHandle = row.createSpan({ cls: 'dmt-drag-handle' });
      IconHelpers.set(dragHandle, 'grip-vertical');
      
      row.style.userSelect = 'none';
      row.style.webkitUserSelect = 'none';
      
      row.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', obj.id);
        e.dataTransfer.effectAllowed = 'move';
        setTimeout(() => {
          row.classList.add('dmt-dragging');
        }, 0);
      });
      
      row.addEventListener('dragend', (e) => {
        row.classList.remove('dmt-dragging');
      });
    }
    
    // Symbol or Icon
    const symbolEl = row.createSpan({ cls: 'dmt-settings-object-symbol' });
    if (obj.iconClass && RPGAwesomeHelpers.isValid(obj.iconClass)) {
      const iconInfo = RPGAwesomeHelpers.getInfo(obj.iconClass);
      const iconSpan = symbolEl.createEl('span', { cls: 'ra' });
      iconSpan.textContent = iconInfo.char;
    } else {
      symbolEl.textContent = obj.symbol || '?';
    }
    
    // Label
    const labelEl = row.createSpan({ text: obj.label, cls: 'dmt-settings-object-label' });
    if (obj.isModified) {
      labelEl.addClass('dmt-settings-modified');
    }
    
    // Actions
    const actions = row.createDiv({ cls: 'dmt-settings-object-actions' });
    
    // Edit button
    const editBtn = actions.createEl('button', { cls: 'dmt-settings-icon-btn', attr: { 'aria-label': 'Edit', title: 'Edit object' } });
    IconHelpers.set(editBtn, 'pencil');
    editBtn.onclick = () => {
      new ObjectEditModal(this.app, this.plugin, obj, async () => {
        this.settingsChanged = true;
        await this.plugin.saveSettings();
        this.display();
      }, this.selectedMapType).open();
    };
    
    if (obj.isBuiltIn) {
      if (isHiddenSection) {
        // Unhide button
        const unhideBtn = actions.createEl('button', { cls: 'dmt-settings-icon-btn', attr: { 'aria-label': 'Unhide', title: 'Show in palette' } });
        IconHelpers.set(unhideBtn, 'eye');
        unhideBtn.onclick = async () => {
          if (this.plugin.settings[overridesKey]?.[obj.id]) {
            delete this.plugin.settings[overridesKey][obj.id].hidden;
            if (Object.keys(this.plugin.settings[overridesKey][obj.id]).length === 0) {
              delete this.plugin.settings[overridesKey][obj.id];
            }
          }
          this.settingsChanged = true;
          await this.plugin.saveSettings();
          this.display();
        };
      } else {
        // Hide button
        const hideBtn = actions.createEl('button', { cls: 'dmt-settings-icon-btn', attr: { 'aria-label': 'Hide', title: 'Hide from palette' } });
        IconHelpers.set(hideBtn, 'eye-off');
        hideBtn.onclick = async () => {
          if (!this.plugin.settings[overridesKey]) {
            this.plugin.settings[overridesKey] = {};
          }
          if (!this.plugin.settings[overridesKey][obj.id]) {
            this.plugin.settings[overridesKey][obj.id] = {};
          }
          this.plugin.settings[overridesKey][obj.id].hidden = true;
          this.settingsChanged = true;
          await this.plugin.saveSettings();
          this.display();
        };
      }
      
      // Reset button (only for modified)
      if (obj.isModified) {
        const resetBtn = actions.createEl('button', { cls: 'dmt-settings-icon-btn', attr: { 'aria-label': 'Reset to default', title: 'Reset to default' } });
        IconHelpers.set(resetBtn, 'rotate-ccw');
        resetBtn.onclick = async () => {
          if (confirm(\`Reset "\${obj.label}" to its default symbol and name?\`)) {
            if (this.plugin.settings[overridesKey]) {
              delete this.plugin.settings[overridesKey][obj.id];
            }
            this.settingsChanged = true;
            await this.plugin.saveSettings();
            this.display();
          }
        };
      }
    } else {
      // Delete button for custom objects
      const deleteBtn = actions.createEl('button', { cls: 'dmt-settings-icon-btn dmt-settings-icon-btn-danger', attr: { 'aria-label': 'Delete', title: 'Delete object' } });
      IconHelpers.set(deleteBtn, 'trash-2');
      deleteBtn.onclick = async () => {
        if (confirm(\`Delete "\${obj.label}"? Maps using this object will show a "?" placeholder.\`)) {
          if (this.plugin.settings[customObjectsKey]) {
            this.plugin.settings[customObjectsKey] = this.plugin.settings[customObjectsKey].filter(o => o.id !== obj.id);
          }
          this.settingsChanged = true;
          await this.plugin.saveSettings();
          this.display();
        }
      };
    }
  }

};`;
```

# settingsPlugin-styles

```js
return `/* settingsPlugin-styles.css
 * Windrose MapDesigner Settings Plugin Styles
 * This file is automatically loaded by Obsidian when the plugin is enabled.
 * Generated by settingsPluginAssembler.js
 */

/* ===========================================
 * Subheadings
 * =========================================== */
.dmt-settings-subheading {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-muted);
  margin: 1.5em 0 0.5em 0;
  padding-bottom: 4px;
  border-bottom: 1px solid var(--background-modifier-border);
}

/* ===========================================
 * Search/Filter
 * =========================================== */
.dmt-settings-search-container {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 1em;
}

.dmt-settings-search-input {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid var(--background-modifier-border);
  border-radius: 4px;
  background: var(--background-primary);
  font-size: 14px;
}

.dmt-settings-search-input:focus {
  border-color: var(--interactive-accent);
  outline: none;
}

.dmt-settings-search-clear {
  background: transparent;
  border: none;
  padding: 6px;
  border-radius: 4px;
  cursor: pointer;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  justify-content: center;
}

.dmt-settings-search-clear:hover {
  background: var(--background-modifier-hover);
  color: var(--text-normal);
}

.dmt-settings-no-results {
  text-align: center;
  padding: 2em;
  color: var(--text-muted);
  font-style: italic;
}

/* ===========================================
 * Category Containers
 * =========================================== */
.dmt-settings-category {
  margin: 1em 0;
  border: 1px solid var(--background-modifier-border);
  border-radius: 8px;
  overflow: hidden;
}

.dmt-settings-category-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 12px;
  background: var(--background-secondary);
  border-bottom: 1px solid var(--background-modifier-border);
}

.dmt-settings-category-label {
  font-weight: 600;
  font-size: 0.95em;
}

.dmt-settings-category-actions {
  display: flex;
  gap: 4px;
}

.dmt-settings-category-muted {
  opacity: 0.7;
}

.dmt-settings-empty-message {
  padding: 16px;
  text-align: center;
  color: var(--text-muted);
  font-style: italic;
}

/* ===========================================
 * Object Rows
 * =========================================== */
.dmt-settings-object-list {
  padding: 4px 0;
}

.dmt-settings-object-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  transition: background-color 0.15s ease;
}

.dmt-settings-object-row:hover {
  background: var(--background-modifier-hover);
}

.dmt-drag-handle {
  color: var(--text-muted);
  cursor: grab;
  padding: 0 4px;
  font-size: 1em;
  opacity: 0.4;
  user-select: none;
  flex-shrink: 0;
}

.dmt-settings-object-row:hover .dmt-drag-handle {
  opacity: 1;
}

.dmt-dragging {
  opacity: 0.5;
  background: var(--interactive-accent) !important;
  border-radius: 4px;
}

.dmt-settings-object-symbol {
  font-family: 'Noto Emoji', 'Noto Sans Symbols 2', sans-serif;
  font-size: 1.4em;
  width: 32px;
  text-align: center;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

.dmt-settings-object-symbol .ra {
  font-size: 1.2em;
  line-height: 1;
}

.dmt-settings-object-label {
  flex: 1;
  min-width: 0;
}

.dmt-settings-object-label.dmt-settings-modified {
  font-style: italic;
  color: var(--text-accent);
}

.dmt-settings-object-label.dmt-settings-modified::after {
  content: ' ';
  font-size: 0.8em;
  opacity: 0.7;
}

.dmt-settings-object-actions {
  display: flex;
  gap: 4px;
  flex-shrink: 0;
}

/* ===========================================
 * Icon Buttons
 * =========================================== */
.dmt-settings-icon-btn {
  background: transparent;
  border: none;
  padding: 4px 6px;
  border-radius: 4px;
  cursor: pointer;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  justify-content: center;
}

.dmt-settings-icon-btn:hover {
  background: var(--background-modifier-hover);
  color: var(--text-normal);
}

.dmt-settings-icon-btn-danger:hover {
  color: var(--text-error);
}

.dmt-btn-icon {
  background: transparent;
  border: none;
  padding: 4px;
  border-radius: 4px;
  cursor: pointer;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  justify-content: center;
}

.dmt-btn-icon:hover {
  background: var(--background-modifier-hover);
  color: var(--text-normal);
}

.dmt-btn-icon.dmt-btn-danger:hover {
  background: var(--background-modifier-error);
  color: var(--text-on-accent);
}

/* ===========================================
 * Hidden Section
 * =========================================== */
.dmt-settings-hidden-section {
  margin-top: 2em;
  padding-top: 1em;
  border-top: 1px solid var(--background-modifier-border);
}

.dmt-settings-hidden-list {
  margin-top: 8px;
  opacity: 0.7;
}

.dmt-settings-hidden-list .dmt-settings-object-row {
  background: var(--background-secondary);
}

/* ===========================================
 * Modal Base Styles
 * =========================================== */
.dmt-object-edit-modal,
.dmt-category-edit-modal {
  padding: 0;
}

.dmt-modal-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 1.5em;
  padding-top: 1em;
  border-top: 1px solid var(--background-modifier-border);
}

/* ===========================================
 * Symbol Input & Preview
 * =========================================== */
.dmt-symbol-input {
  font-family: 'Noto Emoji', 'Noto Sans Symbols 2', sans-serif;
  font-size: 1.5em;
  width: 80px;
  text-align: center;
  padding: 8px;
}

.dmt-symbol-preview {
  font-family: 'Noto Emoji', 'Noto Sans Symbols 2', sans-serif;
  font-size: 2em;
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--background-secondary);
  border-radius: 8px;
  margin-left: 8px;
}

/* ===========================================
 * Quick Symbols Grid
 * =========================================== */
.dmt-quick-symbols {
  margin: 1em 0;
}

.dmt-quick-symbols-label {
  display: block;
  font-size: 0.9em;
  color: var(--text-muted);
  margin-bottom: 8px;
}

.dmt-quick-symbols-grid {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  max-height: 150px;
  overflow-y: auto;
  padding: 4px;
  background: var(--background-secondary);
  border-radius: 8px;
}

.dmt-quick-symbol-btn {
  font-family: 'Noto Emoji', 'Noto Sans Symbols 2', sans-serif;
  width: 32px;
  height: 32px;
  font-size: 1.2em;
  border: 1px solid var(--background-modifier-border);
  background: var(--background-primary);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}

.dmt-quick-symbol-btn:hover {
  background: var(--background-modifier-hover);
  border-color: var(--interactive-accent);
}

/* ===========================================
 * Import/Export Modal Styles
 * =========================================== */
.dmt-export-modal,
.dmt-import-modal {
  padding: 0;
}

.dmt-export-empty {
  text-align: center;
  padding: 1em;
  color: var(--text-muted);
  font-style: italic;
}

.dmt-import-file-container {
  margin: 1em 0;
}

.dmt-import-file-container input[type="file"] {
  width: 100%;
  padding: 1em;
  border: 2px dashed var(--background-modifier-border);
  border-radius: 8px;
  background: var(--background-secondary);
  cursor: pointer;
}

.dmt-import-file-container input[type="file"]:hover {
  border-color: var(--interactive-accent);
}

.dmt-import-preview {
  margin: 1em 0;
  padding: 1em;
  background: var(--background-secondary);
  border-radius: 8px;
}

.dmt-import-preview p {
  margin: 0.25em 0;
}

.dmt-import-date {
  font-size: 0.85em;
  color: var(--text-muted);
}

.dmt-import-note {
  font-size: 0.9em;
  color: var(--text-muted);
  font-style: italic;
}

.dmt-import-error {
  color: var(--text-error);
  font-weight: 500;
}

.dmt-import-options {
  margin-top: 1em;
}

/* ===========================================
 * Icon Type Toggle
 * =========================================== */
.dmt-icon-type-toggle {
  display: flex;
  gap: 8px;
  margin-bottom: 1em;
}

.dmt-icon-type-btn {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid var(--background-modifier-border);
  background: var(--background-primary);
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.15s ease;
}

.dmt-icon-type-btn:hover {
  background: var(--background-modifier-hover);
}

.dmt-icon-type-btn.active {
  background: var(--interactive-accent);
  color: var(--text-on-accent);
  border-color: var(--interactive-accent);
}

/* ===========================================
 * Icon Picker Container
 * =========================================== */
.dmt-icon-picker {
  border: 1px solid var(--background-modifier-border);
  border-radius: 8px;
  background: var(--background-secondary);
  margin-bottom: 1em;
}

.dmt-icon-picker-search {
  padding: 8px;
  border-bottom: 1px solid var(--background-modifier-border);
}

.dmt-icon-picker-search input {
  width: 100%;
  padding: 6px 10px;
  border: 1px solid var(--background-modifier-border);
  border-radius: 4px;
  background: var(--background-primary);
  font-size: 14px;
}

.dmt-icon-picker-search input:focus {
  border-color: var(--interactive-accent);
  outline: none;
}

/* ===========================================
 * Category Tabs (Icon Picker)
 * =========================================== */
.dmt-icon-picker-tabs {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  padding: 8px;
  border-bottom: 1px solid var(--background-modifier-border);
  background: var(--background-primary-alt);
}

.dmt-icon-picker-tab {
  padding: 4px 8px;
  border: 1px solid transparent;
  background: transparent;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  color: var(--text-muted);
  transition: all 0.15s ease;
}

.dmt-icon-picker-tab:hover {
  background: var(--background-modifier-hover);
  color: var(--text-normal);
}

.dmt-icon-picker-tab.active {
  background: var(--interactive-accent);
  color: var(--text-on-accent);
}

/* ===========================================
 * Icon Grid
 * =========================================== */
.dmt-icon-picker-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
  gap: 4px;
  padding: 8px;
  max-height: 200px;
  overflow-y: auto;
}

.dmt-icon-picker-icon {
  width: 40px;
  height: 40px;
  border: 1px solid var(--background-modifier-border);
  background: var(--background-primary);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  transition: all 0.15s ease;
}

.dmt-icon-picker-icon:hover {
  background: var(--background-modifier-hover);
  border-color: var(--interactive-accent);
  transform: scale(1.1);
}

.dmt-icon-picker-icon.selected {
  background: var(--interactive-accent);
  color: var(--text-on-accent);
  border-color: var(--interactive-accent);
}

.dmt-icon-picker-icon .ra {
  font-size: 20px;
  line-height: 1;
}

.dmt-icon-picker-empty {
  padding: 2em;
  text-align: center;
  color: var(--text-muted);
  font-style: italic;
}

/* ===========================================
 * Selected Icon Preview
 * =========================================== */
.dmt-icon-preview-row {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px;
  border-top: 1px solid var(--background-modifier-border);
  background: var(--background-primary);
}

.dmt-icon-preview-large {
  width: 48px;
  height: 48px;
  border: 1px solid var(--background-modifier-border);
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;
  background: var(--background-secondary);
}

.dmt-icon-preview-large .ra {
  font-size: 28px;
  line-height: 1;
}

.dmt-icon-preview-info {
  flex: 1;
}

.dmt-icon-preview-label {
  font-weight: 500;
  margin-bottom: 2px;
}

.dmt-icon-preview-class {
  font-size: 12px;
  color: var(--text-muted);
  font-family: var(--font-monospace);
}

/* ===========================================
 * RPGAwesome Icon Font
 * Font-family name must be exactly 'rpgawesome'
 * Font is bundled in DungeonMapTracker FONTS.css
 * =========================================== */
.ra {
  font-family: 'rpgawesome' !important;
  font-style: normal;
  font-variant: normal;
  font-weight: normal;
  line-height: 1;
  speak: never;
  text-transform: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* ===========================================
 * Collapsible Sections
 * =========================================== */
.dmt-settings-section {
  margin: 0 0 8px 0;
  border: 1px solid var(--background-modifier-border);
  border-radius: 6px;
  overflow: hidden;
}

.dmt-settings-section > summary {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 16px;
  background: var(--background-secondary);
  cursor: pointer;
  font-weight: 600;
  font-size: 15px;
  list-style: none;
  user-select: none;
}

.dmt-settings-section > summary::-webkit-details-marker {
  display: none;
}

.dmt-settings-section > summary::before {
  content: '';
  font-size: 10px;
  transition: transform 0.2s ease;
  color: var(--text-muted);
}

.dmt-settings-section[open] > summary::before {
  transform: rotate(90deg);
}

.dmt-settings-section > summary:hover {
  background: var(--background-modifier-hover);
}

.dmt-settings-section-content {
  padding: 12px 16px;
  border-top: 1px solid var(--background-modifier-border);
}

.dmt-settings-section-content > .setting-item:first-child {
  border-top: none;
  padding-top: 0;
}

/* ===========================================
 * Settings Search
 * =========================================== */
.dmt-settings-search-wrapper {
  margin-bottom: 16px;
  position: sticky;
  top: 0;
  background: var(--background-primary);
  padding: 8px 0;
  z-index: 10;
}

.dmt-settings-search-box {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  border: 1px solid var(--background-modifier-border);
  border-radius: 6px;
  background: var(--background-primary);
}

.dmt-settings-search-box:focus-within {
  border-color: var(--interactive-accent);
}

.dmt-settings-search-box input {
  flex: 1;
  border: none;
  background: transparent;
  font-size: 14px;
  outline: none;
}

.dmt-settings-search-box .search-icon {
  color: var(--text-muted);
}

.dmt-settings-search-box .clear-btn {
  background: transparent;
  border: none;
  padding: 2px 6px;
  cursor: pointer;
  color: var(--text-muted);
  border-radius: 4px;
}

.dmt-settings-search-box .clear-btn:hover {
  background: var(--background-modifier-hover);
  color: var(--text-normal);
}

/* Hide non-matching settings during search */
.dmt-setting-hidden {
  display: none !important;
}

/* Highlight matching text */
.dmt-search-match {
  background: var(--text-highlight-bg);
  border-radius: 2px;
}

/* ===========================================
 * Color Palette Section
 * =========================================== */
.dmt-color-list {
  padding: 8px 0;
}

.dmt-color-row {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 12px;
  transition: background-color 0.15s ease;
}

.dmt-color-row:hover {
  background: var(--background-modifier-hover);
}

.dmt-color-row-swatch {
  width: 28px;
  height: 28px;
  border-radius: 4px;
  border: 2px solid var(--background-modifier-border);
  flex-shrink: 0;
}

.dmt-color-row-label {
  flex: 1;
  min-width: 0;
}

.dmt-color-row-name {
  font-weight: 500;
}

.dmt-color-row-modified,
.dmt-color-row-custom {
  font-size: 0.85em;
  color: var(--text-muted);
  font-style: italic;
}

.dmt-color-row-hex {
  font-size: 0.85em;
  color: var(--text-muted);
  background: var(--background-secondary);
  padding: 2px 6px;
  border-radius: 3px;
}

.dmt-color-row-actions {
  display: flex;
  gap: 4px;
  flex-shrink: 0;
}

/* ===========================================
 * Color Edit Modal
 * =========================================== */
.dmt-color-edit-modal {
  padding: 16px;
}

.dmt-color-hex-input {
  font-family: var(--font-monospace);
  width: 90px !important;
}

.dmt-color-original-info {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  margin: 12px 0;
  background: var(--background-secondary);
  border-radius: 4px;
  font-size: 0.9em;
  color: var(--text-muted);
}

.dmt-color-mini-swatch {
  display: inline-block;
  width: 16px;
  height: 16px;
  border-radius: 3px;
  border: 1px solid var(--background-modifier-border);
  vertical-align: middle;
}

.dmt-opacity-control {
  display: flex;
  align-items: center;
  gap: 8px;
}

.dmt-opacity-control input[type="range"] {
  width: 120px;
}

.dmt-opacity-value {
  min-width: 40px;
  text-align: right;
  font-size: 0.9em;
  color: var(--text-muted);
}

/* ===========================================
 * Insert Map Modal
 * =========================================== */
.dmt-insert-map-modal {
  padding: 16px;
}

.dmt-map-type-selection {
  margin-top: 16px;
}

.dmt-map-type-buttons {
  display: flex;
  gap: 8px;
  margin-top: 8px;
}

.dmt-map-type-btn {
  flex: 1;
  padding: 12px 16px;
  border: 2px solid var(--background-modifier-border);
  border-radius: 6px;
  background: var(--background-primary);
  color: var(--text-normal);
  cursor: pointer;
  font-size: 1em;
  transition: all 0.15s ease;
}

.dmt-map-type-btn:hover {
  border-color: var(--interactive-accent);
  background: var(--background-secondary);
}

.dmt-map-type-btn.selected {
  border-color: var(--interactive-accent);
  background: var(--interactive-accent);
  color: var(--text-on-accent);
}

/* ===========================================
 * Insert Dungeon Modal
 * =========================================== */
.dmt-insert-dungeon-modal {
  padding: 16px;
  min-width: 400px;
}

/* Soften the modal container's border and shadow */
.modal:has(.dmt-insert-dungeon-modal) {
  border: 1px solid var(--background-modifier-border);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
}

/* Header with Visualizer */
.dmt-dungeon-header {
  position: relative;
  margin: -16px -16px 0 -16px; /* Extend to modal edges, no bottom margin */
  overflow: hidden;
}

.dmt-dungeon-visualizer {
  width: 100%;
  height: 180px;
  position: relative;
}

.dmt-dungeon-visualizer canvas {
  display: block;
}

.dmt-dungeon-title-overlay {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 20px 16px 8px 16px;
  background: linear-gradient(to bottom, transparent 0%, var(--modal-background) 60%);
}

.dmt-dungeon-title-overlay h2 {
  margin: 0;
  font-size: 1.3em;
  color: var(--text-normal);
}

/* Space after header before first setting - this also serves as visual separator */
.dmt-dungeon-header + .setting-item {
  margin-top: 16px;
  border-top: none !important;
}

/* Stamp animation for visualizer */
@keyframes dmt-windrose-stamp {
  0% {
    transform: translate(-50%, -50%) scale(1.6) rotate(-18deg);
    opacity: 0;
  }
  50% {
    opacity: 0.8;
  }
  100% {
    transform: translate(-50%, -50%) scale(1) rotate(0deg);
    opacity: 0.75;
  }
}

.dmt-dungeon-size-selection {
  margin-top: 16px;
}

.dmt-dungeon-size-buttons {
  display: flex;
  gap: 8px;
  margin-top: 8px;
  flex-wrap: wrap;
}

.dmt-dungeon-size-btn {
  flex: 1;
  padding: 12px 16px;
  border: 2px solid var(--background-modifier-border);
  border-radius: 6px;
  background: var(--background-primary);
  color: var(--text-normal);
  cursor: pointer;
  font-size: 1em;
  font-weight: 500;
  transition: all 0.15s ease;
  text-align: center;
}

.dmt-dungeon-size-btn:hover {
  border-color: var(--interactive-accent);
  background: var(--background-secondary);
}

.dmt-dungeon-size-btn.selected {
  border-color: var(--interactive-accent);
  background: var(--interactive-accent);
  color: var(--text-on-accent);
}

.dmt-dungeon-style-selection {
  margin-top: 16px;
}

.dmt-dungeon-style-buttons {
  display: flex;
  gap: 8px;
  margin-top: 8px;
  flex-wrap: wrap;
}

.dmt-dungeon-style-btn {
  flex: 1;
  min-width: 70px;
  padding: 10px 12px;
  border: 2px solid var(--background-modifier-border);
  border-radius: 6px;
  background: var(--background-primary);
  color: var(--text-normal);
  cursor: pointer;
  font-size: 0.9em;
  font-weight: 500;
  transition: all 0.15s ease;
  text-align: center;
}

.dmt-dungeon-style-btn:hover {
  border-color: var(--interactive-accent);
  background: var(--background-secondary);
}

.dmt-dungeon-style-btn.selected {
  border-color: var(--interactive-accent);
  background: var(--interactive-accent);
  color: var(--text-on-accent);
}

.dmt-dungeon-distance-row {
  display: flex;
  gap: 8px;
  align-items: center;
  margin-top: 8px;
}

.dmt-dungeon-distance-row input[type="number"] {
  width: 80px;
}

.dmt-dungeon-distance-row input[type="text"] {
  width: 60px;
}

/* Advanced options section */
.dmt-dungeon-advanced {
  margin-top: 16px;
  border: 1px solid var(--background-modifier-border);
  border-radius: 6px;
  overflow: hidden;
}

.dmt-dungeon-advanced-header {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 12px;
  background: var(--background-secondary);
  cursor: pointer;
  user-select: none;
  font-weight: 500;
}

.dmt-dungeon-advanced-header:hover {
  background: var(--background-modifier-hover);
}

.dmt-dungeon-advanced-chevron {
  font-size: 0.75em;
  color: var(--text-muted);
}

.dmt-dungeon-advanced-content {
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.dmt-dungeon-slider-row {
  display: flex;
  align-items: center;
  gap: 12px;
}

.dmt-dungeon-slider-row label {
  flex: 0 0 130px;
  font-size: 0.9em;
  color: var(--text-normal);
}

.dmt-dungeon-slider-container {
  flex: 1;
  display: flex;
  align-items: center;
  gap: 10px;
}

.dmt-dungeon-slider-container input[type="range"] {
  flex: 1;
  height: 4px;
  -webkit-appearance: none;
  appearance: none;
  background: var(--background-modifier-border);
  border-radius: 2px;
  cursor: pointer;
}

.dmt-dungeon-slider-container input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--interactive-accent);
  cursor: pointer;
}

.dmt-dungeon-slider-container input[type="range"]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--interactive-accent);
  border: none;
  cursor: pointer;
}

.dmt-dungeon-slider-value {
  flex: 0 0 60px;
  text-align: right;
  font-size: 0.85em;
  color: var(--text-muted);
  font-family: var(--font-monospace);
}

.dmt-dungeon-toggle-container {
  flex: 1;
  display: flex;
  align-items: center;
}

.dmt-dungeon-select {
  padding: 4px 8px;
  border: 1px solid var(--background-modifier-border);
  border-radius: 4px;
  background: var(--background-primary);
  color: var(--text-normal);
  font-size: 0.9em;
  cursor: pointer;
}

/* ===========================================
 * Dungeon Modal Section Headers
 * =========================================== */
.dmt-dungeon-section-header {
  font-size: 0.85em;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-top: 16px;
  padding-top: 12px;
  border-top: 1px solid var(--background-modifier-border);
}

.dmt-dungeon-subsection {
  font-size: 0.8em;
  font-weight: 500;
  color: var(--text-muted);
  margin-top: 8px;
  padding-left: 4px;
}

.dmt-checkbox-hint {
  font-size: 0.8em;
  color: var(--text-muted);
  margin-left: 142px;
  margin-top: 2px;
}

/* ===========================================
 * Animations
 * =========================================== */
@keyframes dmt-shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-4px); }
  75% { transform: translateX(4px); }
}

.dmt-shake {
  animation: dmt-shake 0.3s ease;
}`;
```

# settingsPluginAssembler

```js
// settingsPluginAssembler.js
// Assembles the Windrose MapDesigner Settings Plugin from component files

// Load all component files directly
const BASE_TEMPLATE = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPluginMain"));

const ObjectHelpers = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-ObjectHelpers"));
const ColorHelpers = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-ColorHelpers"));
const DragHelpers = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-DragHelpers"));
const IconHelpers = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-IconHelpers"));
const RPGAwesomeHelpers = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-RPGAwesomeHelpers"));
const DungeonEssenceVisualizer = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-DungeonEssenceVisualizer"));

const InsertMapModal = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-InsertMapModal"));
const InsertDungeonModal = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-InsertDungeonModal"));
const ObjectEditModal = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-ObjectEditModal"));
const CategoryEditModal = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-CategoryEditModal"));
const ColorEditModal = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-ColorEditModal"));
const ExportModal = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-ExportModal"));
const ImportModal = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-ImportModal"));

const TabRenderCore = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-TabRenderCore"));
const TabRenderSettings = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-TabRenderSettings"));
const TabRenderColors = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-TabRenderColors"));
const TabRenderObjects = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-TabRenderObjects"));

const STYLES_CSS = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-styles"));

// Concatenate content
const HELPERS_CONTENT = [
  ObjectHelpers, ColorHelpers, DragHelpers, IconHelpers, RPGAwesomeHelpers, DungeonEssenceVisualizer
].join('\n\n');

const MODALS_CONTENT = [
  InsertMapModal, InsertDungeonModal, ObjectEditModal, CategoryEditModal, ColorEditModal, ExportModal, ImportModal
].join('\n\n');

const TAB_RENDER_CONTENT = [
  TabRenderCore, TabRenderSettings, TabRenderColors, TabRenderObjects
].join('\n\n');

// Assembly function
function assembleSettingsPlugin() {
  return BASE_TEMPLATE
    .replace(/\{\{HELPER_NAMESPACES\}\}/g, () => HELPERS_CONTENT)
    .replace(/\{\{MODAL_CLASSES\}\}/g, () => MODALS_CONTENT)
    .replace(/\{\{TAB_RENDER_METHODS\}\}/g, () => TAB_RENDER_CONTENT);
}

function getStylesCSS() {
  return STYLES_CSS;
}

return {
  assembleSettingsPlugin,
  getStylesCSS,
  ASSEMBLER_VERSION: '2.0.0'
};
```

# SettingsPluginInstaller

```tsx
/**
 * SettingsPluginInstaller.tsx
 *
 * Inline prompt for settings plugin installation/upgrade.
 * Handles installing or upgrading the Windrose MapDesigner Settings plugin
 * which provides global customization options.
 */

const { THEME, DEFAULTS } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants"));
const { WindroseCompass } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "WindroseCompass"));

// NOTE: Assembler is lazy-loaded only when install/upgrade is triggered
// This avoids running assembly on every app load

const { OBJECT_TYPES, CATEGORIES } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "objectTypes"));
const { RA_ICONS, RA_CATEGORIES } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "rpgAwesomeIcons"));
const QUICK_SYMBOLS = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPlugin-quickSymbols"));

/** Plugin version from template */
const PACKAGED_PLUGIN_VERSION = '0.14.6.4';

/** LocalStorage keys for tracking user preferences */
const STORAGE_KEYS = {
  INSTALL_DECLINED: 'dmt-plugin-install-declined',
  UPGRADE_DECLINED_VERSION: 'dmt-plugin-upgrade-declined-version'
} as const;

/** Plugin mode type */
type PluginMode = 'auto' | 'install' | 'upgrade';

/** Action mode type */
type ActionMode = 'install' | 'upgrade';

/** Generated plugin files */
interface PluginFiles {
  mainJs: string;
  stylesCSS: string | null;
}

/** Plugin manifest structure */
interface PluginManifest {
  id: string;
  name: string;
  version: string;
  minAppVersion: string;
  description: string;
  author: string;
  isDesktopOnly: boolean;
}

/** Props for SettingsPluginInstaller component */
export interface SettingsPluginInstallerProps {
  onInstall: () => void;
  onDecline: () => void;
  mode?: PluginMode;
}

/**
 * Compare semantic version strings (e.g., "1.2.3" vs "1.1.0")
 * @returns 1 if v1 > v2, -1 if v1 < v2, 0 if equal
 */
function compareVersions(v1: string, v2: string): number {
  const parts1 = v1.split('.').map(Number);
  const parts2 = v2.split('.').map(Number);

  for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
    const num1 = parts1[i] || 0;
    const num2 = parts2[i] || 0;

    if (num1 > num2) return 1;
    if (num1 < num2) return -1;
  }

  return 0;
}

/**
 * Get the installed plugin's version from its manifest
 */
function getInstalledPluginVersion(): string | null {
  try {
    // Use manifests object directly - plugin.manifest may be undefined even when plugin exists
    return dc.app.plugins.manifests['dungeon-map-tracker-settings']?.version || null;
  } catch {
    return null;
  }
}

/**
 * Check if plugin is installed
 */
function isPluginInstalled(): boolean {
  try {
    // We'll do an async check in the component, this is just a quick sync check
    return !!dc.app.plugins.plugins['dungeon-map-tracker-settings'];
  } catch {
    return false;
  }
}

/**
 * Check if an upgrade is available and not declined
 */
function shouldOfferUpgrade(): boolean {
  const installedVersion = getInstalledPluginVersion();
  if (!installedVersion) return false;

  // Check if upgrade is available
  const upgradeAvailable = compareVersions(PACKAGED_PLUGIN_VERSION, installedVersion) > 0;
  if (!upgradeAvailable) return false;

  // Check if user declined this specific version
  const declinedVersion = localStorage.getItem(STORAGE_KEYS.UPGRADE_DECLINED_VERSION);
  if (declinedVersion === PACKAGED_PLUGIN_VERSION) return false;

  return true;
}

/**
 * Generate manifest object with current version
 */
function generateManifest(): PluginManifest {
  return {
    id: 'dungeon-map-tracker-settings',
    name: 'Windrose MapDesigner',
    version: PACKAGED_PLUGIN_VERSION,
    minAppVersion: '0.15.0',
    description: 'Global settings and commands for Windrose MapDesigner - customize default colors, hex orientation, and visual preferences.',
    author: 'Windrose MD',
    isDesktopOnly: false
  };
}

/**
 * Escape non-ASCII unicode characters in a string as \uXXXX sequences.
 * Required for PUA (Private Use Area) characters in RA_ICONS that can
 * cause parsing issues on some platforms when embedded as raw characters.
 */
function escapeUnicode(str: string): string {
  return str.replace(/[\u0080-\uffff]/g, (c) => {
    return '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0');
  });
}

/**
 * Generate main.js content from template with injected constants.
 * Assembles fresh each time to ensure upgrades get latest code.
 */
async function generatePluginFiles(): Promise<PluginFiles> {
  // Lazy-load assembler only when actually installing/upgrading
  const { assembleSettingsPlugin, getStylesCSS } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsPluginAssembler"));

  // Assemble the plugin fresh (loads all source files)
  const SETTINGS_PLUGIN_TEMPLATE = await assembleSettingsPlugin();
  const stylesCSS = await getStylesCSS();

  // Build category order map from CATEGORIES
  const categoryOrder: Record<string, number> = {};
  CATEGORIES.forEach((c: { id: string; order: number }) => { categoryOrder[c.id] = c.order; });

  const mainJs = SETTINGS_PLUGIN_TEMPLATE
    .replace(/\{\{PLUGIN_VERSION\}\}/g, PACKAGED_PLUGIN_VERSION)
    .replace(/\{\{DEFAULT_HEX_ORIENTATION\}\}/g, DEFAULTS.hexOrientation)
    .replace(/\{\{DEFAULT_GRID_LINE_COLOR\}\}/g, THEME.grid.lines)
    .replace(/\{\{DEFAULT_BACKGROUND_COLOR\}\}/g, THEME.grid.background)
    .replace(/\{\{DEFAULT_BORDER_COLOR\}\}/g, THEME.cells.border)
    .replace(/\{\{DEFAULT_COORDINATE_KEY_COLOR\}\}/g, THEME.coordinateKey.color)
    .replace(/\{\{DEFAULT_COORDINATE_TEXT_COLOR\}\}/g, THEME.coordinateText.color)
    .replace(/\{\{DEFAULT_COORDINATE_TEXT_SHADOW\}\}/g, THEME.coordinateText.shadow)
    .replace('{{BUILT_IN_OBJECTS}}', JSON.stringify(OBJECT_TYPES, null, 2))
    .replace('{{BUILT_IN_CATEGORIES}}', JSON.stringify(CATEGORIES, null, 2))
    .replace('{{CATEGORY_ORDER}}', JSON.stringify(categoryOrder, null, 2))
    .replace('{{RA_ICONS}}', escapeUnicode(JSON.stringify(RA_ICONS, null, 2)))
    .replace('{{RA_CATEGORIES}}', JSON.stringify(RA_CATEGORIES, null, 2))
    .replace('{{QUICK_SYMBOLS}}', JSON.stringify(QUICK_SYMBOLS));

  return { mainJs, stylesCSS };
}

const SettingsPluginInstaller = ({
  onInstall,
  onDecline,
  mode = 'auto'
}: SettingsPluginInstallerProps): React.ReactElement => {
  const [isInstalling, setIsInstalling] = dc.useState(false);
  const [installError, setInstallError] = dc.useState<string | null>(null);
  const [showSuccessModal, setShowSuccessModal] = dc.useState(false);

  // Determine if we're in install or upgrade mode
  const installedVersion = getInstalledPluginVersion();
  const isUpgradeMode = mode === 'upgrade' || (mode === 'auto' && installedVersion && shouldOfferUpgrade());
  const actionMode: ActionMode = isUpgradeMode ? 'upgrade' : 'install';

  const handleInstall = async (): Promise<void> => {
    setIsInstalling(true);
    setInstallError(null);

    try {
      const pluginDir = '.obsidian/plugins/dungeon-map-tracker-settings';
      const adapter = dc.app.vault.adapter;

      // Check if plugin directory already exists
      const exists = await adapter.exists(pluginDir);
      if (exists) {
        setInstallError('Plugin directory already exists. Please enable it in Community Plugins settings.');
        setIsInstalling(false);
        return;
      }

      // Create plugin directory
      await adapter.mkdir(pluginDir);

      // Write manifest.json
      await adapter.write(
        `${pluginDir}/manifest.json`,
        JSON.stringify(generateManifest(), null, 2)
      );

      // Write main.js from template
      const { mainJs, stylesCSS } = await generatePluginFiles();
      await adapter.write(`${pluginDir}/main.js`, mainJs);

      // Write styles.css for Obsidian to load automatically
      if (stylesCSS) {
        await adapter.write(`${pluginDir}/styles.css`, stylesCSS);
      } else {
        console.warn('[SettingsPluginInstaller] No CSS content available - inline styles will be used');
      }

      // Create initial data.json with defaults from dmtConstants
      const defaultData = {
        version: '1.0.0',
        hexOrientation: DEFAULTS.hexOrientation,
        gridLineColor: THEME.grid.lines,
        gridLineWidth: THEME.grid.lineWidth,
        backgroundColor: THEME.grid.background,
        borderColor: THEME.cells.border,
        coordinateKeyColor: THEME.coordinateKey.color,
        expandedByDefault: false,
        // Object customization
        objectOverrides: {},
        customObjects: [],
        customCategories: []
      };
      await adapter.write(
        `${pluginDir}/data.json`,
        JSON.stringify(defaultData, null, 2)
      );

      try {
        const communityPluginsPath = '.obsidian/community-plugins.json';
        let enabledPlugins: string[] = [];

        // Read existing community-plugins.json if it exists
        if (await adapter.exists(communityPluginsPath)) {
          const content = await adapter.read(communityPluginsPath);
          enabledPlugins = JSON.parse(content);
        }

        // Add our plugin if not already in the list
        if (!enabledPlugins.includes('dungeon-map-tracker-settings')) {
          enabledPlugins.push('dungeon-map-tracker-settings');
          await adapter.write(communityPluginsPath, JSON.stringify(enabledPlugins, null, 2));
        }

        // Reload plugins to detect the new plugin (but don't enable yet)
        await dc.app.plugins.loadManifests();
      } catch (manifestError) {
        console.warn('[SettingsPluginInstaller] Could not reload manifests:', manifestError);
        // Not critical - plugin will be detected on next Obsidian restart
      }

      setIsInstalling(false);
      setShowSuccessModal(true);
    } catch (error) {
      console.error('[SettingsPluginInstaller] Installation error:', error);
      setInstallError(`Installation failed: ${(error as Error).message}`);
      setIsInstalling(false);
    }
  };

  const handleUpgrade = async (): Promise<void> => {
    setIsInstalling(true);
    setInstallError(null);

    try {
      const pluginDir = '.obsidian/plugins/dungeon-map-tracker-settings';
      const adapter = dc.app.vault.adapter;

      // Verify plugin exists
      const exists = await adapter.exists(pluginDir);
      if (!exists) {
        setInstallError('Plugin not found. Please install it first.');
        setIsInstalling(false);
        return;
      }

      // Write updated manifest.json
      await adapter.write(
        `${pluginDir}/manifest.json`,
        JSON.stringify(generateManifest(), null, 2)
      );

      // Write updated main.js from template
      const { mainJs, stylesCSS } = await generatePluginFiles();
      await adapter.write(`${pluginDir}/main.js`, mainJs);

      // Write/update styles.css for Obsidian to load automatically
      if (stylesCSS) {
        await adapter.write(`${pluginDir}/styles.css`, stylesCSS);
      }

      // DO NOT overwrite data.json - preserve user settings

      // Reload the plugin
      try {
        await dc.app.plugins.disablePlugin('dungeon-map-tracker-settings');
        await dc.app.plugins.loadManifests();
        await dc.app.plugins.enablePlugin('dungeon-map-tracker-settings');
      } catch (reloadError) {
        console.warn('[SettingsPluginInstaller] Could not reload plugin:', reloadError);
        // Not critical - plugin will be updated on next Obsidian restart
      }

      setIsInstalling(false);
      setShowSuccessModal(true);
    } catch (error) {
      console.error('[SettingsPluginInstaller] Upgrade error:', error);
      setInstallError(`Upgrade failed: ${(error as Error).message}`);
      setIsInstalling(false);
    }
  };

  const handleAction = (): void => {
    if (actionMode === 'upgrade') {
      handleUpgrade();
    } else {
      handleInstall();
    }
  };

  const handleDecline = (): void => {
    if (actionMode === 'upgrade') {
      // Store the declined version
      localStorage.setItem(STORAGE_KEYS.UPGRADE_DECLINED_VERSION, PACKAGED_PLUGIN_VERSION);
    } else {
      // Store that install was declined
      localStorage.setItem(STORAGE_KEYS.INSTALL_DECLINED, 'true');
    }
    onDecline();
  };

  const handleEnableNow = async (): Promise<void> => {
    try {
      // Small delay to ensure manifest is loaded
      await new Promise(resolve => setTimeout(resolve, 100));

      // Enable the plugin
      await dc.app.plugins.enablePlugin('dungeon-map-tracker-settings');

      setShowSuccessModal(false);
      onInstall();
    } catch (enableError) {
      console.error('[SettingsPluginInstaller] Failed to enable plugin:', enableError);
      setInstallError(`Failed to enable plugin: ${(enableError as Error).message}`);
      setShowSuccessModal(false);
    }
  };

  const handleContinueWithoutEnabling = (): void => {
    setShowSuccessModal(false);
    onInstall();
  };

  return (
    <div className="dmt-plugin-installer">
      <div className="dmt-plugin-installer-card">
        <div className="dmt-plugin-installer-icon">
          <WindroseCompass size={84} />
        </div>
        <div className="dmt-plugin-installer-content">
          <h3>
            {actionMode === 'upgrade'
              ? `Update Available (v${installedVersion}  v${PACKAGED_PLUGIN_VERSION})`
              : 'Enhance Your Mapping Experience'
            }
          </h3>
          <p>
            {actionMode === 'upgrade'
              ? `A new version of the Windrose MapDesigner Settings plugin is available.`
              : `Install the Windrose MapDesigner Settings plugin to customize:`
            }
          </p>
          {actionMode === 'install' && (
            <ul>
              <li>Default colors for grids, borders, and backgrounds</li>
              <li>Hex grid orientation (flat-top or pointy-top)</li>
              <li>Coordinate label colors</li>
              <li>Custom map objects and symbols</li>
              <li>Visual preferences across all your maps</li>
            </ul>
          )}
          {actionMode === 'upgrade' && (
            <p className="dmt-plugin-installer-note">
              Your settings will be preserved during the update.
            </p>
          )}
          <p className="dmt-plugin-installer-note">
            {actionMode === 'upgrade'
              ? 'You can update now or continue with your current version.'
              : 'This is a one-time setup. You can change settings anytime in Obsidian\'s Settings panel. If you decline, default colors will be used.'
            }
          </p>
          {installError && (
            <div className="dmt-plugin-installer-error">
              {installError}
            </div>
          )}
        </div>
        <div className="dmt-plugin-installer-actions">
          <button
            className="dmt-plugin-installer-btn dmt-plugin-installer-btn-primary"
            onClick={handleAction}
            disabled={isInstalling}
          >
            {isInstalling
              ? (actionMode === 'upgrade' ? 'Updating...' : 'Installing...')
              : (actionMode === 'upgrade' ? 'Update Plugin' : 'Install Plugin')
            }
          </button>
          <button
            className="dmt-plugin-installer-btn dmt-plugin-installer-btn-secondary"
            onClick={handleDecline}
            disabled={isInstalling}
          >
            {actionMode === 'upgrade' ? 'Not Now' : 'Use Defaults'}
          </button>
        </div>
      </div>

      {showSuccessModal && (
        <div className="dmt-plugin-success-modal-overlay">
          <div className="dmt-plugin-success-modal">
            <div className="dmt-plugin-success-icon">
              <dc.Icon icon="lucide-check-circle" />
            </div>
            <h3>
              {actionMode === 'upgrade'
                ? 'Plugin Updated Successfully!'
                : 'Plugin Installed Successfully!'
              }
            </h3>
            <p>
              {actionMode === 'upgrade'
                ? `The Windrose MD Settings plugin has been updated to v${PACKAGED_PLUGIN_VERSION}.`
                : `The Windrose MD Settings plugin has been installed.`
              }
              {actionMode === 'install' && ' Would you like to enable it now?'}
            </p>
            {actionMode === 'install' && (
              <p className="dmt-plugin-success-note">
                You can always enable or disable this plugin later in Obsidian's Community Plugins settings.
              </p>
            )}
            <div className="dmt-plugin-success-actions">
              {actionMode === 'install' ? (
                <>
                  <button
                    className="dmt-plugin-installer-btn dmt-plugin-installer-btn-primary"
                    onClick={handleEnableNow}
                  >
                    Enable Now
                  </button>
                  <button
                    className="dmt-plugin-installer-btn dmt-plugin-installer-btn-secondary"
                    onClick={handleContinueWithoutEnabling}
                  >
                    Continue Without Enabling
                  </button>
                </>
              ) : (
                <button
                  className="dmt-plugin-installer-btn dmt-plugin-installer-btn-primary"
                  onClick={() => {
                    setShowSuccessModal(false);
                    onInstall();
                  }}
                >
                  Continue
                </button>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

return {
  SettingsPluginInstaller,
  // Export utilities for other components to check upgrade status
  PACKAGED_PLUGIN_VERSION,
  shouldOfferUpgrade,
  getInstalledPluginVersion,
  isPluginInstalled,
  compareVersions,
  STORAGE_KEYS
};

```

# hexMeasurements

```ts
/**
 * hexMeasurements.ts
 * 
 * Pure functions for hex measurement conversions and grid sizing calculations.
 * Handles conversions between different measurement methods (edge-to-edge, 
 * corner-to-corner) and hexSize (center-to-vertex radius).
 * 
 * Similar to offsetCoordinates.js, this module provides pure mathematical functions
 * with no side effects, state, or dependencies on other modules.
 * 
 * Used by MapSettingsModal for sizing UI and by calculation systems for grid generation.
 * 
 * MEASUREMENT TERMINOLOGY:
 * - hexSize: Center-to-vertex radius (internal representation)
 * - edge-to-edge: Distance between parallel flat sides (flat-to-flat)
 * - corner-to-corner: Distance between opposite vertices (point-to-point)
 * 
 * For both flat-top and pointy-top hexes:
 * - Corner-to-corner = 2 * hexSize (vertex to opposite vertex)
 * - Edge-to-edge = sqrt(3) * hexSize (flat side to opposite flat side)
 */

import type { HexOrientation, GridCalculation } from '#types/settings/settings.types';

// ===========================================
// Type Definitions
// ===========================================

/** Measurement method */
export type MeasurementMethod = 'edge' | 'corner';

/** Validation result */
export interface ValidationResult {
  valid: boolean;
  error: string | null;
}

/** Fine-tune range */
export interface FineTuneRange {
  min: number;
  max: number;
}

// ===========================================
// Constants
// ===========================================

/** Edge-to-edge measurement method */
const MEASUREMENT_EDGE: MeasurementMethod = 'edge';

/** Corner-to-corner measurement method */
const MEASUREMENT_CORNER: MeasurementMethod = 'corner';

/** Minimum hex size in pixels */
const MIN_MEASUREMENT_SIZE = 10;

/** Maximum hex size in pixels */
const MAX_MEASUREMENT_SIZE = 500;

/** Maximum fine-tune adjustment in pixels */
const MAX_FINE_TUNE_OFFSET = 3;

// ===========================================
// Core Conversions
// ===========================================

/**
 * Convert user measurement to hexSize (center-to-vertex radius)
 */
function measurementToHexSize(
  size: number,
  method: MeasurementMethod,
  orientation: HexOrientation = 'flat'
): number {
  if (method === MEASUREMENT_EDGE) {
    // Edge-to-edge = sqrt(3) * hexSize, so hexSize = size / sqrt(3)
    return size / Math.sqrt(3);
  } else {
    // Corner-to-corner = 2 * hexSize, so hexSize = size / 2
    return size / 2;
  }
}

/**
 * Convert hexSize to user measurement
 */
function hexSizeToMeasurement(
  hexSize: number,
  method: MeasurementMethod,
  orientation: HexOrientation = 'flat'
): number {
  if (method === MEASUREMENT_EDGE) {
    // Edge-to-edge = sqrt(3) * hexSize
    return hexSize * Math.sqrt(3);
  } else {
    // Corner-to-corner = 2 * hexSize
    return hexSize * 2;
  }
}

// ===========================================
// Grid Calculations
// ===========================================

/**
 * Calculate columns that fit in given width.
 * Uses ceiling to ensure full image coverage.
 */
function calculateColumns(
  imageWidth: number,
  hexSize: number,
  orientation: HexOrientation
): number {
  if (orientation === 'pointy') {
    // Pointy: columns * sqrt(3) * hexSize = imageWidth
    return Math.ceil(imageWidth / (hexSize * Math.sqrt(3)));
  } else {
    // Flat: hexSize * (2 + (columns - 1) * 1.5) = imageWidth
    // Solving for columns: (imageWidth / hexSize - 2) / 1.5 + 1
    // Simplified: (imageWidth / hexSize - 0.5) / 1.5
    return Math.ceil((imageWidth / hexSize - 0.5) / 1.5);
  }
}

/**
 * Calculate rows that fit in given height.
 * Uses ceiling to ensure full image coverage.
 */
function calculateRows(
  imageHeight: number,
  hexSize: number,
  orientation: HexOrientation
): number {
  if (orientation === 'pointy') {
    // Pointy: hexSize * (2 + (rows - 1) * 1.5) = imageHeight
    return Math.ceil((imageHeight / hexSize - 0.5) / 1.5);
  } else {
    // Flat: rows * sqrt(3) * hexSize = imageHeight
    return Math.ceil(imageHeight / (hexSize * Math.sqrt(3)));
  }
}

/**
 * Calculate hexSize from desired column count (density mode).
 * This is the inverse of calculateColumns.
 */
function calculateHexSizeFromColumns(
  imageWidth: number,
  columns: number,
  orientation: HexOrientation
): number {
  if (orientation === 'pointy') {
    // Pointy: imageWidth = columns * sqrt(3) * hexSize
    return imageWidth / (columns * Math.sqrt(3));
  } else {
    // Flat: imageWidth = hexSize * (2 + (columns - 1) * 1.5)
    return imageWidth / (2 + (columns - 1) * 1.5);
  }
}

/**
 * Calculate grid from user measurement (measurement mode / Advanced tab).
 * Primary API for "Advanced" mode where user specifies hex size directly.
 */
function calculateGridFromMeasurement(
  imageWidth: number,
  imageHeight: number,
  size: number,
  method: MeasurementMethod,
  orientation: HexOrientation = 'flat'
): GridCalculation {
  const hexSize = measurementToHexSize(size, method, orientation);
  const columns = calculateColumns(imageWidth, hexSize, orientation);
  const rows = calculateRows(imageHeight, hexSize, orientation);
  
  return {
    columns,
    rows,
    hexSize
  };
}

/**
 * Calculate grid from column count (density mode / Quick Setup tab).
 * Primary API for "Quick Setup" mode where user selects density preset or custom column count.
 */
function calculateGridFromColumns(
  imageWidth: number,
  imageHeight: number,
  columns: number,
  orientation: HexOrientation = 'flat'
): GridCalculation {
  const hexSize = calculateHexSizeFromColumns(imageWidth, columns, orientation);
  const rows = calculateRows(imageHeight, hexSize, orientation);
  
  return {
    columns,
    rows,
    hexSize
  };
}

// ===========================================
// Validation
// ===========================================

/**
 * Validate measurement size is within acceptable range
 */
function validateMeasurementSize(size: number): ValidationResult {
  if (size < MIN_MEASUREMENT_SIZE) {
    return { 
      valid: false, 
      error: `Hex size must be at least ${MIN_MEASUREMENT_SIZE}px` 
    };
  }
  if (size > MAX_MEASUREMENT_SIZE) {
    return { 
      valid: false, 
      error: `Hex size must be no more than ${MAX_MEASUREMENT_SIZE}px` 
    };
  }
  return { valid: true, error: null };
}

/**
 * Validate fine-tune offset is within acceptable range
 */
function validateFineTune(baseHexSize: number, adjustedHexSize: number): ValidationResult {
  const offset = Math.abs(adjustedHexSize - baseHexSize);
  
  if (offset > MAX_FINE_TUNE_OFFSET) {
    return { 
      valid: false, 
      error: `Fine-tune adjustment limited to ${MAX_FINE_TUNE_OFFSET}px` 
    };
  }
  return { valid: true, error: null };
}

/**
 * Calculate allowed range for fine-tune adjustment
 */
function getFineTuneRange(baseHexSize: number): FineTuneRange {
  return {
    min: Math.max(MIN_MEASUREMENT_SIZE / 2, baseHexSize - MAX_FINE_TUNE_OFFSET),
    max: Math.min(MAX_MEASUREMENT_SIZE / 2, baseHexSize + MAX_FINE_TUNE_OFFSET)
  };
}

// ===========================================
// Exports
// ===========================================

return {
  // Constants
  MEASUREMENT_EDGE,
  MEASUREMENT_CORNER,
  MIN_MEASUREMENT_SIZE,
  MAX_MEASUREMENT_SIZE,
  MAX_FINE_TUNE_OFFSET,
  
  // Core conversions
  measurementToHexSize,
  hexSizeToMeasurement,
  
  // Grid calculations
  calculateColumns,
  calculateRows,
  calculateHexSizeFromColumns,
  calculateGridFromMeasurement,
  calculateGridFromColumns,
  
  // Validation
  validateMeasurementSize,
  validateFineTune,
  getFineTuneRange
};
```

# settingsReducer

```ts
/**
 * settingsReducer.ts
 * 
 * Pure state management for MapSettingsModal.
 * Contains action types, reducer function, and state initialization logic.
 * No React dependencies - can be unit tested independently.
 */

// Type-only imports
import type { MapType, HexBounds, MeasurementMethod } from '#types/core/map.types';
import type {
  HexOrientation,
  DiagonalRule,
  DistanceDisplayFormat,
  HexColor,
  SettingsTabId,
  ImageDimensions,
  GridCalculation,
  GridDensityPreset,
} from '#types/settings/settings.types';
import type { Cell } from '#types/core/cell.types';
import type { MapObject } from '#types/objects/object.types';

// Datacore imports
const { axialToOffset, isWithinOffsetBounds } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "offsetCoordinates")) as {
  axialToOffset: (q: number, r: number, orientation: HexOrientation) => { col: number; row: number };
  isWithinOffsetBounds: (col: number, row: number, bounds: HexBounds) => boolean;
};

const {
  calculateGridFromColumns,
  calculateGridFromMeasurement,
  measurementToHexSize,
  validateMeasurementSize,
  MEASUREMENT_CORNER
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "hexMeasurements")) as {
  calculateGridFromColumns: (w: number, h: number, cols: number, o: HexOrientation) => GridCalculation;
  calculateGridFromMeasurement: (w: number, h: number, size: number, method: MeasurementMethod, o: HexOrientation) => GridCalculation;
  measurementToHexSize: (size: number, method: MeasurementMethod, o: HexOrientation) => number;
  validateMeasurementSize: (size: number) => { valid: boolean; error: string | null };
  MEASUREMENT_CORNER: MeasurementMethod;
};

const { getDisplayNameFromPath } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "imageOperations")) as {
  getDisplayNameFromPath: (path: string) => string;
};

// ===========================================
// Type Definitions
// ===========================================

/** Grid density preset key */
type GridDensityKey = 'sparse' | 'medium' | 'dense' | 'custom';

/** Sizing mode for background image */
type SizingMode = 'density' | 'measurement';

/** Coordinate display mode */
type CoordinateDisplayMode = 'rectangular' | 'axial' | 'none';

/** Color picker identifier */
type ColorPickerId = 
  | 'gridLineColor'
  | 'backgroundColor'
  | 'borderColor'
  | 'coordinateKeyColor'
  | 'coordinateTextColor'
  | 'coordinateTextShadow'
  | 'fogOfWarColor'
  | null;

/** Preference keys */
type PreferenceKey = 'rememberPanZoom' | 'rememberSidebarState' | 'rememberExpandedState';

/** Override settings */
interface SettingsOverrides {
  gridLineColor: HexColor;
  gridLineWidth: number;
  backgroundColor: HexColor;
  borderColor: HexColor;
  coordinateKeyColor: HexColor;
  coordinateTextColor: HexColor;
  coordinateTextShadow: HexColor;
  canvasHeight: number;
  canvasHeightMobile: number;
  fogOfWarColor: HexColor;
  fogOfWarOpacity: number;
  fogOfWarImage: string | null;
  fogOfWarBlurEnabled: boolean;
  fogOfWarBlurFactor: number;
  alwaysShowControls: boolean;
}

/** User preferences */
interface SettingsPreferences {
  rememberPanZoom: boolean;
  rememberSidebarState: boolean;
  rememberExpandedState: boolean;
}

/** Distance settings */
interface DistanceSettings {
  useGlobalDistance: boolean;
  distancePerCell: number;
  distanceUnit: string;
  gridDiagonalRule: DiagonalRule;
  displayFormat: DistanceDisplayFormat;
}

/** Orphan info for resize confirmation */
interface OrphanInfo {
  cells: number;
  objects: number;
}

/** Pending bounds change */
interface PendingBoundsChange {
  newBounds: HexBounds;
  oldBounds: HexBounds;
}

/** Image search result */
interface ImageSearchResult {
  path: string;
  displayName: string;
}

// ===========================================
// Settings Modal State
// ===========================================

/** Complete settings modal state */
interface SettingsModalState {
  activeTab: SettingsTabId;
  
  // Global settings toggle
  useGlobalSettings: boolean;
  overrides: SettingsOverrides;
  
  // Preferences
  preferences: SettingsPreferences;
  
  // Distance settings
  distanceSettings: DistanceSettings;
  
  // Hex bounds
  hexBounds: HexBounds;
  
  // Coordinate display
  coordinateDisplayMode: CoordinateDisplayMode;
  
  // Background image
  backgroundImagePath: string | null;
  backgroundImageDisplayName: string;
  imageDimensions: ImageDimensions | null;
  imageSearchResults: ImageSearchResult[];
  
  // Fog image picker
  fogImageDisplayName: string;
  fogImageSearchResults: ImageSearchResult[];
  
  // Grid density
  gridDensity: GridDensityKey;
  customColumns: number;
  boundsLocked: boolean;
  
  // Image positioning
  imageOpacity: number;
  imageOffsetX: number;
  imageOffsetY: number;
  
  // Sizing mode
  sizingMode: SizingMode;
  measurementMethod: MeasurementMethod;
  measurementSize: number;
  fineTuneEnabled: boolean;
  fineTuneOffset: number;
  
  // UI state
  activeColorPicker: ColorPickerId;
  isLoading: boolean;
  
  // Resize confirmation
  showResizeConfirm: boolean;
  pendingBoundsChange: PendingBoundsChange | null;
  orphanInfo: OrphanInfo;
  deleteOrphanedContent: boolean;
}

// ===========================================
// Props Interface
// ===========================================

/** Current settings from map */
interface CurrentSettings {
  useGlobalSettings?: boolean;
  overrides?: Partial<SettingsOverrides>;
  coordinateDisplayMode?: CoordinateDisplayMode;
}

/** Current background image settings */
interface CurrentBackgroundImage {
  path?: string;
  gridDensity?: GridDensityKey;
  customColumns?: number;
  lockBounds?: boolean;
  opacity?: number;
  offsetX?: number;
  offsetY?: number;
  sizingMode?: SizingMode;
  measurementMethod?: MeasurementMethod;
  measurementSize?: number;
  fineTuneOffset?: number;
}

/** Current distance settings */
interface CurrentDistanceSettings {
  useGlobalDistance?: boolean;
  distancePerCell?: number;
  distanceUnit?: string;
  gridDiagonalRule?: DiagonalRule;
  displayFormat?: DistanceDisplayFormat;
}

/** Global settings from plugin */
interface GlobalSettings {
  gridLineColor?: HexColor;
  gridLineWidth?: number;
  backgroundColor?: HexColor;
  borderColor?: HexColor;
  coordinateKeyColor?: HexColor;
  coordinateTextColor?: HexColor;
  coordinateTextShadow?: HexColor;
  canvasHeight?: number;
  canvasHeightMobile?: number;
  fogOfWarColor?: HexColor;
  fogOfWarOpacity?: number;
  fogOfWarImage?: string | null;
  fogOfWarBlurEnabled?: boolean;
  fogOfWarBlurFactor?: number;
  alwaysShowControls?: boolean;
  distancePerCellHex?: number;
  distancePerCellGrid?: number;
  distanceUnitHex?: string;
  distanceUnitGrid?: string;
  gridDiagonalRule?: DiagonalRule;
  distanceDisplayFormat?: DistanceDisplayFormat;
}

/** Props for buildInitialState */
interface BuildInitialStateProps {
  initialTab?: SettingsTabId;
  mapType: MapType;
  currentSettings?: CurrentSettings;
  currentPreferences?: SettingsPreferences;
  currentHexBounds?: HexBounds;
  currentBackgroundImage?: CurrentBackgroundImage;
  currentDistanceSettings?: CurrentDistanceSettings;
}

// ===========================================
// Action Types
// ===========================================

/** Action type string literals */
const Actions = {
  INITIALIZE: 'INITIALIZE',
  SET_TAB: 'SET_TAB',
  TOGGLE_USE_GLOBAL: 'TOGGLE_USE_GLOBAL',
  SET_OVERRIDE: 'SET_OVERRIDE',
  SET_LINE_WIDTH: 'SET_LINE_WIDTH',
  TOGGLE_PREFERENCE: 'TOGGLE_PREFERENCE',
  SET_DISTANCE_SETTING: 'SET_DISTANCE_SETTING',
  SET_HEX_BOUNDS: 'SET_HEX_BOUNDS',
  SET_COORDINATE_MODE: 'SET_COORDINATE_MODE',
  SET_IMAGE_SEARCH_RESULTS: 'SET_IMAGE_SEARCH_RESULTS',
  SET_IMAGE_DISPLAY_NAME: 'SET_IMAGE_DISPLAY_NAME',
  IMAGE_SELECTED: 'IMAGE_SELECTED',
  CLEAR_IMAGE: 'CLEAR_IMAGE',
  SET_DENSITY: 'SET_DENSITY',
  SET_CUSTOM_COLUMNS: 'SET_CUSTOM_COLUMNS',
  SET_SIZING_MODE: 'SET_SIZING_MODE',
  SET_MEASUREMENT_METHOD: 'SET_MEASUREMENT_METHOD',
  SET_MEASUREMENT_SIZE: 'SET_MEASUREMENT_SIZE',
  SET_FINE_TUNE: 'SET_FINE_TUNE',
  RESET_FINE_TUNE: 'RESET_FINE_TUNE',
  TOGGLE_BOUNDS_LOCK: 'TOGGLE_BOUNDS_LOCK',
  SET_IMAGE_OPACITY: 'SET_IMAGE_OPACITY',
  SET_IMAGE_OFFSET_X: 'SET_IMAGE_OFFSET_X',
  SET_IMAGE_OFFSET_Y: 'SET_IMAGE_OFFSET_Y',
  SET_ACTIVE_COLOR_PICKER: 'SET_ACTIVE_COLOR_PICKER',
  SET_LOADING: 'SET_LOADING',
  SHOW_RESIZE_CONFIRM: 'SHOW_RESIZE_CONFIRM',
  CONFIRM_RESIZE_DELETE: 'CONFIRM_RESIZE_DELETE',
  CANCEL_RESIZE: 'CANCEL_RESIZE',
  CLEAR_DELETE_FLAG: 'CLEAR_DELETE_FLAG',
  SET_FOG_IMAGE_DISPLAY_NAME: 'SET_FOG_IMAGE_DISPLAY_NAME',
  SET_FOG_IMAGE_SEARCH_RESULTS: 'SET_FOG_IMAGE_SEARCH_RESULTS',
  FOG_IMAGE_SELECTED: 'FOG_IMAGE_SELECTED',
  CLEAR_FOG_IMAGE: 'CLEAR_FOG_IMAGE'
} as const;

/** Action type union */
type ActionType = typeof Actions[keyof typeof Actions];

// ===========================================
// Action Interfaces
// ===========================================

interface InitializeAction {
  type: typeof Actions.INITIALIZE;
  payload: { props: BuildInitialStateProps; globalSettings: GlobalSettings };
}

interface SetTabAction {
  type: typeof Actions.SET_TAB;
  payload: SettingsTabId;
}

interface ToggleUseGlobalAction {
  type: typeof Actions.TOGGLE_USE_GLOBAL;
}

interface SetOverrideAction {
  type: typeof Actions.SET_OVERRIDE;
  payload: { key: keyof SettingsOverrides; value: SettingsOverrides[keyof SettingsOverrides] };
}

interface SetLineWidthAction {
  type: typeof Actions.SET_LINE_WIDTH;
  payload: string | number;
}

interface TogglePreferenceAction {
  type: typeof Actions.TOGGLE_PREFERENCE;
  payload: PreferenceKey;
}

interface SetDistanceSettingAction {
  type: typeof Actions.SET_DISTANCE_SETTING;
  payload: Partial<DistanceSettings>;
}

interface SetHexBoundsAction {
  type: typeof Actions.SET_HEX_BOUNDS;
  payload: HexBounds;
}

interface SetCoordinateModeAction {
  type: typeof Actions.SET_COORDINATE_MODE;
  payload: CoordinateDisplayMode;
}

interface SetImageSearchResultsAction {
  type: typeof Actions.SET_IMAGE_SEARCH_RESULTS;
  payload: ImageSearchResult[];
}

interface SetImageDisplayNameAction {
  type: typeof Actions.SET_IMAGE_DISPLAY_NAME;
  payload: string;
}

interface ImageSelectedAction {
  type: typeof Actions.IMAGE_SELECTED;
  payload: { path: string; displayName: string; dimensions: ImageDimensions; bounds: HexBounds };
}

interface ClearImageAction {
  type: typeof Actions.CLEAR_IMAGE;
}

interface SetDensityAction {
  type: typeof Actions.SET_DENSITY;
  payload: { density: GridDensityKey; orientation: HexOrientation };
}

interface SetCustomColumnsAction {
  type: typeof Actions.SET_CUSTOM_COLUMNS;
  payload: { columns: string | number; orientation: HexOrientation };
}

interface SetSizingModeAction {
  type: typeof Actions.SET_SIZING_MODE;
  payload: SizingMode;
}

interface SetMeasurementMethodAction {
  type: typeof Actions.SET_MEASUREMENT_METHOD;
  payload: { method: MeasurementMethod; orientation: HexOrientation };
}

interface SetMeasurementSizeAction {
  type: typeof Actions.SET_MEASUREMENT_SIZE;
  payload: { size: string | number; orientation: HexOrientation };
}

interface SetFineTuneAction {
  type: typeof Actions.SET_FINE_TUNE;
  payload: { adjustedHexSize: number; orientation: HexOrientation };
}

interface ResetFineTuneAction {
  type: typeof Actions.RESET_FINE_TUNE;
  payload: { orientation: HexOrientation };
}

interface ToggleBoundsLockAction {
  type: typeof Actions.TOGGLE_BOUNDS_LOCK;
}

interface SetImageOpacityAction {
  type: typeof Actions.SET_IMAGE_OPACITY;
  payload: number;
}

interface SetImageOffsetXAction {
  type: typeof Actions.SET_IMAGE_OFFSET_X;
  payload: number;
}

interface SetImageOffsetYAction {
  type: typeof Actions.SET_IMAGE_OFFSET_Y;
  payload: number;
}

interface SetActiveColorPickerAction {
  type: typeof Actions.SET_ACTIVE_COLOR_PICKER;
  payload: ColorPickerId;
}

interface SetLoadingAction {
  type: typeof Actions.SET_LOADING;
  payload: boolean;
}

interface ShowResizeConfirmAction {
  type: typeof Actions.SHOW_RESIZE_CONFIRM;
  payload: { pendingBoundsChange: PendingBoundsChange; orphanInfo: OrphanInfo };
}

interface ConfirmResizeDeleteAction {
  type: typeof Actions.CONFIRM_RESIZE_DELETE;
}

interface CancelResizeAction {
  type: typeof Actions.CANCEL_RESIZE;
}

interface ClearDeleteFlagAction {
  type: typeof Actions.CLEAR_DELETE_FLAG;
}

interface SetFogImageDisplayNameAction {
  type: typeof Actions.SET_FOG_IMAGE_DISPLAY_NAME;
  payload: string;
}

interface SetFogImageSearchResultsAction {
  type: typeof Actions.SET_FOG_IMAGE_SEARCH_RESULTS;
  payload: ImageSearchResult[];
}

interface FogImageSelectedAction {
  type: typeof Actions.FOG_IMAGE_SELECTED;
  payload: { path: string; displayName: string };
}

interface ClearFogImageAction {
  type: typeof Actions.CLEAR_FOG_IMAGE;
}

/** Discriminated union of all actions */
type SettingsAction =
  | InitializeAction
  | SetTabAction
  | ToggleUseGlobalAction
  | SetOverrideAction
  | SetLineWidthAction
  | TogglePreferenceAction
  | SetDistanceSettingAction
  | SetHexBoundsAction
  | SetCoordinateModeAction
  | SetImageSearchResultsAction
  | SetImageDisplayNameAction
  | ImageSelectedAction
  | ClearImageAction
  | SetDensityAction
  | SetCustomColumnsAction
  | SetSizingModeAction
  | SetMeasurementMethodAction
  | SetMeasurementSizeAction
  | SetFineTuneAction
  | ResetFineTuneAction
  | ToggleBoundsLockAction
  | SetImageOpacityAction
  | SetImageOffsetXAction
  | SetImageOffsetYAction
  | SetActiveColorPickerAction
  | SetLoadingAction
  | ShowResizeConfirmAction
  | ConfirmResizeDeleteAction
  | CancelResizeAction
  | ClearDeleteFlagAction
  | SetFogImageDisplayNameAction
  | SetFogImageSearchResultsAction
  | FogImageSelectedAction
  | ClearFogImageAction;

// ===========================================
// Constants
// ===========================================

const GRID_DENSITY_PRESETS: Record<Exclude<GridDensityKey, 'custom'>, GridDensityPreset> = {
  sparse: { columns: 12, label: 'Sparse (~12 columns)', description: 'Regional scale' },
  medium: { columns: 24, label: 'Medium (~24 columns)', description: 'Dungeon scale' },
  dense:  { columns: 48, label: 'Dense (~48 columns)', description: 'Tactical scale' }
};

// ===========================================
// Pure Helper Functions
// ===========================================

/**
 * Check if content would be orphaned by new bounds
 */
function getOrphanedContentInfo(
  newBounds: HexBounds,
  mapType: MapType,
  currentCells: Cell[] | null | undefined,
  currentObjects: MapObject[] | null | undefined,
  orientation: HexOrientation
): OrphanInfo {
  if (mapType !== 'hex') return { cells: 0, objects: 0 };
  
  let orphanedCells = 0;
  let orphanedObjects = 0;
  
  if (currentCells && currentCells.length > 0) {
    currentCells.forEach(cell => {
      // Hex cells use q/r (axial) coordinates
      const hexCell = cell as Cell & { q?: number; r?: number };
      if (hexCell.q !== undefined && hexCell.r !== undefined) {
        const { col, row } = axialToOffset(hexCell.q, hexCell.r, orientation);
        if (!isWithinOffsetBounds(col, row, newBounds)) {
          orphanedCells++;
        }
      }
    });
  }
  
  if (currentObjects && currentObjects.length > 0) {
    currentObjects.forEach(obj => {
      const { col, row } = axialToOffset(obj.position.x, obj.position.y, orientation);
      if (!isWithinOffsetBounds(col, row, newBounds)) {
        orphanedObjects++;
      }
    });
  }
  
  return { cells: orphanedCells, objects: orphanedObjects };
}

/**
 * Calculate new bounds based on sizing mode and settings
 */
function calculateBoundsFromSettings(
  imageDimensions: ImageDimensions | null,
  sizingMode: SizingMode,
  gridDensity: GridDensityKey,
  customColumns: number,
  measurementSize: number,
  measurementMethod: MeasurementMethod,
  orientation: HexOrientation
): HexBounds | null {
  if (!imageDimensions) return null;
  
  if (sizingMode === 'density') {
    const columns = gridDensity === 'custom' 
      ? customColumns 
      : GRID_DENSITY_PRESETS[gridDensity]?.columns ?? 24;
    const calc = calculateGridFromColumns(imageDimensions.width, imageDimensions.height, columns, orientation);
    return { maxCol: calc.columns, maxRow: calc.rows };
  } else {
    const calc = calculateGridFromMeasurement(imageDimensions.width, imageDimensions.height, measurementSize, measurementMethod, orientation);
    return { maxCol: calc.columns, maxRow: calc.rows };
  }
}

/**
 * Build initial state from props and global settings
 */
function buildInitialState(props: BuildInitialStateProps, globalSettings: GlobalSettings): SettingsModalState {
  const {
    initialTab,
    mapType,
    currentSettings,
    currentPreferences,
    currentHexBounds,
    currentBackgroundImage,
    currentDistanceSettings
  } = props;
  
  const isHexMap = mapType === 'hex';
  const defaultDistancePerCell = isHexMap 
    ? (globalSettings.distancePerCellHex ?? 6) 
    : (globalSettings.distancePerCellGrid ?? 5);
  const defaultDistanceUnit = isHexMap 
    ? (globalSettings.distanceUnitHex ?? 'mi') 
    : (globalSettings.distanceUnitGrid ?? 'ft');
  
  return {
    activeTab: initialTab || 'appearance',
    
    useGlobalSettings: currentSettings?.useGlobalSettings ?? true,
    overrides: {
      gridLineColor: currentSettings?.overrides?.gridLineColor ?? globalSettings.gridLineColor ?? '#666666',
      gridLineWidth: currentSettings?.overrides?.gridLineWidth ?? globalSettings.gridLineWidth ?? 1,
      backgroundColor: currentSettings?.overrides?.backgroundColor ?? globalSettings.backgroundColor ?? '#1a1a1a',
      borderColor: currentSettings?.overrides?.borderColor ?? globalSettings.borderColor ?? '#8b6842',
      coordinateKeyColor: currentSettings?.overrides?.coordinateKeyColor ?? globalSettings.coordinateKeyColor ?? '#c4a57b',
      coordinateTextColor: currentSettings?.overrides?.coordinateTextColor ?? globalSettings.coordinateTextColor ?? '#ffffff',
      coordinateTextShadow: currentSettings?.overrides?.coordinateTextShadow ?? globalSettings.coordinateTextShadow ?? '#000000',
      canvasHeight: currentSettings?.overrides?.canvasHeight ?? globalSettings.canvasHeight ?? 600,
      canvasHeightMobile: currentSettings?.overrides?.canvasHeightMobile ?? globalSettings.canvasHeightMobile ?? 400,
      fogOfWarColor: currentSettings?.overrides?.fogOfWarColor ?? globalSettings.fogOfWarColor ?? '#000000',
      fogOfWarOpacity: currentSettings?.overrides?.fogOfWarOpacity ?? globalSettings.fogOfWarOpacity ?? 0.9,
      fogOfWarImage: currentSettings?.overrides?.fogOfWarImage ?? globalSettings.fogOfWarImage ?? null,
      fogOfWarBlurEnabled: currentSettings?.overrides?.fogOfWarBlurEnabled ?? globalSettings.fogOfWarBlurEnabled ?? false,
      fogOfWarBlurFactor: currentSettings?.overrides?.fogOfWarBlurFactor ?? globalSettings.fogOfWarBlurFactor ?? 0.99,
      alwaysShowControls: currentSettings?.overrides?.alwaysShowControls ?? globalSettings.alwaysShowControls ?? false
    },
    
    preferences: {
      rememberPanZoom: currentPreferences?.rememberPanZoom ?? true,
      rememberSidebarState: currentPreferences?.rememberSidebarState ?? true,
      rememberExpandedState: currentPreferences?.rememberExpandedState ?? false
    },
    
    distanceSettings: {
      useGlobalDistance: currentDistanceSettings?.useGlobalDistance ?? true,
      distancePerCell: currentDistanceSettings?.distancePerCell ?? defaultDistancePerCell,
      distanceUnit: currentDistanceSettings?.distanceUnit ?? defaultDistanceUnit,
      gridDiagonalRule: currentDistanceSettings?.gridDiagonalRule ?? (globalSettings.gridDiagonalRule ?? 'alternating'),
      displayFormat: currentDistanceSettings?.displayFormat ?? (globalSettings.distanceDisplayFormat ?? 'both')
    },
    
    hexBounds: {
      maxCol: currentHexBounds?.maxCol ?? 26,
      maxRow: currentHexBounds?.maxRow ?? 20
    },
    
    coordinateDisplayMode: currentSettings?.coordinateDisplayMode ?? 'rectangular',
    
    backgroundImagePath: currentBackgroundImage?.path ?? null,
    backgroundImageDisplayName: currentBackgroundImage?.path 
      ? getDisplayNameFromPath(currentBackgroundImage.path) 
      : '',
    imageDimensions: null,
    imageSearchResults: [],
    
    fogImageDisplayName: currentSettings?.overrides?.fogOfWarImage 
      ? getDisplayNameFromPath(currentSettings.overrides.fogOfWarImage) 
      : '',
    fogImageSearchResults: [],
    
    gridDensity: currentBackgroundImage?.gridDensity ?? 'medium',
    customColumns: currentBackgroundImage?.customColumns ?? 24,
    boundsLocked: currentBackgroundImage?.path ? (currentBackgroundImage.lockBounds ?? true) : false,
    
    imageOpacity: currentBackgroundImage?.opacity ?? 1,
    imageOffsetX: currentBackgroundImage?.offsetX ?? 0,
    imageOffsetY: currentBackgroundImage?.offsetY ?? 0,
    
    sizingMode: currentBackgroundImage?.sizingMode ?? 'density',
    measurementMethod: currentBackgroundImage?.measurementMethod ?? MEASUREMENT_CORNER,
    measurementSize: currentBackgroundImage?.measurementSize ?? 86,
    fineTuneEnabled: (currentBackgroundImage?.fineTuneOffset ?? 0) !== 0,
    fineTuneOffset: currentBackgroundImage?.fineTuneOffset ?? 0,
    
    activeColorPicker: null,
    isLoading: false,
    
    showResizeConfirm: false,
    pendingBoundsChange: null,
    orphanInfo: { cells: 0, objects: 0 },
    deleteOrphanedContent: false
  };
}

// ===========================================
// Reducer
// ===========================================

function settingsReducer(state: SettingsModalState, action: SettingsAction): SettingsModalState {
  switch (action.type) {
    
    case Actions.INITIALIZE:
      return buildInitialState(action.payload.props, action.payload.globalSettings);
    
    case Actions.SET_TAB:
      return { ...state, activeTab: action.payload };
    
    case Actions.TOGGLE_USE_GLOBAL:
      return { ...state, useGlobalSettings: !state.useGlobalSettings };
    
    case Actions.SET_OVERRIDE:
      return {
        ...state,
        overrides: { ...state.overrides, [action.payload.key]: action.payload.value }
      };
    
    case Actions.SET_LINE_WIDTH: {
      const numValue = parseInt(String(action.payload), 10);
      if (isNaN(numValue) || numValue < 1 || numValue > 5) return state;
      return {
        ...state,
        overrides: { ...state.overrides, gridLineWidth: numValue }
      };
    }
    
    case Actions.TOGGLE_PREFERENCE:
      return {
        ...state,
        preferences: {
          ...state.preferences,
          [action.payload]: !state.preferences[action.payload]
        }
      };
    
    case Actions.SET_DISTANCE_SETTING:
      return {
        ...state,
        distanceSettings: { ...state.distanceSettings, ...action.payload }
      };
    
    case Actions.SET_HEX_BOUNDS:
      return { ...state, hexBounds: action.payload };
    
    case Actions.SET_COORDINATE_MODE:
      return { ...state, coordinateDisplayMode: action.payload };
    
    case Actions.SET_IMAGE_SEARCH_RESULTS:
      return { ...state, imageSearchResults: action.payload };
    
    case Actions.SET_IMAGE_DISPLAY_NAME:
      return { ...state, backgroundImageDisplayName: action.payload };
    
    case Actions.IMAGE_SELECTED: {
      const { path, displayName, dimensions, bounds } = action.payload;
      return {
        ...state,
        backgroundImagePath: path,
        backgroundImageDisplayName: displayName,
        imageDimensions: dimensions,
        imageSearchResults: [],
        hexBounds: bounds,
        boundsLocked: true
      };
    }
    
    case Actions.CLEAR_IMAGE:
      return {
        ...state,
        backgroundImagePath: null,
        backgroundImageDisplayName: '',
        imageDimensions: null,
        boundsLocked: false,
        imageSearchResults: []
      };
    
    case Actions.SET_DENSITY: {
      const { density, orientation } = action.payload;
      const newState: SettingsModalState = { ...state, gridDensity: density };
      
      if (state.imageDimensions && state.boundsLocked) {
        const columns = density === 'custom' 
          ? state.customColumns 
          : GRID_DENSITY_PRESETS[density]?.columns ?? 24;
        const calc = calculateGridFromColumns(
          state.imageDimensions.width, 
          state.imageDimensions.height, 
          columns, 
          orientation
        );
        newState.hexBounds = { maxCol: calc.columns, maxRow: calc.rows };
      }
      
      return newState;
    }
    
    case Actions.SET_CUSTOM_COLUMNS: {
      const { columns, orientation } = action.payload;
      const numValue = parseInt(String(columns), 10);
      if (isNaN(numValue) || numValue <= 0) return state;
      
      const newState: SettingsModalState = { ...state, customColumns: numValue };
      
      if (state.imageDimensions && state.boundsLocked && state.gridDensity === 'custom') {
        const calc = calculateGridFromColumns(
          state.imageDimensions.width, 
          state.imageDimensions.height, 
          numValue, 
          orientation
        );
        newState.hexBounds = { maxCol: calc.columns, maxRow: calc.rows };
      }
      
      return newState;
    }
    
    case Actions.SET_SIZING_MODE:
      return { ...state, sizingMode: action.payload };
    
    case Actions.SET_MEASUREMENT_METHOD: {
      const { method, orientation } = action.payload;
      const newState: SettingsModalState = { ...state, measurementMethod: method };
      
      if (state.imageDimensions && state.boundsLocked && state.sizingMode === 'measurement') {
        const calc = calculateGridFromMeasurement(
          state.imageDimensions.width, 
          state.imageDimensions.height, 
          state.measurementSize, 
          method, 
          orientation
        );
        newState.hexBounds = { maxCol: calc.columns, maxRow: calc.rows };
      }
      
      return newState;
    }
    
    case Actions.SET_MEASUREMENT_SIZE: {
      const { size, orientation } = action.payload;
      const numValue = parseFloat(String(size));
      if (isNaN(numValue) || !validateMeasurementSize(numValue).valid) return state;
      
      const newState: SettingsModalState = { ...state, measurementSize: numValue };
      
      if (state.imageDimensions && state.boundsLocked && state.sizingMode === 'measurement') {
        const calc = calculateGridFromMeasurement(
          state.imageDimensions.width, 
          state.imageDimensions.height, 
          numValue, 
          state.measurementMethod, 
          orientation
        );
        newState.hexBounds = { maxCol: calc.columns, maxRow: calc.rows };
      }
      
      return newState;
    }
    
    case Actions.SET_FINE_TUNE: {
      const { adjustedHexSize, orientation } = action.payload;
      if (!state.imageDimensions || !state.boundsLocked || state.sizingMode !== 'measurement') {
        return state;
      }
      
      const baseHexSize = measurementToHexSize(state.measurementSize, state.measurementMethod, orientation);
      const offset = adjustedHexSize - baseHexSize;
      
      const columns = Math.ceil(state.imageDimensions.width / (adjustedHexSize * (orientation === 'pointy' ? Math.sqrt(3) : 1.5)));
      const rows = Math.ceil(state.imageDimensions.height / (adjustedHexSize * (orientation === 'flat' ? Math.sqrt(3) : 1.5)));
      
      return {
        ...state,
        fineTuneOffset: offset,
        fineTuneEnabled: offset !== 0,
        hexBounds: { maxCol: columns, maxRow: rows }
      };
    }
    
    case Actions.RESET_FINE_TUNE: {
      const { orientation } = action.payload;
      const newState: SettingsModalState = { ...state, fineTuneOffset: 0, fineTuneEnabled: false };
      
      if (state.imageDimensions && state.boundsLocked && state.sizingMode === 'measurement') {
        const calc = calculateGridFromMeasurement(
          state.imageDimensions.width, 
          state.imageDimensions.height, 
          state.measurementSize, 
          state.measurementMethod, 
          orientation
        );
        newState.hexBounds = { maxCol: calc.columns, maxRow: calc.rows };
      }
      
      return newState;
    }
    
    case Actions.TOGGLE_BOUNDS_LOCK:
      return { ...state, boundsLocked: !state.boundsLocked };
    
    case Actions.SET_IMAGE_OPACITY:
      return { ...state, imageOpacity: action.payload };
    
    case Actions.SET_IMAGE_OFFSET_X:
      return { ...state, imageOffsetX: action.payload };
    
    case Actions.SET_IMAGE_OFFSET_Y:
      return { ...state, imageOffsetY: action.payload };
    
    case Actions.SET_ACTIVE_COLOR_PICKER:
      return { ...state, activeColorPicker: action.payload };
    
    case Actions.SET_LOADING:
      return { ...state, isLoading: action.payload };
    
    case Actions.SHOW_RESIZE_CONFIRM:
      return {
        ...state,
        showResizeConfirm: true,
        pendingBoundsChange: action.payload.pendingBoundsChange,
        orphanInfo: action.payload.orphanInfo
      };
    
    case Actions.CONFIRM_RESIZE_DELETE:
      if (!state.pendingBoundsChange) return state;
      return {
        ...state,
        hexBounds: state.pendingBoundsChange.newBounds,
        deleteOrphanedContent: true,
        showResizeConfirm: false,
        pendingBoundsChange: null
      };
    
    case Actions.CANCEL_RESIZE:
      return {
        ...state,
        showResizeConfirm: false,
        pendingBoundsChange: null
      };
    
    case Actions.CLEAR_DELETE_FLAG:
      return { ...state, deleteOrphanedContent: false };
    
    // Fog of War image picker actions
    case Actions.SET_FOG_IMAGE_DISPLAY_NAME:
      return { ...state, fogImageDisplayName: action.payload };
    
    case Actions.SET_FOG_IMAGE_SEARCH_RESULTS:
      return { ...state, fogImageSearchResults: action.payload };
    
    case Actions.FOG_IMAGE_SELECTED:
      return {
        ...state,
        fogImageDisplayName: action.payload.displayName,
        fogImageSearchResults: [],
        overrides: {
          ...state.overrides,
          fogOfWarImage: action.payload.path
        }
      };
    
    case Actions.CLEAR_FOG_IMAGE:
      return {
        ...state,
        fogImageDisplayName: '',
        fogImageSearchResults: [],
        overrides: {
          ...state.overrides,
          fogOfWarImage: null
        }
      };
    
    default:
      return state;
  }
}

// ===========================================
// Exports
// ===========================================

return {
  Actions,
  GRID_DENSITY_PRESETS,
  settingsReducer,
  buildInitialState,
  calculateBoundsFromSettings,
  getOrphanedContentInfo
};
```

# MapSettingsContext

```tsx
/**
 * MapSettingsContext.tsx
 *
 * React context provider for MapSettingsModal.
 * Manages state via useReducer (logic in settingsReducer.ts),
 * handles effects, and provides handler API to consumers.
 */

import type {
  MapData,
  MapType,
  HexBounds,
  GridDensity,
  SizingMode,
  MeasurementMethod,
} from '#types/core/map.types';
import type { Cell } from '#types/core/cell.types';
import type { MapObject } from '#types/objects/object.types';
import type { IGeometry } from '#types/core/geometry.types';
import type { HexColor } from '#types/core/common.types';
import type {
  PluginSettings,
  DiagonalRule,
  DistanceDisplayFormat,
  HexOrientation,
  SettingsTabId,
  ImageDimensions,
} from '#types/settings/settings.types';

// Reducer and pure logic
const {
  Actions,
  GRID_DENSITY_PRESETS,
  settingsReducer,
  buildInitialState,
  calculateBoundsFromSettings,
  getOrphanedContentInfo
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsReducer"));

// Dependencies for async operations and constants
const { getSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsAccessor"));
const { THEME } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants"));
const {
  getImageDisplayNames,
  getFullPathFromDisplayName,
  getDisplayNameFromPath,
  getImageDimensions
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "imageOperations"));
const {
  calculateGridFromColumns,
  calculateGridFromMeasurement,
  measurementToHexSize,
  hexSizeToMeasurement,
  MEASUREMENT_EDGE,
  MEASUREMENT_CORNER,
  getFineTuneRange
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "hexMeasurements"));

// ===========================================
// Local Types (context-specific, not in #types/)
// ===========================================

/** Tab definition for settings modal */
export interface SettingsTab {
  id: SettingsTabId;
  label: string;
}

/** Coordinate display mode for hex maps */
export type CoordinateDisplayMode = 'none' | 'offset' | 'axial';

/** Background image configuration */
export interface BackgroundImageConfig {
  path: string | null;
  lockBounds?: boolean;
  gridDensity?: GridDensity;
  customColumns?: number;
  opacity?: number;
  offsetX?: number;
  offsetY?: number;
  sizingMode?: SizingMode;
  measurementMethod?: MeasurementMethod;
  measurementSize?: number;
  fineTuneOffset?: number;
}

/** Distance settings for measurement */
export interface DistanceSettings {
  useGlobalDistance: boolean;
  distancePerCell: number;
  distanceUnit: string;
  gridDiagonalRule: DiagonalRule;
  displayFormat: DistanceDisplayFormat;
}

/** User preferences from settings modal */
export interface ModalPreferences {
  showCompass: boolean;
  expandedByDefault: boolean;
  alwaysShowControls: boolean;
  coordinateKeyMode: 'hold' | 'toggle';
}

/** Orphan info for resize confirmation */
export interface OrphanInfo {
  cells: number;
  objects: number;
}

/** Pending bounds change for resize confirmation */
export interface PendingBoundsChange {
  newBounds: HexBounds;
  previousBounds: HexBounds;
}

/** Settings reducer state shape */
export interface SettingsReducerState {
  // Tab state
  activeTab: SettingsTabId;

  // Global settings toggle
  useGlobalSettings: boolean;
  overrides: Partial<PluginSettings>;

  // Coordinate display
  coordinateDisplayMode: CoordinateDisplayMode;

  // Distance settings
  distanceSettings: DistanceSettings;

  // Hex grid settings
  hexBounds: HexBounds;
  boundsLocked: boolean;

  // Background image settings
  backgroundImagePath: string | null;
  backgroundImageDisplayName: string;
  imageDimensions: ImageDimensions | null;
  imageSearchResults: string[];
  sizingMode: SizingMode;
  gridDensity: GridDensity;
  customColumns: number;
  measurementMethod: MeasurementMethod;
  measurementSize: number;
  fineTuneOffset: number;
  imageOpacity: number;
  imageOffsetX: number;
  imageOffsetY: number;

  // Fog of War image
  fogImagePath: string | null;
  fogImageDisplayName: string;
  fogImageSearchResults: string[];

  // Color picker state
  activeColorPicker: string | null;

  // Preferences
  preferences: ModalPreferences;

  // UI state
  isLoading: boolean;

  // Resize confirmation dialog
  showResizeConfirm: boolean;
  pendingBoundsChange: PendingBoundsChange | null;
  orphanInfo: OrphanInfo | null;
  pendingDeleteOutOfBounds: boolean;
}

/** Distance settings for save (without useGlobalDistance flag) */
export interface DistanceSettingsSave {
  distancePerCell: number;
  distanceUnit: string;
  gridDiagonalRule: DiagonalRule;
  displayFormat: DistanceDisplayFormat;
}

/** Settings data passed to onSave */
export interface SettingsSaveData {
  useGlobalSettings: boolean;
  overrides: Partial<PluginSettings>;
  coordinateDisplayMode: CoordinateDisplayMode;
  distanceSettings: DistanceSettingsSave | null;
}

/** Handler functions exposed by context */
export interface MapSettingsHandlers {
  // Tab navigation
  setActiveTab: (tab: SettingsTabId) => void;

  // Global settings
  handleToggleUseGlobal: () => void;
  handleColorChange: (key: string, value: HexColor) => void;
  handleLineWidthChange: (value: number) => void;

  // Preferences
  handlePreferenceToggle: (key: keyof ModalPreferences) => void;

  // Distance settings
  setDistanceSettings: (updates: Partial<DistanceSettings>) => void;
  setCoordinateDisplayMode: (mode: CoordinateDisplayMode) => void;

  // Color picker
  setActiveColorPicker: (picker: string | null) => void;

  // Background image
  setBackgroundImageDisplayName: (name: string) => void;
  handleImageSearch: (searchTerm: string) => Promise<void>;
  handleImageSelect: (displayName: string) => Promise<void>;
  handleImageClear: () => void;
  handleSizingModeChange: (mode: SizingMode) => void;
  handleBoundsLockToggle: () => void;
  setImageOpacity: (opacity: number) => void;
  setImageOffsetX: (x: number) => void;
  setImageOffsetY: (y: number) => void;

  // Hex grid settings
  handleHexBoundsChange: (axis: 'maxCol' | 'maxRow', value: string) => void;
  handleDensityChange: (density: GridDensity) => void;
  handleCustomColumnsChange: (columns: number) => void;
  handleMeasurementMethodChange: (method: MeasurementMethod) => void;
  handleMeasurementSizeChange: (size: number) => void;
  handleFineTuneChange: (adjustedHexSize: number) => void;
  handleFineTuneReset: () => void;

  // Fog of War image
  setFogImageDisplayName: (name: string) => void;
  handleFogImageSearch: (searchTerm: string) => Promise<void>;
  handleFogImageSelect: (displayName: string) => Promise<void>;
  handleFogImageClear: () => void;

  // Save/cancel
  handleSave: () => void;
  handleCancel: () => void;
  handleResizeConfirmDelete: () => void;
  handleResizeConfirmCancel: () => void;
}

/** Grid calculation result */
export interface GridCalculation {
  hexSize: number;
  maxCol: number;
  maxRow: number;
}

/** Fine tune range result */
export interface FineTuneRange {
  min: number;
  max: number;
  step: number;
}

/** Utility functions exposed by context */
export interface MapSettingsUtilities {
  calculateGridFromColumns: (width: number, height: number, columns: number, orientation: HexOrientation) => GridCalculation;
  calculateGridFromMeasurement: (width: number, height: number, hexSize: number, orientation: HexOrientation) => GridCalculation;
  measurementToHexSize: (measurement: number, method: MeasurementMethod, orientation: HexOrientation) => number;
  hexSizeToMeasurement: (hexSize: number, method: MeasurementMethod, orientation: HexOrientation) => number;
  getFineTuneRange: (baseHexSize: number) => FineTuneRange;
}

/** Constants exposed by context */
export interface MapSettingsConstants {
  GRID_DENSITY_PRESETS: Record<GridDensity, number>;
  MEASUREMENT_EDGE: MeasurementMethod;
  MEASUREMENT_CORNER: MeasurementMethod;
  THEME: Record<string, unknown>;
}

/** Complete MapSettingsContext value shape */
export interface MapSettingsContextValue extends
  SettingsReducerState,
  MapSettingsHandlers,
  MapSettingsUtilities,
  MapSettingsConstants {
  // Props passed through
  isOpen: boolean;
  onClose: () => void;
  onOpenAlignmentMode?: () => void;
  mapType: MapType;
  orientation: HexOrientation;

  // Map data for export
  mapData: MapData | null;
  geometry: IGeometry | null;

  // External data
  globalSettings: PluginSettings;
  tabs: SettingsTab[];
  isHexMap: boolean;

  // Refs
  pendingCustomColorRef: React.MutableRefObject<HexColor | null>;
  mouseDownTargetRef: React.MutableRefObject<EventTarget | null>;
}

/** Provider props */
export interface MapSettingsProviderProps {
  children: React.ReactNode;
  isOpen: boolean;
  onClose: () => void;
  onSave: (
    settingsData: SettingsSaveData,
    preferences: ModalPreferences,
    hexBounds: HexBounds | null,
    backgroundImageData: BackgroundImageConfig | undefined,
    calculatedHexSize: number | null,
    forceDelete: boolean
  ) => void;
  onOpenAlignmentMode?: () => void;
  initialTab?: SettingsTabId | null;
  mapType?: MapType;
  orientation?: HexOrientation;
  currentSettings?: Partial<PluginSettings> | null;
  currentPreferences?: Partial<ModalPreferences> | null;
  currentHexBounds?: HexBounds | null;
  currentBackgroundImage?: BackgroundImageConfig | null;
  currentDistanceSettings?: Partial<DistanceSettings> | null;
  currentCells?: Cell[];
  currentObjects?: MapObject[];
  mapData?: MapData | null;
  geometry?: IGeometry | null;
}

// ===========================================
// Context
// ===========================================

const MapSettingsContext = dc.createContext<MapSettingsContextValue | null>(null);

/**
 * Hook to access map settings context
 * @returns Map settings state, handlers, and utilities
 * @throws If used outside MapSettingsProvider
 */
function useMapSettings(): MapSettingsContextValue {
  const context = dc.useContext(MapSettingsContext);
  if (!context) {
    throw new Error('useMapSettings must be used within a MapSettingsProvider');
  }
  return context;
}

// ===========================================
// Provider
// ===========================================

const MapSettingsProvider: React.FC<MapSettingsProviderProps> = ({
  children,
  isOpen,
  onClose,
  onSave,
  onOpenAlignmentMode,
  initialTab = null,
  mapType = 'grid',
  orientation = 'flat',
  currentSettings = null,
  currentPreferences = null,
  currentHexBounds = null,
  currentBackgroundImage = null,
  currentDistanceSettings = null,
  currentCells = [],
  currentObjects = [],
  mapData = null,
  geometry = null
}) => {
  const globalSettings = getSettings() as PluginSettings;
  const isHexMap = mapType === 'hex';

  // State via reducer
  const [state, dispatch] = dc.useReducer(
    settingsReducer,
    { props: { initialTab, mapType, currentSettings, currentPreferences, currentHexBounds, currentBackgroundImage, currentDistanceSettings }, globalSettings },
    (init: { props: Record<string, unknown>; globalSettings: PluginSettings }) => buildInitialState(init.props, init.globalSettings) as SettingsReducerState
  );

  // Refs
  const pendingCustomColorRef = dc.useRef<HexColor | null>(null);
  const mouseDownTargetRef = dc.useRef<EventTarget | null>(null);

  // Derived: available tabs
  const tabs = dc.useMemo<SettingsTab[]>(() => {
    const baseTabs: SettingsTab[] = [{ id: 'appearance', label: 'Appearance' }];
    if (mapType === 'hex') baseTabs.push({ id: 'hexgrid', label: 'Hex Grid' });
    baseTabs.push({ id: 'measurement', label: 'Measurement' });
    baseTabs.push({ id: 'preferences', label: 'Preferences' });
    return baseTabs;
  }, [mapType]);

  // ===========================================================================
  // Effects
  // ===========================================================================

  // Initialize state when modal opens
  dc.useEffect(() => {
    if (!isOpen) return;

    dispatch({
      type: Actions.INITIALIZE,
      payload: {
        props: { initialTab, mapType, currentSettings, currentPreferences, currentHexBounds, currentBackgroundImage, currentDistanceSettings },
        globalSettings
      }
    });

    // Load image dimensions async if path exists
    if (currentBackgroundImage?.path) {
      getImageDimensions(currentBackgroundImage.path).then((dims: ImageDimensions | null) => {
        if (!dims) return;

        const bounds = calculateBoundsFromSettings(
          dims,
          currentBackgroundImage.sizingMode ?? 'density',
          currentBackgroundImage.gridDensity ?? 'medium',
          currentBackgroundImage.customColumns ?? 24,
          currentBackgroundImage.measurementSize ?? 86,
          currentBackgroundImage.measurementMethod ?? MEASUREMENT_CORNER,
          orientation
        );

        dispatch({
          type: Actions.IMAGE_SELECTED,
          payload: {
            path: currentBackgroundImage.path,
            displayName: getDisplayNameFromPath(currentBackgroundImage.path),
            dimensions: dims,
            bounds: (currentBackgroundImage.lockBounds ?? true) ? bounds : (currentHexBounds ?? { maxCol: 26, maxRow: 20 })
          }
        });
      });
    }
  }, [isOpen]);

  // Close color picker on outside click
  dc.useEffect(() => {
    if (!state.activeColorPicker) return;

    const handleClickOutside = (e: MouseEvent | TouchEvent): void => {
      const target = e.target as Element;
      const pickerEl = target.closest('.dmt-color-picker');
      const buttonEl = target.closest('.dmt-color-button');
      const modalEl = target.closest('.dmt-settings-modal');

      if (!pickerEl && !buttonEl && modalEl) {
        if (pendingCustomColorRef.current) {
          dispatch({ type: Actions.SET_OVERRIDE, payload: { key: state.activeColorPicker, value: pendingCustomColorRef.current } });
          pendingCustomColorRef.current = null;
        }
        dispatch({ type: Actions.SET_ACTIVE_COLOR_PICKER, payload: null });
      }
    };

    const timeoutId = setTimeout(() => {
      document.addEventListener('mousedown', handleClickOutside);
      document.addEventListener('touchstart', handleClickOutside);
    }, 0);

    return () => {
      clearTimeout(timeoutId);
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('touchstart', handleClickOutside);
    };
  }, [state.activeColorPicker]);

  // ===========================================================================
  // Async Handlers
  // ===========================================================================

  const handleImageSearch = async (searchTerm: string): Promise<void> => {
    if (!searchTerm?.trim()) {
      dispatch({ type: Actions.SET_IMAGE_SEARCH_RESULTS, payload: [] });
      return;
    }
    const allImages = await getImageDisplayNames() as string[];
    const filtered = allImages.filter((name: string) => name.toLowerCase().includes(searchTerm.toLowerCase()));
    dispatch({ type: Actions.SET_IMAGE_SEARCH_RESULTS, payload: filtered.slice(0, 10) });
  };

  const handleImageSelect = async (displayName: string): Promise<void> => {
    const fullPath = await getFullPathFromDisplayName(displayName) as string | null;
    if (!fullPath) return;

    const dims = await getImageDimensions(fullPath) as ImageDimensions | null;
    if (!dims) return;

    const bounds = calculateBoundsFromSettings(
      dims, state.sizingMode, state.gridDensity, state.customColumns,
      state.measurementSize, state.measurementMethod, orientation
    );

    dispatch({
      type: Actions.IMAGE_SELECTED,
      payload: { path: fullPath, displayName, dimensions: dims, bounds }
    });
  };

  // Fog of War image handlers
  const handleFogImageSearch = async (searchTerm: string): Promise<void> => {
    if (!searchTerm?.trim()) {
      dispatch({ type: Actions.SET_FOG_IMAGE_SEARCH_RESULTS, payload: [] });
      return;
    }
    const allImages = await getImageDisplayNames() as string[];
    const filtered = allImages.filter((name: string) => name.toLowerCase().includes(searchTerm.toLowerCase()));
    dispatch({ type: Actions.SET_FOG_IMAGE_SEARCH_RESULTS, payload: filtered.slice(0, 10) });
  };

  const handleFogImageSelect = async (displayName: string): Promise<void> => {
    const fullPath = await getFullPathFromDisplayName(displayName) as string | null;
    if (!fullPath) return;

    dispatch({
      type: Actions.FOG_IMAGE_SELECTED,
      payload: { path: fullPath, displayName }
    });
  };

  // Core save logic - forceDelete bypasses orphan check
  const doSave = (forceDelete: boolean = false): void => {
    dispatch({ type: Actions.SET_LOADING, payload: true });

    const settingsData: SettingsSaveData = {
      useGlobalSettings: state.useGlobalSettings,
      overrides: state.useGlobalSettings ? {} : state.overrides,
      coordinateDisplayMode: state.coordinateDisplayMode,
      distanceSettings: state.distanceSettings.useGlobalDistance ? null : {
        distancePerCell: state.distanceSettings.distancePerCell,
        distanceUnit: state.distanceSettings.distanceUnit,
        gridDiagonalRule: state.distanceSettings.gridDiagonalRule,
        displayFormat: state.distanceSettings.displayFormat
      }
    };

    const backgroundImageData: BackgroundImageConfig | undefined = mapType === 'hex' ? {
      path: state.backgroundImagePath,
      lockBounds: state.boundsLocked,
      gridDensity: state.gridDensity,
      customColumns: state.customColumns,
      opacity: state.imageOpacity,
      offsetX: state.imageOffsetX,
      offsetY: state.imageOffsetY,
      sizingMode: state.sizingMode,
      measurementMethod: state.measurementMethod,
      measurementSize: state.measurementSize,
      fineTuneOffset: state.fineTuneOffset
    } : undefined;

    let calculatedHexSize: number | null = null;
    if (mapType === 'hex' && state.backgroundImagePath && state.boundsLocked && state.imageDimensions) {
      if (state.sizingMode === 'density') {
        const calc = calculateGridFromColumns(state.imageDimensions.width, state.imageDimensions.height, state.hexBounds.maxCol, orientation) as GridCalculation;
        calculatedHexSize = calc.hexSize;
      } else {
        const baseHexSize = measurementToHexSize(state.measurementSize, state.measurementMethod, orientation) as number;
        calculatedHexSize = state.fineTuneOffset !== 0 ? baseHexSize + state.fineTuneOffset : baseHexSize;
      }
    }

    onSave(settingsData, state.preferences, mapType === 'hex' ? state.hexBounds : null, backgroundImageData, calculatedHexSize, forceDelete);

    dispatch({ type: Actions.CLEAR_DELETE_FLAG });
    dispatch({ type: Actions.SET_LOADING, payload: false });
    onClose();
  };

  const handleSave = (): void => {
    // Check for orphaned content if bounds were reduced (hex maps only)
    if (mapType === 'hex' && currentHexBounds) {
      const isReduction = state.hexBounds.maxCol < currentHexBounds.maxCol ||
                          state.hexBounds.maxRow < currentHexBounds.maxRow;

      if (isReduction) {
        const orphans = getOrphanedContentInfo(state.hexBounds, mapType, currentCells, currentObjects, orientation) as OrphanInfo;
        if (orphans.cells > 0 || orphans.objects > 0) {
          dispatch({
            type: Actions.SHOW_RESIZE_CONFIRM,
            payload: {
              pendingBoundsChange: { newBounds: state.hexBounds, previousBounds: currentHexBounds },
              orphanInfo: orphans
            }
          });
          return;
        }
      }
    }

    doSave(false);
  };

  const handleResizeConfirmDelete = (): void => {
    dispatch({ type: Actions.CANCEL_RESIZE }); // Close dialog
    doSave(true); // Save with delete flag
  };

  // ===========================================================================
  // Dispatch Wrappers
  // ===========================================================================

  const handlers: MapSettingsHandlers = {
    // Simple dispatches
    setActiveTab: (tab) => dispatch({ type: Actions.SET_TAB, payload: tab }),
    handleToggleUseGlobal: () => dispatch({ type: Actions.TOGGLE_USE_GLOBAL }),
    handleColorChange: (key, value) => dispatch({ type: Actions.SET_OVERRIDE, payload: { key, value } }),
    handleLineWidthChange: (value) => dispatch({ type: Actions.SET_LINE_WIDTH, payload: value }),
    handlePreferenceToggle: (key) => dispatch({ type: Actions.TOGGLE_PREFERENCE, payload: key }),
    setDistanceSettings: (updates) => dispatch({ type: Actions.SET_DISTANCE_SETTING, payload: updates }),
    setCoordinateDisplayMode: (mode) => dispatch({ type: Actions.SET_COORDINATE_MODE, payload: mode }),
    setActiveColorPicker: (picker) => dispatch({ type: Actions.SET_ACTIVE_COLOR_PICKER, payload: picker }),
    setBackgroundImageDisplayName: (name) => dispatch({ type: Actions.SET_IMAGE_DISPLAY_NAME, payload: name }),
    handleImageClear: () => dispatch({ type: Actions.CLEAR_IMAGE }),
    handleSizingModeChange: (mode) => dispatch({ type: Actions.SET_SIZING_MODE, payload: mode }),
    handleBoundsLockToggle: () => dispatch({ type: Actions.TOGGLE_BOUNDS_LOCK }),
    setImageOpacity: (opacity) => dispatch({ type: Actions.SET_IMAGE_OPACITY, payload: opacity }),
    setImageOffsetX: (x) => dispatch({ type: Actions.SET_IMAGE_OFFSET_X, payload: x }),
    setImageOffsetY: (y) => dispatch({ type: Actions.SET_IMAGE_OFFSET_Y, payload: y }),
    handleResizeConfirmDelete,
    handleResizeConfirmCancel: () => dispatch({ type: Actions.CANCEL_RESIZE }),
    handleCancel: () => onClose(),

    // Dispatches needing context for orphan checks
    handleHexBoundsChange: (axis, value) => {
      const numValue = parseInt(value, 10);
      if (isNaN(numValue) || numValue <= 0 || numValue > 1000) return;

      const newBounds = { ...state.hexBounds, [axis]: numValue };
      dispatch({ type: Actions.SET_HEX_BOUNDS, payload: newBounds });
    },

    handleDensityChange: (density) => {
      dispatch({
        type: Actions.SET_DENSITY,
        payload: { density, orientation }
      });
    },

    handleCustomColumnsChange: (columns) => {
      dispatch({
        type: Actions.SET_CUSTOM_COLUMNS,
        payload: { columns, orientation }
      });
    },

    handleMeasurementMethodChange: (method) => {
      dispatch({ type: Actions.SET_MEASUREMENT_METHOD, payload: { method, orientation } });
    },

    handleMeasurementSizeChange: (size) => {
      dispatch({ type: Actions.SET_MEASUREMENT_SIZE, payload: { size, orientation } });
    },

    handleFineTuneChange: (adjustedHexSize) => {
      dispatch({ type: Actions.SET_FINE_TUNE, payload: { adjustedHexSize, orientation } });
    },

    handleFineTuneReset: () => {
      dispatch({ type: Actions.RESET_FINE_TUNE, payload: { orientation } });
    },

    // Async
    handleImageSearch,
    handleImageSelect,
    handleSave,

    // Fog of War handlers
    setFogImageDisplayName: (name) => dispatch({ type: Actions.SET_FOG_IMAGE_DISPLAY_NAME, payload: name }),
    handleFogImageSearch,
    handleFogImageSelect,
    handleFogImageClear: () => dispatch({ type: Actions.CLEAR_FOG_IMAGE })
  };

  // ===========================================================================
  // Context Value
  // ===========================================================================

  const contextValue: MapSettingsContextValue = {
    // Props
    isOpen, onClose, onOpenAlignmentMode, mapType, orientation,

    // Map data for export
    mapData, geometry,

    // External
    globalSettings, tabs, isHexMap,

    // State
    ...state,

    // Refs
    pendingCustomColorRef, mouseDownTargetRef,

    // Handlers
    ...handlers,

    // Constants for consumers
    GRID_DENSITY_PRESETS, MEASUREMENT_EDGE, MEASUREMENT_CORNER, THEME,

    // Utilities for consumers
    calculateGridFromColumns, calculateGridFromMeasurement,
    measurementToHexSize, hexSizeToMeasurement, getFineTuneRange
  };

  return (
    <MapSettingsContext.Provider value={contextValue}>
      {children}
    </MapSettingsContext.Provider>
  );
};

return { MapSettingsContext, MapSettingsProvider, useMapSettings, GRID_DENSITY_PRESETS };

```

# CollapsibleSection

```tsx
/**
 * CollapsibleSection.tsx
 *
 * A reusable collapsible section component for settings panels.
 * Provides consistent styling and behavior for collapsible content.
 */

/** Props for CollapsibleSection component */
export interface CollapsibleSectionProps {
  /** Section title */
  title: string;
  /** Whether section starts expanded (uncontrolled mode) */
  defaultOpen?: boolean;
  /** Controlled open state (optional) */
  isOpen?: boolean;
  /** Callback when toggled (optional, for controlled mode) */
  onToggle?: (isOpen: boolean) => void;
  /** Section content */
  children: React.ReactNode;
  /** Optional subtitle text */
  subtitle?: string;
}

/**
 * Collapsible section with header and toggle.
 * Supports both controlled and uncontrolled modes.
 */
function CollapsibleSection({
  title,
  defaultOpen = true,
  isOpen: controlledIsOpen,
  onToggle,
  children,
  subtitle
}: CollapsibleSectionProps): React.ReactElement {
  const [internalIsOpen, setInternalIsOpen] = dc.useState(defaultOpen);

  const isControlled = controlledIsOpen !== undefined;
  const isOpen = isControlled ? controlledIsOpen : internalIsOpen;

  const handleToggle = (): void => {
    if (isControlled && onToggle) {
      onToggle(!isOpen);
    } else {
      setInternalIsOpen(!isOpen);
    }
  };

  return (
    <div class="dmt-collapsible-section" style={{
      borderBottom: '1px solid var(--background-modifier-border)',
      marginBottom: '12px'
    }}>
      <button
        type="button"
        onClick={handleToggle}
        style={{
          display: 'flex',
          alignItems: 'center',
          gap: '8px',
          width: '100%',
          padding: '12px 0',
          background: 'transparent',
          border: 'none',
          cursor: 'pointer',
          textAlign: 'left',
          color: 'var(--text-normal)'
        }}
      >
        <span style={{
          width: '16px',
          height: '16px',
          color: 'var(--text-muted)',
          transition: 'transform 0.15s ease',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          <dc.Icon icon={isOpen ? 'lucide-chevron-down' : 'lucide-chevron-right'} />
        </span>
        <div style={{ flex: 1 }}>
          <span style={{
            fontSize: '14px',
            fontWeight: '600',
            color: 'var(--text-normal)'
          }}>
            {title}
          </span>
          {subtitle && (
            <span style={{
              fontSize: '12px',
              color: 'var(--text-muted)',
              marginLeft: '8px',
              fontWeight: 'normal'
            }}>
              {subtitle}
            </span>
          )}
        </div>
      </button>

      {isOpen && (
        <div style={{
          paddingTop: '8px',
          paddingBottom: '16px',
          paddingLeft: '24px'
        }}>
          {children}
        </div>
      )}
    </div>
  );
}

return { CollapsibleSection };

```

# AppearanceTab

```tsx
/**
 * AppearanceTab.tsx
 *
 * Appearance settings tab for MapSettingsModal.
 * Handles color customization and grid line width.
 */

import type { HexColor } from '#types/core/common.types';

const { ColorPicker } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ColorPicker"));
const { CollapsibleSection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "CollapsibleSection"));
const { useMapSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSettingsContext"));

/** Props for ColorPickerItem */
interface ColorPickerItemProps {
  colorKey: string;
  label: string;
  defaultColor: HexColor;
  align?: 'left' | 'right';
}

/**
 * Individual color picker item for the 2x2 grid
 */
function ColorPickerItem({ colorKey, label, defaultColor, align = 'left' }: ColorPickerItemProps): React.ReactElement {
  const {
    useGlobalSettings,
    overrides,
    activeColorPicker,
    setActiveColorPicker,
    pendingCustomColorRef,
    handleColorChange,
    globalSettings
  } = useMapSettings();

  return (
    <div class="dmt-color-grid-item">
      <label class="dmt-form-label" style={{ marginBottom: '4px', fontSize: '12px' }}>{label}</label>
      <div style={{ display: 'flex', gap: '6px', alignItems: 'center', position: 'relative' }}>
        <button
          class="dmt-color-button"
          disabled={useGlobalSettings}
          onClick={() => !useGlobalSettings && setActiveColorPicker(colorKey)}
          style={{
            backgroundColor: overrides[colorKey],
            cursor: useGlobalSettings ? 'not-allowed' : 'pointer',
            minWidth: '80px'
          }}
        >
          <span class="dmt-color-button-label">{overrides[colorKey]}</span>
        </button>

        <button
          class="dmt-color-reset-btn"
          disabled={useGlobalSettings}
          onClick={() => !useGlobalSettings && handleColorChange(colorKey, defaultColor)}
          title="Reset to default"
          style={{ cursor: useGlobalSettings ? 'not-allowed' : 'pointer' }}
        >
          <dc.Icon icon="lucide-rotate-ccw" />
        </button>

        <ColorPicker
          isOpen={activeColorPicker === colorKey && !useGlobalSettings}
          selectedColor={overrides[colorKey]}
          onColorSelect={(color: HexColor) => handleColorChange(colorKey, color)}
          onClose={() => setActiveColorPicker(null)}
          onReset={() => handleColorChange(colorKey, globalSettings[colorKey])}
          customColors={[]}
          pendingCustomColorRef={pendingCustomColorRef}
          title={label}
          position="below"
          align={align}
        />
      </div>
    </div>
  );
}

/**
 * Fog of War appearance section
 */
function FogOfWarSection(): React.ReactElement {
  const {
    useGlobalSettings,
    overrides,
    activeColorPicker,
    setActiveColorPicker,
    pendingCustomColorRef,
    handleColorChange,
    globalSettings,
    fogImageDisplayName,
    fogImageSearchResults,
    setFogImageDisplayName,
    handleFogImageSearch,
    handleFogImageSelect,
    handleFogImageClear,
    THEME
  } = useMapSettings();

  const [userToggled, setUserToggled] = dc.useState(false);
  const [isOpen, setIsOpen] = dc.useState(false);

  const handleToggle = (newIsOpen: boolean): void => {
    setUserToggled(true);
    setIsOpen(newIsOpen);
  };

  const opacityPercent = Math.round((overrides.fogOfWarOpacity ?? 0.9) * 100);
  const subtitle = overrides.fogOfWarImage
    ? `Image, ${opacityPercent}% opacity`
    : `${overrides.fogOfWarColor ?? '#000000'}, ${opacityPercent}%`;

  return (
    <CollapsibleSection
      title="Fog of War"
      isOpen={isOpen}
      onToggle={handleToggle}
      subtitle={subtitle}
    >
      <p style={{ fontSize: '12px', color: 'var(--text-muted)', marginBottom: '12px' }}>
        Customize how hidden areas appear on the map
      </p>

      <div style={{ marginBottom: '16px', opacity: useGlobalSettings ? 0.5 : 1 }}>
        <label class="dmt-form-label" style={{ marginBottom: '4px', fontSize: '12px' }}>Fog Color</label>
        <div style={{ display: 'flex', gap: '6px', alignItems: 'center', position: 'relative' }}>
          <button
            class="dmt-color-button"
            disabled={useGlobalSettings}
            onClick={() => !useGlobalSettings && setActiveColorPicker('fogOfWarColor')}
            style={{
              backgroundColor: overrides.fogOfWarColor ?? '#000000',
              cursor: useGlobalSettings ? 'not-allowed' : 'pointer',
              minWidth: '80px'
            }}
          >
            <span class="dmt-color-button-label">{overrides.fogOfWarColor ?? '#000000'}</span>
          </button>

          <button
            class="dmt-color-reset-btn"
            disabled={useGlobalSettings}
            onClick={() => !useGlobalSettings && handleColorChange('fogOfWarColor', THEME.fogOfWar.color)}
            title="Reset to default"
            style={{ cursor: useGlobalSettings ? 'not-allowed' : 'pointer' }}
          >
            <dc.Icon icon="lucide-rotate-ccw" />
          </button>

          <ColorPicker
            isOpen={activeColorPicker === 'fogOfWarColor' && !useGlobalSettings}
            selectedColor={overrides.fogOfWarColor ?? '#000000'}
            onColorSelect={(color: HexColor) => handleColorChange('fogOfWarColor', color)}
            onClose={() => setActiveColorPicker(null)}
            onReset={() => handleColorChange('fogOfWarColor', globalSettings.fogOfWarColor)}
            customColors={[]}
            pendingCustomColorRef={pendingCustomColorRef}
            title="Fog Color"
            position="below"
            align="left"
          />
        </div>
        <p style={{ fontSize: '11px', color: 'var(--text-muted)', marginTop: '4px' }}>
          Used if no image is set, or as fallback if image fails to load
        </p>
      </div>

      <div style={{ marginBottom: '16px', opacity: useGlobalSettings ? 0.5 : 1 }}>
        <label class="dmt-form-label" style={{ marginBottom: '8px', display: 'block' }}>
          Fog Opacity: {Math.round((overrides.fogOfWarOpacity ?? 0.9) * 100)}%
        </label>
        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
          <input
            type="range"
            min="10"
            max="100"
            value={Math.round((overrides.fogOfWarOpacity ?? 0.9) * 100)}
            onChange={(e: Event) => !useGlobalSettings && handleColorChange('fogOfWarOpacity', parseInt((e.target as HTMLInputElement).value, 10) / 100)}
            disabled={useGlobalSettings}
            style={{
              flex: 1,
              height: '6px',
              cursor: useGlobalSettings ? 'not-allowed' : 'pointer',
              accentColor: 'var(--interactive-accent)'
            }}
          />
          <span style={{
            fontSize: '12px',
            color: 'var(--text-muted)',
            minWidth: '35px',
            textAlign: 'right'
          }}>
            {Math.round((overrides.fogOfWarOpacity ?? 0.9) * 100)}%
          </span>
          <button
            class="dmt-color-reset-btn"
            disabled={useGlobalSettings}
            onClick={() => !useGlobalSettings && handleColorChange('fogOfWarOpacity', 0.9)}
            title="Reset to default (90%)"
            style={{ cursor: useGlobalSettings ? 'not-allowed' : 'pointer' }}
          >
            <dc.Icon icon="lucide-rotate-ccw" />
          </button>
        </div>
        <p style={{ fontSize: '11px', color: 'var(--text-muted)', marginTop: '4px' }}>
          Higher values make fog more opaque (10-100%)
        </p>
      </div>

      <div style={{ opacity: useGlobalSettings ? 0.5 : 1 }}>
        <label class="dmt-form-label" style={{ marginBottom: '4px', fontSize: '12px' }}>
          Fog Texture (optional)
        </label>
        <div style={{ position: 'relative', marginBottom: '8px' }}>
          <input
            type="text"
            placeholder="Search for tileable image..."
            value={fogImageDisplayName}
            disabled={useGlobalSettings}
            onChange={(e: Event) => {
              if (useGlobalSettings) return;
              const value = (e.target as HTMLInputElement).value;
              setFogImageDisplayName(value);
              handleFogImageSearch(value);
            }}
            style={{
              width: '100%',
              padding: '8px 32px 8px 10px',
              borderRadius: '4px',
              border: '1px solid var(--background-modifier-border)',
              background: 'var(--background-primary)',
              color: 'var(--text-normal)',
              fontSize: '14px',
              cursor: useGlobalSettings ? 'not-allowed' : 'text'
            }}
          />

          {overrides.fogOfWarImage && !useGlobalSettings && (
            <button
              onClick={handleFogImageClear}
              style={{
                position: 'absolute',
                right: '6px',
                top: '50%',
                transform: 'translateY(-50%)',
                background: 'transparent',
                border: 'none',
                color: 'var(--text-muted)',
                cursor: 'pointer',
                padding: '4px',
                fontSize: '16px',
                lineHeight: '1'
              }}
              title="Clear image"
            >
              
            </button>
          )}

          {fogImageSearchResults.length > 0 && !useGlobalSettings && (
            <div style={{
              position: 'absolute',
              top: '100%',
              left: 0,
              right: 0,
              maxHeight: '200px',
              overflowY: 'auto',
              background: 'var(--background-primary)',
              border: '1px solid var(--background-modifier-border)',
              borderRadius: '4px',
              marginTop: '2px',
              zIndex: 1000,
              boxShadow: '0 2px 8px rgba(0,0,0,0.15)'
            }}>
              {fogImageSearchResults.map((name: string, idx: number) => (
                <div
                  key={idx}
                  onClick={() => handleFogImageSelect(name)}
                  style={{
                    padding: '8px 10px',
                    cursor: 'pointer',
                    fontSize: '13px',
                    borderBottom: idx < fogImageSearchResults.length - 1 ? '1px solid var(--background-modifier-border)' : 'none'
                  }}
                  onMouseEnter={(e: MouseEvent) => (e.currentTarget as HTMLElement).style.background = 'var(--background-modifier-hover)'}
                  onMouseLeave={(e: MouseEvent) => (e.currentTarget as HTMLElement).style.background = 'transparent'}
                >
                  {name}
                </div>
              ))}
            </div>
          )}
        </div>
        <p style={{ fontSize: '11px', color: 'var(--text-muted)' }}>
          Select a tileable image to use instead of solid color. Image will be tiled across fogged areas.
        </p>
      </div>

      <div style={{ marginTop: '16px', opacity: useGlobalSettings ? 0.5 : 1 }}>
        <label class="dmt-checkbox-label" style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: useGlobalSettings ? 'not-allowed' : 'pointer' }}>
          <input
            type="checkbox"
            checked={overrides.fogOfWarBlurEnabled ?? false}
            onChange={() => !useGlobalSettings && handleColorChange('fogOfWarBlurEnabled', !(overrides.fogOfWarBlurEnabled ?? false))}
            disabled={useGlobalSettings}
            class="dmt-checkbox"
          />
          <span>Soft edges</span>
        </label>
        <p style={{ fontSize: '11px', color: 'var(--text-muted)', marginTop: '4px', marginLeft: '24px' }}>
          Adds a subtle blur effect at fog boundaries for a softer look
        </p>
      </div>

      {(overrides.fogOfWarBlurEnabled ?? false) && (
        <div style={{ marginTop: '12px', marginLeft: '24px', opacity: useGlobalSettings ? 0.5 : 1 }}>
          <label class="dmt-form-label" style={{ marginBottom: '8px', display: 'block', fontSize: '12px' }}>
            Blur Intensity: {Math.round((overrides.fogOfWarBlurFactor ?? 0.20) * 100)}%
          </label>
          <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
            <input
              type="range"
              min="5"
              max="50"
              value={Math.round((overrides.fogOfWarBlurFactor ?? 0.20) * 100)}
              onChange={(e: Event) => !useGlobalSettings && handleColorChange('fogOfWarBlurFactor', parseInt((e.target as HTMLInputElement).value, 10) / 100)}
              disabled={useGlobalSettings}
              style={{
                flex: 1,
                height: '6px',
                cursor: useGlobalSettings ? 'not-allowed' : 'pointer',
                accentColor: 'var(--interactive-accent)'
              }}
            />
            <span style={{
              fontSize: '12px',
              color: 'var(--text-muted)',
              minWidth: '35px',
              textAlign: 'right'
            }}>
              {Math.round((overrides.fogOfWarBlurFactor ?? 0.20) * 100)}%
            </span>
            <button
              class="dmt-color-reset-btn"
              disabled={useGlobalSettings}
              onClick={() => !useGlobalSettings && handleColorChange('fogOfWarBlurFactor', 0.20)}
              title="Reset to default (8%)"
              style={{ cursor: useGlobalSettings ? 'not-allowed' : 'pointer' }}
            >
              <dc.Icon icon="lucide-rotate-ccw" />
            </button>
          </div>
          <p style={{ fontSize: '11px', color: 'var(--text-muted)', marginTop: '4px' }}>
            Size of blur as percentage of cell size (5-50%)
          </p>
        </div>
      )}
    </CollapsibleSection>
  );
}

/**
 * Appearance tab content
 */
function AppearanceTab(): React.ReactElement {
  const {
    mapType,
    useGlobalSettings,
    overrides,
    globalSettings,
    handleToggleUseGlobal,
    handleLineWidthChange,
    handleColorChange,
    THEME
  } = useMapSettings();

  return (
    <div class="dmt-settings-tab-content">
      <div class="dmt-form-group" style={{ marginBottom: '16px' }}>
        <label class="dmt-checkbox-label">
          <input
            type="checkbox"
            checked={!useGlobalSettings}
            onChange={handleToggleUseGlobal}
            class="dmt-checkbox"
          />
          <span>Use custom colors for this map</span>
        </label>
      </div>

      <div
        class="dmt-color-grid"
        style={{
          opacity: useGlobalSettings ? 0.5 : 1,
          display: 'grid',
          gridTemplateColumns: '1fr 1fr',
          gap: '16px'
        }}
      >
        <ColorPickerItem
          colorKey="gridLineColor"
          label="Grid Lines"
          defaultColor={THEME.grid.lines}
        />
        <ColorPickerItem
          colorKey="backgroundColor"
          label="Background"
          defaultColor={THEME.grid.background}
          align="right"
        />
        <ColorPickerItem
          colorKey="borderColor"
          label="Cell Border"
          defaultColor={THEME.cells.border}
        />
        <ColorPickerItem
          colorKey="coordinateKeyColor"
          label="Coord Key"
          defaultColor={THEME.coordinateKey.color}
          align="right"
        />
      </div>

      {mapType === 'grid' && (
        <div
          class="dmt-form-group"
          style={{
            marginTop: '20px',
            opacity: useGlobalSettings ? 0.5 : 1
          }}
        >
          <label class="dmt-form-label" style={{ marginBottom: '8px' }}>
            Grid Line Width: {overrides.gridLineWidth ?? 1}px
          </label>
          <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
            <input
              type="range"
              min="1"
              max="5"
              value={overrides.gridLineWidth ?? 1}
              onInput={(e: Event) => handleLineWidthChange((e.target as HTMLInputElement).value)}
              disabled={useGlobalSettings}
              style={{
                flex: 1,
                cursor: useGlobalSettings ? 'not-allowed' : 'pointer'
              }}
            />
            <button
              class="dmt-color-reset-btn"
              disabled={useGlobalSettings}
              onClick={() => !useGlobalSettings && handleLineWidthChange(1)}
              title="Reset to default (1px)"
              style={{ cursor: useGlobalSettings ? 'not-allowed' : 'pointer' }}
            >
              <dc.Icon icon="lucide-rotate-ccw" />
            </button>
          </div>
          <p style={{ fontSize: '11px', color: 'var(--text-muted)', marginTop: '6px' }}>
            Thickness of the grid lines (1-5 pixels)
          </p>
        </div>
      )}

      <div style={{ marginTop: '20px' }}>
        <FogOfWarSection />
      </div>

      <div style={{ marginTop: '24px', paddingTop: '16px', borderTop: '1px solid var(--background-modifier-border)' }}>
        <h4 style={{ fontSize: '14px', fontWeight: 600, marginBottom: '8px' }}>Canvas Size</h4>
        <p style={{ fontSize: '12px', color: 'var(--text-muted)', marginBottom: '16px' }}>
          Canvas height settings (leave blank to use global defaults)
        </p>

        <div style={{ display: 'flex', gap: '12px', padding: '0 2px', opacity: useGlobalSettings ? 0.5 : 1 }}>
          <div class="dmt-form-group" style={{ flex: 1, marginBottom: 0 }}>
            <label class="dmt-form-label">Desktop (pixels)</label>
            <input
              type="number"
              class="dmt-modal-input"
              placeholder={String(globalSettings.canvasHeight ?? 600)}
              value={useGlobalSettings ? '' : (overrides.canvasHeight ?? '')}
              onChange={(e: Event) => !useGlobalSettings && handleColorChange('canvasHeight', (e.target as HTMLInputElement).value === '' ? undefined : parseInt((e.target as HTMLInputElement).value, 10))}
              disabled={useGlobalSettings}
              style={{ opacity: useGlobalSettings ? 0.5 : 1 }}
            />
          </div>

          <div class="dmt-form-group" style={{ flex: 1, marginBottom: 0 }}>
            <label class="dmt-form-label">Mobile/Touch (pixels)</label>
            <input
              type="number"
              class="dmt-modal-input"
              placeholder={String(globalSettings.canvasHeightMobile ?? 400)}
              value={useGlobalSettings ? '' : (overrides.canvasHeightMobile ?? '')}
              onChange={(e: Event) => !useGlobalSettings && handleColorChange('canvasHeightMobile', (e.target as HTMLInputElement).value === '' ? undefined : parseInt((e.target as HTMLInputElement).value, 10))}
              disabled={useGlobalSettings}
              style={{ opacity: useGlobalSettings ? 0.5 : 1 }}
            />
          </div>
        </div>
      </div>
    </div>
  );
}

return { AppearanceTab, ColorPickerItem, FogOfWarSection };

```

# BackgroundImageSection

```tsx
/**
 * BackgroundImageSection.tsx
 *
 * Background image configuration section for hex maps.
 * Handles image selection, opacity, and offset controls.
 * Collapsible - starts open, auto-collapses when image is selected.
 */

import type { ImageDimensions } from '#types/settings/settings.types';

const { useMapSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSettingsContext"));
const { CollapsibleSection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "CollapsibleSection"));

/** Map settings context shape for this component */
interface BackgroundImageContext {
  backgroundImagePath: string | null;
  backgroundImageDisplayName: string;
  setBackgroundImageDisplayName: (name: string) => void;
  imageDimensions: ImageDimensions | null;
  imageSearchResults: string[];
  handleImageSearch: (query: string) => void;
  handleImageSelect: (name: string) => void;
  handleImageClear: () => void;
}

/**
 * Background image section with image picker and visual controls
 */
function BackgroundImageSection(): React.ReactElement {
  const {
    backgroundImagePath,
    backgroundImageDisplayName,
    setBackgroundImageDisplayName,
    imageDimensions,
    imageSearchResults,
    handleImageSearch,
    handleImageSelect,
    handleImageClear
  } = useMapSettings() as BackgroundImageContext;

  // Track if user has manually toggled (to override auto-collapse behavior)
  const [userToggled, setUserToggled] = dc.useState(false);
  const [isOpen, setIsOpen] = dc.useState(true);

  // Auto-collapse when image is selected (only if user hasn't manually toggled)
  dc.useEffect(() => {
    if (backgroundImagePath && !userToggled) {
      setIsOpen(false);
    }
  }, [backgroundImagePath, userToggled]);

  const handleToggle = (newIsOpen: boolean): void => {
    setUserToggled(true);
    setIsOpen(newIsOpen);
  };

  // Generate subtitle showing selected image or status
  const subtitle = backgroundImagePath
    ? backgroundImageDisplayName || 'Image selected'
    : 'No image';

  return (
    <CollapsibleSection
      title="Background Image"
      isOpen={isOpen}
      onToggle={handleToggle}
      subtitle={subtitle}
    >
      <p style={{ fontSize: '12px', color: 'var(--text-muted)', marginBottom: '10px' }}>
        Add an image to automatically size the hex grid
      </p>

      {/* Image picker */}
      <div style={{ position: 'relative', marginBottom: '12px' }}>
        <input
          type="text"
          placeholder="Search for image..."
          value={backgroundImageDisplayName}
          onChange={(e: Event) => {
            const value = (e.target as HTMLInputElement).value;
            setBackgroundImageDisplayName(value);
            handleImageSearch(value);
          }}
          style={{
            width: '100%',
            padding: '8px 32px 8px 10px',
            borderRadius: '4px',
            border: '1px solid var(--background-modifier-border)',
            background: 'var(--background-primary)',
            color: 'var(--text-normal)',
            fontSize: '14px'
          }}
        />

        {backgroundImagePath && (
          <button
            onClick={handleImageClear}
            style={{
              position: 'absolute',
              right: '6px',
              top: '50%',
              transform: 'translateY(-50%)',
              background: 'transparent',
              border: 'none',
              color: 'var(--text-muted)',
              cursor: 'pointer',
              padding: '4px',
              fontSize: '16px',
              lineHeight: '1'
            }}
            title="Clear image"
          >
            
          </button>
        )}

        {/* Autocomplete dropdown */}
        {imageSearchResults.length > 0 && (
          <div style={{
            position: 'absolute',
            top: '100%',
            left: 0,
            right: 0,
            maxHeight: '200px',
            overflowY: 'auto',
            background: 'var(--background-primary)',
            border: '1px solid var(--background-modifier-border)',
            borderRadius: '4px',
            marginTop: '2px',
            zIndex: 1000,
            boxShadow: '0 2px 8px rgba(0,0,0,0.15)'
          }}>
            {imageSearchResults.map((name: string, idx: number) => (
              <div
                key={idx}
                onClick={() => handleImageSelect(name)}
                style={{
                  padding: '8px 10px',
                  cursor: 'pointer',
                  fontSize: '13px',
                  borderBottom: idx < imageSearchResults.length - 1 ? '1px solid var(--background-modifier-border)' : 'none'
                }}
                onMouseEnter={(e: Event) => (e.currentTarget as HTMLElement).style.background = 'var(--background-modifier-hover)'}
                onMouseLeave={(e: Event) => (e.currentTarget as HTMLElement).style.background = 'transparent'}
              >
                {name}
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Show dimensions when image is selected */}
      {imageDimensions && (
        <div>
          <p style={{ fontSize: '12px', color: 'var(--text-muted)' }}>
            Detected: {imageDimensions.width}  {imageDimensions.height} px
          </p>
        </div>
      )}
    </CollapsibleSection>
  );
}

return { BackgroundImageSection };

```

# SizingModeSection

```tsx
/**
 * SizingModeSection.tsx
 *
 * Grid sizing configuration for hex maps with background images.
 * Provides Quick Setup (density presets) and Advanced (measurement) modes.
 */

import type {
  HexOrientation,
  ImageDimensions,
  GridCalculation,
  GridDensityPreset,
} from '#types/settings/settings.types';
import type {
  GridDensity,
  SizingMode,
  MeasurementMethod,
  HexBounds,
} from '#types/core/map.types';

const { useMapSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSettingsContext"));
const { CollapsibleSection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "CollapsibleSection"));

/** Fine tune range */
interface FineTuneRange {
  min: number;
  max: number;
}

/** Context for density mode */
interface DensityModeContext {
  gridDensity: GridDensity;
  customColumns: number;
  hexBounds: HexBounds;
  imageDimensions: ImageDimensions | null;
  orientation: HexOrientation;
  handleDensityChange: (density: GridDensity) => void;
  handleCustomColumnsChange: (value: string) => void;
  GRID_DENSITY_PRESETS: Record<string, GridDensityPreset>;
  calculateGridFromColumns: (width: number, height: number, columns: number, orientation: HexOrientation) => GridCalculation;
  hexSizeToMeasurement: (hexSize: number, method: MeasurementMethod, orientation: HexOrientation) => number;
  MEASUREMENT_EDGE: MeasurementMethod;
}

/** Context for measurement mode */
interface MeasurementModeContext {
  measurementMethod: MeasurementMethod;
  measurementSize: number;
  hexBounds: HexBounds;
  imageDimensions: ImageDimensions | null;
  orientation: HexOrientation;
  fineTuneEnabled: boolean;
  fineTuneOffset: number;
  handleMeasurementMethodChange: (method: MeasurementMethod) => void;
  handleMeasurementSizeChange: (value: string) => void;
  handleFineTuneChange: (value: number) => void;
  handleFineTuneReset: () => void;
  MEASUREMENT_EDGE: MeasurementMethod;
  MEASUREMENT_CORNER: MeasurementMethod;
  measurementToHexSize: (size: number, method: MeasurementMethod, orientation: HexOrientation) => number;
  getFineTuneRange: (baseSize: number) => FineTuneRange;
}

/** Context for sizing mode section */
interface SizingModeSectionContext {
  backgroundImagePath: string | null;
  imageDimensions: ImageDimensions | null;
  sizingMode: SizingMode;
  imageOpacity: number;
  setImageOpacity: (opacity: number) => void;
  imageOffsetX: number;
  setImageOffsetX: (offset: number) => void;
  imageOffsetY: number;
  setImageOffsetY: (offset: number) => void;
  handleSizingModeChange: (mode: SizingMode) => void;
  onOpenAlignmentMode?: (offsetX: number, offsetY: number) => void;
}

/**
 * Quick Setup tab content - density presets
 */
function DensityModeContent(): React.ReactElement {
  const {
    gridDensity,
    customColumns,
    hexBounds,
    imageDimensions,
    orientation,
    handleDensityChange,
    handleCustomColumnsChange,
    GRID_DENSITY_PRESETS,
    calculateGridFromColumns,
    hexSizeToMeasurement,
    MEASUREMENT_EDGE
  } = useMapSettings() as DensityModeContext;

  return (
    <div>
      <label class="dmt-form-label" style={{ marginBottom: '8px' }}>Grid Density</label>

      <div style={{ display: 'flex', flexDirection: 'column', gap: '6px' }}>
        <label class="dmt-radio-label" style={{ display: 'flex', alignItems: 'flex-start', gap: '8px', cursor: 'pointer' }}>
          <input
            type="radio"
            name="gridDensity"
            value="sparse"
            checked={gridDensity === 'sparse'}
            onChange={() => handleDensityChange('sparse')}
            style={{ marginTop: '2px' }}
          />
          <div>
            <span style={{ fontWeight: 500 }}>{GRID_DENSITY_PRESETS.sparse.label}</span>
            <p style={{ fontSize: '11px', color: 'var(--text-muted)', marginTop: '2px' }}>
              {GRID_DENSITY_PRESETS.sparse.description}
            </p>
          </div>
        </label>

        <label class="dmt-radio-label" style={{ display: 'flex', alignItems: 'flex-start', gap: '8px', cursor: 'pointer' }}>
          <input
            type="radio"
            name="gridDensity"
            value="medium"
            checked={gridDensity === 'medium'}
            onChange={() => handleDensityChange('medium')}
            style={{ marginTop: '2px' }}
          />
          <div>
            <span style={{ fontWeight: 500 }}>{GRID_DENSITY_PRESETS.medium.label}</span>
            <p style={{ fontSize: '11px', color: 'var(--text-muted)', marginTop: '2px' }}>
              {GRID_DENSITY_PRESETS.medium.description}
            </p>
          </div>
        </label>

        <label class="dmt-radio-label" style={{ display: 'flex', alignItems: 'flex-start', gap: '8px', cursor: 'pointer' }}>
          <input
            type="radio"
            name="gridDensity"
            value="dense"
            checked={gridDensity === 'dense'}
            onChange={() => handleDensityChange('dense')}
            style={{ marginTop: '2px' }}
          />
          <div>
            <span style={{ fontWeight: 500 }}>{GRID_DENSITY_PRESETS.dense.label}</span>
            <p style={{ fontSize: '11px', color: 'var(--text-muted)', marginTop: '2px' }}>
              {GRID_DENSITY_PRESETS.dense.description}
            </p>
          </div>
        </label>

        <label class="dmt-radio-label" style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer' }}>
          <input
            type="radio"
            name="gridDensity"
            value="custom"
            checked={gridDensity === 'custom'}
            onChange={() => handleDensityChange('custom')}
          />
          <span style={{ fontWeight: 500 }}>Custom</span>
          <input
            type="number"
            min="1"
            max="200"
            value={customColumns}
            onChange={(e: Event) => handleCustomColumnsChange((e.target as HTMLInputElement).value)}
            disabled={gridDensity !== 'custom'}
            style={{
              width: '60px',
              padding: '4px 8px',
              borderRadius: '4px',
              border: '1px solid var(--background-modifier-border)',
              background: 'var(--background-primary)',
              color: 'var(--text-normal)',
              fontSize: '13px',
              opacity: gridDensity !== 'custom' ? 0.5 : 1
            }}
          />
          <span style={{ fontSize: '13px', color: 'var(--text-muted)' }}>columns</span>
        </label>
      </div>

      {/* Show calculated result */}
      {imageDimensions && (
        <div style={{ marginTop: '12px', padding: '8px', background: 'var(--background-secondary)', borderRadius: '4px' }}>
          <p style={{ fontSize: '12px', color: 'var(--text-muted)' }}>
            Result: {hexBounds.maxCol} columns  {hexBounds.maxRow} rows
            {(() => {
              const columns = gridDensity === 'custom' ? customColumns : GRID_DENSITY_PRESETS[gridDensity]?.columns || 24;
              const calc = calculateGridFromColumns(imageDimensions.width, imageDimensions.height, columns, orientation);
              return ` (~${Math.round(hexSizeToMeasurement(calc.hexSize, MEASUREMENT_EDGE, orientation))}px hex width)`;
            })()}
          </p>
        </div>
      )}
    </div>
  );
}

/**
 * Advanced tab content - measurement mode
 */
function MeasurementModeContent(): React.ReactElement {
  const {
    measurementMethod,
    measurementSize,
    hexBounds,
    fineTuneOffset,
    handleMeasurementMethodChange,
    handleMeasurementSizeChange,
    handleFineTuneChange,
    handleFineTuneReset,
    MEASUREMENT_EDGE,
    MEASUREMENT_CORNER,
    measurementToHexSize,
    getFineTuneRange,
    orientation
  } = useMapSettings() as MeasurementModeContext;

  const baseHexSize = measurementToHexSize(measurementSize, measurementMethod, orientation);
  const fineTuneEnabled = fineTuneOffset !== 0;
  const effectiveHexSize = fineTuneEnabled ? baseHexSize + fineTuneOffset : baseHexSize;
  const fineTuneRange = getFineTuneRange(baseHexSize);

  return (
    <div>
      <label class="dmt-form-label" style={{ marginBottom: '8px' }}>Hex Measurement</label>

      {/* Measurement method selector */}
      <div style={{ display: 'flex', gap: '12px', marginBottom: '12px' }}>
        <label style={{ display: 'flex', alignItems: 'center', gap: '6px', cursor: 'pointer' }}>
          <input
            type="radio"
            name="measurementMethod"
            value={MEASUREMENT_EDGE}
            checked={measurementMethod === MEASUREMENT_EDGE}
            onChange={() => handleMeasurementMethodChange(MEASUREMENT_EDGE)}
          />
          <span style={{ fontSize: '13px' }}>Edge-to-edge</span>
        </label>
        <label style={{ display: 'flex', alignItems: 'center', gap: '6px', cursor: 'pointer' }}>
          <input
            type="radio"
            name="measurementMethod"
            value={MEASUREMENT_CORNER}
            checked={measurementMethod === MEASUREMENT_CORNER}
            onChange={() => handleMeasurementMethodChange(MEASUREMENT_CORNER)}
          />
          <span style={{ fontSize: '13px' }}>Corner-to-corner</span>
        </label>
      </div>

      {/* Size input */}
      <div style={{ display: 'flex', gap: '8px', alignItems: 'center', marginBottom: '12px' }}>
        <span style={{ fontSize: '13px', color: 'var(--text-muted)' }}>Size:</span>
        <input
          type="number"
          min="10"
          max="500"
          step="1"
          value={measurementSize}
          onChange={(e: Event) => handleMeasurementSizeChange((e.target as HTMLInputElement).value)}
          style={{
            width: '80px',
            padding: '4px 8px',
            borderRadius: '4px',
            border: '1px solid var(--background-modifier-border)',
            background: 'var(--background-primary)',
            color: 'var(--text-normal)',
            fontSize: '13px'
          }}
        />
        <span style={{ fontSize: '13px', color: 'var(--text-muted)' }}>pixels</span>
      </div>

      {/* Calculated result */}
      <div style={{ padding: '8px', background: 'var(--background-secondary)', borderRadius: '4px', marginBottom: '12px' }}>
        <p style={{ fontSize: '12px', color: 'var(--text-muted)' }}>
          Calculated Grid: {hexBounds.maxCol} columns  {hexBounds.maxRow} rows
          {` (hexSize: ${effectiveHexSize.toFixed(1)}px)`}
        </p>
      </div>

      {/* Fine-tune section */}
      <details style={{ marginTop: '12px' }}>
        <summary style={{
          cursor: 'pointer',
          fontWeight: '500',
          fontSize: '13px',
          color: 'var(--text-normal)',
          padding: '4px 0',
          userSelect: 'none'
        }}>
           Fine-Tune Alignment
        </summary>

        <div style={{ marginTop: '8px', padding: '12px', background: 'var(--background-secondary)', borderRadius: '4px' }}>
          <p style={{ fontSize: '11px', color: 'var(--text-muted)', marginBottom: '12px' }}>
            Adjust if hexes don't align perfectly with your image grid. Small changes can make a big difference.
          </p>

          <div style={{ display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' }}>
            <span style={{ fontSize: '12px', color: 'var(--text-muted)' }}>Hex size:</span>
            <input
              type="number"
              min={fineTuneRange.min}
              max={fineTuneRange.max}
              step="0.5"
              value={effectiveHexSize.toFixed(1)}
              onChange={(e: Event) => handleFineTuneChange(parseFloat((e.target as HTMLInputElement).value))}
              style={{
                width: '80px',
                padding: '4px 8px',
                borderRadius: '4px',
                border: '1px solid var(--background-modifier-border)',
                background: 'var(--background-primary)',
                color: 'var(--text-normal)',
                fontSize: '13px'
              }}
            />
            <span style={{ fontSize: '12px', color: 'var(--text-muted)' }}>px</span>

            {fineTuneOffset !== 0 && (
              <>
                <span style={{ fontSize: '12px', color: 'var(--text-accent)' }}>
                  ({fineTuneOffset > 0 ? '+' : ''}{fineTuneOffset.toFixed(1)})
                </span>
                <button
                  onClick={handleFineTuneReset}
                  style={{
                    padding: '4px 8px',
                    fontSize: '11px',
                    background: 'var(--interactive-normal)',
                    border: 'none',
                    borderRadius: '3px',
                    cursor: 'pointer',
                    color: 'var(--text-normal)'
                  }}
                >
                  Reset
                </button>
              </>
            )}
          </div>
        </div>
      </details>
    </div>
  );
}

/**
 * Sizing mode section with tabbed interface
 */
function SizingModeSection(): React.ReactElement | null {
  const {
    backgroundImagePath,
    imageDimensions,
    sizingMode,
    imageOpacity,
    setImageOpacity,
    imageOffsetX,
    setImageOffsetX,
    imageOffsetY,
    setImageOffsetY,
    handleSizingModeChange,
    onOpenAlignmentMode
  } = useMapSettings() as SizingModeSectionContext;

  // Only show when image is selected and dimensions are loaded
  if (!backgroundImagePath || !imageDimensions) {
    return null;
  }

  return (
    <div style={{ marginTop: '20px' }}>
      {/* Tab buttons */}
      <div style={{
        display: 'flex',
        gap: '4px',
        borderBottom: '1px solid var(--background-modifier-border)',
        marginBottom: '16px'
      }}>
        <button
          onClick={() => handleSizingModeChange('density')}
          style={{
            flex: 1,
            padding: '8px 16px',
            background: sizingMode === 'density' ? 'var(--background-modifier-hover)' : 'transparent',
            border: 'none',
            borderBottom: sizingMode === 'density' ? '2px solid var(--interactive-accent)' : '2px solid transparent',
            color: sizingMode === 'density' ? 'var(--text-normal)' : 'var(--text-muted)',
            cursor: 'pointer',
            fontSize: '13px',
            fontWeight: sizingMode === 'density' ? '600' : '400',
            transition: 'all 0.2s'
          }}
        >
          Quick Setup
        </button>
        <button
          onClick={() => handleSizingModeChange('measurement')}
          style={{
            flex: 1,
            padding: '8px 16px',
            background: sizingMode === 'measurement' ? 'var(--background-modifier-hover)' : 'transparent',
            border: 'none',
            borderBottom: sizingMode === 'measurement' ? '2px solid var(--interactive-accent)' : '2px solid transparent',
            color: sizingMode === 'measurement' ? 'var(--text-normal)' : 'var(--text-muted)',
            cursor: 'pointer',
            fontSize: '13px',
            fontWeight: sizingMode === 'measurement' ? '600' : '400',
            transition: 'all 0.2s'
          }}
        >
          Advanced
        </button>
      </div>

      {/* Tab content */}
      {sizingMode === 'density' && <DensityModeContent />}
      {sizingMode === 'measurement' && <MeasurementModeContent />}

      {/* Opacity slider */}
      <div style={{ marginTop: '16px' }}>
        <label class="dmt-form-label" style={{ marginBottom: '8px', display: 'block' }}>
          Image Opacity: {Math.round(imageOpacity * 100)}%
        </label>
        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
          <input
            type="range"
            min="0"
            max="100"
            value={Math.round(imageOpacity * 100)}
            onChange={(e: Event) => setImageOpacity(parseInt((e.target as HTMLInputElement).value, 10) / 100)}
            style={{
              flex: 1,
              height: '6px',
              cursor: 'pointer',
              accentColor: 'var(--interactive-accent)'
            }}
          />
          <span style={{
            fontSize: '12px',
            color: 'var(--text-muted)',
            minWidth: '35px',
            textAlign: 'right'
          }}>
            {Math.round(imageOpacity * 100)}%
          </span>
        </div>
        <p style={{ fontSize: '11px', color: 'var(--text-muted)', marginTop: '4px' }}>
          Lower opacity makes the grid more visible over the image
        </p>
      </div>

      {/* Image offset controls - collapsible, starts collapsed */}
      <CollapsibleSection
        title="Image Offset"
        defaultOpen={false}
        subtitle={`X: ${imageOffsetX}, Y: ${imageOffsetY}`}
      >
        <div style={{ display: 'flex', gap: '16px', alignItems: 'center', flexWrap: 'wrap', marginBottom: '8px' }}>
          <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
            <span style={{ color: 'var(--text-muted)', fontSize: '13px' }}>X:</span>
            <input
              type="number"
              value={imageOffsetX}
              onChange={(e: Event) => setImageOffsetX(parseInt((e.target as HTMLInputElement).value, 10) || 0)}
              class="dmt-number-input"
              style={{
                width: '80px',
                padding: '4px 8px',
                borderRadius: '4px',
                border: '1px solid var(--background-modifier-border)',
                background: 'var(--background-primary)',
                color: 'var(--text-normal)',
                fontSize: '13px'
              }}
            />
          </div>
          <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
            <span style={{ color: 'var(--text-muted)', fontSize: '13px' }}>Y:</span>
            <input
              type="number"
              value={imageOffsetY}
              onChange={(e: Event) => setImageOffsetY(parseInt((e.target as HTMLInputElement).value, 10) || 0)}
              class="dmt-number-input"
              style={{
                width: '80px',
                padding: '4px 8px',
                borderRadius: '4px',
                border: '1px solid var(--background-modifier-border)',
                background: 'var(--background-primary)',
                color: 'var(--text-normal)',
                fontSize: '13px'
              }}
            />
          </div>
        </div>
        <p style={{ fontSize: '11px', color: 'var(--text-muted)', marginBottom: '8px' }}>
          Fine-tune image position relative to grid center
        </p>
        <button
          onClick={() => onOpenAlignmentMode?.(imageOffsetX, imageOffsetY)}
          style={{
            padding: '6px 12px',
            fontSize: '12px',
            fontWeight: '500',
            background: 'var(--interactive-normal)',
            color: 'var(--text-normal)',
            border: '1px solid var(--background-modifier-border)',
            borderRadius: '4px',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            gap: '6px'
          }}
          onMouseEnter={(e: Event) => (e.target as HTMLElement).style.background = 'var(--interactive-hover)'}
          onMouseLeave={(e: Event) => (e.target as HTMLElement).style.background = 'var(--interactive-normal)'}
        >
          <span></span>
          <span>Adjust Position Interactively</span>
        </button>
      </CollapsibleSection>
    </div>
  );
}

return { SizingModeSection, DensityModeContent, MeasurementModeContent };

```

# BoundsSection

```tsx
/**
 * BoundsSection.tsx
 *
 * Map bounds configuration section for hex maps.
 * Handles column/row limits for the playable grid area.
 */

const { useMapSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSettingsContext"));

/** Hex bounds configuration */
interface HexBounds {
  maxCol: number;
  maxRow: number;
}

/** Map settings context shape for this component */
interface BoundsSectionContext {
  hexBounds: HexBounds;
  boundsLocked: boolean;
  backgroundImagePath: string | null;
  handleHexBoundsChange: (field: 'maxCol' | 'maxRow', value: string) => void;
  handleBoundsLockToggle: () => void;
}

/**
 * Map bounds configuration section
 */
function BoundsSection(): React.ReactElement {
  const {
    hexBounds,
    boundsLocked,
    backgroundImagePath,
    handleHexBoundsChange,
    handleBoundsLockToggle
  } = useMapSettings() as BoundsSectionContext;

  // Generate display label for playable area (e.g., "A1 to Z20")
  const getPlayableAreaLabel = (): string => {
    const maxColLetter = String.fromCharCode(65 + Math.min(hexBounds.maxCol - 1, 25));
    const overflow = hexBounds.maxCol > 26 ? '+' : '';
    return `A1 to ${maxColLetter}${overflow}${hexBounds.maxRow}`;
  };

  const isDisabled = boundsLocked && !!backgroundImagePath;

  return (
    <div class="dmt-form-group">
      <label class="dmt-form-label">
        Map Bounds
        {isDisabled && (
          <span style={{ fontSize: '11px', color: 'var(--text-muted)', fontWeight: 'normal', marginLeft: '8px' }}>
            (controlled by background image)
          </span>
        )}
      </label>
      <div style={{
        display: 'flex',
        gap: '16px',
        alignItems: 'center',
        flexWrap: 'wrap',
        opacity: isDisabled ? 0.6 : 1
      }}>
        <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
          <span style={{ color: 'var(--text-muted)', fontSize: '13px' }}>Columns:</span>
          <input
            type="number"
            min="1"
            max="1000"
            value={hexBounds.maxCol}
            onChange={(e: Event) => handleHexBoundsChange('maxCol', (e.target as HTMLInputElement).value)}
            disabled={isDisabled}
            class="dmt-number-input"
            style={{
              padding: '6px 10px',
              borderRadius: '4px',
              border: '1px solid var(--background-modifier-border)',
              background: isDisabled ? 'var(--background-secondary)' : 'var(--background-primary)',
              color: isDisabled ? 'var(--text-muted)' : 'var(--text-normal)',
              fontSize: '14px',
              width: '70px'
            }}
          />
        </div>
        <span style={{ color: 'var(--text-muted)' }}></span>
        <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
          <span style={{ color: 'var(--text-muted)', fontSize: '13px' }}>Rows:</span>
          <input
            type="number"
            min="1"
            max="1000"
            value={hexBounds.maxRow}
            onChange={(e: Event) => handleHexBoundsChange('maxRow', (e.target as HTMLInputElement).value)}
            disabled={isDisabled}
            class="dmt-number-input"
            style={{
              padding: '6px 10px',
              borderRadius: '4px',
              border: '1px solid var(--background-modifier-border)',
              background: isDisabled ? 'var(--background-secondary)' : 'var(--background-primary)',
              color: isDisabled ? 'var(--text-muted)' : 'var(--text-normal)',
              fontSize: '14px',
              width: '70px'
            }}
          />
        </div>
      </div>
      <p style={{ fontSize: '11px', color: 'var(--text-muted)', marginTop: '8px' }}>
        Playable area: {getPlayableAreaLabel()}
      </p>

      {/* Lock bounds checkbox - only show when background image is present */}
      {backgroundImagePath && (
        <label class="dmt-checkbox-label" style={{ marginTop: '12px', display: 'flex', alignItems: 'center', gap: '8px' }}>
          <input
            type="checkbox"
            checked={boundsLocked}
            onChange={handleBoundsLockToggle}
            class="dmt-checkbox"
          />
          <span style={{ fontSize: '13px' }}>Lock bounds to image dimensions</span>
        </label>
      )}
    </div>
  );
}

return { BoundsSection };

```

# CoordinateDisplaySection

```tsx
/**
 * CoordinateDisplaySection.tsx
 *
 * Coordinate display configuration for hex maps.
 * Handles display mode (rectangular vs radial) and text colors.
 */

import type { HexColor } from '#types/core/common.types';

const { useMapSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSettingsContext"));
const { CollapsibleSection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "CollapsibleSection"));
const { ColorPickerItem } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "AppearanceTab"));

/** Coordinate display mode type */
type CoordinateDisplayMode = 'rectangular' | 'radial';

/** Theme constants for coordinates */
interface CoordinateTheme {
  color: HexColor;
  shadow: HexColor;
}

/** Map settings context for coordinate mode */
interface CoordinateModeContext {
  coordinateDisplayMode: CoordinateDisplayMode;
  setCoordinateDisplayMode: (mode: CoordinateDisplayMode) => void;
}

/** Map settings context for coordinate colors */
interface CoordinateColorsContext {
  useGlobalSettings: boolean;
  THEME: {
    coordinateText: CoordinateTheme;
  };
}

/**
 * Coordinate display mode selector (content only, no wrapper)
 */
function CoordinateModeContent(): React.ReactElement {
  const {
    coordinateDisplayMode,
    setCoordinateDisplayMode
  } = useMapSettings() as CoordinateModeContext;

  return (
    <div style={{ marginBottom: '16px' }}>
      <label class="dmt-form-label" style={{ marginBottom: '4px' }}>Display Mode</label>
      <p style={{ fontSize: '12px', color: 'var(--text-muted)', marginBottom: '10px' }}>
        How coordinates appear when pressing C
      </p>

      <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
        <label class="dmt-radio-label" style={{ display: 'flex', alignItems: 'flex-start', gap: '8px', cursor: 'pointer' }}>
          <input
            type="radio"
            name="coordMode"
            value="rectangular"
            checked={coordinateDisplayMode === 'rectangular'}
            onChange={() => setCoordinateDisplayMode('rectangular')}
            style={{ marginTop: '2px' }}
          />
          <div>
            <span style={{ fontWeight: 500 }}>Rectangular (A1, B2, ...)</span>
            <p style={{ fontSize: '11px', color: 'var(--text-muted)', marginTop: '2px' }}>
              Column-row labels for standard grid layouts
            </p>
          </div>
        </label>

        <label class="dmt-radio-label" style={{ display: 'flex', alignItems: 'flex-start', gap: '8px', cursor: 'pointer' }}>
          <input
            type="radio"
            name="coordMode"
            value="radial"
            checked={coordinateDisplayMode === 'radial'}
            onChange={() => setCoordinateDisplayMode('radial')}
            style={{ marginTop: '2px' }}
          />
          <div>
            <span style={{ fontWeight: 500 }}>Radial (, 1-1, 2-5, ...)</span>
            <p style={{ fontSize: '11px', color: 'var(--text-muted)', marginTop: '2px' }}>
              Ring-position labels centered in grid
            </p>
          </div>
        </label>
      </div>
    </div>
  );
}

/**
 * Coordinate text color pickers (content only, no wrapper)
 */
function CoordinateColorsContent(): React.ReactElement {
  const {
    useGlobalSettings,
    THEME
  } = useMapSettings() as CoordinateColorsContext;

  return (
    <div>
      <label class="dmt-form-label" style={{ marginBottom: '4px' }}>Text Colors</label>
      <p style={{ fontSize: '12px', color: 'var(--text-muted)', marginBottom: '10px' }}>
        {useGlobalSettings
          ? 'Using global settings (enable custom colors in Appearance tab to override)'
          : 'Custom colors for coordinate overlay text'}
      </p>

      <div
        style={{
          opacity: useGlobalSettings ? 0.5 : 1,
          display: 'grid',
          gridTemplateColumns: '1fr 1fr',
          gap: '16px'
        }}
      >
        <ColorPickerItem
          colorKey="coordinateTextColor"
          label="Text Color"
          defaultColor={THEME.coordinateText.color}
        />
        <ColorPickerItem
          colorKey="coordinateTextShadow"
          label="Text Shadow"
          defaultColor={THEME.coordinateText.shadow}
          align="right"
        />
      </div>
    </div>
  );
}

/**
 * Combined coordinate display section - collapsible, starts collapsed
 */
function CoordinateDisplaySection(): React.ReactElement {
  const { coordinateDisplayMode } = useMapSettings() as CoordinateModeContext;

  // Generate subtitle based on current mode
  const subtitle = coordinateDisplayMode === 'rectangular' ? 'A1, B2, ...' : 'Ring-Position';

  return (
    <CollapsibleSection
      title="Coordinate Display"
      defaultOpen={false}
      subtitle={subtitle}
    >
      <CoordinateModeContent />
      <CoordinateColorsContent />
    </CollapsibleSection>
  );
}

return { CoordinateDisplaySection, CoordinateModeContent, CoordinateColorsContent };

```

# HexGridTab

```tsx
/**
 * HexGridTab.tsx
 *
 * Hex Grid settings tab for MapSettingsModal.
 * Composes BackgroundImageSection, SizingModeSection, BoundsSection,
 * and CoordinateDisplaySection into a unified tab.
 */

import type { MapType } from '#types/core/map.types';

const { useMapSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSettingsContext"));
const { BackgroundImageSection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "BackgroundImageSection"));
const { SizingModeSection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "SizingModeSection"));
const { BoundsSection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "BoundsSection"));
const { CoordinateDisplaySection } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "CoordinateDisplaySection"));

/**
 * Hex Grid tab content - composes all hex-specific settings sections
 */
function HexGridTab(): React.ReactElement | null {
  const { mapType } = useMapSettings() as { mapType: MapType };

  // Guard: only render for hex maps
  if (mapType !== 'hex') {
    return null;
  }

  return (
    <div class="dmt-settings-tab-content">
      {/* Background Image Section - image picker and dimensions */}
      <BackgroundImageSection />

      {/* Sizing Mode Section - Quick Setup / Advanced tabs, lock, opacity, offset */}
      <SizingModeSection />

      {/* Map Bounds Section - columns  rows */}
      <BoundsSection />

      {/* Coordinate Display Section - mode selector and text colors */}
      <CoordinateDisplaySection />
    </div>
  );
}

return { HexGridTab };

```

# MeasurementTab

```tsx
/**
 * MeasurementTab.tsx
 *
 * Distance measurement settings tab for MapSettingsModal.
 * Handles distance per cell, units, diagonal rules, and display format.
 */

import type { DiagonalRule, DistanceDisplayFormat } from '#types/settings/settings.types';

const { useMapSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSettingsContext"));

/** Distance settings state */
interface DistanceSettingsState {
  useGlobalDistance: boolean;
  distancePerCell: number;
  distanceUnit: string;
  gridDiagonalRule: DiagonalRule;
  displayFormat: DistanceDisplayFormat;
}

/**
 * Measurement tab content
 */
function MeasurementTab(): React.ReactElement {
  const {
    isHexMap,
    distanceSettings,
    setDistanceSettings
  } = useMapSettings();

  const handleToggleUseGlobal = (): void => {
    setDistanceSettings((prev: DistanceSettingsState) => ({
      ...prev,
      useGlobalDistance: !prev.useGlobalDistance
    }));
  };

  const handleDistancePerCellChange = (e: Event): void => {
    const val = parseFloat((e.target as HTMLInputElement).value);
    if (!isNaN(val) && val > 0) {
      setDistanceSettings((prev: DistanceSettingsState) => ({ ...prev, distancePerCell: val }));
    }
  };

  const handleUnitChange = (e: Event): void => {
    setDistanceSettings((prev: DistanceSettingsState) => ({
      ...prev,
      distanceUnit: (e.target as HTMLSelectElement).value
    }));
  };

  const handleDiagonalRuleChange = (e: Event): void => {
    setDistanceSettings((prev: DistanceSettingsState) => ({
      ...prev,
      gridDiagonalRule: (e.target as HTMLSelectElement).value as DiagonalRule
    }));
  };

  const handleDisplayFormatChange = (e: Event): void => {
    setDistanceSettings((prev: DistanceSettingsState) => ({
      ...prev,
      displayFormat: (e.target as HTMLSelectElement).value as DistanceDisplayFormat
    }));
  };

  return (
    <div class="dmt-settings-tab-content">
      <div class="dmt-form-group" style={{ marginBottom: '16px' }}>
        <label class="dmt-checkbox-label">
          <input
            type="checkbox"
            checked={!distanceSettings.useGlobalDistance}
            onChange={handleToggleUseGlobal}
            class="dmt-checkbox"
          />
          <span>Use custom measurement settings for this map</span>
        </label>
      </div>

      <div style={{ opacity: distanceSettings.useGlobalDistance ? 0.5 : 1 }}>
        <div class="dmt-form-group">
          <label class="dmt-form-label">Distance per {isHexMap ? 'Hex' : 'Cell'}</label>
          <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
            <input
              type="number"
              min="0.1"
              step="0.1"
              value={distanceSettings.distancePerCell}
              disabled={distanceSettings.useGlobalDistance}
              onChange={handleDistancePerCellChange}
              class="dmt-form-input"
              style={{ width: '80px' }}
            />
            <select
              value={distanceSettings.distanceUnit}
              disabled={distanceSettings.useGlobalDistance}
              onChange={handleUnitChange}
              class="dmt-form-select"
              style={{ width: '120px' }}
            >
              <option value="ft">feet</option>
              <option value="m">meters</option>
              <option value="mi">miles</option>
              <option value="km">kilometers</option>
              <option value="yd">yards</option>
            </select>
          </div>
        </div>

        {!isHexMap && (
          <div class="dmt-form-group">
            <label class="dmt-form-label">Diagonal Movement</label>
            <select
              value={distanceSettings.gridDiagonalRule}
              disabled={distanceSettings.useGlobalDistance}
              onChange={handleDiagonalRuleChange}
              class="dmt-form-select"
            >
              <option value="alternating">Alternating (5-10-5-10, D&D 5e)</option>
              <option value="equal">Equal (Chebyshev, all moves = 1)</option>
              <option value="euclidean">True Distance (Euclidean)</option>
            </select>
          </div>
        )}

        <div class="dmt-form-group">
          <label class="dmt-form-label">Display Format</label>
          <select
            value={distanceSettings.displayFormat}
            disabled={distanceSettings.useGlobalDistance}
            onChange={handleDisplayFormatChange}
            class="dmt-form-select"
          >
            <option value="both">Cells and Units (e.g., "3 cells (15 ft)")</option>
            <option value="cells">Cells Only (e.g., "3 cells")</option>
            <option value="units">Units Only (e.g., "15 ft")</option>
          </select>
        </div>
      </div>
    </div>
  );
}

return { MeasurementTab };

```

# exportOperations

```ts
/**
 * exportOperations.ts
 * 
 * Functions for exporting map as image.
 * Handles content bounds calculation, rendering to offscreen canvas,
 * and triggering browser download.
 */

// Type-only imports
import type { Point, BoundingBox } from '#types/core/geometry.types';
import type { MapData, MapLayer } from '#types/core/map.types';
import type { Cell } from '#types/core/cell.types';
import type { MapObject } from '#types/objects/object.types';
import type { TextLabel, FontFace } from './textLabelOperations';
import type { HexColor } from '#types/settings/settings.types';
import type {
  ExportGeometry,
  RenderParams,
  ExportResult,
  ExportTheme,
  ExportVisibilityOptions
} from '#types/core/export.types';
import type { App, TFile } from 'obsidian';

// Datacore imports
const { getActiveLayer } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor")) as {
  getActiveLayer: (mapData: MapData) => MapLayer
};

const { getFontCss } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "fontOptions")) as {
  getFontCss: (fontFace: FontFace) => string
};

// Obsidian app reference
declare const app: App;

// ===========================================
// Text Label Bounds
// ===========================================

/**
 * Calculate the bounding box of a text label in world coordinates.
 * Uses canvas text measurement API to get accurate bounds.
 */
function getTextLabelBounds(label: TextLabel, ctx: CanvasRenderingContext2D): BoundingBox {
  // Set font for measurement
  const fontSize = label.fontSize || 16;
  const fontFace = label.fontFace || 'sans';
  const fontFamily = getFontCss(fontFace);
  ctx.font = `${fontSize}px ${fontFamily}`;
  
  // Measure text
  const metrics = ctx.measureText(label.content);
  const textWidth = metrics.width;
  
  // Estimate text height (approximation since canvas doesn't provide exact height)
  const textHeight = fontSize * 1.2;
  
  // Text labels use position.x and position.y
  const worldX = label.position.x;
  const worldY = label.position.y;
  
  // Text is positioned at its center point
  const minX = worldX - textWidth / 2;
  const minY = worldY - textHeight / 2;
  const maxX = worldX + textWidth / 2;
  const maxY = worldY + textHeight / 2;
  
  return { minX, minY, maxX, maxY };
}

// ===========================================
// Content Bounds Calculation
// ===========================================

/**
 * Calculate the world-coordinate bounding box of all content on a layer
 */
function calculateContentBounds(
  mapData: MapData,
  layer: MapLayer,
  geometry: ExportGeometry
): BoundingBox | null {
  let minX = Infinity, minY = Infinity;
  let maxX = -Infinity, maxY = -Infinity;
  
  let hasContent = false;
  
  // 1. Painted cells
  if (layer.cells && layer.cells.length > 0) {
    for (const cell of layer.cells) {
      hasContent = true;
      const bounds = geometry.getCellBounds(cell);
      minX = Math.min(minX, bounds.minX);
      minY = Math.min(minY, bounds.minY);
      maxX = Math.max(maxX, bounds.maxX);
      maxY = Math.max(maxY, bounds.maxY);
    }
  }
  
  // 2. Objects
  if (layer.objects && layer.objects.length > 0) {
    for (const obj of layer.objects) {
      hasContent = true;
      const bounds = geometry.getObjectBounds(obj as unknown as MapObject);
      minX = Math.min(minX, bounds.minX);
      minY = Math.min(minY, bounds.minY);
      maxX = Math.max(maxX, bounds.maxX);
      maxY = Math.max(maxY, bounds.maxY);
    }
  }
  
  // 3. Text labels (need temporary canvas for measurement)
  if (layer.textLabels && layer.textLabels.length > 0) {
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    
    if (tempCtx) {
      for (const label of layer.textLabels) {
        hasContent = true;
        const bounds = getTextLabelBounds(label as unknown as TextLabel, tempCtx);
        minX = Math.min(minX, bounds.minX);
        minY = Math.min(minY, bounds.minY);
        maxX = Math.max(maxX, bounds.maxX);
        maxY = Math.max(maxY, bounds.maxY);
      }
    }
  }
  
  if (!hasContent) return null;
  
  return { minX, minY, maxX, maxY };
}

// ===========================================
// Canvas Rendering
// ===========================================

/**
 * Render map content to a canvas context using the same rendering logic as the main canvas.
 */
async function renderMapToCanvas(
  ctx: CanvasRenderingContext2D,
  params: RenderParams
): Promise<void> {
  const { mapData, geometry, bounds, width, height } = params;
  
  // Import rendering dependencies
  const { renderCanvas } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useCanvasRenderer")) as {
    renderCanvas: (
      canvas: HTMLCanvasElement,
      fogCanvas: HTMLCanvasElement | null,
      mapData: MapData,
      geometry: ExportGeometry,
      selection: unknown[],
      isSelected: boolean,
      theme: ExportTheme,
      showPreview: boolean,
      visibility: ExportVisibilityOptions
    ) => void
  };
  
  const { GridGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "GridGeometry")) as {
    GridGeometry: new () => ExportGeometry
  };
  
  // Calculate viewport parameters for export
  const contentCenterX = (bounds.minX + bounds.maxX) / 2;
  const contentCenterY = (bounds.minY + bounds.maxY) / 2;
  
  let exportCenter: Point;
  if (geometry.worldToGrid) {
    // Grid maps: convert world coords to grid coords
    const gridCoords = geometry.worldToGrid(contentCenterX, contentCenterY);
    exportCenter = { x: gridCoords.x, y: gridCoords.y };
  } else {
    // Hex maps use world coordinates directly
    exportCenter = { x: contentCenterX, y: contentCenterY };
  }
  
  // Create temporary canvas for rendering
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = width;
  tempCanvas.height = height;
  
  // Create export-specific map data
  const exportMapData: MapData = {
    ...mapData,
    // Override viewport for export
  };
  
  // Get effective settings for theming
  const { getSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsAccessor")) as {
    getSettings: () => { 
      gridLineColor: HexColor;
      gridLineWidth: number;
      backgroundColor: HexColor;
      borderColor: HexColor;
      coordinateKeyColor: HexColor;
    }
  };
  
  const effectiveSettings = getSettings();
  
  // Build export theme
  const theme: ExportTheme = {
    grid: {
      lines: effectiveSettings.gridLineColor,
      lineWidth: effectiveSettings.gridLineWidth,
      background: effectiveSettings.backgroundColor
    },
    cells: {
      fill: '#c4a57b',
      border: effectiveSettings.borderColor,
      borderWidth: 2
    },
    compass: {
      color: '#c4a57b',
      size: 100
    },
    decorativeBorder: {
      color: '#8b7355',
      width: 20,
      pattern: 'fancy'
    },
    coordinateKey: effectiveSettings.coordinateKeyColor
  };
  
  // Render using existing render function
  renderCanvas(
    tempCanvas,
    null,
    exportMapData,
    geometry,
    [],
    false,
    theme,
    false,
    { objects: true, textLabels: true, hexCoordinates: false }
  );
  
  // Copy to target context
  ctx.drawImage(tempCanvas, 0, 0);
}

// ===========================================
// Image Export
// ===========================================

/**
 * Export map as PNG image
 */
async function exportMapAsImage(
  mapData: MapData,
  geometry: ExportGeometry,
  buffer: number = 20
): Promise<Blob> {
  const activeLayer = getActiveLayer(mapData);
  
  // Calculate content bounds
  const bounds = calculateContentBounds(mapData, activeLayer, geometry);
  
  if (!bounds) {
    throw new Error('No content to export');
  }
  
  // Add buffer
  const exportBounds: BoundingBox = {
    minX: bounds.minX - buffer,
    minY: bounds.minY - buffer,
    maxX: bounds.maxX + buffer,
    maxY: bounds.maxY + buffer
  };
  
  // Calculate canvas dimensions
  const width = Math.ceil(exportBounds.maxX - exportBounds.minX);
  const height = Math.ceil(exportBounds.maxY - exportBounds.minY);
  
  // Create offscreen canvas
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  
  if (!ctx) {
    throw new Error('Failed to create canvas context');
  }
  
  // Render map to canvas
  await renderMapToCanvas(ctx, {
    mapData,
    geometry,
    bounds: exportBounds,
    width,
    height
  });
  
  // Convert to blob
  return new Promise((resolve, reject) => {
    canvas.toBlob((blob) => {
      if (blob) {
        resolve(blob);
      } else {
        reject(new Error('Failed to create image blob'));
      }
    }, 'image/png');
  });
}

/**
 * Save exported image to vault root
 */
async function saveMapImageToVault(
  mapData: MapData,
  geometry: ExportGeometry,
  filename?: string
): Promise<ExportResult> {
  try {
    const blob = await exportMapAsImage(mapData, geometry);
    
    // Convert blob to array buffer
    const arrayBuffer = await blob.arrayBuffer();
    
    // Generate filename with timestamp if not provided
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const mapName = (mapData as MapData & { name?: string }).name || 'map';
    const finalFilename = filename || `${mapName}-${timestamp}.png`;
    
    // Save to vault root
    const path = `${finalFilename}`;
    
    // Check if file exists
    const existingFile = app.vault.getAbstractFileByPath(path);
    if (existingFile) {
      // File exists, modify it
      await app.vault.modifyBinary(existingFile as TFile, arrayBuffer);
    } else {
      // Create new file
      await app.vault.createBinary(path, arrayBuffer);
    }
    
    return { success: true, path };
  } catch (error) {
    console.error('[exportOperations] Export failed:', error);
    return { success: false, error: (error as Error).message };
  }
}

// ===========================================
// Exports
// ===========================================

return {
  calculateContentBounds,
  renderMapToCanvas,
  exportMapAsImage,
  saveMapImageToVault
};
```

# PreferencesTab

```tsx
/**
 * PreferencesTab.tsx
 *
 * Preferences settings tab for MapSettingsModal.
 * Handles state persistence options, canvas height configuration, and map export.
 */

const { useMapSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSettingsContext"));
const { saveMapImageToVault } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "exportOperations"));

/** Export result */
interface ExportResult {
  success: boolean;
  path?: string;
  error?: string;
}

/**
 * Preferences tab content
 */
function PreferencesTab(): React.ReactElement {
  const {
    preferences,
    useGlobalSettings,
    overrides,
    globalSettings,
    handlePreferenceToggle,
    handleColorChange,
    mapData,
    geometry
  } = useMapSettings();

  const [isExporting, setIsExporting] = dc.useState(false);
  const [exportError, setExportError] = dc.useState<string | null>(null);
  const [exportSuccess, setExportSuccess] = dc.useState<string | null>(null);

  const handleExportImage = async (): Promise<void> => {
    if (!mapData || !geometry) {
      setExportError('Map data not available');
      return;
    }

    setIsExporting(true);
    setExportError(null);
    setExportSuccess(null);

    try {
      const result: ExportResult = await saveMapImageToVault(mapData, geometry);

      if (result.success) {
        setExportSuccess(`Map saved to: ${result.path}`);
        setTimeout(() => setExportSuccess(null), 5000);
      } else {
        setExportError(result.error || 'Export failed. Please try again.');
      }
    } catch (error) {
      console.error('[PreferencesTab] Export error:', error);
      setExportError((error as Error).message || 'Export failed. Please try again.');
    } finally {
      setIsExporting(false);
    }
  };

  const alwaysShowControls = overrides.alwaysShowControls ?? globalSettings.alwaysShowControls ?? false;

  return (
    <div class="dmt-settings-tab-content">
      <p style={{ fontSize: '12px', color: 'var(--text-muted)', marginBottom: '16px' }}>
        Control what state is remembered for this map
      </p>

      <div class="dmt-form-group">
        <label class="dmt-checkbox-label">
          <input
            type="checkbox"
            checked={preferences.rememberPanZoom}
            onChange={() => handlePreferenceToggle('rememberPanZoom')}
            class="dmt-checkbox"
          />
          <span>Remember pan and zoom position</span>
        </label>
      </div>

      <div class="dmt-form-group">
        <label class="dmt-checkbox-label">
          <input
            type="checkbox"
            checked={preferences.rememberSidebarState}
            onChange={() => handlePreferenceToggle('rememberSidebarState')}
            class="dmt-checkbox"
          />
          <span>Remember sidebar collapsed state</span>
        </label>
      </div>

      <div class="dmt-form-group">
        <label class="dmt-checkbox-label">
          <input
            type="checkbox"
            checked={preferences.rememberExpandedState}
            onChange={() => handlePreferenceToggle('rememberExpandedState')}
            class="dmt-checkbox"
          />
          <span>Remember expanded state</span>
        </label>
      </div>

      <div class="dmt-form-group">
        <label class="dmt-checkbox-label">
          <input
            type="checkbox"
            checked={alwaysShowControls}
            onChange={(e: Event) => handleColorChange('alwaysShowControls', (e.target as HTMLInputElement).checked)}
            class="dmt-checkbox"
          />
          <span>Always show map controls</span>
        </label>
        <p style={{ fontSize: '11px', color: 'var(--text-muted)', marginTop: '4px', marginLeft: '22px' }}>
          Keep zoom, layers, and settings buttons visible instead of auto-hiding
        </p>
      </div>

      <div style={{ marginTop: '24px', paddingTop: '16px', borderTop: '1px solid var(--background-modifier-border)' }}>
        <h4 style={{ fontSize: '14px', fontWeight: 600, marginBottom: '8px' }}>Export</h4>
        <p style={{ fontSize: '12px', color: 'var(--text-muted)', marginBottom: '12px' }}>
          Export your map as a PNG image
        </p>

        <button
          class="windrose-btn"
          onClick={handleExportImage}
          disabled={isExporting}
          style={{
            padding: '6px 12px',
            cursor: isExporting ? 'wait' : 'pointer',
            opacity: isExporting ? 0.6 : 1
          }}
        >
          {isExporting ? 'Exporting...' : 'Export as Image'}
        </button>

        {exportError && (
          <div style={{
            marginTop: '8px',
            padding: '8px',
            backgroundColor: 'var(--background-modifier-error)',
            color: 'var(--text-error)',
            borderRadius: '4px',
            fontSize: '12px'
          }}>
            {exportError}
          </div>
        )}

        {exportSuccess && (
          <div style={{
            marginTop: '8px',
            padding: '8px',
            backgroundColor: 'var(--background-modifier-success)',
            color: 'var(--text-success)',
            borderRadius: '4px',
            fontSize: '12px'
          }}>
            {exportSuccess}
          </div>
        )}
      </div>
    </div>
  );
}

return { PreferencesTab };

```

# ResizeConfirmDialog

```tsx
/**
 * ResizeConfirmDialog.tsx
 *
 * Confirmation dialog shown when resizing the grid would orphan content.
 * Warns users about cells/objects that will be deleted outside new bounds.
 */

const { ModalPortal } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ModalPortal"));
const { useMapSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSettingsContext"));

/** Orphan content info */
interface OrphanInfo {
  cells: number;
  objects: number;
}

/**
 * Resize confirmation dialog
 */
function ResizeConfirmDialog(): React.ReactElement | null {
  const {
    showResizeConfirm,
    orphanInfo,
    handleResizeConfirmDelete,
    handleResizeConfirmCancel
  } = useMapSettings() as {
    showResizeConfirm: boolean;
    orphanInfo: OrphanInfo;
    handleResizeConfirmDelete: () => void;
    handleResizeConfirmCancel: () => void;
  };

  if (!showResizeConfirm) {
    return null;
  }

  return (
    <ModalPortal>
      <div
        class="dmt-modal-backdrop"
        style={{
          position: 'fixed',
          inset: 0,
          background: 'rgba(0, 0, 0, 0.5)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 10001
        }}
        onClick={(e: Event) => e.stopPropagation()}
      >
        <div
          class="dmt-confirm-dialog"
          style={{
            background: 'var(--background-primary)',
            borderRadius: '8px',
            padding: '20px',
            maxWidth: '400px',
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.3)',
            border: '1px solid var(--background-modifier-border)'
          }}
        >
          {/* Header */}
          <div style={{ display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '16px' }}>
            <span style={{ color: 'var(--text-warning)', display: 'flex' }}>
              <dc.Icon icon="lucide-alert-triangle" />
            </span>
            <h3 style={{ margin: 0, fontSize: '16px', fontWeight: 600, color: 'var(--text-normal)' }}>
              Content Outside New Grid
            </h3>
          </div>

          {/* Message */}
          <p style={{ fontSize: '14px', color: 'var(--text-normal)', marginBottom: '12px', lineHeight: '1.5' }}>
            Resizing the grid will remove content outside the new boundaries:
          </p>

          {/* Content list */}
          <ul style={{
            fontSize: '13px',
            color: 'var(--text-muted)',
            marginBottom: '16px',
            paddingLeft: '20px',
            lineHeight: '1.6'
          }}>
            {orphanInfo.cells > 0 && (
              <li>{orphanInfo.cells} painted cell{orphanInfo.cells !== 1 ? 's' : ''}</li>
            )}
            {orphanInfo.objects > 0 && (
              <li>{orphanInfo.objects} object{orphanInfo.objects !== 1 ? 's' : ''}/pin{orphanInfo.objects !== 1 ? 's' : ''}</li>
            )}
          </ul>

          {/* Warning */}
          <p style={{ fontSize: '13px', color: 'var(--text-muted)', marginBottom: '20px', lineHeight: '1.5' }}>
            This content will be permanently deleted when you save. To recover it, cancel and expand the grid bounds instead.
          </p>

          {/* Actions */}
          <div style={{ display: 'flex', gap: '8px', justifyContent: 'flex-end', flexWrap: 'wrap' }}>
            <button
              class="dmt-modal-btn"
              onClick={handleResizeConfirmCancel}
              style={{
                padding: '8px 16px',
                borderRadius: '4px',
                border: '1px solid var(--background-modifier-border)',
                background: 'var(--background-secondary)',
                color: 'var(--text-normal)',
                cursor: 'pointer',
                fontSize: '13px'
              }}
            >
              Cancel
            </button>
            <button
              class="dmt-modal-btn"
              onClick={handleResizeConfirmDelete}
              style={{
                padding: '8px 16px',
                borderRadius: '4px',
                border: 'none',
                background: 'var(--text-error)',
                color: 'white',
                cursor: 'pointer',
                fontSize: '13px',
                fontWeight: 500
              }}
            >
              Delete & Resize
            </button>
          </div>
        </div>
      </div>
    </ModalPortal>
  );
}

return { ResizeConfirmDialog };

```

# MapSettingsModal

```tsx
/**
 * MapSettingsModal.tsx
 *
 * Modal for configuring per-map settings and UI preferences.
 * Organized into tabs:
 * 1. Appearance - Color customization
 * 2. Hex Grid (hex maps only) - Bounds, coordinate display, and background image
 * 3. Measurement - Distance settings
 * 4. Preferences - UI state persistence options
 *
 * Features:
 * - Draggable by header
 * - Resizable (size persists across sessions)
 */

import type { MapType } from '#types/core/map.types';

const { ModalPortal } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ModalPortal"));
const { MapSettingsProvider, useMapSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSettingsContext"));
const { AppearanceTab } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "AppearanceTab"));
const { HexGridTab } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "HexGridTab"));
const { MeasurementTab } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MeasurementTab"));
const { PreferencesTab } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "PreferencesTab"));
const { ResizeConfirmDialog } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ResizeConfirmDialog"));

/** Tab configuration */
interface SettingsTab {
  id: string;
  label: string;
}

/** Modal size */
interface ModalSize {
  width: number;
  height: number;
}

/** Modal position */
interface ModalPosition {
  x: number | null;
  y: number | null;
}

/** Drag offset */
interface DragOffset {
  x: number;
  y: number;
}

/** Resize start reference */
interface ResizeStart {
  x: number;
  y: number;
  width: number;
  height: number;
  posX: number;
  posY: number;
}

/** Resize edge direction */
type ResizeEdge = 'e' | 'w' | 's' | 'se' | 'sw' | null;

/** Props for MapSettingsModal */
export interface MapSettingsModalProps {
  isOpen: boolean;
  mapData: unknown;
  mapType: MapType;
  globalSettings: Record<string, unknown>;
  onSave: (updates: Record<string, unknown>) => void;
  onCancel: () => void;
}

const MODAL_SIZE_KEY = 'windrose-settings-modal-size';
const DEFAULT_WIDTH = 480;
const DEFAULT_HEIGHT = 500;
const MIN_WIDTH = 380;
const MIN_HEIGHT = 350;
const MAX_WIDTH = 800;
const MAX_HEIGHT = 800;

/**
 * Load persisted modal size from localStorage
 */
function loadPersistedSize(): ModalSize {
  try {
    const stored = localStorage.getItem(MODAL_SIZE_KEY);
    if (stored) {
      const parsed = JSON.parse(stored);
      return {
        width: Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, parsed.width || DEFAULT_WIDTH)),
        height: Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, parsed.height || DEFAULT_HEIGHT))
      };
    }
  } catch {
    // Ignore parse errors
  }
  return { width: DEFAULT_WIDTH, height: DEFAULT_HEIGHT };
}

/**
 * Save modal size to localStorage
 */
function savePersistedSize(width: number, height: number): void {
  try {
    localStorage.setItem(MODAL_SIZE_KEY, JSON.stringify({ width, height }));
  } catch {
    // Ignore storage errors
  }
}

/**
 * Inner modal content that uses the settings context
 */
function MapSettingsModalContent(): React.ReactElement | null {
  const {
    isOpen,
    activeTab,
    setActiveTab,
    tabs,
    mapType,
    isLoading,
    handleSave,
    handleCancel,
    mouseDownTargetRef
  } = useMapSettings();

  const [position, setPosition] = dc.useState<ModalPosition>({ x: null, y: null });
  const [size, setSize] = dc.useState<ModalSize>(loadPersistedSize);

  const [isDragging, setIsDragging] = dc.useState(false);
  const [dragOffset, setDragOffset] = dc.useState<DragOffset>({ x: 0, y: 0 });

  const [isResizing, setIsResizing] = dc.useState(false);
  const [resizeEdge, setResizeEdge] = dc.useState<ResizeEdge>(null);
  const resizeStartRef = dc.useRef<ResizeStart>({ x: 0, y: 0, width: 0, height: 0, posX: 0, posY: 0 });

  const modalRef = dc.useRef<HTMLDivElement | null>(null);

  dc.useEffect(() => {
    if (isOpen) {
      setPosition({ x: null, y: null });
    }
  }, [isOpen]);

  const handleDragStart = dc.useCallback((e: MouseEvent): void => {
    if (!(e.target as HTMLElement).closest('.dmt-modal-header')) return;

    e.preventDefault();

    const modalRect = modalRef.current?.getBoundingClientRect();
    if (!modalRect) return;

    const actualX = position.x ?? (window.innerWidth - modalRect.width) / 2;
    const actualY = position.y ?? (window.innerHeight - modalRect.height) / 2;

    setDragOffset({
      x: e.clientX - actualX,
      y: e.clientY - actualY
    });
    setIsDragging(true);
  }, [position]);

  dc.useEffect(() => {
    if (!isDragging) return;

    const handleMouseMove = (e: MouseEvent): void => {
      const newX = e.clientX - dragOffset.x;
      const newY = e.clientY - dragOffset.y;

      const maxX = window.innerWidth - size.width;
      const maxY = window.innerHeight - size.height;

      setPosition({
        x: Math.max(0, Math.min(maxX, newX)),
        y: Math.max(0, Math.min(maxY, newY))
      });
    };

    const handleMouseUp = (): void => {
      setIsDragging(false);
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDragging, dragOffset, size]);

  const handleResizeStart = dc.useCallback((e: MouseEvent, edge: ResizeEdge): void => {
    e.preventDefault();
    e.stopPropagation();

    const modalRect = modalRef.current?.getBoundingClientRect();
    if (!modalRect) return;

    const actualX = position.x ?? (window.innerWidth - modalRect.width) / 2;
    const actualY = position.y ?? (window.innerHeight - modalRect.height) / 2;

    resizeStartRef.current = {
      x: e.clientX,
      y: e.clientY,
      width: size.width,
      height: size.height,
      posX: actualX,
      posY: actualY
    };

    setResizeEdge(edge);
    setIsResizing(true);
  }, [position, size]);

  dc.useEffect(() => {
    if (!isResizing || !resizeEdge) return;

    const handleMouseMove = (e: MouseEvent): void => {
      const start = resizeStartRef.current;
      const deltaX = e.clientX - start.x;
      const deltaY = e.clientY - start.y;

      let newWidth = start.width;
      let newHeight = start.height;
      let newX = start.posX;
      let newY = start.posY;

      if (resizeEdge.includes('e')) {
        newWidth = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, start.width + deltaX));
      }
      if (resizeEdge.includes('w')) {
        const widthDelta = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, start.width - deltaX)) - start.width;
        newWidth = start.width + widthDelta;
        newX = start.posX - widthDelta;
      }
      if (resizeEdge.includes('s')) {
        newHeight = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, start.height + deltaY));
      }

      newX = Math.max(0, Math.min(window.innerWidth - newWidth, newX));
      newY = Math.max(0, Math.min(window.innerHeight - newHeight, newY));

      setSize({ width: newWidth, height: newHeight });
      setPosition({ x: newX, y: newY });
    };

    const handleMouseUp = (): void => {
      setIsResizing(false);
      setResizeEdge(null);
      savePersistedSize(size.width, size.height);
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isResizing, resizeEdge, size]);

  if (!isOpen) return null;

  const actualLeft = position.x ?? `calc(50% - ${size.width / 2}px)`;
  const actualTop = position.y ?? `calc(50% - ${size.height / 2}px)`;

  const getCursor = (): string => {
    if (isDragging) return 'grabbing';
    if (isResizing) {
      if (resizeEdge === 'e' || resizeEdge === 'w') return 'ew-resize';
      if (resizeEdge === 's') return 'ns-resize';
      return 'nwse-resize';
    }
    return 'default';
  };

  return (
    <ModalPortal>
      <div
        class="dmt-modal-overlay"
        onMouseDown={(e: MouseEvent) => { mouseDownTargetRef.current = e.target; }}
        onClick={(e: MouseEvent) => {
          if (mouseDownTargetRef.current === e.target) {
            handleCancel();
          }
          mouseDownTargetRef.current = null;
        }}
        style={{ cursor: getCursor() }}
      >
        <div
          ref={modalRef}
          class="dmt-modal-content dmt-settings-modal"
          onClick={(e: MouseEvent) => e.stopPropagation()}
          style={{
            position: 'fixed',
            left: typeof actualLeft === 'number' ? `${actualLeft}px` : actualLeft,
            top: typeof actualTop === 'number' ? `${actualTop}px` : actualTop,
            width: `${size.width}px`,
            height: `${size.height}px`,
            maxWidth: '95vw',
            maxHeight: '95vh',
            transform: 'none',
            display: 'flex',
            flexDirection: 'column'
          }}
        >
          <div
            class="dmt-modal-header"
            onMouseDown={handleDragStart}
            style={{
              cursor: isDragging ? 'grabbing' : 'grab',
              userSelect: 'none',
              flexShrink: 0
            }}
          >
            <h3>Map Settings</h3>
          </div>

          <div class="dmt-settings-tab-bar" style={{ flexShrink: 0 }}>
            {tabs.map((tab: SettingsTab) => (
              <button
                key={tab.id}
                class={`dmt-settings-tab ${activeTab === tab.id ? 'dmt-settings-tab-active' : ''}`}
                onClick={() => setActiveTab(tab.id)}
              >
                {tab.label}
              </button>
            ))}
          </div>

          <div class="dmt-modal-body" style={{
            paddingTop: '16px',
            flex: 1,
            overflowY: 'auto',
            minHeight: 0
          }}>
            {activeTab === 'appearance' && <AppearanceTab />}
            {activeTab === 'hexgrid' && mapType === 'hex' && <HexGridTab />}
            {activeTab === 'measurement' && <MeasurementTab />}
            {activeTab === 'preferences' && <PreferencesTab />}
          </div>

          <div class="dmt-modal-footer" style={{ flexShrink: 0 }}>
            <button
              class="dmt-modal-btn dmt-modal-btn-cancel"
              onClick={handleCancel}
              disabled={isLoading}
            >
              Cancel
            </button>

            <button
              class="dmt-modal-btn dmt-modal-btn-submit"
              onClick={handleSave}
              disabled={isLoading}
            >
              {isLoading ? 'Saving...' : 'Save'}
            </button>
          </div>

          <div
            style={{
              position: 'absolute',
              right: 0,
              top: '40px',
              bottom: '8px',
              width: '6px',
              cursor: 'ew-resize'
            }}
            onMouseDown={(e: MouseEvent) => handleResizeStart(e, 'e')}
          />
          <div
            style={{
              position: 'absolute',
              left: 0,
              top: '40px',
              bottom: '8px',
              width: '6px',
              cursor: 'ew-resize'
            }}
            onMouseDown={(e: MouseEvent) => handleResizeStart(e, 'w')}
          />
          <div
            style={{
              position: 'absolute',
              left: '8px',
              right: '8px',
              bottom: 0,
              height: '6px',
              cursor: 'ns-resize'
            }}
            onMouseDown={(e: MouseEvent) => handleResizeStart(e, 's')}
          />
          <div
            style={{
              position: 'absolute',
              right: 0,
              bottom: 0,
              width: '12px',
              height: '12px',
              cursor: 'nwse-resize'
            }}
            onMouseDown={(e: MouseEvent) => handleResizeStart(e, 'se')}
          />
          <div
            style={{
              position: 'absolute',
              left: 0,
              bottom: 0,
              width: '12px',
              height: '12px',
              cursor: 'nesw-resize'
            }}
            onMouseDown={(e: MouseEvent) => handleResizeStart(e, 'sw')}
          />
        </div>
      </div>

      <ResizeConfirmDialog />
    </ModalPortal>
  );
}

/**
 * Main MapSettingsModal component
 */
function MapSettingsModal(props: MapSettingsModalProps): React.ReactElement {
  return (
    <MapSettingsProvider {...props}>
      <MapSettingsModalContent />
    </MapSettingsProvider>
  );
}

return { MapSettingsModal };

```

# ImageAlignmentMode

```jsx
const { ModalPortal } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ModalPortal"));

/**
 * Image Alignment Mode - Interactive image positioning control panel
 * 
 * Renders a draggable floating panel that allows users to adjust background image
 * offset in real-time without closing the settings modal.
 * 
 * Features:
 * - Drag image directly on canvas
 * - Arrow keys for 1px nudges
 * - Shift+Arrow for 10px jumps
 * - Live offset display
 * - Apply/Reset/Cancel actions
 */
function ImageAlignmentMode({ dc, isActive, offsetX, offsetY, onOffsetChange, onApply, onCancel }) {
  const [panelPosition, setPanelPosition] = dc.useState({ x: null, y: null });
  const [isDragging, setIsDragging] = dc.useState(false);
  const [dragStart, setDragStart] = dc.useState({ x: 0, y: 0 });
  const [initialOffset, setInitialOffset] = dc.useState({ x: offsetX, y: offsetY });
  
  // Initialize panel position and store initial offset
  dc.useEffect(() => {
    if (isActive && panelPosition.x === null) {
      // Position in bottom-right, accounting for panel size
      const panelWidth = 280;
      const panelHeight = 200;
      const padding = 80;
      
      setPanelPosition({
        x: window.innerWidth - panelWidth - padding,
        y: window.innerHeight - panelHeight - padding
      });
      
      // Store initial offset for reset/cancel
      setInitialOffset({ x: offsetX, y: offsetY });
    }
  }, [isActive]);
  
  // Use refs to avoid stale closures in event handlers
  const isDraggingRef = dc.useRef(false);
  const dragStartOffsetRef = dc.useRef({ x: 0, y: 0 });
  const dragStartClientRef = dc.useRef({ x: 0, y: 0 });
  
  // Canvas drag event handlers - use useCallback to stabilize
  const handleCanvasPointerDown = dc.useCallback((e) => {
    // Only handle events on the canvas
    const canvas = document.querySelector('.dmt-canvas');
    if (!canvas || !e.target.closest('.dmt-canvas')) {
      return;
    }    // Only handle single-finger/mouse events (let two-finger pan through)
    if (e.touches && e.touches.length > 1) {      return;
    }
    
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;    isDraggingRef.current = true;
    dragStartOffsetRef.current = { x: offsetX, y: offsetY };
    dragStartClientRef.current = { x: clientX, y: clientY };
    
    e.preventDefault();
    e.stopPropagation();
  }, [offsetX, offsetY]);
  
  const handleCanvasPointerMove = dc.useCallback((e) => {
    if (!isDraggingRef.current) return;
    
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    const dx = clientX - dragStartClientRef.current.x;
    const dy = clientY - dragStartClientRef.current.y;
    
    const newOffsetX = Math.round(dragStartOffsetRef.current.x + dx);
    const newOffsetY = Math.round(dragStartOffsetRef.current.y + dy);    onOffsetChange(newOffsetX, newOffsetY);
  }, [onOffsetChange]);
  
  const handleCanvasPointerUp = dc.useCallback(() => {
    if (isDraggingRef.current) {      isDraggingRef.current = false;
    }
  }, []);
  
  // Attach event listeners - only when isActive changes
  dc.useEffect(() => {    if (!isActive) {      return;
    }
    
    const allCanvases = document.querySelectorAll('.dmt-canvas');    allCanvases.forEach((c, i) => {    });
    
    const canvas = document.querySelector('.dmt-canvas');
    if (!canvas) return;
    
    // Check if this is the SAME canvas useEventCoordinator is using    
    // Check if canvas has pointer-events blocked
    const computedStyle = window.getComputedStyle(canvas);    
    // Check what element is actually at the canvas center
    const rect = canvas.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;    
    const elementAtCenter = document.elementFromPoint(centerX, centerY);    
    // Check if anything is overlaying
    const allElementsAtPoint = [];
    let checkElement = elementAtCenter;
    while (checkElement) {
      allElementsAtPoint.push(`${checkElement.tagName}.${checkElement.className}`);
      checkElement = checkElement.parentElement;
    }    
    // Check canvas visibility    
    // Check for scroll containers
    let scrollParent = canvas.parentElement;
    while (scrollParent) {
      const scrollStyle = window.getComputedStyle(scrollParent);
      const hasScroll = scrollParent.scrollHeight > scrollParent.clientHeight || 
                       scrollParent.scrollWidth > scrollParent.clientWidth;
      if (hasScroll || scrollStyle.overflow !== 'visible') {      }
      if (scrollParent === document.body) break;
      scrollParent = scrollParent.parentElement;
    }
    
    // Test if ANY events reach this canvas
    const testHandler = (e) => {    };
    canvas.addEventListener('click', testHandler);
    canvas.addEventListener('mousedown', testHandler);
    canvas.addEventListener('mouseup', testHandler);
    canvas.addEventListener('pointerdown', testHandler);    
    // Attach to document instead of canvas to avoid CodeMirror interception
    document.addEventListener('pointerdown', handleCanvasPointerDown);
    document.addEventListener('pointermove', handleCanvasPointerMove);
    document.addEventListener('pointerup', handleCanvasPointerUp);
    document.addEventListener('pointercancel', handleCanvasPointerUp);
    
    // Also handle touch events for better mobile support
    document.addEventListener('touchstart', handleCanvasPointerDown);
    document.addEventListener('touchmove', handleCanvasPointerMove);
    document.addEventListener('touchend', handleCanvasPointerUp);
    document.addEventListener('touchcancel', handleCanvasPointerUp);
    
    return () => {      document.removeEventListener('pointerdown', handleCanvasPointerDown);
      document.removeEventListener('pointermove', handleCanvasPointerMove);
      document.removeEventListener('pointerup', handleCanvasPointerUp);
      document.removeEventListener('pointercancel', handleCanvasPointerUp);
      document.removeEventListener('touchstart', handleCanvasPointerDown);
      document.removeEventListener('touchmove', handleCanvasPointerMove);
      document.removeEventListener('touchend', handleCanvasPointerUp);
      document.removeEventListener('touchcancel', handleCanvasPointerUp);
    };
  }, [isActive, handleCanvasPointerDown, handleCanvasPointerMove, handleCanvasPointerUp]);
  
  // Keyboard shortcuts
  dc.useEffect(() => {
    if (!isActive) return;
    
    const handleKeyDown = (e) => {
      // Ignore if typing in input field
      if (e.target.tagName === 'INPUT') return;
      
      const step = e.shiftKey ? 10 : 1;
      let handled = false;
      
      switch (e.key) {
        case 'ArrowLeft':
          onOffsetChange(offsetX - step, offsetY);
          handled = true;
          break;
        case 'ArrowRight':
          onOffsetChange(offsetX + step, offsetY);
          handled = true;
          break;
        case 'ArrowUp':
          onOffsetChange(offsetX, offsetY - step);
          handled = true;
          break;
        case 'ArrowDown':
          onOffsetChange(offsetX, offsetY + step);
          handled = true;
          break;
        case 'Enter':
          handleApply();
          handled = true;
          break;
        case 'Escape':
          handleCancel();
          handled = true;
          break;
      }
      
      if (handled) {
        e.preventDefault();
        e.stopPropagation();
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isActive, offsetX, offsetY, onOffsetChange]);
  
  // Panel dragging
  const handlePanelMouseDown = dc.useCallback((e) => {
    // Only drag from header
    if (!e.target.closest('.alignment-panel-header')) return;
    
    setIsDragging(true);
    setDragStart({
      x: e.clientX - panelPosition.x,
      y: e.clientY - panelPosition.y
    });
    e.preventDefault();
  }, [panelPosition]);
  
  dc.useEffect(() => {
    if (!isDragging) return;
    
    const handleMouseMove = (e) => {
      setPanelPosition({
        x: e.clientX - dragStart.x,
        y: e.clientY - dragStart.y
      });
    };
    
    const handleMouseUp = () => {
      setIsDragging(false);
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDragging, dragStart]);
  
  const handleApply = dc.useCallback(() => {
    onApply(offsetX, offsetY);
  }, [offsetX, offsetY, onApply]);
  
  const handleReset = dc.useCallback(() => {
    onOffsetChange(0, 0);
  }, [onOffsetChange]);
  
  const handleCancel = dc.useCallback(() => {
    // Revert to initial offset
    onCancel(initialOffset.x, initialOffset.y);
  }, [initialOffset, onCancel]);
  
  const handleOffsetXChange = dc.useCallback((e) => {
    const value = parseInt(e.target.value, 10) || 0;
    onOffsetChange(value, offsetY);
  }, [offsetY, onOffsetChange]);
  
  const handleOffsetYChange = dc.useCallback((e) => {
    const value = parseInt(e.target.value, 10) || 0;
    onOffsetChange(offsetX, value);
  }, [offsetX, onOffsetChange]);
  
  if (!isActive || panelPosition.x === null) return null;
  
  return (
    <ModalPortal>
      <div
        class="alignment-mode-panel"
        style={{
          position: 'fixed',
          left: `${panelPosition.x}px`,
          top: `${panelPosition.y}px`,
          width: '280px',
          background: 'var(--background-primary)',
          border: '1px solid var(--background-modifier-border)',
          borderRadius: '8px',
          boxShadow: '0 4px 16px rgba(0, 0, 0, 0.3)',
          zIndex: 10000,
          cursor: isDragging ? 'grabbing' : 'default',
          userSelect: 'none'
        }}
        onMouseDown={handlePanelMouseDown}
      >
        {/* Header - Draggable */}
        <div
          class="alignment-panel-header"
          style={{
            padding: '12px 16px',
            background: 'var(--background-modifier-hover)',
            borderBottom: '1px solid var(--background-modifier-border)',
            borderRadius: '8px 8px 0 0',
            cursor: 'grab',
            display: 'flex',
            alignItems: 'center',
            gap: '8px'
          }}
        >
          <span style={{ fontSize: '16px' }}></span>
          <span style={{ fontSize: '14px', fontWeight: '500', color: 'var(--text-normal)' }}>
            Image Alignment
          </span>
        </div>
        
        {/* Content */}
        <div style={{ padding: '16px' }}>
          {/* Offset Display */}
          <div style={{ marginBottom: '16px' }}>
            <div style={{ display: 'flex', gap: '12px', marginBottom: '8px' }}>
              <div style={{ flex: 1 }}>
                <label style={{ display: 'block', fontSize: '12px', color: 'var(--text-muted)', marginBottom: '4px' }}>
                  Offset X
                </label>
                <input
                  type="number"
                  value={offsetX}
                  onChange={handleOffsetXChange}
                  style={{
                    width: '100%',
                    padding: '6px 8px',
                    fontSize: '13px',
                    background: 'var(--background-primary)',
                    border: '1px solid var(--background-modifier-border)',
                    borderRadius: '4px',
                    color: 'var(--text-normal)'
                  }}
                />
              </div>
              <div style={{ flex: 1 }}>
                <label style={{ display: 'block', fontSize: '12px', color: 'var(--text-muted)', marginBottom: '4px' }}>
                  Offset Y
                </label>
                <input
                  type="number"
                  value={offsetY}
                  onChange={handleOffsetYChange}
                  style={{
                    width: '100%',
                    padding: '6px 8px',
                    fontSize: '13px',
                    background: 'var(--background-primary)',
                    border: '1px solid var(--background-modifier-border)',
                    borderRadius: '4px',
                    color: 'var(--text-normal)'
                  }}
                />
              </div>
            </div>
          </div>
          
          {/* Instructions */}
          <div
            style={{
              padding: '12px',
              background: 'var(--background-secondary)',
              borderRadius: '4px',
              marginBottom: '16px'
            }}
          >
            <div style={{ fontSize: '11px', color: 'var(--text-muted)', lineHeight: '1.5' }}>
              <div style={{ marginBottom: '4px' }}> Drag image to reposition</div>
              <div style={{ marginBottom: '4px' }}> Arrow keys: 1px nudge</div>
              <div> Shift+Arrow: 10px jump</div>
            </div>
          </div>
          
          {/* Action Buttons */}
          <div style={{ display: 'flex', gap: '8px' }}>
            <button
              onClick={handleApply}
              style={{
                flex: 1,
                padding: '8px 12px',
                fontSize: '13px',
                fontWeight: '500',
                background: 'var(--interactive-accent)',
                color: 'var(--text-on-accent)',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer'
              }}
              onMouseEnter={(e) => e.target.style.background = 'var(--interactive-accent-hover)'}
              onMouseLeave={(e) => e.target.style.background = 'var(--interactive-accent)'}
            >
              Apply
            </button>
            <button
              onClick={handleReset}
              style={{
                padding: '8px 12px',
                fontSize: '13px',
                background: 'var(--background-modifier-hover)',
                color: 'var(--text-normal)',
                border: '1px solid var(--background-modifier-border)',
                borderRadius: '4px',
                cursor: 'pointer'
              }}
            >
              Reset
            </button>
            <button
              onClick={handleCancel}
              style={{
                padding: '8px 12px',
                fontSize: '13px',
                background: 'var(--background-modifier-hover)',
                color: 'var(--text-normal)',
                border: '1px solid var(--background-modifier-border)',
                borderRadius: '4px',
                cursor: 'pointer'
              }}
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
    </ModalPortal>
  );
}

return { ImageAlignmentMode };
```

# LayerControls

```tsx
/**
 * LayerControls.tsx
 *
 * Floating panel for z-layer management.
 * Provides controls for switching, adding, deleting, and reordering layers.
 */

import type { JSX } from 'preact';
import type { MapData, MapLayer } from '#types/core/map.types';

const { getLayersOrdered } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor"));

/** Drag state for layer reordering */
interface DragState {
  layerId: string;
  index: number;
}

/** Props for LayerControls component */
export interface LayerControlsProps {
  /** Full map data object */
  mapData: MapData | null;
  /** Callback when layer is selected */
  onLayerSelect: (layerId: string) => void;
  /** Callback to add a new layer */
  onLayerAdd: () => void;
  /** Callback to delete a layer */
  onLayerDelete: (layerId: string) => void;
  /** Callback to reorder a layer */
  onLayerReorder: (layerId: string, newIndex: number) => void;
  /** Callback to toggle show layer below */
  onToggleShowLayerBelow: (layerId: string) => void;
  /** Callback to set layer below opacity */
  onSetLayerBelowOpacity: (layerId: string, opacity: number) => void;
  /** Callback to open layer edit modal */
  onEditLayer: (layerId: string) => void;
  /** Whether object sidebar is collapsed */
  sidebarCollapsed: boolean;
  /** Whether the layer controls panel is open */
  isOpen?: boolean;
}

const { getIconInfo } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "rpgAwesomeIcons"));

const LAYER_NAME_MAX_LENGTH = 25;
const LAYER_NAME_TRUNCATE_AT = 22;

const LayerControls = ({
  mapData,
  onLayerSelect,
  onLayerAdd,
  onLayerDelete,
  onLayerReorder,
  onToggleShowLayerBelow,
  onSetLayerBelowOpacity,
  onEditLayer,
  sidebarCollapsed,
  isOpen = true
}: LayerControlsProps): React.ReactElement => {
  const [expandedLayerId, setExpandedLayerId] = dc.useState<string | null>(null);
  const [dragState, setDragState] = dc.useState<DragState | null>(null);
  const [dragOverIndex, setDragOverIndex] = dc.useState<number | null>(null);
  const [sliderHoveredLayerId, setSliderHoveredLayerId] = dc.useState<string | null>(null);

  const longPressTimerRef = dc.useRef<ReturnType<typeof setTimeout> | null>(null);
  const longPressTriggeredRef = dc.useRef(false);
  const sliderHideTimeoutRef = dc.useRef<ReturnType<typeof setTimeout> | null>(null);

  const layers = getLayersOrdered(mapData) as MapLayer[];
  const reversedLayers = [...layers].reverse();
  const activeLayerId = mapData?.activeLayerId;

  const handleOverlayClick = (e: JSX.TargetedMouseEvent<HTMLDivElement> | JSX.TargetedTouchEvent<HTMLDivElement>): void => {
    e.stopPropagation();
    e.preventDefault();
    setExpandedLayerId(null);
  };

  dc.useEffect(() => {
    if (!expandedLayerId) return;

    const handleEscape = (e: KeyboardEvent): void => {
      if (e.key === 'Escape') {
        setExpandedLayerId(null);
      }
    };

    document.addEventListener('keydown', handleEscape);
    return () => document.removeEventListener('keydown', handleEscape);
  }, [expandedLayerId]);

  const handleLayerClick = (layerId: string, e: JSX.TargetedMouseEvent<HTMLButtonElement>): void => {
    e.stopPropagation();

    if (longPressTriggeredRef.current) {
      longPressTriggeredRef.current = false;
      return;
    }

    if (expandedLayerId === layerId) {
      setExpandedLayerId(null);
      return;
    }

    setExpandedLayerId(null);

    if (layerId !== activeLayerId) {
      onLayerSelect(layerId);
    }
  };

  const handleContextMenu = (layerId: string, e: JSX.TargetedMouseEvent<HTMLButtonElement>): void => {
    e.preventDefault();
    e.stopPropagation();
    setExpandedLayerId(expandedLayerId === layerId ? null : layerId);
  };

  const handleTouchStart = (layerId: string): void => {
    longPressTriggeredRef.current = false;

    longPressTimerRef.current = setTimeout(() => {
      longPressTriggeredRef.current = true;
      setExpandedLayerId(expandedLayerId === layerId ? null : layerId);
    }, 500);
  };

  const handleTouchEnd = (): void => {
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
      longPressTimerRef.current = null;
    }
  };

  const handleDelete = (layerId: string, e: JSX.TargetedMouseEvent<HTMLButtonElement>): void => {
    e.stopPropagation();

    if (layers.length <= 1) {
      return;
    }

    setExpandedLayerId(null);
    onLayerDelete(layerId);
  };

  const handleDragStart = (layerId: string, index: number, e: JSX.TargetedDragEvent<HTMLDivElement>): void => {
    setDragState({ layerId, index });
    if (e.dataTransfer) {
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', layerId);
    }
  };

  const handleDragOver = (index: number, e: JSX.TargetedDragEvent<HTMLDivElement>): void => {
    e.preventDefault();
    if (e.dataTransfer) {
      e.dataTransfer.dropEffect = 'move';
    }
    setDragOverIndex(index);
  };

  const handleDragLeave = (): void => {
    setDragOverIndex(null);
  };

  const handleDrop = (targetIndex: number, e: JSX.TargetedDragEvent<HTMLDivElement>): void => {
    e.preventDefault();

    if (dragState && dragState.index !== targetIndex) {
      const visualLength = reversedLayers.length;
      const toOrderIndex = visualLength - 1 - targetIndex;
      onLayerReorder(dragState.layerId, toOrderIndex);
    }

    setDragState(null);
    setDragOverIndex(null);
  };

  const handleDragEnd = (): void => {
    setDragState(null);
    setDragOverIndex(null);
  };

  const getLayerNumber = (layer: MapLayer): string => {
    return String(layer.order + 1);
  };

  const isDefaultName = (layer: MapLayer): boolean => {
    const num = getLayerNumber(layer);
    return !layer.name || layer.name === num;
  };

  const getLayerDisplayName = (layer: MapLayer): string => {
    if (isDefaultName(layer)) {
      return getLayerNumber(layer);
    }
    return layer.name.length > LAYER_NAME_MAX_LENGTH
      ? layer.name.slice(0, LAYER_NAME_TRUNCATE_AT) + '...'
      : layer.name;
  };

  const shouldShowPill = (layer: MapLayer): boolean => {
    return !isDefaultName(layer) || !!layer.icon;
  };

  const getLayerIcon = (layer: MapLayer): { char: string; isRpgAwesome: boolean } | null => {
    if (!layer.icon) return null;
    if (layer.icon.startsWith('ra-')) {
      const info = getIconInfo(layer.icon);
      return info ? { char: info.char, isRpgAwesome: true } : null;
    }
    return { char: layer.icon, isRpgAwesome: false };
  };

  const layerDisplayInfo = dc.useMemo(() => {
    return new Map(layers.map(layer => [
      layer.id,
      {
        isPill: shouldShowPill(layer),
        icon: getLayerIcon(layer),
        displayName: getLayerDisplayName(layer)
      }
    ]));
  }, [layers]);

  const handleEdit = (layerId: string, e: JSX.TargetedMouseEvent<HTMLButtonElement>): void => {
    e.stopPropagation();
    setExpandedLayerId(null);
    onEditLayer(layerId);
  };

  const handleTransparencyToggle = (layerId: string, e: JSX.TargetedMouseEvent<HTMLButtonElement>): void => {
    e.stopPropagation();
    onToggleShowLayerBelow(layerId);
  };

  const handleOpacityChange = (layerId: string, e: JSX.TargetedEvent<HTMLInputElement>): void => {
    const value = parseFloat((e.target as HTMLInputElement).value);
    onSetLayerBelowOpacity(layerId, value);
  };

  const handleSliderAreaEnter = (layerId: string): void => {
    if (sliderHideTimeoutRef.current) {
      clearTimeout(sliderHideTimeoutRef.current);
      sliderHideTimeoutRef.current = null;
    }
    setSliderHoveredLayerId(layerId);
  };

  const handleSliderAreaLeave = (): void => {
    sliderHideTimeoutRef.current = setTimeout(() => {
      setSliderHoveredLayerId(null);
    }, 150);
  };

  return (
    <>
      {expandedLayerId && (
        <div
          className="dmt-layer-overlay"
          onClick={handleOverlayClick}
          onContextMenu={handleOverlayClick}
          onMouseDown={handleOverlayClick}
          onTouchStart={handleOverlayClick}
        />
      )}

      <div
        className={`dmt-layer-controls ${sidebarCollapsed ? 'sidebar-closed' : 'sidebar-open'} ${isOpen ? 'dmt-layer-controls-open' : ''}`}
      >
        {reversedLayers.map((layer, visualIndex) => {
          const isActive = layer.id === activeLayerId;
          const isExpanded = layer.id === expandedLayerId;
          const isDragging = dragState?.layerId === layer.id;
          const isDragOver = dragOverIndex === visualIndex && dragState?.layerId !== layer.id;
          const canDelete = layers.length > 1;

          return (
            <div
              key={layer.id}
              className="dmt-layer-btn-wrapper"
              draggable
              onDragStart={(e) => handleDragStart(layer.id, visualIndex, e)}
              onDragOver={(e) => handleDragOver(visualIndex, e)}
              onDragLeave={handleDragLeave}
              onDrop={(e) => handleDrop(visualIndex, e)}
              onDragEnd={handleDragEnd}
            >
              {(() => {
                const info = layerDisplayInfo.get(layer.id)!;
                return (
                  <button
                    className={`dmt-layer-btn ${info.isPill ? 'dmt-layer-btn-pill' : ''} ${isActive ? 'dmt-layer-btn-active' : ''} ${isDragging ? 'dragging' : ''} ${isDragOver ? 'drag-over' : ''}`}
                    onClick={(e) => handleLayerClick(layer.id, e)}
                    onContextMenu={(e) => handleContextMenu(layer.id, e)}
                    onTouchStart={() => handleTouchStart(layer.id)}
                    onTouchEnd={handleTouchEnd}
                    onTouchCancel={handleTouchEnd}
                    title={`${layer.name}${isActive ? ' (active)' : ''} - Right-click for options`}
                  >
                    {info.icon && (
                      <span className={`dmt-layer-icon ${info.icon.isRpgAwesome ? 'ra' : ''}`}>
                        {info.icon.char}
                      </span>
                    )}
                    <span className="dmt-layer-name">{info.displayName}</span>
                  </button>
                );
              })()}

              <div className={`dmt-layer-options ${isExpanded ? 'expanded' : ''}`}>
                <button
                  className="dmt-layer-option-btn edit"
                  onClick={(e) => handleEdit(layer.id, e)}
                  title="Edit layer"
                >
                  <dc.Icon icon="lucide-pencil" />
                </button>
                {canDelete && (
                  <button
                    className="dmt-layer-option-btn delete"
                    onClick={(e) => handleDelete(layer.id, e)}
                    title="Delete layer"
                  >
                    <dc.Icon icon="lucide-trash-2" />
                  </button>
                )}
                <div
                  className="dmt-layer-transparency-wrapper"
                  onMouseEnter={() => handleSliderAreaEnter(layer.id)}
                  onMouseLeave={handleSliderAreaLeave}
                >
                  <button
                    className={`dmt-layer-option-btn transparency ${layer.showLayerBelow ? 'active' : ''}`}
                    onClick={(e) => handleTransparencyToggle(layer.id, e)}
                    title={layer.showLayerBelow ? 'Hide layer below' : 'Show layer below'}
                  >
                    <dc.Icon icon="lucide-layers" />
                  </button>
                  {sliderHoveredLayerId === layer.id && layer.showLayerBelow && (
                    <div
                      className="dmt-opacity-slider-popup"
                      onMouseEnter={() => handleSliderAreaEnter(layer.id)}
                      onMouseLeave={handleSliderAreaLeave}
                    >
                      <input
                        type="range"
                        min="0.1"
                        max="0.5"
                        step="0.05"
                        value={layer.layerBelowOpacity ?? 0.25}
                        onChange={(e) => handleOpacityChange(layer.id, e)}
                        className="dmt-opacity-slider"
                      />
                      <span className="dmt-opacity-value">
                        {Math.round((layer.layerBelowOpacity ?? 0.25) * 100)}%
                      </span>
                    </div>
                  )}
                </div>
              </div>
            </div>
          );
        })}

        <button
          className="dmt-layer-add-btn"
          onClick={onLayerAdd}
          title="Add new layer"
        >
          <dc.Icon icon="lucide-plus" />
        </button>
      </div>
    </>
  );
};

return { LayerControls };

```

# LayerEditModal

```tsx
/**
 * LayerEditModal.tsx
 */

import type { JSX } from 'preact';
import type { MapLayer } from '#types/core/map.types';
import type { IconWithClass, IconMap, IconCategory } from '#types/objects/icon.types';

const {
  RA_CATEGORIES,
  RA_ICONS,
  getIconInfo,
  getIconsByCategory,
  searchIcons
} = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "rpgAwesomeIcons")) as {
  RA_CATEGORIES: IconCategory[];
  RA_ICONS: IconMap;
  getIconInfo: (iconClass: string) => { char: string; label: string; category: string } | null;
  getIconsByCategory: (categoryId: string) => IconWithClass[];
  searchIcons: (query: string) => IconWithClass[];
};

const LAYER_NAME_MAX_LENGTH = 25;
const LAYER_NAME_TRUNCATE_AT = 22;
const ICON_GRID_MAX_VISIBLE = 100;

const QUICK_SYMBOLS = [
  '1', '2', '3', '4', '5', '6', '7', '8', '9',
  '', '', '', '', '', '', '', '',
  '', '', '', '', '', '', '', '',
  '', '', '', '', '', '', '', ''
];

type IconMode = 'none' | 'symbol' | 'rpgawesome';

/** Props for LayerEditModal */
export interface LayerEditModalProps {
  /** The layer being edited */
  layer: MapLayer;
  /** Default name to show when name matches layer order */
  defaultName: string;
  /** Callback when save is clicked */
  onSave: (name: string, icon: string | null) => void;
  /** Callback when modal is cancelled */
  onCancel: () => void;
}

const LayerEditModal = ({
  layer,
  defaultName,
  onSave,
  onCancel
}: LayerEditModalProps): React.ReactElement => {
  const isDefaultLayerName = !layer.name || layer.name === defaultName;
  const initialName = isDefaultLayerName ? '' : layer.name;
  const initialIcon = layer.icon || null;
  const initialMode: IconMode = initialIcon
    ? (initialIcon.startsWith('ra-') ? 'rpgawesome' : 'symbol')
    : 'none';

  const [name, setName] = dc.useState(initialName);
  const [iconMode, setIconMode] = dc.useState<IconMode>(initialMode);
  const [symbol, setSymbol] = dc.useState(
    initialIcon && !initialIcon.startsWith('ra-') ? initialIcon : ''
  );
  const [iconClass, setIconClass] = dc.useState(
    initialIcon && initialIcon.startsWith('ra-') ? initialIcon : ''
  );
  const [searchQuery, setSearchQuery] = dc.useState('');
  const [iconCategory, setIconCategory] = dc.useState('all');

  const nameInputRef = dc.useRef<HTMLInputElement>(null);

  dc.useEffect(() => {
    if (nameInputRef.current) {
      nameInputRef.current.focus();
      nameInputRef.current.select();
    }
  }, []);

  const handleKeyDown = (e: JSX.TargetedKeyboardEvent<HTMLInputElement>): void => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleSave();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      onCancel();
    }
  };

  const handleSave = (): void => {
    // Read from input ref directly to avoid stale state when Enter is pressed quickly
    const currentName = nameInputRef.current?.value ?? name;
    const finalName = currentName.trim() || defaultName;
    let finalIcon: string | null = null;

    if (iconMode === 'symbol' && symbol) {
      finalIcon = symbol;
    } else if (iconMode === 'rpgawesome' && iconClass) {
      finalIcon = iconClass;
    }

    onSave(finalName, finalIcon);
  };

  const handleModalClick = (e: JSX.TargetedMouseEvent<HTMLDivElement>): void => {
    e.stopPropagation();
  };

  const getDisplayName = (): string => {
    return name.trim() || defaultName;
  };

  const getDisplayIcon = (): string | null => {
    if (iconMode === 'symbol' && symbol) return symbol;
    if (iconMode === 'rpgawesome' && iconClass) {
      const info = getIconInfo(iconClass);
      return info?.char || null;
    }
    return null;
  };

  const filteredIcons = dc.useMemo((): IconWithClass[] => {
    if (searchQuery.trim()) {
      return searchIcons(searchQuery);
    }
    if (iconCategory === 'all') {
      return Object.entries(RA_ICONS).map(([cls, data]) => ({
        iconClass: cls,
        ...data
      }));
    }
    return getIconsByCategory(iconCategory);
  }, [searchQuery, iconCategory]);

  return (
    <div className="dmt-modal-overlay" onMouseDown={onCancel}>
      <div
        className="dmt-modal-content dmt-layer-edit-modal"
        onMouseDown={handleModalClick}
      >
        <h3 className="dmt-modal-title">Edit Layer</h3>

        {/* Name input */}
        <div className="dmt-layer-edit-section">
          <label className="dmt-layer-edit-label">Name</label>
          <input
            ref={nameInputRef}
            type="text"
            className="dmt-modal-input"
            value={name}
            onChange={(e) => setName((e.target as HTMLInputElement).value)}
            onKeyDown={handleKeyDown}
            placeholder={defaultName}
          />
        </div>

        {/* Icon mode toggle */}
        <div className="dmt-layer-edit-section">
          <label className="dmt-layer-edit-label">Icon (optional)</label>
          <div className="dmt-icon-mode-toggle">
            <button
              type="button"
              className={`dmt-icon-mode-btn ${iconMode === 'none' ? 'active' : ''}`}
              onClick={() => setIconMode('none')}
            >
              None
            </button>
            <button
              type="button"
              className={`dmt-icon-mode-btn ${iconMode === 'symbol' ? 'active' : ''}`}
              onClick={() => setIconMode('symbol')}
            >
              Symbol
            </button>
            <button
              type="button"
              className={`dmt-icon-mode-btn ${iconMode === 'rpgawesome' ? 'active' : ''}`}
              onClick={() => setIconMode('rpgawesome')}
            >
              RPGAwesome
            </button>
          </div>
        </div>

        {/* Symbol picker */}
        {iconMode === 'symbol' && (
          <div className="dmt-layer-edit-section">
            <div className="dmt-symbol-input-row">
              <input
                type="text"
                className="dmt-symbol-input"
                value={symbol}
                onChange={(e) => setSymbol((e.target as HTMLInputElement).value)}
                placeholder="Type or select..."
                maxLength={8}
              />
              <div className="dmt-symbol-preview">
                {symbol || '?'}
              </div>
            </div>
            <div className="dmt-quick-symbols-grid">
              {QUICK_SYMBOLS.map((sym) => (
                <button
                  key={sym}
                  type="button"
                  className={`dmt-quick-symbol-btn ${symbol === sym ? 'selected' : ''}`}
                  onClick={() => setSymbol(sym)}
                >
                  {sym}
                </button>
              ))}
            </div>
          </div>
        )}

        {/* RPGAwesome picker */}
        {iconMode === 'rpgawesome' && (
          <div className="dmt-layer-edit-section dmt-icon-picker">
            <input
              type="text"
              className="dmt-icon-search"
              value={searchQuery}
              onChange={(e) => setSearchQuery((e.target as HTMLInputElement).value)}
              placeholder="Search icons..."
            />
            <div className="dmt-icon-category-tabs">
              <button
                type="button"
                className={`dmt-icon-category-tab ${iconCategory === 'all' ? 'active' : ''}`}
                onClick={() => setIconCategory('all')}
              >
                All
              </button>
              {RA_CATEGORIES.map((cat: { id: string; label: string }) => (
                <button
                  key={cat.id}
                  type="button"
                  className={`dmt-icon-category-tab ${iconCategory === cat.id ? 'active' : ''}`}
                  onClick={() => setIconCategory(cat.id)}
                >
                  {cat.label}
                </button>
              ))}
            </div>
            <div className="dmt-icon-grid">
              {filteredIcons.slice(0, ICON_GRID_MAX_VISIBLE).map((icon) => (
                <button
                  key={icon.iconClass}
                  type="button"
                  className={`dmt-icon-grid-btn ${iconClass === icon.iconClass ? 'selected' : ''}`}
                  onClick={() => setIconClass(icon.iconClass)}
                  title={icon.label}
                >
                  <span className="ra">{icon.char}</span>
                </button>
              ))}
              {filteredIcons.length > ICON_GRID_MAX_VISIBLE && (
                <div className="dmt-icon-grid-more">
                  +{filteredIcons.length - ICON_GRID_MAX_VISIBLE} more...
                </div>
              )}
              {filteredIcons.length === 0 && (
                <div className="dmt-icon-grid-empty">No icons found</div>
              )}
            </div>
          </div>
        )}

        {/* Preview */}
        <div className="dmt-layer-edit-section">
          <label className="dmt-layer-edit-label">Preview</label>
          <div className="dmt-layer-preview">
            <div className={`dmt-layer-preview-btn ${getDisplayIcon() || getDisplayName().length > 2 ? 'pill' : ''}`}>
              {getDisplayIcon() && (
                <span className={iconMode === 'rpgawesome' ? 'ra dmt-layer-preview-icon' : 'dmt-layer-preview-icon'}>
                  {getDisplayIcon()}
                </span>
              )}
              <span className="dmt-layer-preview-name">
                {getDisplayName().length > LAYER_NAME_MAX_LENGTH
                  ? getDisplayName().slice(0, LAYER_NAME_TRUNCATE_AT) + '...'
                  : getDisplayName()}
              </span>
            </div>
          </div>
        </div>

        {/* Buttons */}
        <div className="dmt-modal-buttons">
          <button
            type="button"
            className="dmt-modal-btn dmt-modal-btn-cancel"
            onClick={onCancel}
          >
            Cancel
          </button>
          <button
            type="button"
            className="dmt-modal-btn dmt-modal-btn-submit"
            onClick={handleSave}
          >
            Save
          </button>
        </div>

        <div className="dmt-modal-hint">
          Press Enter to save, Esc to cancel
        </div>
      </div>
    </div>
  );
};

return { LayerEditModal };

```

# rpgAwesomeLoader

```ts
/**
 * rpgAwesomeLoader.ts - Font loading utility for RPGAwesome icon font
 * Handles loading the font for both canvas rendering and CSS display
 */

import type { IconMap } from '#types/objects/icon.types';

/** Font loading state */
let fontLoaded = false;
let fontLoadPromise: Promise<boolean> | null = null;

/**
 * CSS for the @font-face declaration
 */
const RPGAWESOME_FONT_CSS = `
@font-face {
  font-family: 'rpgawesome';
  src: url('{{FONT_PATH}}') format('woff');
  font-weight: normal;
  font-style: normal;
}

/* Base class for RPGAwesome icons */
.ra {
  font-family: 'rpgawesome' !important;
  font-style: normal;
  font-variant: normal;
  font-weight: normal;
  line-height: 1;
  speak: never;
  text-transform: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
`;

/**
 * Load the RPGAwesome font
 * @returns True if font loaded successfully
 */
async function loadRPGAwesomeFont(fontPath: string): Promise<boolean> {
  if (fontLoadPromise) {
    return fontLoadPromise;
  }

  fontLoadPromise = new Promise<boolean>(async (resolve) => {
    try {
      if (document.fonts.check('1em rpgawesome')) {
        fontLoaded = true;
        resolve(true);
        return;
      }

      if (typeof FontFace !== 'undefined') {
        try {
          const font = new FontFace('rpgawesome', `url(${fontPath})`);
          await font.load();
          document.fonts.add(font);
          fontLoaded = true;
          resolve(true);
          return;
        } catch (fontFaceError) {
          console.warn('[RPGAwesome] FontFace API failed, falling back to CSS injection:', fontFaceError);
        }
      }

      const styleId = 'rpgawesome-font-style';
      if (!document.getElementById(styleId)) {
        const style = document.createElement('style');
        style.id = styleId;
        style.textContent = RPGAWESOME_FONT_CSS.replace('{{FONT_PATH}}', fontPath);
        document.head.appendChild(style);
      }

      await document.fonts.load('1em rpgawesome');

      if (document.fonts.check('1em rpgawesome')) {
        fontLoaded = true;
        resolve(true);
      } else {
        console.warn('[RPGAwesome] Font may not have loaded correctly');
        resolve(false);
      }
    } catch (error) {
      console.error('[RPGAwesome] Failed to load font:', error);
      fontLoaded = false;
      resolve(false);
    }
  });

  return fontLoadPromise;
}

/**
 * Check if font is currently loaded
 */
function isRPGAwesomeFontLoaded(): boolean {
  return fontLoaded || document.fonts.check('1em rpgawesome');
}

/**
 * Reset font loading state (for testing/debugging)
 */
function resetFontLoadState(): void {
  fontLoaded = false;
  fontLoadPromise = null;
}

/**
 * Inject RPGAwesome CSS classes into document
 */
function injectIconCSS(iconMap: IconMap): void {
  const styleId = 'rpgawesome-icon-classes';
  if (document.getElementById(styleId)) {
    return;
  }

  let css = '';
  for (const [iconClass, data] of Object.entries(iconMap)) {
    const codePoint = data.char.charCodeAt(0).toString(16);
    css += '.ra.' + iconClass + ':before { content: "\\' + codePoint + '"; }\n';
  }

  const style = document.createElement('style');
  style.id = styleId;
  style.textContent = css;
  document.head.appendChild(style);
}

return {
  loadRPGAwesomeFont,
  isRPGAwesomeFontLoaded,
  resetFontLoadState,
  injectIconCSS,
  RPGAWESOME_FONT_CSS
};

```

# DungeonMapTracker

```tsx
// DungeonMapTracker.tsx - Main component with undo/redo, objects, text labels, and color support

import type {
  MapData,
  MapType,
  ViewState,
  IGeometry,
  ToolId,
  ObjectTypeId,
  Cell,
  MapObject,
  TextLabel,
  Edge,
  TextLabelSettings,
  FogToolId,
  LayerVisibility,
  BackgroundImage,
  UIPreferences,
  MapSettings,
  ObjectLink,
} from '#types/index';
import type { ResolvedTheme } from '#types/settings/settings.types';

// ============================================================================
// IMPORTS
// ============================================================================

const css = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "WindroseMD-CSS"))

const combinedCss = [
  css,
].join('\n');


const { useMapData } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useMapData"));
const { useLayerHistory } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useLayerHistory"));
const { useToolState } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useToolState"));
const { useFogOfWar } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useFogOfWar"));
const { useDataHandlers } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "useDataHandlers"));
const { GridGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "GridGeometry"));
const { HexGeometry } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "HexGeometry"));
const { MapHeader } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapHeader"));
const { MapCanvas } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapCanvas"));
const { MapControls } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapControls"));
const { ToolPalette } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ToolPalette"));
const { ObjectSidebar } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ObjectSidebar"));
const { VisibilityToolbar } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "VisibilityToolbar"));
const { SettingsPluginInstaller, shouldOfferUpgrade } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "SettingsPluginInstaller"));
const { MapSettingsModal } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "MapSettingsModal"));
const { getSetting, getTheme, getEffectiveSettings } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "settingsAccessor"));
const { DEFAULTS } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "dmtConstants"));
const { getColorByHex, isDefaultColor } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "colorOperations"));
const { axialToOffset, isWithinOffsetBounds } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "offsetCoordinates"));
const { ImageAlignmentMode } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ImageAlignmentMode"));
const { ModalPortal } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "ModalPortal"));

const { getActiveLayer, getLayerById } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "layerAccessor"));
const { LayerControls } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "LayerControls"));
const { LayerEditModal } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "LayerEditModal"));

// RPGAwesome icon font support
const { RA_ICONS } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "rpgAwesomeIcons"));
const { injectIconCSS } = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "rpgAwesomeLoader"));



// Inject RPGAwesome icon CSS classes on module load
injectIconCSS(RA_ICONS);

// ============================================================================
// LOCAL TYPE DEFINITIONS
// ============================================================================

interface DungeonMapTrackerProps {
  mapId?: string;
  mapName?: string;
  mapType?: MapType;
}

interface LayerVisibilityState {
  objects: boolean;
  textLabels: boolean;
  hexCoordinates: boolean;
}

type CornerPosition = 'tl' | 'tr' | 'bl' | 'br';

interface CornerBracketProps {
  position: CornerPosition;
}

interface HexBounds {
  maxCol: number;
  maxRow: number;
}

// ============================================================================
// MAIN COMPONENT
// ============================================================================

// Corner Bracket SVG Component
const CornerBracket = ({ position }: CornerBracketProps): React.ReactElement => {
  return (
    <svg
      className={`dmt-corner-bracket dmt-corner-bracket-${position}`}
      viewBox="0 0 50 50"
    >
      <defs>
        <filter id={`bracket-glow-${position}`}>
          <feGaussianBlur stdDeviation="2" result="coloredBlur" />
          <feMerge>
            <feMergeNode in="coloredBlur" />
            <feMergeNode in="SourceGraphic" />
          </feMerge>
        </filter>
      </defs>
      {/* Main L-bracket with ornamental details */}
      <path
        d="M 0 18 L 0 0 L 18 0"
        stroke="#c4a57b"
        strokeWidth="3"
        fill="none"
        filter={`url(#bracket-glow-${position})`}
      />
      {/* Inner detail line */}
      <path
        d="M 3 15 L 3 3 L 15 3"
        stroke="rgba(255, 255, 255, 0.4)"
        strokeWidth="1"
        fill="none"
      />
      {/* Small notches for detail */}
      <line
        x1="0" y1="9" x2="5" y2="9"
        stroke="#c4a57b"
        strokeWidth="2"
      />
      <line
        x1="9" y1="0" x2="9" y2="5"
        stroke="#c4a57b"
        strokeWidth="2"
      />
      {/* Corner ornament */}
      <circle
        cx="18" cy="18" r="3"
        fill="none"
        stroke="#c4a57b"
        strokeWidth="1.5"
        filter={`url(#bracket-glow-${position})`}
      />
    </svg>
  );
};

const DungeonMapTracker = ({ mapId = 'default-map', mapName = '', mapType = 'grid' }: DungeonMapTrackerProps): React.ReactElement => {
  const { mapData, isLoading, saveStatus, updateMapData, forceSave, fowImageReady } = useMapData(mapId, mapName, mapType);

  // Get current file path for deep linking
  const currentFile = dc.useCurrentFile();
  const notePath = currentFile?.$path || '';

  // Tool and color state (extracted to useToolState hook)
  const {
    currentTool, setCurrentTool,
    selectedObjectType, setSelectedObjectType,
    selectedColor, setSelectedColor,
    selectedOpacity, setSelectedOpacity,
    isColorPickerOpen, setIsColorPickerOpen
  } = useToolState();

  const [showFooter, setShowFooter] = dc.useState(false);
  const [isFocused, setIsFocused] = dc.useState(false);
  const [isExpanded, setIsExpanded] = dc.useState(false);
  const [isAnimating, setIsAnimating] = dc.useState(false);
  const [pluginInstalled, setPluginInstalled] = dc.useState<boolean | null>(null); // null = checking, true/false = result
  const [showPluginInstaller, setShowPluginInstaller] = dc.useState(false);
  const [settingsVersion, setSettingsVersion] = dc.useState(0); // Incremented to force re-render on settings change
  const [showSettingsModal, setShowSettingsModal] = dc.useState(false);
  const [showVisibilityToolbar, setShowVisibilityToolbar] = dc.useState(false);
  const [showLayerPanel, setShowLayerPanel] = dc.useState(false);
  const [editingLayerId, setEditingLayerId] = dc.useState<string | null>(null);
const editingLayer = dc.useMemo(() => {
    return editingLayerId ? getLayerById(mapData, editingLayerId) : null;
  }, [editingLayerId, mapData]);

  // Image alignment mode state
  const [isAlignmentMode, setIsAlignmentMode] = dc.useState(false);
  const [alignmentOffsetX, setAlignmentOffsetX] = dc.useState(0);
  const [alignmentOffsetY, setAlignmentOffsetY] = dc.useState(0);
  const [returningFromAlignment, setReturningFromAlignment] = dc.useState(false);

  // Layer visibility state (session-only, resets on reload)
  const [layerVisibility, setLayerVisibility] = dc.useState<LayerVisibilityState>({
    objects: true,
    textLabels: true,
    hexCoordinates: false
  });

  // Toggle a specific layer's visibility
  const handleToggleLayerVisibility = dc.useCallback((layerId: keyof LayerVisibilityState) => {
    setLayerVisibility((prev: LayerVisibilityState) => ({
      ...prev,
      [layerId]: !prev[layerId]
    }));
  }, []);

  // Create geometry instance for coordinate conversions
  // Same logic as MapCanvas for consistency
  const geometry = dc.useMemo((): IGeometry | null => {
    if (!mapData) return null;

    const currentMapType = mapData.mapType || DEFAULTS.mapType;

    if (currentMapType === 'hex') {
      const hexSize = mapData.hexSize || DEFAULTS.hexSize;
      const orientation = mapData.orientation || DEFAULTS.hexOrientation;
      const hexBounds = mapData.hexBounds || null;
      return new HexGeometry(hexSize, orientation, hexBounds);
    } else {
      const gridSize = mapData.gridSize || DEFAULTS.gridSize;
      return new GridGeometry(gridSize);
    }
  }, [mapData?.mapType, mapData?.gridSize, mapData?.hexSize, mapData?.orientation, mapData?.hexBounds]);

  // Fog of War state and handlers (extracted to useFogOfWar hook)
  const {
    showFogTools,
    fogActiveTool,
    currentFogState,
    handleFogToolsToggle,
    handleFogToolSelect,
    handleFogVisibilityToggle,
    handleFogFillAll,
    handleFogClearAll,
    handleFogChange
  } = useFogOfWar({ mapData, geometry, updateMapData });

  // Get current theme with effective settings (global + map overrides)
  // This will be called on every render, fetching fresh settings each time
  const effectiveSettings = mapData ? getEffectiveSettings(mapData.settings) : null;
  const theme: ResolvedTheme = effectiveSettings ? {
    grid: {
      lines: effectiveSettings.gridLineColor,
      lineWidth: effectiveSettings.gridLineWidth,
      background: effectiveSettings.backgroundColor
    },
    cells: {
      fill: getTheme().cells.fill,
      border: effectiveSettings.borderColor,
      borderWidth: getTheme().cells.borderWidth
    },
    compass: getTheme().compass,
    decorativeBorder: getTheme().decorativeBorder,
    coordinateKey: effectiveSettings.coordinateKeyColor
  } : getTheme();

  // Determine canvas height based on device type and settings
  // Detect touch devices using media query match
  const isTouchDevice = dc.useMemo(() => {
    return window.matchMedia('(hover: none) and (pointer: coarse)').matches;
  }, []);

  const canvasHeight = effectiveSettings
    ? (isTouchDevice
        ? (effectiveSettings.canvasHeightMobile ?? 400)
        : (effectiveSettings.canvasHeight ?? 600))
    : (isTouchDevice ? 400 : 600);

  // Check if settings plugin is installed
  dc.useEffect(() => {
    async function checkPlugin(): Promise<void> {
      try {
        const pluginDir = '.obsidian/plugins/dungeon-map-tracker-settings';
        const exists = await dc.app.vault.adapter.exists(pluginDir);
        setPluginInstalled(exists);
      } catch (error) {
        console.error('[DungeonMapTracker] Error checking plugin:', error);
        setPluginInstalled(false);
      }
    }
    checkPlugin();
  }, []);

  // Determine if we should show the plugin installer (install or upgrade mode)
  dc.useEffect(() => {
    if (pluginInstalled === null || !mapData) return; // Still checking or data not loaded

    // Check if we should show installer for new install
    if (!pluginInstalled && !mapData.settingsPluginDeclined) {
      setShowPluginInstaller(true);
      return;
    }

    // Check if we should show installer for upgrade
    if (pluginInstalled && shouldOfferUpgrade()) {
      setShowPluginInstaller(true);
      return;
    }

    // Otherwise, hide installer
    setShowPluginInstaller(false);
  }, [pluginInstalled, mapData]);

  // Initialize expanded state from settings or saved state (only if not showing installer)
  dc.useEffect(() => {
    if (showPluginInstaller || !mapData) return; // Don't apply if showing installer or no data

    // Small delay to ensure plugins are loaded
    const timer = setTimeout(() => {
      try {
        // Check if we should remember expanded state for this map
        if (mapData.uiPreferences?.rememberExpandedState && mapData.expandedState !== undefined) {
          // Use saved expanded state
          if (mapData.expandedState && !isExpanded) {
            setIsExpanded(true);
            setIsAnimating(false);
          }
        } else {
          // Fall back to global expandedByDefault setting
          const expandedByDefault = getSetting('expandedByDefault');
          if (expandedByDefault && !isExpanded) {
            setIsExpanded(true);
            setIsAnimating(false);
          }
        }
      } catch (error) {
        console.warn('[DungeonMapTracker] Error reading expanded state:', error);
        // Continue with default (not expanded)
      }
    }, 100);

    return () => clearTimeout(timer);
  }, [showPluginInstaller, mapData]); // Run when installer status or map data changes

  // Initialize opacity from mapData when loaded
  dc.useEffect(() => {
    if (!mapData) return;

    if (mapData.lastSelectedOpacity !== undefined) {
      setSelectedOpacity(mapData.lastSelectedOpacity);
    }
  }, [mapData?.lastSelectedOpacity]);

  // Handler to update opacity and persist to mapData
  const handleOpacityChange = dc.useCallback((newOpacity: number) => {
    setSelectedOpacity(newOpacity);
    updateMapData((currentMapData: MapData) => ({
      ...currentMapData,
      lastSelectedOpacity: newOpacity
    }));
  }, [updateMapData]);

  // Listen for settings changes and force re-render
  dc.useEffect(() => {
    const handleSettingsChange = (): void => {
      // Increment settingsVersion to force component re-render
      // This causes getTheme() to be called again with fresh settings
      setSettingsVersion((prev: number) => prev + 1);
    };

    window.addEventListener('dmt-settings-changed', handleSettingsChange);

    return () => {
      window.removeEventListener('dmt-settings-changed', handleSettingsChange);
    };
  }, []);

  // Handle plugin installation
  const handlePluginInstall = (): void => {
    setPluginInstalled(true);
    setShowPluginInstaller(false);
  };

  // Handle plugin decline
  const handlePluginDecline = (): void => {
    if (mapData) {
      updateMapData({
        ...mapData,
        settingsPluginDeclined: true
      });
    }
    setShowPluginInstaller(false);
  };

  // Layer and history management (extracted to useLayerHistory hook)
  const {
    // Layer management
    handleLayerSelect,
    handleLayerAdd,
    handleLayerDelete,
    handleLayerReorder,
    handleToggleShowLayerBelow,
    handleSetLayerBelowOpacity,
    handleUpdateLayerDisplay,
    // History state
    canUndo,
    canRedo,
    // History actions
    handleUndo,
    handleRedo,
    // For data change handlers
    addToHistory,
    isApplyingHistory
  } = useLayerHistory({ mapData, updateMapData, isLoading });

  // Listen for deep link navigation events
  dc.useEffect(() => {
    const handleNavigateTo = (event: CustomEvent): void => {
      const { mapId: targetMapId, x, y, zoom, layerId } = event.detail;

      // Only respond if this is our map
      if (targetMapId !== mapId) return;

      // Switch to target layer if it exists and is different
      if (mapData?.layers && layerId) {
        const targetLayer = mapData.layers.find((l: { id: string }) => l.id === layerId);
        if (targetLayer && mapData.activeLayerId !== layerId) {
          handleLayerSelect(layerId);
        }
      }

      // Navigate to a comfortable viewing zoom regardless of what the link stored
      const DEEP_LINK_ZOOM = 1.175;
      updateMapData((currentMapData: MapData) => ({
        ...currentMapData,
        viewState: {
          ...currentMapData.viewState,
          center: { x, y },
          zoom: DEEP_LINK_ZOOM
        }
      }));

      new Notice(`Navigated to location on ${mapData?.name || 'map'}`);
    };

    window.addEventListener('dmt-navigate-to', handleNavigateTo as EventListener);

    return () => {
      window.removeEventListener('dmt-navigate-to', handleNavigateTo as EventListener);
    };
  }, [mapId, mapData, updateMapData, handleLayerSelect]);

  // Listen for cross-layer object link events
  dc.useEffect(() => {
    type LinkUpdate = { layerId: string; objectId: string; link?: ObjectLink };

    const updateObjectLinksAcrossLayers = (updates: LinkUpdate[]): void => {
      updateMapData((currentMapData: MapData) => ({
        ...currentMapData,
        layers: currentMapData.layers.map((layer: { id: string; objects?: MapObject[] }) => {
          const layerUpdates = updates.filter(u => u.layerId === layer.id);
          if (layerUpdates.length === 0 || !layer.objects) return layer;

          return {
            ...layer,
            objects: layer.objects.map((obj: MapObject) => {
              const update = layerUpdates.find(u => u.objectId === obj.id);
              if (!update) return obj;
              if (update.link !== undefined) {
                return { ...obj, linkedObject: update.link };
              }
              const { linkedObject: _removed, ...rest } = obj;
              return rest as MapObject;
            })
          };
        })
      }));
    };

    const handleCreateObjectLink = (event: CustomEvent): void => {
      const { sourceLayerId, sourceObjectId, sourceLink, targetLayerId, targetObjectId, targetLink } = event.detail;
      updateObjectLinksAcrossLayers([
        { layerId: sourceLayerId, objectId: sourceObjectId, link: sourceLink },
        { layerId: targetLayerId, objectId: targetObjectId, link: targetLink }
      ]);
    };

    const handleRemoveObjectLink = (event: CustomEvent): void => {
      const { sourceLayerId, sourceObjectId, targetLayerId, targetObjectId } = event.detail;
      updateObjectLinksAcrossLayers([
        { layerId: sourceLayerId, objectId: sourceObjectId },
        { layerId: targetLayerId, objectId: targetObjectId }
      ]);
    };

    window.addEventListener('dmt-create-object-link', handleCreateObjectLink as EventListener);
    window.addEventListener('dmt-remove-object-link', handleRemoveObjectLink as EventListener);

    return () => {
      window.removeEventListener('dmt-create-object-link', handleCreateObjectLink as EventListener);
      window.removeEventListener('dmt-remove-object-link', handleRemoveObjectLink as EventListener);
    };
  }, [updateMapData]);

  // Data change handlers (extracted to useDataHandlers hook)
  const {
    handleNameChange,
    handleCellsChange,
    handleObjectsChange,
    handleTextLabelsChange,
    handleEdgesChange,
    handleCurvesChange,
    handleAddCustomColor,
    handleDeleteCustomColor,
    handleUpdateColorOpacity,
    handleViewStateChange,
    handleSidebarCollapseChange,
    handleTextLabelSettingsChange
  } = useDataHandlers({ mapData, updateMapData, addToHistory, isApplyingHistory });

  const containerRef = dc.useRef<HTMLDivElement | null>(null);

  // Effect to manage parent element classes
  dc.useEffect(() => {
    if (!containerRef.current) return;

    const container = containerRef.current;

    // Walk up to find cm-embed-block
    let cmEmbedBlock: HTMLElement | null = container.parentElement;
    while (cmEmbedBlock && !cmEmbedBlock.classList.contains('cm-embed-block')) {
      cmEmbedBlock = cmEmbedBlock.parentElement;
      if (cmEmbedBlock?.classList.contains('cm-editor')) {
        cmEmbedBlock = null;
        break;
      }
    }

    // Manage classes on container
    container.classList.toggle('dmt-expanded', isExpanded);
    container.classList.toggle('dmt-animating', isAnimating);

    // Manage classes on parent if found
    if (cmEmbedBlock) {
      cmEmbedBlock.classList.add('dmt-cm-parent');
      cmEmbedBlock.classList.toggle('dmt-cm-expanded', isExpanded);
      cmEmbedBlock.classList.toggle('dmt-cm-animating', isAnimating);
    }

    // Cleanup
    return () => {
      container.classList.remove('dmt-expanded', 'dmt-animating');
      cmEmbedBlock?.classList.remove('dmt-cm-parent', 'dmt-cm-expanded', 'dmt-cm-animating');
    };
  }, [isExpanded, isAnimating]);

  // Zoom in (increase zoom by step)
  const handleZoomIn = (): void => {
    if (!mapData) return;
    const newZoom = Math.min(
      DEFAULTS.maxZoom,
      mapData.viewState.zoom + DEFAULTS.zoomButtonStep
    );
    handleViewStateChange({
      ...mapData.viewState,
      zoom: newZoom
    });
  };

  // Zoom out (decrease zoom by step)
  const handleZoomOut = (): void => {
    if (!mapData) return;
    const newZoom = Math.max(
      DEFAULTS.minZoom,
      mapData.viewState.zoom - DEFAULTS.zoomButtonStep
    );
    handleViewStateChange({
      ...mapData.viewState,
      zoom: newZoom
    });
  };

  // Compass click - cycle through rotations
  const handleCompassClick = (): void => {
    if (!mapData) return;

    // Cycle through: 0 -> 90 -> 180 -> 270 -> 0 degrees
    const rotations = [0, 90, 180, 270];
    const currentIndex = rotations.indexOf(mapData.northDirection);
    const nextIndex = (currentIndex + 1) % rotations.length;
    const newRotation = rotations[nextIndex];

    const newMapData = {
      ...mapData,
      northDirection: newRotation
    };
    updateMapData(newMapData);
  };

  const animationTimeoutRef = dc.useRef<ReturnType<typeof setTimeout> | null>(null);

  const handleToggleExpand = (): void => {

    // Clear any pending animation timeout
    if (animationTimeoutRef.current) {
      clearTimeout(animationTimeoutRef.current);
      animationTimeoutRef.current = null;
    }

    const newExpandedState = !isExpanded;

    if (newExpandedState) {
      setIsExpanded(true);
      setIsAnimating(false);
    } else {
      setIsAnimating(true);
      setIsExpanded(false);

      animationTimeoutRef.current = setTimeout(() => {
        setIsAnimating(false);
        animationTimeoutRef.current = null;
      }, 300);
    }

    // Save expanded state if preference is enabled
    if (mapData && mapData.uiPreferences?.rememberExpandedState) {
      const newMapData = {
        ...mapData,
        expandedState: newExpandedState
      };
      updateMapData(newMapData);
    }
  };

  const handleSettingsClick = (): void => {
    setShowSettingsModal(true);
  };

  const handleSettingsSave = (
    settingsData: MapSettings,
    preferencesData: UIPreferences,
    hexBounds: HexBounds | null = null,
    backgroundImage: BackgroundImage | undefined = undefined,
    hexSize: number | null = null,
    deleteOrphanedContent: boolean = false
  ): void => {
    if (!mapData) return;

    const newMapData: MapData = {
      ...mapData,
      settings: settingsData,
      uiPreferences: preferencesData
    };

    // Only update hexBounds for hex maps
    if (hexBounds !== null && mapData.mapType === 'hex') {
      newMapData.hexBounds = hexBounds;

      // If requested, delete content that would be outside the new bounds
      if (deleteOrphanedContent) {
        const orientation = mapData.orientation || 'flat';

        // Filter cells to keep only those within new bounds
        if (newMapData.cells && newMapData.cells.length > 0) {
          newMapData.cells = newMapData.cells.filter((cell: Cell) => {
            const { col, row } = axialToOffset(cell.q, cell.r, orientation);
            return isWithinOffsetBounds(col, row, hexBounds);
          });
        }

        // Filter objects to keep only those within new bounds
        if (newMapData.objects && newMapData.objects.length > 0) {
          newMapData.objects = newMapData.objects.filter((obj: MapObject) => {
            const { col, row } = axialToOffset(obj.position.x, obj.position.y, orientation);
            return isWithinOffsetBounds(col, row, hexBounds);
          });
        }
      }
    }

    // Only update backgroundImage for hex maps
    if (backgroundImage !== undefined && mapData.mapType === 'hex') {
      newMapData.backgroundImage = backgroundImage;
    }

    // Update hexSize if calculated from background image
    if (hexSize !== null && mapData.mapType === 'hex') {
      newMapData.hexSize = hexSize;
    }

    updateMapData(newMapData);

    // Force re-render to apply new settings
    setSettingsVersion((prev: number) => prev + 1);
  };


  const handleSettingsClose = (): void => {
    setShowSettingsModal(false);
    setReturningFromAlignment(false); // Reset flag when modal closes
  };

  // Image alignment mode handlers
  const handleOpenAlignmentMode = dc.useCallback((currentX: number, currentY: number) => {
    setAlignmentOffsetX(currentX);
    setAlignmentOffsetY(currentY);
    setIsAlignmentMode(true);
    setShowSettingsModal(false); // Hide settings modal
  }, []);

  const handleAlignmentOffsetChange = dc.useCallback((newX: number, newY: number) => {
    setAlignmentOffsetX(newX);
    setAlignmentOffsetY(newY);

    // Update the map data immediately for visual feedback
    if (mapData && mapData.backgroundImage) {
      updateMapData({
        ...mapData,
        backgroundImage: {
          ...mapData.backgroundImage,
          offsetX: newX,
          offsetY: newY
        }
      });
    }
  }, [mapData, updateMapData]);

  const handleAlignmentApply = dc.useCallback((finalX: number, finalY: number) => {
    // Offset values are already in mapData from handleAlignmentOffsetChange
    setIsAlignmentMode(false);
    setReturningFromAlignment(true); // Flag that we're returning from alignment
    setShowSettingsModal(true); // Reopen settings modal
  }, []);

  const handleAlignmentCancel = dc.useCallback((originalX: number, originalY: number) => {
    // Revert to original offset
    setAlignmentOffsetX(originalX);
    setAlignmentOffsetY(originalY);

    if (mapData && mapData.backgroundImage) {
      updateMapData({
        ...mapData,
        backgroundImage: {
          ...mapData.backgroundImage,
          offsetX: originalX,
          offsetY: originalY
        }
      });
    }

    setIsAlignmentMode(false);
    setReturningFromAlignment(true); // Flag that we're returning from alignment
    setShowSettingsModal(true); // Reopen settings modal
  }, [mapData, updateMapData]);

  // Loading state
  if (isLoading) {
    return (
      <div className="dmt-loading">
        Loading map...
      </div>
    );
  }

  // Show plugin installer if needed (before map renders)
  if (showPluginInstaller) {
    return (
      <>
        <style>{combinedCss}</style>
        <div ref={containerRef} className={`dmt-container interactive-child`}>
          <SettingsPluginInstaller
            onInstall={handlePluginInstall}
            onDecline={handlePluginDecline}
          />
        </div>
      </>
    );
  }

  // Get color display name
  const getColorDisplayName = (): string => {
    if (isDefaultColor(selectedColor)) return 'Default';
    const colorDef = getColorByHex(selectedColor);
    return colorDef ? colorDef.label : selectedColor;
  };

  // Main render
  return (
    <>
      <style>{combinedCss}</style>
      <div
        ref={containerRef}
        className={`dmt-container interactive-child`}
      >
        {/* Decorative corner brackets */}
        <CornerBracket position="tl" />
        <CornerBracket position="tr" />
        <CornerBracket position="bl" />
        <CornerBracket position="br" />

        <MapHeader
          mapData={mapData}
          onNameChange={handleNameChange}
          saveStatus={saveStatus}
          onToggleFooter={() => setShowFooter(!showFooter)}
        />

        <ToolPalette
          currentTool={currentTool}
          onToolChange={setCurrentTool}
          onUndo={handleUndo}
          onRedo={handleRedo}
          canUndo={canUndo}
          canRedo={canRedo}
          selectedColor={selectedColor}
          onColorChange={setSelectedColor}
          selectedOpacity={selectedOpacity}
          onOpacityChange={handleOpacityChange}
          isColorPickerOpen={isColorPickerOpen}
          onColorPickerOpenChange={setIsColorPickerOpen}
          customColors={mapData.customColors || []}
          paletteColorOpacityOverrides={mapData.paletteColorOpacityOverrides || {}}
          onAddCustomColor={handleAddCustomColor}
          onDeleteCustomColor={handleDeleteCustomColor}
          onUpdateColorOpacity={handleUpdateColorOpacity}
          mapType={mapData.mapType}
          isFocused={isFocused}
        />

        <VisibilityToolbar
          isOpen={showVisibilityToolbar}
          layerVisibility={layerVisibility}
          onToggleLayer={handleToggleLayerVisibility}
          mapType={mapData.mapType}
          // Fog of War props
          fogOfWarState={currentFogState}
          showFogTools={showFogTools}
          onFogToolsToggle={handleFogToolsToggle}
          onFogToolSelect={handleFogToolSelect}
          onFogVisibilityToggle={handleFogVisibilityToggle}
          onFogFillAll={handleFogFillAll}
          onFogClearAll={handleFogClearAll}
        />

        <div
          className="dmt-canvas-wrapper"
          style={{ height: `${canvasHeight}px` }}
          onMouseEnter={() => setIsFocused(true)}
          onMouseLeave={() => setIsFocused(false)}
        >
          <ObjectSidebar
            selectedObjectType={selectedObjectType}
            onObjectTypeSelect={setSelectedObjectType}
            onToolChange={setCurrentTool}
            isCollapsed={mapData.sidebarCollapsed || false}
            onCollapseChange={handleSidebarCollapseChange}
            mapType={mapData.mapType || 'grid'}
          />

          {/* Layer Controls Panel (Z-Layer System) */}
          <LayerControls
            mapData={mapData}
            onLayerSelect={handleLayerSelect}
            onLayerAdd={handleLayerAdd}
            onLayerDelete={handleLayerDelete}
            onLayerReorder={handleLayerReorder}
            onToggleShowLayerBelow={handleToggleShowLayerBelow}
            onSetLayerBelowOpacity={handleSetLayerBelowOpacity}
            onEditLayer={setEditingLayerId}
            sidebarCollapsed={mapData.sidebarCollapsed || false}
            isOpen={showLayerPanel}
          />

          {/* For hex maps, override northDirection to 0 for rendering while keeping real value for compass display */}
          {/* This allows the compass to show and persist the north direction without actually rotating hex maps */}
          <div className="dmt-canvas-and-controls">
            <MapCanvas
              mapId={mapId}
              notePath={notePath}
              mapData={mapData.mapType === 'hex' ? { ...mapData, northDirection: 0 } : mapData}
              onCellsChange={handleCellsChange}
              onObjectsChange={handleObjectsChange}
              onTextLabelsChange={handleTextLabelsChange}
              onEdgesChange={handleEdgesChange}
              onCurvesChange={handleCurvesChange}
              onViewStateChange={handleViewStateChange}
              onTextLabelSettingsChange={handleTextLabelSettingsChange}
              currentTool={currentTool}
              isAlignmentMode={isAlignmentMode}
              selectedObjectType={selectedObjectType}
              selectedColor={selectedColor}
              isColorPickerOpen={isColorPickerOpen}
              customColors={mapData.customColors || []}
              onAddCustomColor={handleAddCustomColor}
              onDeleteCustomColor={handleDeleteCustomColor}
              isFocused={isFocused}
              isAnimating={isAnimating}
              theme={theme}
              layerVisibility={layerVisibility}
            >
              {/* DrawingLayer - handles all drawing tools */}
              <MapCanvas.DrawingLayer
                currentTool={currentTool}
                selectedColor={selectedColor}
                selectedOpacity={selectedOpacity}
              />

              {/* ObjectLayer - handles object placement and interactions */}
              <MapCanvas.ObjectLayer
                currentTool={currentTool}
                selectedObjectType={selectedObjectType}
                onObjectsChange={handleObjectsChange}
                customColors={mapData.customColors || []}
                onAddCustomColor={handleAddCustomColor}
                onDeleteCustomColor={handleDeleteCustomColor}
              />

              {/* AreaSelectLayer - handles area selection tool for multi-select */}
              <MapCanvas.AreaSelectLayer
                currentTool={currentTool}
              />

              {/* TextLayer - handles text label interactions */}
              <MapCanvas.TextLayer
                currentTool={currentTool}
                customColors={mapData.customColors || []}
                onAddCustomColor={handleAddCustomColor}
                onDeleteCustomColor={handleDeleteCustomColor}
              />

              {/* NotePinLayer - handles note pin placement */}
              <MapCanvas.NotePinLayer
                currentTool={currentTool}
                selectedObjectType={selectedObjectType}
              />

              {/* FogOfWarLayer - handles fog painting/erasing interactions */}
              {fogActiveTool && (
                <MapCanvas.FogOfWarLayer
                  activeTool={fogActiveTool}
                  onFogChange={handleFogChange}
                  onInitializeFog={(updatedMapData: MapData) => updateMapData(updatedMapData)}
                />
              )}

              {/* HexCoordinateLayer - displays coordinate labels when 'C' key is held */}
              <MapCanvas.HexCoordinateLayer />

              {/* MeasurementLayer - distance measurement tool overlay */}
              <MapCanvas.MeasurementLayer
                currentTool={currentTool}
                globalSettings={effectiveSettings}
                mapDistanceOverrides={mapData?.settings?.distanceSettings}
              />

              {/* DiagonalFillOverlay - diagonal fill tool preview */}
              <MapCanvas.DiagonalFillOverlay
                currentTool={currentTool}
              />

              {/* Re-roll button for generated dungeons */}
              <MapCanvas.RerollDungeonButton />
            </MapCanvas>
          </div>

          <MapControls
            onZoomIn={handleZoomIn}
            onZoomOut={handleZoomOut}
            onCompassClick={handleCompassClick}
            onSettingsClick={handleSettingsClick}
            northDirection={mapData.northDirection}
            currentZoom={mapData.viewState.zoom}
            isExpanded={isExpanded}
            onToggleExpand={handleToggleExpand}
            mapType={mapData.mapType}
            showLayerPanel={showLayerPanel}
            onToggleLayerPanel={() => setShowLayerPanel(!showLayerPanel)}
            showVisibilityToolbar={showVisibilityToolbar}
            onToggleVisibilityToolbar={() => setShowVisibilityToolbar(!showVisibilityToolbar)}
            alwaysShowControls={effectiveSettings?.alwaysShowControls ?? false}
          />
        </div>

        {showFooter && (
          <div className="dmt-footer">
            Map ID: {mapId} | Color: {getColorDisplayName()} | {
              currentTool === 'select' ? 'Click to select text/objects | Drag to move | Press R to rotate | Press Delete to remove' :
                currentTool === 'draw' ? 'Click/drag to draw' :
                  currentTool === 'erase' ? 'Click/drag to erase (text first, then objects, then cells)' :
                    currentTool === 'rectangle' ? 'Click two corners to fill rectangle' :
                      currentTool === 'circle' ? 'Click edge point, then center to fill circle' :
                        currentTool === 'clearArea' ? 'Click two corners to clear area' :
                          currentTool === 'addObject' ? (selectedObjectType ? 'Click to place object' : 'Select an object from the sidebar') :
                            currentTool === 'addText' ? 'Click to add text label' :
                              'Select a tool'
            } | Undo/redo available | Middle-click or two-finger drag to pan | Scroll to zoom | Click compass to rotate | {getActiveLayer(mapData).cells.length} cells filled | {(getActiveLayer(mapData).objects || []).length} objects placed | {(getActiveLayer(mapData).textLabels || []).length} text labels
          </div>
        )}

        {/* Map Settings Modal */}
        <MapSettingsModal
          isOpen={showSettingsModal}
          onClose={handleSettingsClose}
          onSave={handleSettingsSave}
          onOpenAlignmentMode={handleOpenAlignmentMode}
          initialTab={returningFromAlignment ? 'hexgrid' : null}
          mapType={mapData?.mapType || 'grid'}
          orientation={mapData?.orientation || 'flat'}
          currentSettings={mapData.settings}
          currentPreferences={mapData.uiPreferences}
          currentHexBounds={mapData.mapType === 'hex' ? mapData.hexBounds : null}
          currentBackgroundImage={mapData.mapType === 'hex' ? mapData.backgroundImage : null}
          currentCells={mapData.mapType === 'hex' ? (getActiveLayer(mapData).cells || []) : []}
          currentObjects={mapData.mapType === 'hex' ? (getActiveLayer(mapData).objects || []) : []}
          mapData={mapData}
          geometry={geometry}
        />

        {/* Image Alignment Mode */}
        {isAlignmentMode && mapData.backgroundImage?.path && (
          <ImageAlignmentMode
            dc={dc}
            isActive={isAlignmentMode}
            offsetX={alignmentOffsetX}
            offsetY={alignmentOffsetY}
            onOffsetChange={handleAlignmentOffsetChange}
            onApply={handleAlignmentApply}
            onCancel={handleAlignmentCancel}
          />
        )}

        
        {editingLayer && (
          <ModalPortal>
            <LayerEditModal
              layer={editingLayer}
              defaultName={String(editingLayer.order + 1)}
              onSave={(name, icon) => {
                handleUpdateLayerDisplay(editingLayerId!, name, icon);
                setEditingLayerId(null);
              }}
              onCancel={() => setEditingLayerId(null)}
            />
          </ModalPortal>
        )}
      </div>
    </>
  );
};

// ============================================================================
// EXPORTS
// ============================================================================

return { View: DungeonMapTracker };
```

---

# CSS Styles

> [!TIP] Using CSS Files
> CSS files are bundled as JavaScript modules that return CSS strings:
> ```javascript
> const myStyles = await dc.require(dc.headerLink(dc.resolvePath("compiled-windrose-md"), "styleName"));
> // Use in JSX: <style>{myStyles}</style>
> ```

## WindroseMD-CSS

```js
const css = `
/* ============================================
   WINDROSE MAPDESIGNER STYLES
   ============================================ */

/* CSS Custom Properties */
:root {
  --dmt-bg-primary: #1a1a1a;
  --dmt-bg-secondary: #2a2a2a;
  --dmt-bg-tertiary: #3a3a3a;
  --dmt-border-primary: #c4a57b;
  --dmt-border-secondary: #3a3a3a;
  --dmt-text-primary: #ffffff;
  --dmt-text-secondary: #cccccc;
  --dmt-text-muted: #888;
  --dmt-text-disabled: #666;
  --dmt-accent-blue: #4a9eff;
  --dmt-accent-red: #8b0000;
  --dmt-warning: #ffaa00;
  --dmt-error: #ff4444;
  --dmt-success: var(--dmt-accent-blue);
  --dmt-transition: all 0.15s ease;
}

/* ============================================
   RPGAWESOME ICON FONT BASE STYLES
   ============================================ */

/* Base class for RPGAwesome icons */
.ra {
  font-family: 'rpgawesome' !important;
  font-style: normal;
  font-variant: normal;
  font-weight: normal;
  line-height: 1;
  text-transform: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* ============================================
   CONTAINER & LAYOUT
   ============================================ */

.dmt-container {
  font-family: var(--font-interface);
  background-color: var(--dmt-bg-primary);
  padding: 12px;
  border-radius: 6px;
  color: var(--dmt-text-primary);
  position: relative;
  border: 2px solid var(--dmt-border-primary);
  box-shadow:
    inset 0 0 0 4px var(--dmt-bg-primary),
    inset 0 0 0 5px rgba(196, 165, 123, 0.3),
    0 0 20px rgba(196, 165, 123, 0.2);
  width: 100%;
  transition: width 0.3s ease, margin-left 0.3s ease;
}

.callout[data-callout="dungeon-map"],
.callout[data-callout="dungeon-map"] .callout-content {
  overflow: visible !important;
}

.dmt-container.dmt-expanded {
  --dmt-offset: 0px;
  width: calc(100cqi - 2 * var(--dmt-offset));
  margin-inline: calc((100% - 100cqi) / 2 + var(--dmt-offset));
}

.markdown-source-view.is-live-preview {
  & .dmt-container.dmt-expanded,
  & .dmt-container.dmt-animating {
    --dmt-offset: 20px;
  }

  .cm-content > .cm-embed-block[contenteditable=false].dmt-cm-expanded,
  .cm-content > .cm-embed-block[contenteditable=false].dmt-cm-animating {
    contain: none !important;
    overflow: normal; 
    animation: none;
  }

  & .cm-embed-block:hover.dmt-cm-parent.dmt-cm-expanded,
  & .cm-embed-block:hover.dmt-cm-parent.dmt-cm-animating {
    overflow: visible;
    animation: none;
  }
}

.dmt-loading {
  padding: 20px;
  text-align: center;
  color: var(--dmt-text-muted);
}

.dmt-canvas-wrapper {
  display: flex;
  flex-direction: row;
  position: relative;
  background-color: var(--dmt-bg-primary);
  border-radius: 4px;
  overflow: hidden;
  width: 100%;
}

.dmt-canvas-and-controls {
  flex: 1;
  position: relative;
  min-width: 0;
  height: 100%;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
}

.dmt-canvas-container {
  position: relative;
  background-color: var(--dmt-bg-primary);
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;

  canvas {
    display: block;
  }
}

/* ============================================
   HEADER
   ============================================ */

.dmt-header {
  margin-bottom: 12px;
  padding: 4px;
  background-color: rgba(255, 255, 255, 0.05);
  border-radius: 4px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.dmt-map-name {
  background: transparent;
  border: none;
  color: var(--dmt-text-primary);
  font-size: 16px;
  font-weight: bold;
  outline: none;
  flex: 1;
  margin-right: 16px;

  &::placeholder {
    color: var(--dmt-text-disabled);
  }
}

.dmt-header-controls {
  display: flex;
  align-items: center;
  gap: 8px;
}

/* Info Toggle Button */
.dmt-info-toggle {
  background: transparent !important;
  border: 1px solid var(--dmt-border-secondary);
  border-radius: 4px;
  color: var(--dmt-text-disabled);
  cursor: pointer;
  padding: 4px 8px;
  transition: var(--dmt-transition);
  display: flex;
  align-items: center;
  justify-content: center;
  height: 28px;
  width: 28px;
  box-shadow: none !important;
  appearance: none !important;
  outline: none;

  svg {
    width: 16px;
    height: 16px;
    color: currentColor;
  }

  &::before,
  &::after {
    display: none !important;
  }

  &:hover {
    border-color: #4a4a4a;
    color: var(--dmt-border-primary);
  }

  &.dmt-info-toggle-active {
    border-color: var(--dmt-border-primary);
    color: var(--dmt-border-primary);

    &:hover {
      border-color: #8b6842;
      color: #8b6842;
    }
  }
}

/* Save Status */
.dmt-save-status {
  font-size: 18px;
  color: var(--dmt-success);
  padding: 0 8px;
  display: flex;
  align-items: center;
  line-height: 1;

  &.dmt-save-status-unsaved {
    color: var(--dmt-warning);
  }

  &.dmt-save-status-saving {
    animation: rotate 1s linear infinite;
  }

  &.dmt-save-status-error {
    color: var(--dmt-error);
  }
}

@keyframes rotate {
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
}

/* Orientation change animation */


/* ============================================
   FOOTER
   ============================================ */

.dmt-footer {
  margin-top: 8px;
  font-size: 11px;
  color: var(--dmt-text-disabled);
  text-align: center;
}

/* ============================================
   DECORATIVE CORNER BRACKETS
   ============================================ */

.dmt-corner-bracket {
  position: absolute;
  width: 50px;
  height: 50px;
  pointer-events: none;
  z-index: 10;

  /* Style all SVG paths and elements to use CSS variable */
  path, line, circle {
    stroke: var(--dmt-border-primary);
  }

  &.dmt-corner-bracket-tl {
    top: -2px;
    left: -2px;
  }

  &.dmt-corner-bracket-tr {
    top: -2px;
    right: -2px;
    transform: scaleX(-1);
  }

  &.dmt-corner-bracket-bl {
    bottom: -2px;
    left: -2px;
    transform: scaleY(-1);
  }

  &.dmt-corner-bracket-br {
    bottom: -2px;
    right: -2px;
    transform: scale(-1);
  }
}

/* Tool Palette Brackets (Outward facing) */
.dmt-tool-palette-bracket {
  position: absolute;
  width: 40px;
  height: 40px;
  pointer-events: none;
  z-index: 10;

  &.dmt-tool-palette-bracket-tl {
    top: -2px;
    left: -2px;
    transform: rotate(0deg);
  }

  &.dmt-tool-palette-bracket-tr {
    top: -2px;
    right: -2px;
    transform: scaleX(-1);
  }

  &.dmt-tool-palette-bracket-bl {
    bottom: -2px;
    left: -2px;
    transform: scaleY(-1);
  }

  &.dmt-tool-palette-bracket-br {
    bottom: -2px;
    right: -2px;
    transform: scale(-1);
  }
}

/* ============================================
   CANVAS CURSOR STATES
   ============================================ */

.dmt-canvas,
.dmt-canvas-drawing,
.dmt-canvas-erasing,
.dmt-canvas-erase,
.dmt-canvas-rectangle,
.dmt-canvas-rectangle-active,
.dmt-canvas-circle,
.dmt-canvas-circle-active,
.dmt-canvas-cleararea,
.dmt-canvas-cleararea-active,
.dmt-canvas-panning,
.dmt-canvas-space-grab,
.dmt-canvas-select,
.dmt-canvas-selecting {
  border: 1px solid var(--dmt-border-secondary);
}

.dmt-canvas,
.dmt-canvas-rectangle,
.dmt-canvas-circle,
.dmt-canvas-cleararea,
.dmt-canvas-add-object,
.dmt-canvas-add-text,
.dmt-canvas-measure,
.dmt-canvas-diagonal-fill {
  cursor: crosshair;
}

.dmt-canvas-drawing,
.dmt-canvas-rectangle-active,
.dmt-canvas-circle-active,
.dmt-canvas-measure-active {
  cursor: cell;
}

.dmt-canvas-erasing,
.dmt-canvas-erase,
.dmt-canvas-cleararea-active {
  cursor: not-allowed;
}

.dmt-canvas-panning {
  cursor: grabbing;
}

.dmt-canvas-space-grab {
  cursor: grab;
}

.dmt-canvas-select {
  cursor: default;
}

.dmt-canvas-selecting {
  cursor: move;
}

/* ============================================
   TOOL PALETTE
   ============================================ */

.dmt-tool-palette {
  display: flex;
  gap: 4px;
  padding: 8px;
  background-color: var(--dmt-bg-primary);
  border: 2px solid var(--dmt-border-primary);
  border-radius: 4px;
  align-items: center;
  margin-bottom: 8px;
  position: relative;
  box-shadow:
    inset 0 0 0 3px var(--dmt-bg-primary),
    inset 0 0 0 4px rgba(196, 165, 123, 0.3),
    0 0 15px rgba(196, 165, 123, 0.15);
}

.dmt-tool-btn {
  position: relative;
  background-color: var(--dmt-bg-secondary);
  border: 1px solid var(--dmt-border-secondary);
  border-radius: 3px;
  color: var(--dmt-text-primary);
  cursor: pointer;
  padding: 6px 8px;
  font-size: 16px;
  transition: var(--dmt-transition);
  min-width: 32px;
  max-width: 42px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;

  &:hover:not(.dmt-tool-btn-active) {
    background-color: var(--dmt-bg-tertiary);
    border-color: #4a4a4a;

    svg {
      color: var(--dmt-text-primary);
    }
  }

  &.dmt-tool-btn-active {
    background-color: var(--dmt-border-primary);
    border-color: #8b6842;
    color: var(--dmt-bg-primary);

    svg {
      color: var(--dmt-accent-red);
      filter:
        drop-shadow(1px 0 0 var(--dmt-border-primary)) drop-shadow(-1px 0 0 var(--dmt-border-primary)) drop-shadow(0 1px 0 var(--dmt-border-primary)) drop-shadow(0 -1px 0 var(--dmt-border-primary));
    }
  }

  svg {
    color: var(--dmt-border-primary);
    width: 20px;
    height: 20px;
  }
}

.dmt-color-tool-btn {
  position: relative;
  /* Bottom border shows current color - defined inline via style attribute */
}

/* Sub-tool indicator triangle */
.dmt-subtool-indicator {
  position: absolute;
  bottom: 1px;
  right: 1px;
  font-size: 7px;
  opacity: 0.6;
  pointer-events: none;
  line-height: 1;
}

/* Buttons with sub-tools should be narrower to fit on iPad */
.dmt-tool-btn-container .dmt-tool-btn {
  min-width: 28px;
  padding: 6px 5px;
}

.dmt-tool-btn-active .dmt-subtool-indicator {
  opacity: 0.9;
  color: var(--dmt-bg-primary);
}

/* Tool button container for sub-menu positioning */
.dmt-tool-btn-container {
  position: relative;
  display: inline-block;
}

/* Sub-menu flyout */
.dmt-subtool-menu {
  position: absolute;
  left: 100%;
  top: 50%;
  transform: translateY(-50%);
  margin-left: 6px;
  background: var(--dmt-bg-secondary);
  border: 1px solid var(--dmt-border-primary);
  border-radius: 6px;
  padding: 4px;
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 2px;
  z-index: 1001;
  box-shadow: 
    0 4px 12px rgba(0, 0, 0, 0.4),
    inset 0 1px 0 rgba(255, 255, 255, 0.05);
  min-width: 120px;
}

.dmt-subtool-option {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 8px;
  padding: 8px 12px;
  border: none;
  background: transparent;
  color: var(--dmt-text-primary);
  cursor: pointer;
  border-radius: 4px;
  white-space: nowrap;
  font-size: 13px;
  transition: var(--dmt-transition);
  width: 100%;
  text-align: left;
  box-sizing: border-box;

  svg {
    width: 16px;
    height: 16px;
    color: var(--dmt-border-primary);
    flex-shrink: 0;
  }

  &:hover {
    background: var(--dmt-bg-tertiary);
  }

  &.dmt-subtool-option-active {
    background: var(--dmt-border-primary);
    color: var(--dmt-bg-primary);

    svg {
      color: var(--dmt-bg-primary);
    }
  }
}

/* History Controls */
.dmt-history-controls {
  display: flex;
  gap: 4px;
  margin-left: 4px;
  padding-left: 8px;
  border-left: 1px solid var(--dmt-border-secondary);
}

.dmt-history-btn {
  background-color: var(--dmt-bg-secondary);
  border: 1px solid var(--dmt-border-secondary);
  border-radius: 3px;
  color: var(--dmt-text-primary);
  cursor: pointer;
  padding: 6px 8px;
  font-size: 16px;
  transition: var(--dmt-transition);
  min-width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;

  svg {
    color: var(--dmt-text-muted);
    width: 18px;
    height: 18px;
  }

  &:hover:not(:disabled) {
    background-color: var(--dmt-bg-tertiary);
    border-color: #4a4a4a;

    svg {
      color: var(--dmt-border-primary);
    }
  }

  &:disabled {
    opacity: 0.3;
    cursor: not-allowed;

    svg {
      color: #444;
    }
  }
}

/* ============================================
   MAP CONTROLS (COMPASS & ZOOM)
   ============================================ */

.dmt-controls {
  position: absolute;
  top: 12px;
  right: 4px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 100;
  min-width: 80px;
  width: 80px;
  align-items: center;
}

.dmt-compass {
  width: 70px;
  height: 70px;
  min-width: 70px;
  min-height: 70px;
  max-width: 70px;
  max-height: 70px;
  background-color: transparent;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border: none;
  user-select: none;
  transition: all 0.2s ease;
  position: relative;
  flex-shrink: 0;

  &:hover {
    transform: scale(1.03);
  }
}

.dmt-compass-disabled {
  filter: grayscale(1);
  opacity: 0.5;
  
  &:hover {
    transform: none;
  }
}

.dmt-compass-svg {
  width: 100%;
  height: 100%;
  overflow: visible;
}

.dmt-zoom-controls {
  display: flex;
  flex-direction: column;
  gap: 6px;
  align-items: center;
}

button.dmt-zoom-btn,
.is-tablet button.dmt-zoom-btn,
button.dmt-expand-btn,
.is-tablet button.dmt-expand-btn,
button.dmt-layer-btn,
.is-tablet button.dmt-layer-btn,
button.dmt-orientation-btn,
.is-tablet button.dmt-orientation-btn {
  width: 35px;
  height: 35px;
  min-width: 35px;
  min-height: 35px;
  max-width: 35px;
  max-height: 35px;
  background-color: rgba(0, 0, 0, 0.7);
  border: 2px solid rgba(196, 165, 123, 0.4);
  color: var(--dmt-text-primary);
  border-radius: 50%;
  cursor: pointer;
  font-size: 18px;
  font-weight: bold;
  line-height: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
  flex: 0 0 auto;
  padding: 0;
  box-sizing: border-box;
  overflow: hidden;
  user-select: none;

  &:hover {
    background-color: rgba(0, 0, 0, 0.85);
    border-color: rgba(196, 165, 123, 0.6);
    transform: scale(1.05);
  }
}

.dmt-zoom-level {
  font-size: 10px;
  font-weight: 600;
  color: rgba(196, 165, 123, 0.8);
  text-align: center;
  padding: 3px 6px;
  user-select: none;
  background-color: rgba(0, 0, 0, 0.5);
  border-radius: 6px;
  width: 38px;
  box-sizing: border-box;
}

/* ============================================
   CONTROLS DRAWER (Collapsible Animation)
   ============================================ */

/* Invisible overlay to capture taps outside controls (touch devices) */
.dmt-controls-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 99; /* Just below controls (100) */
  background: transparent;
  cursor: default;
}

.dmt-controls-drawer {
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: center;
  overflow: hidden;
}

/* Compass slides down to make room for expand button */
.dmt-compass-animated {
  transform: translateY(-43px);  /* Button height (35px) + gap (8px) */
  transition: transform 180ms cubic-bezier(0.25, 0.1, 0.25, 1);  /* Near-linear with subtle ease-out */
}

.dmt-compass-revealed {
  transform: translateY(0);
}

.dmt-drawer-item {
  opacity: 0;
  transform: translateY(-20px) scale(0.8);
  pointer-events: none;
  transition-property: opacity, transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
}

/* Upward slide variant for items above the compass */
.dmt-drawer-item-up {
  transform: translateY(20px) scale(0.8);
}

.dmt-drawer-item-visible {
  opacity: 1;
  transform: translateY(0) scale(1);
  pointer-events: auto;
}

/* ============================================
   OBJECT SIDEBAR
   ============================================ */

.dmt-object-sidebar {
  width: 110px;
  min-width: 110px;
  height: 100%;
  background-color: var(--dmt-bg-primary);
  border-right: 2px solid var(--dmt-border-primary);
  border-top: 1px solid rgba(196, 165, 123, 0.4);
  border-bottom: 1px solid rgba(196, 165, 123, 0.4);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  flex-shrink: 0;
  transition: all 0.3s ease;
  position: relative;
  box-shadow:
    inset -3px 0 0 0 var(--dmt-bg-primary),
    inset -4px 0 0 0 rgba(196, 165, 123, 0.4);

  &.dmt-object-sidebar-collapsed {
    width: 0;
    min-width: 0;
    border-right: none;
    overflow: visible;
  }
}

.dmt-sidebar-header {
  font-size: 10pt;
  font-weight: 600;
  padding: 8px;
  text-align: center;
  border-bottom: 1px solid var(--dmt-border-secondary);
  color: var(--dmt-text-primary);
  background-color: #252525;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.dmt-sidebar-collapse-btn {
  background: transparent;
  border: 1.5px solid rgba(196, 165, 123, 0.4);
  border-radius: 3px;
  color: var(--dmt-border-primary) !important;
  cursor: pointer;
  padding: 4px;
  font-size: 10px;
  line-height: 1;
  transition: var(--dmt-transition);
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  box-shadow: 0 0 8px rgba(196, 165, 123, 0.2) !important;

  &:hover {
    color: var(--dmt-text-primary);
    border-color: var(--dmt-border-primary);
    background-color: rgba(196, 165, 123, 0.1);
    box-shadow: 0 0 12px rgba(196, 165, 123, 0.4);
  }

  svg {
    display: block;
    flex-shrink: 0;
  }
}

.dmt-sidebar-toggle {
  position: absolute;
  left: 0;
  top: 8px;
  background-color: rgba(42, 42, 42, 0.95) !important;
  border: 1.5px solid var(--dmt-border-primary);
  border-radius: 0 6px 6px 0;
  color: var(--dmt-border-primary) !important;
  cursor: pointer;
  padding: 4px 6px;
  font-size: 14px;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  z-index: 200;
  box-shadow:
    2px 2px 6px rgba(0, 0, 0, 0.4),
    0 0 12px rgba(196, 165, 123, 0.3) !important;
  overflow: visible;

  svg {
    display: block;
    flex-shrink: 0;
  }

  &:hover {
    background-color: rgba(58, 58, 58, 0.95);
    border-color: var(--dmt-border-primary);
    color: var(--dmt-text-primary);
    box-shadow:
      2px 2px 8px rgba(0, 0, 0, 0.5),
      0 0 16px rgba(196, 165, 123, 0.5);
    transform: translateX(3px);
  }
}

.dmt-sidebar-content {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 4px;

  &::-webkit-scrollbar {
    width: 6px;
  }

  &::-webkit-scrollbar-track {
    background: var(--dmt-bg-primary);
  }

  &::-webkit-scrollbar-thumb {
    background: var(--dmt-bg-tertiary);
    border-radius: 3px;

    &:hover {
      background: #4a4a4a;
    }
  }
}

.dmt-sidebar-category {
  margin-bottom: 8px;
}

.dmt-category-label {
  font-size: 8pt;
  font-weight: 500;
  color: var(--dmt-text-muted);
  padding: 4px 2px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.dmt-object-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 8px;
  margin: 2px 0;
  background: var(--background-secondary);
  border: 1px solid transparent;
  border-radius: 4px;
  cursor: pointer;
  transition: var(--dmt-transition);
  width: 100%;
  min-height: 58px;
  box-sizing: border-box;

  &:hover {
    background-color: var(--background-secondary-alt);
    border-color: var(--background-modifier-border);
  }

  &.dmt-object-item-selected {
    background-color: var(--background-modifier-hover);
    border-color: var(--dmt-border-primary);

    &:hover {
      background-color: var(--background-modifier-hover);
    }

    .dmt-object-label {
      color: var(--text-normal);
      font-weight: 500;
    }
  }
}

/* Force early loading of emoji fonts to prevent flash */
.dmt-font-preloader {
  position: absolute;
  left: -9999px;
  font-family: 'Noto Emoji', 'Noto Sans Symbols 2', monospace;
  visibility: hidden;
}

.dmt-object-symbol {
  font-size: 18px;
  font-family: 'Noto Emoji', 'Noto Sans Symbols 2', monospace;
  line-height: 1.1;
  margin-bottom: 4px;
  color: var(--dmt-text-primary);
  
  /* Optimize rendering and prepare font early */
  will-change: contents;
  text-rendering: optimizeSpeed;
}

.dmt-object-label {
  font-size: 8pt;
  line-height: 1.2;
  color: var(--dmt-text-secondary);
  word-wrap: break-word;
  overflow-wrap: break-word;
  hyphens: auto;
  text-align: center;
}

.dmt-sidebar-footer {
  padding: 6px;
  border-top: 1px solid var(--dmt-border-secondary);
  background-color: #252525;
}

.dmt-deselect-btn {
  width: 100%;
  padding: 6px 4px;
  font-size: 9pt;
  background-color: var(--dmt-bg-tertiary);
  color: var(--dmt-text-primary);
  border: 1px solid #4a4a4a;
  border-radius: 3px;
  cursor: pointer;
  transition: var(--dmt-transition);

  &:hover {
    background-color: #454545;
    border-color: #5a5a5a;
  }

  &:active {
    background-color: var(--dmt-bg-secondary);
  }
}

/* Note Pin Special Button */
.dmt-sidebar-note-section {
  padding: 8px 4px;
  border-bottom: 1px solid var(--background-modifier-border);
  margin-bottom: 4px;
}

.dmt-note-pin-btn {
  width: 100%;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 16px;
  background: var(--background-primary-alt);
  border: 1px solid var(--background-modifier-border);
  border-radius: 4px;
  color: var(--text-normal);
  cursor: pointer;
  font-size: 13px;
  transition: background 0.2s;
  box-sizing: border-box;

  svg {
    width: 16px;
    height: 16px;
    min-width: 16px;
    flex-shrink: 0;
  }

  span {
    flex: 1;
    white-space: nowrap;
  }

  &:hover {
    background: var(--background-modifier-hover);
  }
}

.dmt-note-pin-btn-selected {
  background: var(--interactive-accent);
  color: var(--text-on-accent);
  border-color: var(--interactive-accent);
}

/* ============================================
   OBJECT INTERACTION BUTTONS
   ============================================ */

.dmt-object-tooltip {
  background-color: rgba(42, 42, 42, 0.95);
  color: var(--dmt-text-primary);
  font-size: 11pt;
  padding: 6px 10px;
  border-radius: 4px;
  white-space: nowrap;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  border: 1px solid #4a4a4a;
  font-family: sans-serif;
  pointer-events: none;
  position: fixed;
  z-index: 1000;
}

.dmt-rotate-button,
.dmt-note-button,
.dmt-link-note-button,
.dmt-resize-button {
  width: 32px;
  height: 32px;
  background-color: rgba(74, 158, 255, 0.9);
  border: 2px solid var(--dmt-text-primary);
  border-radius: 50%;
  color: var(--dmt-text-primary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: var(--dmt-transition);
  z-index: 150;
  user-select: none;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);

  &:hover {
    background-color: rgba(74, 158, 255, 1);
    transform: scale(1.1);
  }

  &:active {
    transform: scale(0.95);
  }
}

.dmt-rotate-button {
  font-size: 20px;
}

.dmt-resize-button {
  font-size: 18px;
}

.dmt-note-button svg {
  width: 18px;
  height: 18px;
  color: var(--dmt-text-primary);
}

.dmt-link-note-button svg {
  width: 18px;
  height: 18px;
  color: var(--dmt-text-primary);
}

/* Visible Note Link Display */
.dmt-selected-object-note {
  background: var(--background-primary);
  border: 1px solid var(--background-modifier-border);
  border-radius: 4px;
  padding: 4px 8px;
  white-space: nowrap;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  z-index: 150;
  position: relative;
}

.dmt-note-display-link {
  display: flex;
  align-items: center;
  gap: 4px;
  color: var(--text-accent);
  text-decoration: none;
  font-size: 13px;
  cursor: pointer;
  position: relative;
  z-index: 2;
  
  &:hover {
    color: var(--text-accent-hover);
    text-decoration: underline;
  }
}

/* Selection Toolbar */
.dmt-selection-toolbar {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 4px;
  padding: 0;
  z-index: 150;
}

/* Multi-select toolbar styling */
.dmt-multi-select-toolbar {
  align-items: center;
}

.dmt-selection-count {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 0 12px;
  height: 44px;
  background: var(--interactive-accent);
  color: var(--text-on-accent);
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  white-space: nowrap;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.dmt-selection-count svg {
  width: 14px;
  height: 14px;
  opacity: 0.9;
}

.dmt-toolbar-button {
  width: 44px;
  height: 44px;
  background: var(--background-primary);
  border: 1px solid var(--background-modifier-border-hover);
  border-radius: 6px;
  color: var(--text-normal);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: var(--dmt-transition);
  user-select: none;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);

  &:hover {
    background: var(--background-primary-alt, var(--background-secondary));
    border-color: var(--text-accent);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }

  &:active {
    transform: translateY(0);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  }

  svg {
    width: 20px;
    height: 20px;
  }
}

.dmt-toolbar-color-button {
  border: 2px solid rgba(255, 255, 255, 0.3);
  
  svg {
    filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.8));
    color: #000;
  }

  &:hover {
    border-color: rgba(255, 255, 255, 0.5);
  }
}

.dmt-toolbar-delete-button {
  &:hover {
    background: var(--background-modifier-error);
    border-color: var(--text-error);
    color: var(--text-on-accent);
  }
}

/* Linked note display when used with toolbar */
.dmt-selection-linked-note {
  background: var(--background-primary);
  border: 1px solid var(--background-modifier-border);
  border-radius: 4px;
  padding: 4px 8px;
  white-space: nowrap;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  z-index: 150;
}

/* Invisible hover links over objects */
.dmt-object-hover-link {
  pointer-events: auto;  /* Changed: We handle clicks in JS now */
  overflow: hidden;
  cursor: default;  /* Show default cursor instead of pointer */

  /* Hide dc.Link text visually but keep it functional for hover */
  & > * {
    color: transparent !important;
    text-indent: -9999px !important;
  }
}

/* Linking mode banner */
.dmt-linking-banner {
  position: absolute;
  top: 8px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 200;
  pointer-events: auto;
}

.dmt-linking-banner-content {
  display: flex;
  align-items: center;
  gap: 8px;
  background: var(--interactive-accent);
  color: var(--text-on-accent);
  padding: 8px 12px;
  border-radius: 6px;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.4);
  font-size: 13px;
  white-space: nowrap;
}

.dmt-linking-banner-content svg {
  width: 16px;
  height: 16px;
  flex-shrink: 0;
}

.dmt-linking-banner-cancel {
  background: rgba(255, 255, 255, 0.2);
  border: none;
  color: inherit;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  margin-left: 4px;
}

.dmt-linking-banner-cancel:hover {
  background: rgba(255, 255, 255, 0.3);
}

/* Active state for linked object button */
.dmt-toolbar-button-active {
  background-color: var(--interactive-accent) !important;
  color: var(--text-on-accent) !important;
}

/* ============================================
   TEXT LABEL/MODAL SYSTEM
   ============================================ */

.dmt-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
  animation: fadeIn 0.15s ease;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }

  to {
    opacity: 1;
  }
}

.dmt-modal-content {
  background-color: var(--dmt-bg-secondary);
  border: 1px solid #4a4a4a;
  border-radius: 8px;
  padding: 20px;
  width: 400px;
  max-width: 90vw;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
  animation: slideUp 0.2s ease;
}

@keyframes slideUp {
  from {
    transform: translateY(20px);
    opacity: 0;
  }

  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.dmt-modal-title {
  margin: 0 0 16px 0;
  font-size: 18px;
  font-weight: 600;
  color: var(--dmt-text-primary);
}

.dmt-modal-input {
  width: 100%;
  padding: 10px 12px;
  font-size: 16px;
  background-color: var(--dmt-bg-primary);
  border: 1px solid var(--dmt-border-secondary);
  border-radius: 4px;
  color: var(--dmt-text-primary);
  outline: none;
  transition: border-color 0.15s ease;
  box-sizing: border-box;

  &:focus {
    border-color: var(--dmt-accent-blue);
  }

  &::placeholder {
    color: var(--dmt-text-disabled);
  }
}

.dmt-modal-buttons {
  display: flex;
  gap: 8px;
  margin-top: 16px;
}

.dmt-modal-header {
  margin-bottom: 16px;
  
  h3 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
    color: var(--dmt-text-primary);
  }
}

.dmt-modal-body {
  margin-bottom: 16px;
}

/* Settings modal specific - cap height and make scrollable */
.dmt-settings-modal {
  max-height: 500px;
  display: flex;
  flex-direction: column;
  
  .dmt-modal-body {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    min-height: 0;
  }
}

.dmt-modal-footer {
  display: flex;
  gap: 8px;
  margin-top: 16px;
}

.dmt-form-group {
  margin-bottom: 12px;
  
  &:last-child {
    margin-bottom: 0;
  }
}

.dmt-form-label {
  display: block;
  margin-bottom: 6px;
  font-size: 14px;
  font-weight: 500;
  color: var(--dmt-text-secondary);
}

.dmt-modal-btn {
  flex: 1;
  padding: 10px 16px;
  font-size: 14px;
  font-weight: 500;
  border-radius: 4px;
  border: 1px solid;
  cursor: pointer;
  transition: var(--dmt-transition);

  &.dmt-modal-btn-cancel {
    background-color: var(--dmt-bg-tertiary);
    border-color: #4a4a4a;
    color: var(--dmt-text-primary);

    &:hover {
      background-color: #454545;
      border-color: #5a5a5a;
    }
  }

  &.dmt-modal-btn-submit {
    background-color: var(--dmt-accent-blue);
    border-color: var(--dmt-accent-blue);
    color: var(--dmt-text-primary);

    &:hover:not(:disabled) {
      background-color: #3a8eef;
      border-color: #3a8eef;
    }

    &:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  }

  &.dmt-modal-btn-danger {
    background-color: var(--dmt-accent-red);
    border-color: var(--dmt-accent-red);
    color: var(--dmt-text-primary);

    &:hover:not(:disabled) {
      background-color: #a00000;
      border-color: #a00000;
    }

    &:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  }
}

.dmt-modal-hint {
  margin-top: 12px;
  font-size: 11px;
  color: var(--dmt-text-muted);
  text-align: center;
}

/* Settings Modal Specific Styles */
.dmt-settings-section {
  margin-bottom: 16px;
}

/* Modal Portal - for rendering modals outside viewport */
.dmt-modal-portal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 10000;
  pointer-events: none;
}

.dmt-modal-portal-content {
  pointer-events: auto;
}

.dmt-settings-section-header {
  margin-bottom: 12px;
}

.dmt-settings-section-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--dmt-text-primary);
  margin: 0 0 4px 0;
}

.dmt-settings-section-description {
  font-size: 12px;
  color: var(--dmt-text-muted);
  margin: 0;
}

/* Settings Modal Tab Bar */
.dmt-settings-tab-bar {
  display: flex;
  gap: 0;
  border-bottom: 1px solid var(--background-modifier-border);
  margin: 0 -20px;
  padding: 0 20px;
}

.dmt-settings-tab {
  padding: 10px 16px;
  font-size: 13px;
  font-weight: 500;
  color: var(--text-muted);
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  cursor: pointer;
  transition: color 0.15s ease, border-color 0.15s ease;
  margin-bottom: -1px;
  
  &:hover {
    color: var(--text-normal);
  }
}

.dmt-settings-tab-active {
  color: var(--text-normal);
  border-bottom-color: var(--interactive-accent);
}

.dmt-settings-tab-content {
  min-height: 325px;
}

/* Color picker 2x2 grid items */
.dmt-color-grid-item {
  display: flex;
  flex-direction: column;
}

/* Upgrade Banner */
.dmt-settings-upgrade-banner {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 12px 16px;
  margin: -8px -8px 16px -8px;
  background: linear-gradient(135deg, rgba(74, 158, 255, 0.1), rgba(74, 158, 255, 0.05));
  border: 1px solid rgba(74, 158, 255, 0.3);
  border-radius: 6px;
  animation: slideDown 0.3s ease;
}

.dmt-settings-upgrade-info {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 13px;
  color: var(--dmt-text-primary);
  
  svg {
    width: 18px;
    height: 18px;
    color: var(--dmt-accent-blue);
    flex-shrink: 0;
  }
}

.dmt-settings-upgrade-btn {
  padding: 6px 14px;
  font-size: 12px;
  font-weight: 600;
  background-color: var(--dmt-accent-blue);
  border: 1px solid var(--dmt-accent-blue);
  border-radius: 4px;
  color: var(--dmt-text-primary);
  cursor: pointer;
  transition: var(--dmt-transition);
  white-space: nowrap;
  
  &:hover {
    background-color: #3a8eef;
    border-color: #3a8eef;
  }
}

.dmt-settings-upgrade-container {
  margin: -8px -8px 16px -8px;
  padding: 12px;
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 6px;
  
  .dmt-plugin-installer-card {
    margin: 0;
  }
}

.dmt-form-group {
  margin-bottom: 12px;
}

.dmt-form-label {
  display: block;
  font-size: 12px;
  font-weight: 500;
  color: var(--dmt-text-secondary);
  margin-bottom: 6px;
}

.dmt-checkbox-label {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  font-size: 13px;
  color: var(--dmt-text-primary);
  user-select: none;
  
  &:hover {
    color: var(--dmt-accent-blue);
  }
}

.dmt-checkbox {
  width: 16px;
  height: 16px;
  cursor: pointer;
  accent-color: var(--dmt-accent-blue);
}

.dmt-color-button {
  width: 100%;
  height: 36px;
  border: 1px solid var(--dmt-border-secondary);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: var(--dmt-transition);
  position: relative;
  
  &:hover:not(:disabled) {
    border-color: var(--dmt-accent-blue);
    transform: scale(1.01);
  }
  
  &:disabled {
    cursor: not-allowed;
    opacity: 0.6;
  }
}

.dmt-color-button-label {
  font-size: 12px;
  font-weight: 600;
  text-shadow: 
    0 0 4px rgba(0, 0, 0, 0.8),
    0 1px 2px rgba(0, 0, 0, 0.9);
  color: white;
  padding: 2px 8px;
  background-color: rgba(0, 0, 0, 0.4);
  border-radius: 3px;
  font-family: var(--font-monospace);
}

.dmt-color-settings {
  transition: opacity 0.2s ease;
}

/* ============================================
   COLOR PICKER SYSTEM
   ============================================ */

.dmt-color-picker-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: transparent;
  z-index: 2099;
  pointer-events: auto;
}

.dmt-color-picker {
  background-color: var(--dmt-bg-secondary);
  border: 1px solid #4a4a4a;
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
  z-index: 2100;
  min-width: 290px;
  animation: slideDown 0.15s ease;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.dmt-color-picker-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.dmt-color-picker-title {
  font-size: 12px;
  font-weight: 600;
  color: var(--dmt-text-primary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.dmt-color-reset-btn {
  background-color: transparent;
  border: 1px solid var(--dmt-text-disabled);
  color: var(--dmt-text-primary);
  width: 24px;
  height: 24px;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  transition: var(--dmt-transition);

  &:hover {
    background-color: var(--dmt-bg-tertiary);
    border-color: var(--dmt-text-muted);
  }
}

.dmt-color-grid {
  display: grid;
  grid-template-columns: repeat(6, 40px);
  gap: 6px;
}

.dmt-color-swatch {
  width: 40px;
  height: 40px;
  border: 2px solid #4a4a4a;
  border-radius: 6px;
  cursor: pointer;
  transition: var(--dmt-transition);
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;

  &:hover {
    border-color: var(--dmt-text-primary);
    transform: scale(1.1);
  }

  &.dmt-color-swatch-selected {
    border-color: var(--dmt-text-primary);
    border-width: 3px;
    box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
  }

  &.dmt-color-swatch-reset {
    background-color: var(--dmt-bg-tertiary);
    border: 2px solid var(--dmt-text-disabled);

    &:hover {
      background-color: #4a4a4a;
      border-color: var(--dmt-text-muted);
    }
  }

  &.dmt-color-swatch-preview {
    border: 2px dashed var(--dmt-accent-blue);
    position: relative;
    animation: pulse 1s ease-in-out infinite;
  }

  &.dmt-color-swatch-add {
    background-color: var(--dmt-bg-secondary);
    border: 2px dashed var(--dmt-text-disabled);
    position: relative;
    overflow: hidden;

    &:hover {
      background-color: var(--dmt-bg-tertiary);
      border-color: var(--dmt-text-muted);
      border-style: solid;
    }
  }
}

@keyframes pulse {

  0%,
  100% {
    opacity: 0.7;
  }

  50% {
    opacity: 1;
  }
}

.dmt-color-reset-icon,
.dmt-color-checkmark {
  color: var(--dmt-text-primary);
  font-weight: bold;
  text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
}

.dmt-color-reset-icon {
  font-size: 18px;
}

.dmt-color-checkmark {
  font-size: 20px;
  pointer-events: none;
}

.dmt-color-preview-spinner {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: var(--dmt-text-primary);
  font-size: 18px;
  font-weight: bold;
  text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
  animation: spin 2s linear infinite;
  mix-blend-mode: difference;
}

@keyframes spin {
  from {
    transform: translate(-50%, -50%) rotate(0deg);
  }

  to {
    transform: translate(-50%, -50%) rotate(360deg);
  }
}

.dmt-color-add-icon,
.dmt-color-add-icon-overlay {
  color: var(--dmt-text-primary);
  font-size: 24px;
  font-weight: bold;
}

.dmt-color-add-icon-overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;
  z-index: 1;
}

.dmt-color-input-as-button {
  width: 100%;
  height: 100%;
  opacity: 0;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  z-index: 2;
}

.dmt-color-delete-button {
  position: absolute;
  left: calc(100% + 4px);
  top: 50%;
  transform: translateY(-50%);
  width: 32px;
  height: 32px;
  background-color: rgba(239, 68, 68, 0.9);
  border: 2px solid var(--dmt-text-primary);
  border-radius: 50%;
  color: var(--dmt-text-primary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: var(--dmt-transition);
  z-index: 150;
  user-select: none;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);

  svg {
    width: 16px;
    height: 16px;
    color: var(--dmt-text-primary);
  }

  &:hover {
    background-color: rgba(239, 68, 68, 1);
    transform: translateY(-50%) scale(1.1);
  }

  &:active {
    transform: translateY(-50%) scale(0.95);
  }
}

/* Custom color edit panel (right-click/long-press) */
.dmt-color-edit-panel {
  position: absolute;
  left: calc(100% + 4px);
  top: 50%;
  transform: translateY(-50%);
  background: var(--dmt-bg-secondary);
  border: 1px solid var(--dmt-border-secondary);
  border-radius: 6px;
  padding: 8px;
  display: flex;
  align-items: center;
  gap: 8px;
  z-index: 150;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  white-space: nowrap;
}

.dmt-color-edit-opacity {
  display: flex;
  align-items: center;
  gap: 6px;
}

.dmt-color-edit-opacity-label {
  font-size: 11px;
  color: var(--dmt-text-secondary);
}

.dmt-color-edit-opacity-value {
  font-size: 11px;
  color: var(--dmt-text-primary);
  min-width: 32px;
  text-align: right;
}

.dmt-color-edit-opacity input[type="range"] {
  width: 80px;
  height: 4px;
  cursor: pointer;
  appearance: none;
  background: var(--dmt-bg-tertiary);
  border-radius: 2px;
  
  &::-webkit-slider-thumb {
    appearance: none;
    width: 12px;
    height: 12px;
    background: var(--dmt-border-primary);
    border-radius: 50%;
    cursor: pointer;
  }
  
  &::-moz-range-thumb {
    width: 12px;
    height: 12px;
    background: var(--dmt-border-primary);
    border: none;
    border-radius: 50%;
    cursor: pointer;
  }
}

.dmt-color-edit-delete {
  width: 24px;
  height: 24px;
  background-color: rgba(239, 68, 68, 0.8);
  border: none;
  border-radius: 4px;
  color: var(--dmt-text-primary);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: var(--dmt-transition);
  padding: 0;
  
  svg {
    width: 14px;
    height: 14px;
  }
  
  &:hover {
    background-color: rgba(239, 68, 68, 1);
  }
}

/* Color picker opacity slider */
.dmt-color-opacity-section {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid var(--dmt-bg-tertiary);
}

.dmt-color-opacity-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.dmt-color-opacity-label {
  font-size: 11px;
  font-weight: 600;
  color: var(--dmt-text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.dmt-color-opacity-value {
  font-size: 12px;
  color: var(--dmt-text-primary);
  font-weight: 500;
  min-width: 35px;
  text-align: right;
}

.dmt-color-opacity-slider {
  width: 100%;
  height: 6px;
  -webkit-appearance: none;
  appearance: none;
  background: var(--dmt-bg-tertiary);
  border-radius: 3px;
  outline: none;
  cursor: pointer;
}

.dmt-color-opacity-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  background: var(--dmt-accent-blue);
  border-radius: 50%;
  cursor: pointer;
  border: 2px solid var(--dmt-text-primary);
  transition: transform 0.15s ease;
}

.dmt-color-opacity-slider::-webkit-slider-thumb:hover {
  transform: scale(1.15);
}

.dmt-color-opacity-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background: var(--dmt-accent-blue);
  border-radius: 50%;
  cursor: pointer;
  border: 2px solid var(--dmt-text-primary);
  transition: transform 0.15s ease;
}

.dmt-color-opacity-slider::-moz-range-thumb:hover {
  transform: scale(1.15);
}

/* ============================================
   TOUCH/TABLET RESPONSIVE ADJUSTMENTS
   ============================================ */

@media (hover: none) and (pointer: coarse) {

  .dmt-compass {
    width: 35px;
    height: 35px;
    max-width: 35px;
    max-height: 35px;
  }

  .dmt-zoom-btn {
    width: 35px;
    height: 35px;
    max-width: 35px;
    max-height: 35px;
  }

  .dmt-modal-input {
    font-size: 18px;
    padding: 12px;
  }

  .dmt-modal-btn {
    padding: 14px 16px;
    font-size: 16px;
  }

  .dmt-rotate-button,
  .dmt-note-button,
  .dmt-link-note-button,
  .dmt-resize-button,
  .dmt-object-color-button {
    width: 44px;
    height: 44px;
  }

  .dmt-rotate-button {
    font-size: 24px;
  }

  .dmt-resize-button {
    font-size: 22px;
  }

  .dmt-note-button svg {
    width: 22px;
    height: 22px;
  }

  .dmt-link-note-button svg {
    width: 22px;
    height: 22px;
  }

  .dmt-color-swatch {
    width: 44px;
    height: 44px;
  }

  .dmt-color-grid {
    grid-template-columns: repeat(6, 44px);
    gap: 8px;
  }

  .dmt-color-picker {
    min-width: 320px;
  }

  .dmt-color-reset-btn {
    width: 28px;
    height: 28px;
  }

  .dmt-color-delete-button {
    width: 44px;
    height: 44px;

    svg {
      width: 20px;
      height: 20px;
    }
  }
}

/* Text Label Editor Modal Styles */
.dmt-text-editor-modal {
  width: 420px;
  max-width: 90vw;
}

.dmt-text-editor-section {
  margin-bottom: 16px;
}

.dmt-text-editor-section-grow {
  flex: 1;
}

.dmt-text-editor-section-small {
  width: 80px;
}

.dmt-text-editor-label {
  display: block;
  font-size: 12px;
  color: var(--text-muted);
  margin-bottom: 4px;
  font-weight: 500;
}

.dmt-text-editor-row {
  display: flex;
  gap: 12px;
}

.dmt-text-editor-select {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid var(--background-modifier-border);
  border-radius: 4px;
  background: var(--background-primary);
  color: var(--text-normal);
  font-family: inherit;
  font-size: 14px;
  line-height: 1.6;
  cursor: pointer;
  min-height: 40px;
}

.dmt-text-editor-select:focus {
  outline: none;
  border-color: var(--interactive-accent);
}

.dmt-text-editor-number {
  width: 100%;
  padding: 8px 10px;
  border: 1px solid var(--background-modifier-border);
  border-radius: 4px;
  background: var(--background-primary);
  color: var(--text-normal);
  font-family: inherit;
  font-size: 14px;
}

.dmt-text-editor-number:focus {
  outline: none;
  border-color: var(--interactive-accent);
}

.dmt-text-editor-color-button {
  width: 100%;
  height: 40px;
  border: 2px solid var(--background-modifier-border);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s ease;
}

.dmt-text-editor-color-button:hover {
  border-color: var(--interactive-accent);
  transform: translateY(-1px);
}

.dmt-text-editor-color-label {
  font-size: 11px;
  font-weight: 600;
  color: white;
  text-shadow:
    -1px -1px 0 #000,
    1px -1px 0 #000,
    -1px 1px 0 #000,
    1px 1px 0 #000,
    0 0 3px rgba(0, 0, 0, 0.8);
  letter-spacing: 0.5px;
}

/* Live Preview Section */
.dmt-text-editor-preview-toggle {
  background: none;
  border: none;
  color: var(--text-muted);
  cursor: pointer;
  padding: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  transition: all 0.15s ease;
}

.dmt-text-editor-preview-toggle:hover {
  background: var(--background-modifier-hover);
  color: var(--text-normal);
}

.dmt-text-editor-preview-toggle svg {
  width: 16px;
  height: 16px;
}

.dmt-text-editor-preview {
  padding: 16px;
  text-align: center;
  background: #2a2a2a;
  border-radius: 4px;
  min-height: 60px;
  max-height: 200px;
  overflow: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  word-wrap: break-word;
  overflow-wrap: break-word;
  border: 1px solid var(--background-modifier-border);
  margin-top: 8px;
}

/* Edit Button (for text labels) */
.dmt-edit-button {
  position: absolute;
  width: 32px;
  height: 32px;
  background: linear-gradient(135deg, #4a9eff 0%, #357abd 100%);
  color: white;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 18px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  transition: all 0.2s ease;
  z-index: 1000;
}

.dmt-edit-button:hover {
  background: linear-gradient(135deg, #5aa5ff 0%, #4088cd 100%);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

.dmt-edit-button:active {
  transform: translateY(0);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

/* Object Color Button (for objects) */
.dmt-object-color-button {
  width: 32px;
  height: 32px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
  transition: all 0.2s ease;
  z-index: 1000;
}

.dmt-object-color-button svg {
  width: 16px;
  height: 16px;
  filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.8));
  color: #000;
}

.dmt-object-color-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  border-color: rgba(255, 255, 255, 0.5);
}

.dmt-object-color-button:active {
  transform: translateY(0);
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.dmt-object-color-button .dmt-color-picker {
  position: absolute;
  left: 100%;
  top: 0;
  margin-left: 8px;
}

/* Mobile/tablet adjustments for text editor */
@media (max-width: 768px) {
  .dmt-text-editor-modal {
    width: 360px;
  }

  .dmt-text-editor-number {
    width: 60px;
  }

  .dmt-edit-button {
    width: 44px;
    height: 44px;
    font-size: 22px;
  }
}

/* ============================================
   PLUGIN INSTALLER
   ============================================ */

.dmt-plugin-installer {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  padding: 20px;
  background: var(--dmt-bg-primary);
}

.dmt-plugin-installer-card {
  max-width: 600px;
  background: var(--dmt-bg-secondary);
  border: 2px solid var(--dmt-border-primary);
  border-radius: 8px;
  padding: 32px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3),
              inset 0 0 0 1px rgba(196, 165, 123, 0.2);
}

.dmt-plugin-installer-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 24px;
  
  svg {
    width: 64px;
    height: 64px;
    color: var(--dmt-border-primary);
    filter: drop-shadow(0 0 8px rgba(196, 165, 123, 0.4));
  }
}

.dmt-plugin-installer-content {
  h3 {
    margin: 0 0 16px 0;
    font-size: 24px;
    font-weight: 600;
    color: var(--dmt-text-primary);
    text-align: center;
  }
  
  p {
    margin: 0 0 12px 0;
    font-size: 15px;
    line-height: 1.6;
    color: var(--dmt-text-secondary);
  }
  
  ul {
    margin: 16px 0;
    padding-left: 24px;
    
    li {
      margin: 8px 0;
      font-size: 14px;
      color: var(--dmt-text-secondary);
    }
  }
  
  .dmt-plugin-installer-note {
    margin-top: 20px;
    padding: 12px;
    background: rgba(196, 165, 123, 0.1);
    border-left: 3px solid var(--dmt-border-primary);
    border-radius: 4px;
    font-size: 13px;
    color: var(--dmt-text-muted);
  }
}

.dmt-plugin-installer-error {
  margin-top: 16px;
  padding: 12px;
  background: rgba(255, 68, 68, 0.1);
  border: 1px solid var(--dmt-error);
  border-radius: 4px;
  color: var(--dmt-error);
  font-size: 14px;
  text-align: center;
}

.dmt-plugin-installer-actions {
  display: flex;
  gap: 12px;
  margin-top: 24px;
  justify-content: center;
}

.dmt-plugin-installer-btn {
  padding: 12px 24px;
  border: none;
  border-radius: 6px;
  font-size: 15px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  
  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
}

.dmt-plugin-installer-btn-primary {
  background: linear-gradient(135deg, var(--dmt-border-primary) 0%, #8b6842 100%);
  color: var(--dmt-bg-primary);
  box-shadow: 0 2px 8px rgba(196, 165, 123, 0.3);
  
  &:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 16px rgba(196, 165, 123, 0.4);
  }
  
  &:active:not(:disabled) {
    transform: translateY(0);
  }
}

.dmt-plugin-installer-btn-secondary {
  background: var(--dmt-bg-tertiary);
  color: var(--dmt-text-secondary);
  border: 1px solid var(--dmt-border-secondary);
  
  &:hover:not(:disabled) {
    background: rgba(255, 255, 255, 0.1);
    color: var(--dmt-text-primary);
  }
}

/* Success Modal */
.dmt-plugin-success-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  backdrop-filter: blur(4px);
}

.dmt-plugin-success-modal {
  max-width: 500px;
  background: var(--dmt-bg-secondary);
  border: 2px solid var(--dmt-border-primary);
  border-radius: 8px;
  padding: 32px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5),
              inset 0 0 0 1px rgba(196, 165, 123, 0.2);
  animation: dmt-modal-fade-in 0.2s ease;
}

@keyframes dmt-modal-fade-in {
  from {
    opacity: 0;
    transform: scale(0.95) translateY(-10px);
  }
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

.dmt-plugin-success-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 20px;
  
  svg {
    width: 56px;
    height: 56px;
    color: #4ade80;
    filter: drop-shadow(0 0 12px rgba(74, 222, 128, 0.5));
  }
}

.dmt-plugin-success-modal h3 {
  margin: 0 0 16px 0;
  font-size: 22px;
  font-weight: 600;
  color: var(--dmt-text-primary);
  text-align: center;
}

.dmt-plugin-success-modal p {
  margin: 0 0 12px 0;
  font-size: 15px;
  line-height: 1.6;
  color: var(--dmt-text-secondary);
  text-align: center;
}

.dmt-plugin-success-note {
  margin-top: 16px;
  padding: 12px;
  background: rgba(196, 165, 123, 0.1);
  border-left: 3px solid var(--dmt-border-primary);
  border-radius: 4px;
  font-size: 13px;
  color: var(--dmt-text-muted);
  text-align: left;
}

.dmt-plugin-success-actions {
  display: flex;
  gap: 12px;
  margin-top: 24px;
  justify-content: center;
}

/* ============================================
   Hex Coordinate Layer
   ============================================ */

.dmt-coordinate-layer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 15; /* Above drawing/objects, below UI controls */
  overflow: hidden;
}

.dmt-hex-coordinate {
  font-family: var(--font-monospace);
  font-weight: 600;
  /* color and text-shadow applied via inline styles from settings */
  user-select: none;
  white-space: nowrap;
  letter-spacing: 0.5px;
}

/* ============================================
   Visibility Toolbar
   ============================================ */

.dmt-visibility-toolbar {
  position: absolute;
  top: 128px; /* Below MapHeader + ToolPalette + extra spacing for iPad/mobile (header ~44px + palette ~60px + container padding 12px + gap 12px) */
  left: 50%;
  transform: translateX(-50%) translateY(-20px);
  display: flex;
  gap: 4px;
  padding: 4px;
  background-color: var(--dmt-bg-primary);
  border: 2px solid var(--dmt-border-primary);
  border-radius: 4px;
  z-index: 200;
  box-shadow:
    0 4px 12px rgba(0, 0, 0, 0.5),
    inset 0 0 0 1px rgba(196, 165, 123, 0.2);
  opacity: 0;
  pointer-events: none;
  transition: opacity 200ms ease-out, transform 200ms ease-out;
}

.dmt-visibility-toolbar-open {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
  pointer-events: auto;
}

.dmt-visibility-btn {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--dmt-bg-secondary);
  border: 1px solid var(--dmt-border-secondary);
  border-radius: 3px;
  color: var(--dmt-text-primary);
  cursor: pointer;
  padding: 6px;
  width: 32px;
  height: 32px;
  transition: var(--dmt-transition);

  &:hover:not(.dmt-visibility-btn-hidden) {
    background-color: var(--dmt-bg-tertiary);
    border-color: var(--dmt-border-primary);
  }

  svg:not(.dmt-visibility-strikethrough) {
    color: var(--dmt-border-primary);
    width: 18px;
    height: 18px;
  }
}

.dmt-visibility-strikethrough {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 24px;
  height: 24px;
  color: var(--dmt-accent-red);
  pointer-events: none;
}

.dmt-visibility-btn-hidden {
  opacity: 0.6;
  background-color: rgba(0, 0, 0, 0.3);
  
  &:hover {
    background-color: rgba(0, 0, 0, 0.4);
    border-color: var(--dmt-border-secondary);
  }

  svg:not(.dmt-visibility-strikethrough) {
    color: var(--dmt-text-muted);
  }
}

/* Active state for visibility toggle button in controls */
.dmt-expand-btn-active {
  background-color: var(--dmt-border-primary) !important;
  border-color: #8b6842 !important;
  
  svg {
    color: var(--dmt-bg-primary);
  }
}

/* ==========================================================================
   Fog of War UI
   ========================================================================== */

/* Separator between layer toggles and FoW section */
.dmt-visibility-separator {
  width: 1px;
  height: 24px;
  background: var(--dmt-border-secondary);
  margin: 0 4px;
}

/* FoW section container */
.dmt-fow-section {
  display: flex;
  align-items: center;
  gap: 2px;
}

/* FoW toggle button (always visible) */
/* FoW toggle button - with tablet overrides */
.is-tablet button.dmt-fow-toggle-btn,
button.dmt-fow-toggle-btn,
.dmt-fow-toggle-btn {
  display: flex;
  align-items: center;
  gap: 4px;
  background-color: var(--dmt-bg-secondary);
  border: 1px solid var(--dmt-border-secondary);
  border-radius: 3px;
  color: var(--dmt-text-primary);
  cursor: pointer;
  padding: 4px 8px;
  height: 32px;
  min-height: 32px;
  max-height: 32px;
  transition: var(--dmt-transition);
  white-space: nowrap;
  
  svg {
    color: var(--dmt-border-primary);
    width: 16px;
    height: 16px;
    min-width: 16px;
    min-height: 16px;
    flex-shrink: 0;
  }
  
  &:hover {
    background-color: var(--dmt-bg-tertiary);
    border-color: var(--dmt-border-primary);
  }
  
  &.expanded {
    background-color: var(--dmt-bg-tertiary);
    border-color: var(--dmt-border-primary);
  }
}

.dmt-fow-label {
  font-size: 11px;
  color: var(--dmt-text-muted);
}

/* FoW tools panel (expandable) */
.dmt-fow-tools-panel {
  display: flex;
  align-items: center;
  gap: 2px;
  overflow: hidden;
  max-width: 0;
  opacity: 0;
  transition: max-width 200ms ease-out, opacity 200ms ease-out, margin 200ms ease-out;
  
  &.expanded {
    max-width: 250px;
    opacity: 1;
    margin-left: 4px;
    padding-left: 4px;
    border-left: 1px solid var(--dmt-border-secondary);
  }
}

/* Individual FoW tool buttons - with tablet overrides */
.is-tablet button.dmt-fow-tool-btn,
button.dmt-fow-tool-btn,
.dmt-fow-tool-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--dmt-bg-secondary);
  border: 1px solid var(--dmt-border-secondary);
  border-radius: 3px;
  color: var(--dmt-text-primary);
  cursor: pointer;
  padding: 4px;
  width: 28px;
  height: 28px;
  min-width: 28px;
  min-height: 28px;
  max-width: 28px;
  max-height: 28px;
  transition: var(--dmt-transition);
  
  svg {
    color: var(--dmt-text-muted);
    width: 16px;
    height: 16px;
  }
  
  &:hover:not(:disabled) {
    background-color: var(--dmt-bg-tertiary);
    border-color: var(--dmt-border-primary);
    
    svg {
      color: var(--dmt-text-primary);
    }
  }
  
  &.active {
    background-color: var(--dmt-border-primary);
    border-color: #8b6842;
    
    svg {
      color: var(--dmt-bg-primary);
    }
  }
  
  &.disabled,
  &:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    
    svg {
      color: var(--dmt-text-muted);
    }
  }
}

/* ==========================================================================
   Scale Slider (shown during resize mode)
   ========================================================================== */

.dmt-scale-slider-container {
  background: var(--dmt-bg-secondary);
  border: 1px solid var(--dmt-border-primary);
  border-radius: 6px;
  padding: 6px 10px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3),
              inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.dmt-scale-slider-inner {
  display: flex;
  align-items: center;
  gap: 8px;
  
  svg {
    color: var(--dmt-text-muted);
    flex-shrink: 0;
  }
}

.dmt-scale-slider {
  flex: 1;
  height: 4px;
  -webkit-appearance: none;
  appearance: none;
  background: var(--dmt-bg-tertiary);
  border-radius: 2px;
  cursor: pointer;
  
  &::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    background: var(--dmt-border-primary);
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid var(--dmt-bg-secondary);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    transition: transform 0.1s ease;
    
    &:hover {
      transform: scale(1.15);
    }
  }
  
  &::-moz-range-thumb {
    width: 14px;
    height: 14px;
    background: var(--dmt-border-primary);
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid var(--dmt-bg-secondary);
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
    transition: transform 0.1s ease;
    
    &:hover {
      transform: scale(1.15);
    }
  }
  
  &::-webkit-slider-runnable-track {
    height: 4px;
    background: var(--dmt-bg-tertiary);
    border-radius: 2px;
  }
  
  &::-moz-range-track {
    height: 4px;
    background: var(--dmt-bg-tertiary);
    border-radius: 2px;
  }
}

.dmt-scale-value {
  font-size: 12px;
  font-weight: 600;
  color: var(--dmt-text-muted);
  min-width: 36px;
  text-align: right;
  font-family: var(--font-monospace);
}

/* ============================================
   LAYER CONTROLS PANEL (Z-Layer System)
   ============================================ */

/* Invisible overlay to block clicks when context menu is open */
.dmt-layer-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 149; /* Just below layer controls (150) */
  background: transparent;
  cursor: default;
}

.dmt-layer-controls {
  position: absolute;
  top: 50%;
  transform: translateY(-50%) translateX(-20px);
  display: flex;
  flex-direction: column;
  gap: 4px;
  z-index: 150;
  opacity: 0;
  pointer-events: none;
  transition: left 0.3s ease, opacity 200ms ease-out, transform 200ms ease-out;
  /* Constrain height to canvas and enable scrolling */
  max-height: calc(100% - 80px);
  overflow-y: auto;
  overscroll-behavior: contain;
  /* Padding for slide-out options menu and slider popup */
  padding-right: 200px;
  margin-right: -200px;
  /* Hide scrollbar but keep scroll functionality */
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.dmt-layer-controls::-webkit-scrollbar {
  display: none;
}

.dmt-layer-controls.dmt-layer-controls-open {
  opacity: 1;
  transform: translateY(-50%) translateX(0);
  pointer-events: auto;
}

.dmt-layer-controls.sidebar-open {
  left: calc(110px + 8px); /* sidebar width + gap */
}

.dmt-layer-controls.sidebar-closed {
  left: 8px;
}

/* Layer Button Wrapper (for drag handling) */
.dmt-layer-btn-wrapper {
  position: relative;
  display: flex;
  align-items: center;
  width: fit-content;
}

/* Layer Button */
.is-tablet button.dmt-layer-btn,
button.dmt-layer-btn {
  width: 35px;
  height: 35px;
  min-width: 35px;
  min-height: 35px;
  max-width: 35px;
  max-height: 35px;
  border-radius: 50%;
  background: rgba(0, 0, 0, 0.7);
  border: 2px solid rgba(196, 165, 123, 0.4);
  color: var(--dmt-text-primary);
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
  position: relative;
  user-select: none;
}

.dmt-layer-btn:hover {
  border-color: rgba(196, 165, 123, 0.6);
  background: rgba(0, 0, 0, 0.85);
  transform: scale(1.05);
}

.dmt-layer-btn-active {
  border-color: #c4a57b;
  box-shadow: 0 0 8px rgba(196, 165, 123, 0.4);
  background: rgba(196, 165, 123, 0.2);
}

.dmt-layer-btn-active:hover {
  border-color: #c4a57b;
  background: rgba(196, 165, 123, 0.3);
}

/* Layer Options Slide-out */
.dmt-layer-options {
  position: absolute;
  left: 100%;
  top: 0;
  height: 100%;
  display: flex;
  align-items: center;
  padding-left: 4px;
  gap: 4px;
  opacity: 0;
  transform: translateX(-10px);
  pointer-events: none;
  transition: all 0.2s ease;
}

.dmt-layer-options.expanded {
  opacity: 1;
  transform: translateX(0);
  pointer-events: auto;
}

.is-tablet button.dmt-layer-option-btn,
button.dmt-layer-option-btn {
  width: 28px;
  height: 28px;
  min-width: 28px;
  min-height: 28px;
  max-width: 28px;
  max-height: 28px;
  border-radius: 50%;
  background: rgba(0, 0, 0, 0.8);
  border: 2px solid rgba(196, 165, 123, 0.4);
  color: var(--dmt-text-muted);
  cursor: pointer;
  display: flex;
  flex: 0 0 auto;
  padding: 0;
  box-sizing: border-box;
  overflow: hidden;
  align-items: center;
  justify-content: center;
  transition: all 0.15s ease;
}

.dmt-layer-option-btn:hover {
  color: var(--dmt-text-normal);
  border-color: rgba(196, 165, 123, 0.6);
}

.dmt-layer-option-btn.delete:hover {
  color: #e74c3c;
  border-color: #e74c3c;
  background: rgba(231, 76, 60, 0.1);
}

/* Layer Transparency Toggle */
.dmt-layer-transparency-wrapper {
  position: relative;
}

.dmt-layer-option-btn.transparency.active {
  color: #4a9eff;
  border-color: #4a9eff;
  background: rgba(74, 158, 255, 0.15);
  box-shadow: 0 0 8px rgba(74, 158, 255, 0.4);
}

.dmt-layer-option-btn.transparency:hover {
  color: #4a9eff;
  border-color: rgba(74, 158, 255, 0.6);
}

.dmt-opacity-slider-popup {
  position: absolute;
  left: calc(100% + 8px);
  top: 50%;
  transform: translateY(-50%);
  background: rgba(20, 20, 20, 0.95);
  border: 1px solid rgba(196, 165, 123, 0.4);
  border-radius: 6px;
  padding: 8px 12px;
  display: flex;
  align-items: center;
  gap: 8px;
  z-index: 200;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  white-space: nowrap;
}

.dmt-opacity-slider-popup::before {
  content: '';
  position: absolute;
  right: 100%;
  top: 50%;
  transform: translateY(-50%);
  border: 6px solid transparent;
  border-right-color: rgba(196, 165, 123, 0.4);
}

.dmt-opacity-slider {
  width: 70px;
  height: 4px;
  -webkit-appearance: none;
  appearance: none;
  background: rgba(255, 255, 255, 0.2);
  border-radius: 2px;
  cursor: pointer;
}

.dmt-opacity-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 12px;
  height: 12px;
  background: #4a9eff;
  border-radius: 50%;
  cursor: pointer;
}

.dmt-opacity-slider::-moz-range-thumb {
  width: 12px;
  height: 12px;
  background: #4a9eff;
  border-radius: 50%;
  border: none;
  cursor: pointer;
}

.dmt-opacity-value {
  color: var(--dmt-text-muted);
  font-size: 11px;
}

/* Add Layer Button */
.is-tablet button.dmt-layer-add-btn,
button.dmt-layer-add-btn {
  width: 35px;
  height: 35px;
  min-width: 35px;
  min-height: 35px;
  max-width: 35px;
  max-height: 35px;
  border-radius: 50%;
  background: rgba(0, 0, 0, 0.5);
  border: 2px dashed rgba(196, 165, 123, 0.4);
  color: var(--dmt-text-muted);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  flex: 0 0 auto;
  padding: 0;
  box-sizing: border-box;
  overflow: hidden;
  transition: all 0.2s ease;
  margin-top: 4px;
}

.dmt-layer-add-btn:hover {
  background: rgba(0, 0, 0, 0.7);
  border-color: rgba(196, 165, 123, 0.6);
  border-style: solid;
  color: var(--dmt-text-primary);
  transform: scale(1.05);
}

.dmt-layer-add-btn svg {
  width: 16px;
  height: 16px;
}

/* Drag states */
.dmt-layer-btn.dragging {
  opacity: 0.5;
}

.dmt-layer-btn.drag-over {
  border-color: #c4a57b;
  transform: scale(1.05);
  box-shadow: 0 0 12px rgba(196, 165, 123, 0.5);
}

/* Layer Button - Pill Mode (for named layers) */
.is-tablet button.dmt-layer-btn.dmt-layer-btn-pill,
button.dmt-layer-btn.dmt-layer-btn-pill {
  width: auto;
  max-width: 180px;
  min-width: 35px;
  border-radius: 17.5px;
  padding: 0 12px;
  gap: 4px;
}

.dmt-layer-icon {
  font-size: 14px;
  line-height: 1;
  flex-shrink: 0;
}

.dmt-layer-icon.ra {
  font-family: 'rpgawesome' !important;
  font-style: normal;
  -webkit-font-feature-settings: normal;
  font-feature-settings: normal;
  font-variant: normal;
  text-transform: none;
  line-height: 1;
  -webkit-font-smoothing: antialiased;
}

.dmt-layer-name {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Edit button styling */
.dmt-layer-option-btn.edit:hover {
  color: #4a9eff;
  border-color: #4a9eff;
  background: rgba(74, 158, 255, 0.1);
}

/* ==========================================================================
   LAYER EDIT MODAL
   ========================================================================== */

.dmt-layer-edit-modal {
  max-width: 400px;
  max-height: 80vh;
  overflow-y: auto;
}

.dmt-layer-edit-section {
  margin-bottom: 16px;
}

.dmt-layer-edit-label {
  display: block;
  font-size: 12px;
  color: var(--dmt-text-muted);
  margin-bottom: 6px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

/* Icon mode toggle */
.dmt-icon-mode-toggle {
  display: flex;
  gap: 4px;
  margin-bottom: 12px;
}

.dmt-icon-mode-btn {
  flex: 1;
  padding: 8px 12px;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(196, 165, 123, 0.3);
  border-radius: 4px;
  color: var(--dmt-text-muted);
  font-size: 12px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.dmt-icon-mode-btn:hover {
  border-color: rgba(196, 165, 123, 0.5);
  color: var(--dmt-text-normal);
}

.dmt-icon-mode-btn.active {
  background: rgba(196, 165, 123, 0.2);
  border-color: #c4a57b;
  color: var(--dmt-text-primary);
}

/* Symbol picker */
.dmt-symbol-input-row {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
}

.dmt-symbol-input {
  flex: 1;
  padding: 8px 12px;
  font-size: 16px;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(196, 165, 123, 0.3);
  border-radius: 4px;
  color: var(--dmt-text-primary);
}

.dmt-symbol-input:focus {
  outline: none;
  border-color: #c4a57b;
}

.dmt-symbol-preview {
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.4);
  border: 1px solid rgba(196, 165, 123, 0.3);
  border-radius: 4px;
  font-size: 20px;
}

.dmt-quick-symbols-grid {
  display: grid;
  grid-template-columns: repeat(9, 1fr);
  gap: 4px;
}

.dmt-quick-symbol-btn {
  width: 100%;
  aspect-ratio: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(196, 165, 123, 0.2);
  border-radius: 4px;
  font-size: 14px;
  color: var(--dmt-text-normal);
  cursor: pointer;
  transition: all 0.1s ease;
}

.dmt-quick-symbol-btn:hover {
  background: rgba(196, 165, 123, 0.15);
  border-color: rgba(196, 165, 123, 0.4);
}

.dmt-quick-symbol-btn.selected {
  background: rgba(196, 165, 123, 0.25);
  border-color: #c4a57b;
}

/* Icon picker */
.dmt-icon-picker {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.dmt-icon-search {
  width: 100%;
  padding: 8px 12px;
  font-size: 13px;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(196, 165, 123, 0.3);
  border-radius: 4px;
  color: var(--dmt-text-primary);
}

.dmt-icon-search:focus {
  outline: none;
  border-color: #c4a57b;
}

.dmt-icon-category-tabs {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
}

.dmt-icon-category-tab {
  padding: 4px 8px;
  font-size: 10px;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(196, 165, 123, 0.2);
  border-radius: 3px;
  color: var(--dmt-text-muted);
  cursor: pointer;
  transition: all 0.1s ease;
}

.dmt-icon-category-tab:hover {
  border-color: rgba(196, 165, 123, 0.4);
  color: var(--dmt-text-normal);
}

.dmt-icon-category-tab.active {
  background: rgba(196, 165, 123, 0.2);
  border-color: #c4a57b;
  color: var(--dmt-text-primary);
}

.dmt-icon-grid {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 4px;
  max-height: 180px;
  overflow-y: auto;
  padding: 4px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 4px;
}

.dmt-icon-grid-btn {
  width: 100%;
  aspect-ratio: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid transparent;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.1s ease;
}

.dmt-icon-grid-btn .ra {
  font-size: 16px;
  color: var(--dmt-text-normal);
}

.dmt-icon-grid-btn:hover {
  background: rgba(196, 165, 123, 0.15);
  border-color: rgba(196, 165, 123, 0.3);
}

.dmt-icon-grid-btn.selected {
  background: rgba(196, 165, 123, 0.25);
  border-color: #c4a57b;
}

.dmt-icon-grid-more {
  grid-column: 1 / -1;
  text-align: center;
  font-size: 11px;
  color: var(--dmt-text-muted);
  padding: 8px;
}

.dmt-icon-grid-empty {
  grid-column: 1 / -1;
  text-align: center;
  font-size: 12px;
  color: var(--dmt-text-muted);
  padding: 16px;
}

/* Layer preview */
.dmt-layer-preview {
  display: flex;
  justify-content: center;
  padding: 12px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 6px;
}

.dmt-layer-preview-btn {
  min-width: 35px;
  height: 35px;
  padding: 0 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  background: rgba(0, 0, 0, 0.7);
  border: 2px solid rgba(196, 165, 123, 0.6);
  border-radius: 17.5px;
  color: var(--dmt-text-primary);
  font-size: 14px;
  font-weight: 600;
}

.dmt-layer-preview-btn:not(.pill) {
  width: 35px;
  border-radius: 50%;
  padding: 0;
}

.dmt-layer-preview-icon {
  font-size: 14px;
  line-height: 1;
}

.dmt-layer-preview-icon.ra {
  font-family: 'rpgawesome' !important;
}

.dmt-layer-preview-name {
  white-space: nowrap;
}

/* ==========================================================================
   RE-ROLL DUNGEON
   ========================================================================== */

/* Re-roll button - positioned to the left of MapControls */
.dmt-reroll-btn {
  position: absolute;
  top: 12px;
  /* Position relative to right edge, offset from MapControls (80px width + 4px right + 12px gap) */
  right: 96px;
  z-index: 100;
  width: 36px;
  height: 36px;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, rgba(139, 90, 43, 0.6), rgba(101, 67, 33, 0.6)) !important;
  border: 2px solid rgba(196, 165, 123, 0.6) !important;
  border-radius: 6px;
  color: #c4a57b;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.dmt-reroll-btn:hover {
  background: linear-gradient(135deg, rgba(139, 90, 43, 0.8), rgba(101, 67, 33, 0.8)) !important;
  border-color: #c4a57b !important;
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

.dmt-reroll-btn svg {
  width: 18px;
  height: 18px;
}

/* Tablet adjustments */
.is-tablet .dmt-reroll-btn {
  width: 44px;
  height: 44px;
  right: 100px; /* Slightly more space on tablet */
}

.is-tablet .dmt-reroll-btn svg {
  width: 22px;
  height: 22px;
}

/* Re-roll confirmation dialog overlay */
.dmt-reroll-confirm-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  backdrop-filter: blur(2px);
}

/* Re-roll confirmation dialog */
.dmt-reroll-confirm-dialog {
  background: var(--background-primary);
  border: 2px solid rgba(196, 165, 123, 0.5);
  border-radius: 8px;
  padding: 24px;
  max-width: 90vw;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
}

.dmt-reroll-confirm-dialog h3 {
  margin: 0 0 12px 0;
  color: var(--text-normal);
  font-size: 1.2em;
}

.dmt-reroll-confirm-dialog p {
  margin: 0 0 12px 0;
  color: var(--text-muted);
  line-height: 1.5;
}

.dmt-reroll-warning {
  color: var(--text-error, #e74c3c) !important;
  font-weight: 500;
}

.dmt-reroll-confirm-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  justify-content: flex-end;
  margin-top: 20px;
}

.dmt-reroll-confirm-buttons.dmt-reroll-three-buttons {
  justify-content: center;
}

.dmt-btn {
  padding: 8px 16px;
  border-radius: 4px;
  border: none;
  cursor: pointer;
  font-size: 0.95em;
  transition: all 0.15s ease;
}

.dmt-btn-secondary {
  background: var(--background-modifier-border);
  color: var(--text-normal);
}

.dmt-btn-secondary:hover {
  background: var(--background-modifier-border-hover);
}

.dmt-btn-primary {
  background: var(--interactive-accent);
  color: var(--text-on-accent);
}

.dmt-btn-primary:hover {
  background: var(--interactive-accent-hover);
}
`;

return css;
```
